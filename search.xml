<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编程基础之计算机组成原理(组成篇)</title>
      <link href="2021/03/22/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%BB%84%E6%88%90%E7%AF%87/"/>
      <url>2021/03/22/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%BB%84%E6%88%90%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="计算机总线"><a href="#计算机总线" class="headerlink" title="计算机总线"></a>计算机总线</h2><ol><li><p>计算机总线概述</p><ul><li><p>是什么、有什么用</p><blockquote><p>日常生活中，我们常用的USB（<strong>Universal Serial Bus，通用串行总线</strong>）</p><p>为什么使用USB？</p><ul><li>提供了对外连接的接口</li><li>不同设备可以通过USB接口进行连接</li><li>连接的标准，促使外围设备接口的统一</li></ul><hr><p>作用：解决不同设备之间的通信问题</p><p>假设没有总线的时候，我们需要对现有系统新增一个输入设备，就需要分别将新增的输入设备连接到存储器运算器和控制器，这将导致线路极其复杂。</p><p><img src="https://blog.chasingwind.top/91xnAu.png" class="lazyload" data-srcset="https://blog.chasingwind.top/91xnAu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在总线的基础上进行连接，只需要将设备连接到总线上即可</p><p><img src="https://blog.chasingwind.top/aBFocW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/aBFocW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>总线分类</p><ol><li><p>片内总线</p><blockquote><p><img src="https://blog.chasingwind.top/9uHOwy.png" class="lazyload" data-srcset="https://blog.chasingwind.top/9uHOwy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>大大简化芯片内部的电路结构</p></blockquote></li><li><p>系统总线</p><blockquote><p>连接计算机各种外围设备的总线</p><p>CPU、主内存、IO设备、各个组件之间的信息传输线</p><p><img src="https://blog.chasingwind.top/FUF5Jb.png" class="lazyload" data-srcset="https://blog.chasingwind.top/FUF5Jb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>系统总线的分类</p><ol><li><p>数据总线</p><blockquote><p>双向传输各个部件之间的数据信息</p><p>数据总线的位数（总线宽度）是数据总线的重要参数，位数一般与CPU位数相同（32位、64位）</p></blockquote></li><li><p>地址总线</p><blockquote><p>用于传输数据的地址而使用的，用于数据的寻址</p><p><img src="https://blog.chasingwind.top/EiJR3C.png" class="lazyload" data-srcset="https://blog.chasingwind.top/EiJR3C.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>控制总线</p><blockquote><p><img src="https://blog.chasingwind.top/uQn6mb.png" class="lazyload" data-srcset="https://blog.chasingwind.top/uQn6mb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol></li></ul></li><li><p>总线的仲裁</p><ol><li><p>为什么需要总线仲裁</p><blockquote><p>为了解决不同设备总线使用权的冲突问题</p><p>举例：假设主存现在需要和硬盘和IO设备交换数据，并且现在硬盘和IO设备都处于就绪状态，那么主存是由硬盘先使用还是IO设备先使用呢？</p><p><img src="https://blog.chasingwind.top/D9KK7i.png" class="lazyload" data-srcset="https://blog.chasingwind.top/D9KK7i.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>总线仲裁的方法</p><ol><li><p>链式查询</p><blockquote><p><img src="https://blog.chasingwind.top/0nrUHy.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0nrUHy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>设备1和设备2同时向仲裁控制器发出总线使用申请，仲裁控制器返回允许使用信号给设备之后，设备就可以使用总线，但是是在优先级高的设备不在使用的情况下。</p><p>好处：电路复杂度低（串联），仲裁方式简单</p><p>坏处：优先级低的设备难以获得总线使用权，对电路故障敏感</p></blockquote></li><li><p>计时器定时查询</p><p>步骤一：仲裁控制器对设备编号并使用计数器累计计数</p><p>步骤二：接收到仲裁信号后，往所有设备发出计数值</p><p>步骤三：计数值与设备编号一致则获得总线使用权</p></li><li><p>独立请求</p><ul><li><p>每个设备均有总线独立连接仲裁器</p></li><li><p>设备可单独向仲裁器发送请求和接收请求</p></li><li><p>当同时收到多个请求信号，仲裁器有权按优先级分配使用权</p><blockquote><p><img src="https://blog.chasingwind.top/414s3f.png" class="lazyload" data-srcset="https://blog.chasingwind.top/414s3f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>优点：响应速度快，优先顺序可动态改变</p><p>缺点： 设备连线多，总线控制复杂</p></blockquote></li></ul></li></ol></li></ol></li></ol><h2 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h2><ol><li><p>常见的输入输出设备</p><ul><li>常见输入设备：字符输入设备（键盘）、图形输入设备（鼠标、数位板、扫描仪）等等</li><li>常见输出设备：显示器、打印机、投影仪等等</li></ul></li><li><p>输入输出接口的通用设计</p><ul><li>设计包含：数据线、状态线、命令线、设备选择线</li><li>数据线：是I/O设备与主机之间进行数据交换的传送线，分为单向传输线和双向传输线</li><li>状态线：IO设备向主机报告状态的信号线，查询设备是否已经正常连接并就绪或者查询设备是否已经被占用</li><li>命令线：CPU向设备发送命令的信号线，包括发送读写信号，发送启动停止信号</li><li>设备选择线：主机选择I/O设备进行操作的信号线，对连在总线上的设备进行选择。</li></ul></li><li><p>CPU与IO设备的通信</p><ul><li>前提：CPU速度和IO设备速度不一致</li></ul><ol><li><p>程序中断：提供低速设备通知CPU的一种异步方式</p><ul><li><p>当CPU需要和IO设备进行通信的时候（数据传输），当外围IO设备就绪时，向CPU发出中断信号，CPU有专门的电路响应中断信号</p><blockquote><p>模拟打印机与CPU通信时序图</p><p><img src="https://blog.chasingwind.top/gzHS7N.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gzHS7N.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>优点：CPU可以高速运转同时兼顾低速设备的响应</p><p>缺点：如果频繁中断CPU的话，CPU执行效率会降低</p></blockquote></li></ul></li><li><p>DMA（直接存储器访问）</p><ul><li><p>DMA直接连接主存与IO设备，DMA工作时不需要CPU的参与</p><blockquote><p><img src="https://blog.chasingwind.top/O8zxgL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/O8zxgL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在我们平常使用的硬盘显卡中都有DMA设备</p></blockquote></li></ul></li></ol></li></ol><h2 id="计算机的存储器"><a href="#计算机的存储器" class="headerlink" title="计算机的存储器"></a>计算机的存储器</h2><h3 id="存储器概览"><a href="#存储器概览" class="headerlink" title="存储器概览"></a>存储器概览</h3><ol><li><p>存储器分类</p><ul><li><p>按照存储介质分类</p><blockquote><p><img src="https://blog.chasingwind.top/yIhFpq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/yIhFpq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>按照存取方式分类</p><blockquote><p><img src="https://blog.chasingwind.top/Thy3eM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Thy3eM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>存储器的层次结构</p><blockquote><p>需要考虑的因素</p><p><img src="https://blog.chasingwind.top/vweNay.png" class="lazyload" data-srcset="https://blog.chasingwind.top/vweNay.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>按照位价对存储器进行分类</p><p>缓存：一般是指CPU寄存器以及高速缓存</p><p>主存：指的是计算机内存</p><p>辅存：硬盘，U盘等等 </p><p><img src="https://blog.chasingwind.top/hJWIdy.png" class="lazyload" data-srcset="https://blog.chasingwind.top/hJWIdy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>层次之间的数据交换</p><p>CPU和高速缓存以及主存之间都可以进行数据传输</p><p>辅存只与主存进行数据的传输</p><p><img src="https://blog.chasingwind.top/BwXzYW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/BwXzYW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>缓存-主存层次</strong></p><p>原理：局部性原理</p><p>实现：在CPU与主存之间增加一层速度快（容量小）的Cache（高速缓存）</p><p>目的：<strong>解决主存和CPU速度不一致的问题</strong></p><p><img src="https://blog.chasingwind.top/oimQ81.png" class="lazyload" data-srcset="https://blog.chasingwind.top/oimQ81.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>基于局部性原理，我们将这个较小的连续区域单独取出来，这一片就是高速缓存</p><p><img src="https://blog.chasingwind.top/bg1ZxA.png" class="lazyload" data-srcset="https://blog.chasingwind.top/bg1ZxA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>主存-辅存层次</strong></p><p>原理：局部性原理</p><p>实现：在主存之外增加辅助存储器（磁盘、SD卡、U盘等）</p><p>目的：<strong>解决主存容量不足的问题</strong></p><p>常见案例：如果我们需要运行一个游戏,这个游戏有20GB,但是我们内存只有8GB,那么这个游戏时怎么运行起来的呢</p><ul><li>由于局部性原理，计算机将当前使用到的数据加载到主存中，而未使用到的数据不进行加载，还是存放到辅存中</li></ul></blockquote></li></ol><h3 id="计算机的主存储器与辅助存储器"><a href="#计算机的主存储器与辅助存储器" class="headerlink" title="计算机的主存储器与辅助存储器"></a>计算机的主存储器与辅助存储器</h3><p>先思考2个问题：计算机断电，为什么内存数据丢失？为什么磁盘数据不会丢失？</p><ol><li><p>主存储器–内存</p><blockquote><p><img src="https://blog.chasingwind.top/BcV9oL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/BcV9oL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>组成部分</p><p>主存如何与CPU进行交互？</p><p>CPU中的MDR通过数据总线连接读写电路，传输数据</p><p>CPU中的MAR通过地址总线连接译码器，指定数据的位置信息</p><p><img src="https://blog.chasingwind.top/dt3lKs.png" class="lazyload" data-srcset="https://blog.chasingwind.top/dt3lKs.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>主存最大大小和操作系统位数的关系</p><p>32位系统最多支持4GB内存，因为主存地址寄存器最多可以寻址范围是$2^{32}$</p><p><img src="https://blog.chasingwind.top/MQJ4bJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/MQJ4bJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=" "></p></blockquote></li><li><p>辅助存储器–磁盘</p><blockquote><p>磁盘结构示意图</p><p><img src="https://blog.chasingwind.top/KrlXGL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/KrlXGL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>盘片结构图</p><p><img src="https://blog.chasingwind.top/QVBxyX.png" class="lazyload" data-srcset="https://blog.chasingwind.top/QVBxyX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>磁头位置：表示磁头当前位于哪一个磁道</p><p>磁头方向：是往里还是往外</p><hr><p>磁盘表面是可磁化的硬磁特性材料</p><p>移动磁头径向运动读取磁道信息</p></blockquote><ul><li><p>磁盘调度算法</p><blockquote><p>案例介绍：</p><p>我们将最外面的磁道定义为第1个磁道，最里面的磁道是第5个磁道</p><p>目前磁头在磁道4，磁头方向是由里向外读取的，现在想要读取磁道：1 4 2 3 1 5</p></blockquote><ol><li><p>先来先服务算法</p><blockquote><p>对于多个读写磁盘的请求，将所有的请求放到一个队列中，按照顺序完成读写需求</p><p>那么上面的案例的读取顺序就是：1 4 2 3 1 5</p></blockquote></li><li><p>最短寻道时间优先</p><blockquote><p>优先访问距离磁头最近的磁道</p><p>那么访问顺序就是： 4 3 2 1 1 5或者4 5 3 2 1 1，与磁头方向无关</p></blockquote></li><li><p>扫描算法（电梯算法）</p><blockquote><p>每次只向一个方向移动，到达一个方向尽头然后再反方向移动</p><p>那么访问顺序就是：4 3 2 1 1 5（由于目前在4磁道，由里往外）</p></blockquote></li><li><p>循环扫描算法</p><blockquote><p>读取方向是不变的，一个方向读取完之后，回到起点重新读取</p><p>假设这里读取方向是<strong>由外向里</strong></p><p>那么访问顺序就是：4 5 1 1 2 3 </p></blockquote></li></ol></li></ul></li></ol><h3 id="计算机的高速缓存"><a href="#计算机的高速缓存" class="headerlink" title="计算机的高速缓存"></a>计算机的高速缓存</h3><ol><li><p>高速缓存的工作原理</p><blockquote><p>字：是指存放在一个存储单元中的二进制代码组合，可以表示数据，指令，字符串等等，是内存中存储单元的最小单位</p><p>字块：存储在连续的存储单元中而被看作是一个单元的一组字</p><p><img src="https://blog.chasingwind.top/BB3fBV.png" class="lazyload" data-srcset="https://blog.chasingwind.top/BB3fBV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="主存大小和字以及字块之间的关系"></p><hr><p>字的寻址</p><p>首先，字的地址组成包含2部分</p><p><img src="https://blog.chasingwind.top/1cbpPM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1cbpPM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>字的地址长度和主存的关系</p><p><img src="https://blog.chasingwind.top/9s5dnI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/9s5dnI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>计算</p><p>块地址的数量（$2^m$）≤主存中字块数</p><p>块内地址数量（$2^b$）≤字块中字的数量</p><p><img src="https://blog.chasingwind.top/eYZH8J.png" class="lazyload" data-srcset="https://blog.chasingwind.top/eYZH8J.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>高速缓存中存储的数据与主存比较类似，也有字和字块的概念</p><p>同时，高速缓存中存储的数据是主存中数据的复制</p><p>主存字块数远大于缓存字块数</p><p><img src="https://blog.chasingwind.top/NZTJx8.png" class="lazyload" data-srcset="https://blog.chasingwind.top/NZTJx8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当高速缓存中有CPU需要的数据的时候，会直接从CPU中取数据。</p><p>否则，就需要从主存中取数据，这样就会降低CPU的效率</p><p>那么该怎么量化从告诉缓存取数据成功的几率呢？–缓存命中率或者访问效率</p><p><img src="https://blog.chasingwind.top/JgL0UG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/JgL0UG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="命中率"></p><p><img src="https://blog.chasingwind.top/j76OEb.png" class="lazyload" data-srcset="https://blog.chasingwind.top/j76OEb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="访问效率"></p></blockquote></li><li><p>高速缓存的替换策略</p><ul><li><p>高速缓存替换时机：当高速缓存中没有CPU所需要的数据的时候，就需要从主存载入所需数据到高速缓存中进行替换</p></li><li><p>替换策略</p><ol><li><p>随机算法</p><blockquote><p>随机选取高速缓存中的某位置的内容进行替换</p></blockquote></li><li><p>先进先出算法（FIFO）</p><blockquote><p>把高速缓存看做是一个先进先出的队列，优先替换最先进入队列的字块</p><p><img src="https://blog.chasingwind.top/VKNDrp.png" class="lazyload" data-srcset="https://blog.chasingwind.top/VKNDrp.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>最不经常使用算法（LFU）</p><blockquote><p>优先淘汰最不经常使用的字块，需要额外的空间记录字块的使用频率</p><p><img src="https://blog.chasingwind.top/DYmk9X.png" class="lazyload" data-srcset="https://blog.chasingwind.top/DYmk9X.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>最近最少使用算法（LRU）</p><blockquote><p>优先淘汰一段时间内没有使用的字块，有多种实现方法，通常使用双向链表实现；<strong>实现时，需要始终保证头部是最近使用的</strong></p><p><img src="https://blog.chasingwind.top/WKmGmy.png" class="lazyload" data-srcset="https://blog.chasingwind.top/WKmGmy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol><h2 id="计算机的CPU"><a href="#计算机的CPU" class="headerlink" title="计算机的CPU"></a>计算机的CPU</h2><h3 id="计算机的指令系统"><a href="#计算机的指令系统" class="headerlink" title="计算机的指令系统"></a>计算机的指令系统</h3><h3 id="计算机的控制器"><a href="#计算机的控制器" class="headerlink" title="计算机的控制器"></a>计算机的控制器</h3><h3 id="计算机的运算器"><a href="#计算机的运算器" class="headerlink" title="计算机的运算器"></a>计算机的运算器</h3><h3 id="计算机指令执行过程"><a href="#计算机指令执行过程" class="headerlink" title="计算机指令执行过程"></a>计算机指令执行过程</h3>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程基础之计算机组成原理(概述篇)</title>
      <link href="2021/03/21/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0%E7%AF%87/"/>
      <url>2021/03/21/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>这里简单的介绍了计算机的发展简史以及分类，计算机的体系结构以及为计算机进行分层便于理解，介绍了每一层对应的编程语言。另外还介绍了我们常见的用于衡量容量和速度的单位，之后介绍了计算机中的字符和编码集。</p><a id="more"></a><h2 id="计算机发展简史"><a href="#计算机发展简史" class="headerlink" title="计算机发展简史"></a>计算机发展简史</h2><ol><li><p>计算机发展的四个阶段</p><blockquote><p><img src="https://blog.chasingwind.top/MeCgQF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/MeCgQF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第一阶段：电子管计算机，代表是ENIAC（埃尼阿克），特点：集成度低，空间占用大，功耗高，运行速度慢，操作复杂。</p><p>第二阶段：晶体管计算机，代表TX-0，PDP-1，特点：集成度相对较高，空间占用相对较小；功耗相对较低，运行速度较快；操作相对简单，交互更加方便。</p><p>第三阶段：集成电路计算机，集成电路（IC）。并且这个阶段<strong>操作系统也诞生了</strong>（IBM的System/360），计算机变得更小，功耗更低，运算速度更快。</p><p>第四阶段：超大规模集成电路计算机，Apple和Apple二代诞生了。</p></blockquote></li><li><p>微型计算机的发展历史</p><blockquote><p><img src="https://blog.chasingwind.top/0XJNUx.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0XJNUx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>摩尔定律：集成电路的性能，每18~24个月就会提升一倍（适用于20世纪）</p><p>多核CPU的发展</p><p><img src="https://blog.chasingwind.top/3d37Jj.png" class="lazyload" data-srcset="https://blog.chasingwind.top/3d37Jj.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><ol><li><p>超级计算机</p><ul><li><p>特点：功能最强、运算速度最快、存储容量最大的计算机；多用于国家高科技领域和尖端技术研究</p></li><li><p>衡量单位：运算速度TFlop/s，<strong>1TFlop/s=每秒一万亿次浮点计算</strong></p><blockquote><p><img src="https://blog.chasingwind.top/fISkLJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/fISkLJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>大型计算机</p><ul><li><p>特点：又称大型机、大型主机、主机等，具有高性能，可处理大量数据与复杂的运算（比如银行系统），在大型机市场领域，IBM占据着很大的份额</p><blockquote><p><img src="https://blog.chasingwind.top/p2D08Z.png" class="lazyload" data-srcset="https://blog.chasingwind.top/p2D08Z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>迷你计算机（服务器）</p><ul><li>特点：也称为小型机，普通服务器。去IOE行动，就是将大型机转换为服务器</li><li>制造商：联想、华为、浪潮</li></ul></li><li><p>工作站</p><ul><li>特点：高端的通用微型计算机，提供比个人计算机更强大的性能；类似于普通台式电脑，体积较大，但性能强劲</li></ul></li><li><p>微型计算机</p><ul><li>又称为个人计算机，笔记本电脑</li><li><strong>从构成的本质上来讲，个人计算机与前面的分类无异</strong></li></ul></li></ol><h2 id="计算机的体系结构"><a href="#计算机的体系结构" class="headerlink" title="计算机的体系结构"></a>计算机的体系结构</h2><ol><li><p>冯诺依曼体系</p><ul><li><p>概念：<strong>将程序指令和数据一起存储的计算机设计概念结构</strong></p><blockquote><p>为什么会诞生冯诺依曼体系？</p><p>设计<strong>通用电路</strong>而非专用电路，然后将程序语言翻译成通用电路能够理解的语言，然后让通用电路去执行这个程序。</p><p><img src="https://blog.chasingwind.top/HhqrZF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/HhqrZF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>冯诺依曼结构的计算机组件</p><ul><li>存储器：存储运行程序和运行所需要的数据</li><li>控制器：控制程序流转</li><li>运算器：完成运算操作</li><li>输入设备</li><li>输出设备</li></ul></li><li><p>现代计算机都是属于冯诺依曼体系结构的计算机</p></li><li><p>冯诺依曼体系结构的计算机需要完成的功能</p><ul><li>能够把需要的程序和数据送至计算机中（输入设备）</li><li>能够长期记忆程序、数据、中间结果及最终运算结果的能力（存储器）</li><li>能够具备算术、逻辑运算和数据传送等数据加工处理的能力（控制器、运算器）</li><li>能够按照要求将处理结果输出给用户（输出设备）</li></ul></li><li><p>冯诺依曼体系结构图</p><blockquote><p><img src="https://blog.chasingwind.top/5CButL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/5CButL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>将存储器和CPU分开存在的问题：CPU和存储器速率之间的问题无法调和 </p></blockquote></li></ul></li><li><p>现代计算机的结构</p><ul><li><p>出现的原因：为了解决冯诺依曼体系计算机的瓶颈问题，充分利用CPU</p><blockquote><p><img src="https://blog.chasingwind.top/WWyT7X.png" class="lazyload" data-srcset="https://blog.chasingwind.top/WWyT7X.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>现代计算机的结构：以存储器为核心的结构</p><blockquote><p><img src="https://blog.chasingwind.top/c36gnm.png" class="lazyload" data-srcset="https://blog.chasingwind.top/c36gnm.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里所指的存储器并不是广义的存储器（硬盘、磁带等等），而是指围绕CPU所产生的更高速的设备，比如<strong>内存，CPU寄存器</strong></p></blockquote></li></ul></li></ol><h2 id="计算机的层次与编程语言"><a href="#计算机的层次与编程语言" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h2><ol><li><p>程序翻译和程序解释</p><ul><li><p>为什么需要这两步？因为人类语言和计算机语言并不相通，这就需要进行语言之间的转换。</p><blockquote><p>理解程序翻译和程序解释</p><p><img src="https://blog.chasingwind.top/CX3C3I.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CX3C3I.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>程序翻译：将高级语言L1翻译成等价的计算机语言L0的过程</p><blockquote><p><img src="https://blog.chasingwind.top/Hi06RJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Hi06RJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>程序解释：在程序运行过程中，将高级语言L1一句一句解释成计算机语言L0，过程中并不生成目标程序文件</p><blockquote><p><img src="https://blog.chasingwind.top/jF8iE9.png" class="lazyload" data-srcset="https://blog.chasingwind.top/jF8iE9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><hr><p>二者的区别：翻译过程生成新的L0程序，解释过程不生成新的L0程序</p></blockquote></li><li><p>程序翻译型语言（一次性编译生成目标文件再执行）：C/C++、Object-C、Golang</p></li><li><p>程序解释型语言（边解释边执行）：Python、PHP、JavaScript</p></li><li><p>翻译+解释：Java、C#</p><blockquote><p><img src="https://blog.chasingwind.top/jDvIAa.png" class="lazyload" data-srcset="https://blog.chasingwind.top/jDvIAa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>计算机的层次和编程语言</p><ul><li><p>计算机层次划分</p><blockquote><p><img src="https://blog.chasingwind.top/0wEESs.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0wEESs.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>硬件逻辑层：门、触发器等逻辑电路组成；属于电子工程的领域</p><p>微程序机器层：编程语言是微指令集； 微指令所组成的微程序直接交由硬件执行</p><p>传统机器层：编程语言是CPU指令集（机器指令）；编程语言和硬件是直接相关；不同架构的CPU使用不同的CPU指令集</p><ul><li><p>微指令、微程序和机器指令之间的关系</p><p><img src="https://blog.chasingwind.top/8HCfwM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/8HCfwM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul><p>操作系统层：向上提供了简易的操作界面；向下对接了指令系统，管理硬件资源（包括CPU，硬盘，输入输出设备等等）。操作系统层是软件和硬件之间的适配层。</p><p>汇编语言层：编程语言是汇编语言，<strong>可以翻译成直接执行的机器语言</strong>，由汇编器来完成翻译过程。</p><p>高级语言层：比如Java，C++</p><p>应用层：应用软件，比如Word、Excel、PPT等等</p></blockquote></li></ul></li></ol><h2 id="计算机的计算单位"><a href="#计算机的计算单位" class="headerlink" title="计算机的计算单位"></a>计算机的计算单位</h2><ol><li><p>容量单位</p><blockquote><p><img src="https://blog.chasingwind.top/e9oD2y.png" class="lazyload" data-srcset="https://blog.chasingwind.top/e9oD2y.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>为了存储更多的内容，需要更大的容量进行表示</p><p><img src="https://blog.chasingwind.top/z7HhkT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/z7HhkT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>生活中常见的问题</p><p><img src="https://blog.chasingwind.top/aLm5NP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/aLm5NP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>速度单位</p><ol><li><p>网络速度</p><blockquote><p><img src="https://blog.chasingwind.top/M9FPct.png" class="lazyload" data-srcset="https://blog.chasingwind.top/M9FPct.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>CPU速度</p><blockquote><p>CPU速度一般体现在CPU的时钟频率，单位一般是Hz（秒分之一），每秒钟周期性变动重复次数的计量</p><p>用在CPU中就表示高低电平在每秒内变化的次数</p><p><img src="https://blog.chasingwind.top/CvJDrG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CvJDrG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="计算机的字符和编码集"><a href="#计算机的字符和编码集" class="headerlink" title="计算机的字符和编码集"></a>计算机的字符和编码集</h2><ol><li><p>计算机字符编码集的历史</p><ul><li>ASCII码：使用7bits就可以完全表示，包含95个可打印字符以及33个不可打印字符（包括控制字符）</li><li>可扩展的ASCII码：8bit共256种</li><li>字符编码集的国际化</li></ul></li><li><p>中文编码集</p><ul><li><p>GB2312：一共7445个字符</p></li><li><p>GBK：向下兼容GB2312，向上支持ISO标准，共21003个汉字，支持全部中日韩汉字</p></li><li><p>Unicode：Unicode定义了世界通用的符号集，UTF-*实现了编码，UTF-8以字节为单位对Unicode进行编码</p><blockquote><p><img src="https://blog.chasingwind.top/49AE6p.png" class="lazyload" data-srcset="https://blog.chasingwind.top/49AE6p.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶</title>
      <link href="2021/03/15/Redis%E8%BF%9B%E9%98%B6/"/>
      <url>2021/03/15/Redis%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>这里填写摘要信息</p><a id="more"></a><h2 id="走进Redis"><a href="#走进Redis" class="headerlink" title="走进Redis"></a>走进Redis</h2><ol><li><p>Redis系统架构</p><blockquote><p>以下是Redis的特点</p><p><img src="https://blog.chasingwind.top/rzru6b.png" class="lazyload" data-srcset="https://blog.chasingwind.top/rzru6b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/hdd4Hk.png" class="lazyload" data-srcset="https://blog.chasingwind.top/hdd4Hk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>memcached也是一种内存数据库，但是数据类型是String，同时不支持持久化。</p><hr><p><img src="https://blog.chasingwind.top/1PWLWx.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1PWLWx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Redis主要数据结构</p><blockquote><p><img src="https://blog.chasingwind.top/tmIloM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/tmIloM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/qarPeq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qarPeq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>底层数据结构</p><p>String底层用的是Simple Dynamic String，同时存储长度</p><p>可以看到集合一般都有两套数据结构来支持，一种是为了性能，一种是为了节省内存。</p><p>Ziplist节省内存</p><p>数据大的时候用的树LinkedList ，其他三种也是同理</p><p>rehash操作，扩容的时候需要迁移数据，对性能产生影响</p><p><img src="https://blog.chasingwind.top/J30hKI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/J30hKI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Redis高性能关键技术</p><blockquote><p>高性能：基于内存操作</p><p>单线程：Redis6.0之前，操作如右图，单线程完成，后面新增了主线程之外的线程去进行其他操作</p><p><img src="https://blog.chasingwind.top/LrizOJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/LrizOJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/jUyVSx.png" class="lazyload" data-srcset="https://blog.chasingwind.top/jUyVSx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Redis高可用关键技术</p><blockquote><p>一个实例挂了，其他实例顶上来</p><p>主从复制：</p><p>故障切换</p><p>主观下线：某一个哨兵认为主实例下线</p><p>客观下线：哨兵统一认为主实例下线</p><p><img src="https://blog.chasingwind.top/695xPE.png" class="lazyload" data-srcset="https://blog.chasingwind.top/695xPE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Redis高扩展性关键技术</p><blockquote><p>数据量越来越多，进行扩展</p><p><img src="https://blog.chasingwind.top/HkDHnV.png" class="lazyload" data-srcset="https://blog.chasingwind.top/HkDHnV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>MOVED重定向机制：当客户端发现实例中哈希槽对应不上，就会返回给客户端这个信息</p><p><img src="https://blog.chasingwind.top/GfsJQP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GfsJQP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Redis3.2版本</p><p><img src="https://blog.chasingwind.top/mjWQoH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/mjWQoH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/Xla9fV.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Xla9fV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对比</p><p><img src="https://blog.chasingwind.top/HGMr4R.png" class="lazyload" data-srcset="https://blog.chasingwind.top/HGMr4R.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/0E7ry7.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0E7ry7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>单线程怎么高并发？epoll网络IO多路复用</p></li></ol><h2 id="Redis体验"><a href="#Redis体验" class="headerlink" title="Redis体验"></a>Redis体验</h2><ol><li><p>开源Redis的使用</p></li><li><p>Redis.conf配置</p><blockquote><p>bind：是否允许远程连接Redis</p><p>appendonly：是否打开aof，通常设置为appendsec,表示每秒刷新</p></blockquote></li><li><p>云Redis开通以及设置</p></li><li><p>春运迁徙页面</p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM:类加载子系统</title>
      <link href="2021/03/08/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/03/08/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>这里填写摘要信息</p><a id="more"></a><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><ol><li><p>内存图</p><blockquote><p>class字节码文件需要通过类加载子系统加载到内存中</p><p><img src="https://blog.chasingwind.top/2PuNhf.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/2PuNhf.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>详细内存图</p><blockquote><p>类加载器子系统中包含3个环节：</p><ol><li>加载（Loading）：将字节码文件通过类加载器加载到内存中</li><li>链接（Linking）：验证–&gt;准备–&gt;解析</li><li>初始化（Initialization）：静态变量的显示初始化</li></ol><p><img src="https://blog.chasingwind.top/x1NhuJ.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/x1NhuJ.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h2><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><h2 id="ClassLoader的使用说明"><a href="#ClassLoader的使用说明" class="headerlink" title="ClassLoader的使用说明"></a>ClassLoader的使用说明</h2><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
      
      
      <categories>
          
          <category> JVM系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM内存与垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM:Java体系结构</title>
      <link href="2021/03/05/JVM-Java%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2021/03/05/JVM-Java%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>本节先介绍了Java的历史以及JVM的历史，以便我们对JVM整个发展有更好的了解，方便在以后的学习中更加快速掌握细节知识。</p><a id="more"></a><h2 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h2><h3 id="Java以及JVM简介"><a href="#Java以及JVM简介" class="headerlink" title="Java以及JVM简介"></a>Java以及JVM简介</h3><ol><li><p>Java程序运行在JVM之上</p><blockquote><p>Java是跨平台的语言</p><p><img src="https://blog.chasingwind.top/f44G2F.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/f44G2F.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/TPreNA.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/TPreNA.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>JVM是跨语言的平台：面向字节码文件，只要其他语言编译后能转成字节码文件，都可以在JVM上运行，所以具有语言无关性。</p><p><img src="https://blog.chasingwind.top/5VHbsu.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/5VHbsu.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>JVM与C++的垃圾回收机制</p><blockquote><p>为什么需要垃圾回收机制？</p><p>如果内存中垃圾一直不进行回收的话，到最后程序可能会出现OOM异常（Out Of Memory）</p><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p><p>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</p></blockquote></li></ol><h3 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h3><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款<strong>软件</strong>，用来执行一系列虚拟计算机指令。大体上，<strong>虚拟机可以分为系统虚拟机和程序虚拟机</strong>。</p><ul><li>大名鼎鼎的Visual Box，Mware就属于<strong>系统虚拟机</strong>，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li><li><strong>程序虚拟机</strong>的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li><li>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</li></ul></li><li><p>JVM虚拟机</p><ul><li>Java虚拟机是一台<strong>执行Java字节码的虚拟计算机</strong>，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成（语言无关性）。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li><li>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里</li><li>特点：一次编译，到处运行；自动内存管理；自动垃圾回收</li></ul></li><li><p>JVM在系统中所处的位置</p><blockquote><p>JVM运行在操作系统之上</p><p><img src="https://blog.chasingwind.top/bCjSCR.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/bCjSCR.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在Java中的体系结构</p><p>.java—javac编译—&gt;.class——&gt;JVM运行字节码文件</p><p><img src="https://blog.chasingwind.top/f3UkMF.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/f3UkMF.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h3><ol><li><p>结构图</p><blockquote><p><img src="https://blog.chasingwind.top/bYpF2N.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/bYpF2N.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>此图主要针对HotSpotVM，目前市面上高性能虚拟机代表作之一</li><li>上图中间部分，橙色的方法区和堆表示的是<strong>多个线程共享</strong>；而Java栈和本地方法栈以及程序计数器是<strong>每个线程独有的</strong>。</li><li>执行引擎包括解释器，JIT即时编译器和垃圾回收器。<strong>执行引擎的作用</strong>：将字节码文件翻译成机器语言</li></ul></blockquote></li></ol><h3 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h3><blockquote><p><img src="https://blog.chasingwind.top/jFkNOu.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/jFkNOu.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在编译过程中，任何一步出现错误都不能正常生成字节码文件</p><p>执行引擎可以将我们写的高级语言翻译成机器语言</p></blockquote><h3 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h3><ul><li><p>Java编译器输入的指令流基本上可以分为2种：<strong>基于栈的指令集架构</strong>以及<strong>基于寄存器的指令集架构</strong>。HotSpot是基于栈的指令集架构，HotSpot中除了PC寄存器之外，再也没有与寄存器相关的部分</p></li><li><p>两种架构之间的区别</p><ol><li><p>基于栈式架构特点</p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，执行过程依赖于操作栈。指令集更小（字节码文件中每8位进行对齐），编译器容易实现</li><li>不需要硬件支持，只需要操作栈，不与硬件打交道，可移植性更好，更好实现跨平台</li></ul></li><li><p>基于寄存器架构的特点</p><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀，执行更加高效</li><li>完成一项操作使用的指令更少（指令集采用16位进行对齐）</li><li>在大部分情况下，基于寄存器的指令集往往都以一地址指令、二地址指令、三地址指令为主。</li></ul></li><li><p>基于栈和基于寄存机完成同一个操作使用的指令集</p><ul><li><p>计算2+3</p><blockquote><p>基于栈的计算流程：</p><pre><code>iconst_2 //常量2入栈istore_1iconst_3 // 常量3入栈istore_2iload_1iload_2iadd //常量2/3出栈，执行相加istore_0 // 结果5入栈</code></pre><hr><p>基于指令集的计算流程：</p><pre><code>mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3</code></pre><hr><p>同样的操作，虽然基于栈实现操作需要的指令集小（指令是8位），但是基于栈需要的指令比基于寄存器需要的指令多</p></blockquote></li><li><p>查看字节码中的指令</p><blockquote><p>编译之后 生成的字节码在target目录下</p><p>反编译<code>javap -v xxxx</code>  代码对应的指令如下</p><p><img src="https://blog.chasingwind.top/700oSD.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/700oSD.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol></li><li><p>基于栈的架构总结</p><ul><li>跨平台性、指令集小但是指令多、执行性能比基于寄存器的架构差</li></ul></li></ul><h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><ol><li>启动<ul><li>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个初始类是由虚拟机的具体实现指定的。</li></ul></li><li>运行<ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</li></ul></li><li>退出<ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止（没有处理这些异常或者错误）</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ul></li></ol><h3 id="JVM的发展历程"><a href="#JVM的发展历程" class="headerlink" title="JVM的发展历程"></a>JVM的发展历程</h3><ol><li><p>Sun Classic VM</p><ul><li>Java1.0，Sun公司发布，世界上第一款商用虚拟机</li><li>内部只提供解释器，没有JIT即时编译器</li></ul></li><li><p>Exact VM</p></li><li><p>HotSpot VM</p><ul><li>JDK1.3开始成为默认虚拟机</li><li>服务器、客户端以及嵌入式都有应用</li><li>HotSpot就是体现热点代码探测技术<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器和解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul></li><li><p>JRockit VM</p><ul><li><p>BEA公司，后被Oracle收购</p></li><li><p>专注于服务器端应用，不太关注启动速度，因此不包含解释器，全部代码都靠即时编译器编译后执行</p></li><li><p>JRockit JVM是目前世界上最快的JVM，面向延迟敏感型应用</p></li></ul></li><li><p>J9 JVM，IBM公司</p></li><li><p>KVM和CDC/CLDC HotSpot</p><ul><li><p>Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p></li><li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul></li></ul><p>所有的虚拟机的原则：一次编译，到处运行。</p></li><li><p>Azul VM</p><ul><li>性能更高，但是与特定硬件平台绑定、软硬件配合的专用虚拟机</li><li>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li><li>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li><li>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性</li></ul></li><li><p>Liquid VM</p><ul><li>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</li></ul></li><li><p>Apache Harmony</p></li><li><p>Micorsoft JVM</p><ul><li>当年微软为了在IE3浏览器中支持Java Applets开发的</li></ul></li><li><p>TaoBao VM</p><ul><li>基于OpenJDK HotSpot VM深度定制的、开源的高性能服务器版JVM</li><li>创新的GCIH（GC invisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap(堆)中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li><li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li><li>使用crc32指令实现JVM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGc</li><li>taobao JVM应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</li></ul></li><li><p>Dalvik VM</p><ul><li>Android5.0之前使用的虚拟机，Dalvik 只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范，不能直接执行Java的Class文件</li><li>基于寄存器架构，不是jvm的栈架构。</li><li>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</li><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li><li>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li></ul></li><li><p>GRaal VM</p><ul><li>2018年4月，Oracle Labs公开了Graal VM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</li><li>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM内存与垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁机制以及主从复制</title>
      <link href="2021/02/24/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>2021/02/24/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>MySQL中锁的重要性是不言而喻的，在面试中以及平时工作中都会经常使用。理解锁机制，掌握锁的分类以及每一种锁可能会带来的问题将会有很大的帮助。另外，主从复制这一部分的内容需要单独–&gt;TODOList</p><a id="more"></a><h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><ul><li>锁是计算机协调多个进程或线程并发访问某一资源的机制</li><li>在数据库中，除传统的计算资源（如CPU、RAM、IO等）的争用以外，数据（表）也是一种供许多用户共享的资源。<strong>如何保证数据并发访问的一致性、有效性</strong>是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</li></ul><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ol><li><p>根据数据操作类型分类：读锁、写锁</p><div class="note "><p>读锁（共享锁）： 针对同一份数据，多个读操作可以同时进行而不会相互影响。</p></div><div class="note "><p>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</p></div></li><li><p>对数据操作粒度分类：表锁（偏读）、行锁（偏写）、页锁</p><div class="note "><p><strong>表锁</strong></p><details green><summary> 特点： </summary>              <div class='content'>              <div class="note guide clear"><p>偏向MyISAM存储引擎，开销小，加锁快</p></div><div class="note guide clear"><p>无死锁，因为锁的是整个表</p></div><div class="note guide clear"><p>锁粒度大，发生锁冲突概率高</p></div><div class="note guide clear"><p>并发度最低</p></div>              </div>            </details></div></li></ol><h3 id="表锁案例演示（偏读，偏向MyISAM存储引擎）"><a href="#表锁案例演示（偏读，偏向MyISAM存储引擎）" class="headerlink" title="表锁案例演示（偏读，偏向MyISAM存储引擎）"></a>表锁案例演示（偏读，偏向MyISAM存储引擎）</h3><pre><code class="mysql"># 查看表是否有锁show open tables ;</code></pre>   <span class='p cyan'>In_use = 0表示当前表未加锁</span><p>   <img src="https://blog.chasingwind.top/VgXLt8.png" class="lazyload" data-srcset="https://blog.chasingwind.top/VgXLt8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="VgXLt8"></p><hr><pre><code class="mysql"># 手动为account表上读锁,article表上写锁lock tables account read, SqlPro.article write ;</code></pre><p>   为account表上读锁之后进行查询</p><p>   <img src="https://blog.chasingwind.top/PR8djq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/PR8djq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>   解锁</p><pre><code class="mysql">## 解锁unlock tables ;</code></pre><p>   解锁之后再次进行查询</p><p>   <img src="https://blog.chasingwind.top/cCwBUd.png" class="lazyload" data-srcset="https://blog.chasingwind.top/cCwBUd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>   读锁和写锁究竟会如何影响我们的操作呢？</p><blockquote><p>以下案例均在两个Session中实现</p><p><img src="https://blog.chasingwind.top/IXQvHf.png" class="lazyload" data-srcset="https://blog.chasingwind.top/IXQvHf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol><li><p>加读锁（共享锁）</p><blockquote><p>在Session1中为account加读锁，在Session2中读取account</p><p>Session1和Session2均可以读取，这就说明了读锁是共享锁</p><p><img src="https://blog.chasingwind.top/OaDbPU.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OaDbPU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Session1写（insert或者update）加读锁的表</p><p>结果是不允许修改</p><p><img src="https://blog.chasingwind.top/4RrhLQ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4RrhLQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Session1读别的表  不允许。因为目前Session1已经有了一把表锁在手上，而且还未释放锁。</p><p>由于MySQL出于自我保护的机制，需要当前表解锁之后才能读其他的表，否则这个表可能会一直被锁而没有后续操作。</p><p><img src="https://blog.chasingwind.top/WexAd0.png" class="lazyload" data-srcset="https://blog.chasingwind.top/WexAd0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Session2写Session1中加了读锁的表</p><p>发现Session2一直处于阻塞状态。</p><p>当在系统中如果有多个操作都需要写加读锁的表，那么都会处于阻塞状态，这就会大大影响系统的性能了。</p><p><img src="https://blog.chasingwind.top/zXTMkr.png" class="lazyload" data-srcset="https://blog.chasingwind.top/zXTMkr.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在Session1解锁之后 Session2的写操作立即执行了</p><hr><p>总结  Session1中某张表加读锁</p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>当前Session可以查询加读锁的表</td><td>当前Session可以查询Session1中加读锁的表</td></tr><tr><td>当前Session不能查询其他没有锁定的表（因为占据着一个锁，未释放锁就不能操作其他的表）</td><td>当前Session可以查询或者更新其他未锁定的表</td></tr><tr><td>当前Session写加读锁的表报错（读锁不允许进行写操作）</td><td>当前Session写Session1中加读锁的表会<strong>一直等待（阻塞）</strong></td></tr><tr><td>释放锁</td><td>在Session1释放锁之后，执行阻塞的对之前加锁的表的写操作</td></tr></tbody></table></blockquote></li><li><p>加写锁（排它锁）</p><blockquote><p><img src="https://blog.chasingwind.top/lLhtAr.png" class="lazyload" data-srcset="https://blog.chasingwind.top/lLhtAr.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Session1读、写加写锁的表 都可以执行</p><p><img src="https://blog.chasingwind.top/PnK8zv.png" class="lazyload" data-srcset="https://blog.chasingwind.top/PnK8zv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Session1读、写其他表  均报错</p><p><img src="https://blog.chasingwind.top/2ty7TM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/2ty7TM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Session2读取加写锁的表 一直处于阻塞状态  Session1释放写锁之后 Session2读取命令执行</p><p><img src="https://blog.chasingwind.top/71xlF4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/71xlF4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同样  Session2写加写锁的表 同样处于阻塞状态，等待Session1写锁释放之后就会执行</p><p><img src="https://blog.chasingwind.top/qbgEUG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qbgEUG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Session1中某张表加写锁</p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>可以读写加写锁的表</td><td>读取和写加写锁的表会阻塞</td></tr><tr><td>不可以读写其他表（因为占据着一个锁，未释放锁就不能操作其他的表）</td><td>读写其他的表都可以正常进行</td></tr></tbody></table></blockquote></li><li><p>表锁分析</p><blockquote><p>查看当前表的锁的情况</p><pre><code class="mysql"># 查看数据库中表的加锁情况show open tables;# 查看MySQL表的锁定情况show status like &#39;table_locks%&#39;;</code></pre><p><img src="https://blog.chasingwind.top/M6CvYJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/M6CvYJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加一</p><p><strong>Table_locks_waited</strong>：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值就加一），此值高说明当前系统存在较严重的表级锁争用情况</p></blockquote></li><li><p>总结</p><ul><li>MyISAM存储引擎在执行<strong>查询（SELECT语句）之前，会自动给涉及的所有表加读锁</strong></li><li>MyISAM存储引擎在执行<strong>增删改之前，会自动给涉及的所有表加写锁</strong></li><li>因此，MyISAM存储引擎的读写调度是<strong>写优先</strong>，所以不适合作为写为主表的引擎。因为执行写操作，会加写锁，其他线程不能做任何操作（包括读写），大量的写操作会使读很难获取到锁，从而造成永远堵塞。</li><li>MySQL的表级锁有两种模式：表共享读锁、表独占写锁</li><li><p class='p cyan'>读锁会阻塞写，但不会阻塞读。而写锁会阻塞读和写。</p></li></ul></li></ol><h3 id="行锁案例演示（偏写，偏向InnoDB存储引擎）"><a href="#行锁案例演示（偏写，偏向InnoDB存储引擎）" class="headerlink" title="行锁案例演示（偏写，偏向InnoDB存储引擎）"></a>行锁案例演示（偏写，偏向InnoDB存储引擎）</h3><ol><li><p>特点</p><ul><li><p>偏向InnoDB存储引擎</p></li><li><p>开销大，加锁慢，会出现死锁</p></li><li><p>锁的粒度最小，发生锁冲突的概率最低，并发度也最高</p><blockquote><p>InnoDB和MyISAM最大的不同点：InnoDB支持事务，InnoDB采用行级别的锁</p><hr><p><strong>事务（Transaction）</strong>：事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常称为ACID属性。</p><ul><li><p>原子性（Atomicity）：事务是一个原子操作。里面的SQL语句要么同时执行，要么都不执行</p></li><li><p>一致性（Consistent）：ACID里的AID都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个C,实际上它依赖于应用层,也就是依赖于开发者。这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态，什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性.<a href="https://www.zhihu.com/question/31346392">参考文章</a></p></li><li><p>隔离性（Isolation）：数据库提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”的环境执行。这也同时意味着事务处理过程中的中间状态对外部是不可见的。</p></li><li><p>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使系统出现故障也能够保持。</p></li></ul><hr><p>并发事务处理带来的问题</p><ul><li><p>更新丢失：当多个事务更新同一行数据的时候，由于事务之间是隔离的，就会可能出现A事务和B事务在时间上有一定的执行顺序，比如事务A和事务B，修改同一个数据，事务开始的时候，查询的这一行数据是相同的，A事务执行完之后提交，此时数据已经被修改了，但是B事务还是以为数据还是刚开始的时候的。那么A事务执行的更新就丢失了，被B事务修改的内容覆盖了。<strong>解决方法</strong>：在A事务提交之前，B事务不可访问同一行数据。<a href="https://www.cnblogs.com/immer/p/10930020.html">参考文章</a></p></li><li><p>脏读：一个事务正在对一条记录修改，在这个事务未提交之前，这条数据就处于不一致的状态，此时另一个事务也来读取这个数据，<strong>如果不加控制</strong>，第二个事务就读到了脏数据并在此基础之上做进一步的处理了，就会产生未提交的数据依赖关系。<strong>总结</strong>：事务A读取了事务B已修改但尚未提交的数据，并在此基础之上进行操作。此时，如果A事务回滚，那么数据就不符合一致性原则。</p></li><li><p>不可重复读：事务A在读取某些数据之后，过段时间（还在事务中）再次读取以前读过的数据，发现数据已经被事务B被改变并提交，那么事务A再次读取的时候，就会发现数据已经不匹配了。<strong>总结</strong>：事务A读取到了事务B已经提交的修改数据，不符合隔离性</p></li><li><p>幻读：一个事务按照相同的查询条件进行查询，过段时间后，重新按照相同条件查询（还在同一个事务中），却发现了其他事务insert了新的记录。总结：事务A读取到了事务B新增的数据，不符合隔离性。</p></li></ul><hr><p>事务的隔离级别</p><p>MySQL默认隔离级别：可重复读</p><p><img src="https://blog.chasingwind.top/q031Ez.png" class="lazyload" data-srcset="https://blog.chasingwind.top/q031Ez.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>案例演示</p><blockquote><p>InnoDB引擎  事务隔离级别是可重复度  并关闭自动提交 </p><p>分别为a、b创建单值索引，因为<strong>如果where条件没有索引的话，行锁会变成表锁</strong></p><p><img src="https://blog.chasingwind.top/6PNqKx.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6PNqKx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>A 修改之后未手动提交，然后查询，发现可以读取到已经修改未提交的数据</p><p>此时A还是未提交 B去查询，发现是修改之前的数据</p><p><img src="https://blog.chasingwind.top/WYEBst.png" class="lazyload" data-srcset="https://blog.chasingwind.top/WYEBst.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>A手动提交事务之后 B手动提交事务之后</p><p>二者再次查询 发现都能读取到A修改后的数据</p><p><img src="https://blog.chasingwind.top/6oQbaI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6oQbaI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>修改同一行数据</p><p>A修改之后还未提交 B修改同一行数据  B会处于阻塞状态</p><p><img src="https://blog.chasingwind.top/QYCx4X.png" class="lazyload" data-srcset="https://blog.chasingwind.top/QYCx4X.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>A commit之后  B处于阻塞的更新语句也执行了</p><p><img src="https://blog.chasingwind.top/zvzfkt.png" class="lazyload" data-srcset="https://blog.chasingwind.top/zvzfkt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>B commit</p><p><img src="https://blog.chasingwind.top/AnG2uT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/AnG2uT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>A修改一行不提交 B修改另一行不提交  两者都不会冲突</p><p><img src="https://blog.chasingwind.top/tXo2Pn.png" class="lazyload" data-srcset="https://blog.chasingwind.top/tXo2Pn.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>二者都commit之后  更新都提交了</p><p><img src="https://blog.chasingwind.top/gQmKSb.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gQmKSb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>索引失效导致行锁变表锁</p><blockquote><p>这个问题很隐蔽，需要多加注意</p><p>首先建立一个新表 a是int型  b是varchar型，并为a、b创建索引</p><p><img src="https://blog.chasingwind.top/2hguQI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/2hguQI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>正常情况下 A修改第1行数据，B修改第6行数据。二者互不影响，如下图</p><p>A修改未提，B修改也未提交。这种情况下B并未阻塞，因为修改的不是同一行数据。</p><p><img src="https://blog.chasingwind.top/Bv79wZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Bv79wZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>二者都commit之后  数据都修改了</p><p><img src="https://blog.chasingwind.top/SN7Top.png" class="lazyload" data-srcset="https://blog.chasingwind.top/SN7Top.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们知道 如果MySQL数据进行了数据类型转换，会使得索引失效。在行锁的情况下，索引失效会导致行锁变为表锁。</p><p>这里varchar类型必须使用<code>&#39;&#39;</code>，否则会发生类型转换导致索引失效</p><p>左边where条件b列索引使用的是number类型，原本是varchar类型，导致索引失效</p><p>左边update执行完之后 再去执行右边的update ，右边的update被阻塞了！！</p><p><img src="https://blog.chasingwind.top/gNZvDl.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gNZvDl.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>左侧commit之后，右边立即执行了</p><p><img src="https://blog.chasingwind.top/rA0NzC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/rA0NzC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>两个都commit之后  修改成功</p><p><img src="https://blog.chasingwind.top/r8bomu.png" class="lazyload" data-srcset="https://blog.chasingwind.top/r8bomu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>总结：<strong>如果索引失效，InnoDB默认会将行锁变为表锁！</strong></p></blockquote></li><li><p>间隙锁</p><ol><li><p>什么是间隙锁</p><blockquote><p>当我们的<strong>查询条件是范围条件</strong>而不是相等条件的时候，InnoDB会给符合条件的已有数据记录的索引项进行加锁；对于键值条件在范围内但并不存在的记录，就叫做“间隙”。</p><p>InnoDB也同时会对间隙进行加锁，也就是所谓的间隙锁（Next-Key锁）</p></blockquote></li><li><p>危害</p><blockquote><p>间隙锁锁定某个范围的索引值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定期间，无法插入锁定键值范围内的数任何据。</p></blockquote></li><li><p>演示</p><blockquote><p>首先设置数据库隔离级别：可重复读</p><pre><code class="mysql">set GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></pre><p>初始数据 a字段设置有单值索引</p><p><img src="https://blog.chasingwind.top/Cwg3eF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Cwg3eF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>左侧更新（where条件使用索引范围），不提交</p><p>右侧insert 右侧会阻塞，即使右侧insert的键是3，在表中并不存在</p><p><img src="https://blog.chasingwind.top/GvSI4U.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GvSI4U.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>左侧commit之后 右侧的update也立即执行了</p><p><img src="https://blog.chasingwind.top/Hmufjl.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Hmufjl.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>间隙锁解决的问题：幻读（隔离级别：可重复读下）</p><ul><li><a href="https://www.jianshu.com/p/32904ee07e56">参考文章</a></li></ul></li><li><p>手动锁定某一行</p><blockquote><p>当我们需要确定修改某一条数据时，不希望其他人这条具体数据进行操作</p><p>左边两条语句就是指定锁住某一行  并且未提交</p><p>右边去更新锁定的行的时候 会被阻塞</p><p><img src="https://blog.chasingwind.top/eEQWbA.png" class="lazyload" data-srcset="https://blog.chasingwind.top/eEQWbA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>左边commit ，右边也被执行了</p><p><img src="https://blog.chasingwind.top/TT7uM4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/TT7uM4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>关于<code>for update</code>和<code>for share </code>以及<code>lock in share mode</code></p><p><code>for update</code>：排它锁</p><p><code>for share </code>以及<code>lock in share mode</code>：均为共享锁</p><p><img src="https://blog.chasingwind.top/QemHJ2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/QemHJ2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h3 id="行锁总结"><a href="#行锁总结" class="headerlink" title="行锁总结"></a>行锁总结</h3><ul><li><p>查看行锁状况</p><pre><code class="mysql"># 查看当前系统行锁的状况show status like &#39;innodb_row_lock%&#39;</code></pre><blockquote><p>参数意义</p><p><img src="https://blog.chasingwind.top/cJb1tb.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/cJb1tb.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>优化建议</p><ol><li>尽可能让所有数据检索都通过索引来完成，避免无索引或者索引失效导致行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件，避免间隙锁的出现</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li></ol></li></ul><h2 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h2><p>TODO </p>]]></content>
      
      
      <categories>
          
          <category> MySQL高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL锁机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO</title>
      <link href="2021/01/02/Java-IO/"/>
      <url>2021/01/02/Java-IO/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="Java-IO的演进"><a href="#Java-IO的演进" class="headerlink" title="Java IO的演进"></a>Java IO的演进</h2><h3 id="IO模型基本说明"><a href="#IO模型基本说明" class="headerlink" title="IO模型基本说明"></a>IO模型基本说明</h3><ul><li>IO模型：就是用什么样的通道或者说通信模式和架构进行数据的传递与接收，这在很大程度上决定了程序通信的性能。Java共支持3种网络编程的IO模型：BIO、NIO、AIO</li></ul><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ul><li><p>BIO（Blocking IO，同步阻塞）：每个客户端与服务器之间的通信都需要创建一个单独的连接，也就是一个线程。如果客户端越来越多，则需要更多的线程，那么线程之间的切换也会消耗大量的系统开销。何为同步？如果当前线程在等待客户端的数据，客户端没有发送数据，那么此线程也会一直处于等待，不能做其他的事情。</p><blockquote><p><img src="https://blog.chasingwind.top/k7BlE4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/k7BlE4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>NIO（Non-Blocking IO，同步非阻塞）：服务器实现模式为一个线程来管理一个多路复用器，客户端所有的请求都会注册到多路复用器上，之后多路复用器就会轮询各个通道，通道中有数据的话，才会创建线程处理请求。否则，就不必分配线程去等待通道中传来数据，这就实现了非阻塞。</p><blockquote><p><img src="https://blog.chasingwind.top/59kjZG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/59kjZG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>AIO（Asynchronous IO，异步非阻塞）：AIO也称为NIO.2，NIO的2.0版本。服务器的实现模式是一个有效请求对应一个线程，客户端的IO请求都是先由操作系统先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间长的应用</p></li></ul><h3 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h3><ul><li>BIO适用于连接数目比较小并且架构固定。这种方式对服务器资源要求比较高（一个客户端就需要一个线程），并发局限于应用中</li><li>NIO适用于连接数目多并且连接时间比较短（轻操作）的架构。比如聊天服务器，弹幕系统，服务器间通讯等等</li><li>AIO方式适用于连接数目多并且连接比较长（重操作）的架构。比如相册服务器，充分调用OS参与并发操作。</li></ul><h2 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h2><h3 id="BIO工作机制"><a href="#BIO工作机制" class="headerlink" title="BIO工作机制"></a>BIO工作机制</h3><ul><li>Java BIO就是传统的Java IO编程，相关的类和接口都在java.io包下</li><li>BIO（Blocking IO）：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。</li></ul><h3 id="传统BIO编程实例"><a href="#传统BIO编程实例" class="headerlink" title="传统BIO编程实例"></a>传统BIO编程实例</h3><ul><li><p>基础BIO模式下，基于IO流通信模式</p><blockquote><p><img src="https://blog.chasingwind.top/UdQq9l.png" class="lazyload" data-srcset="https://blog.chasingwind.top/UdQq9l.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编程实现</p><ul><li><p>传统的网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定IP地址和端口号），客户端通过连接操作向服务端监听的端口地址发起请求操作，基于TCP协议下进行三次握手连接，连接成功过后，双方通过Socket进行通信</p></li><li><p>传统的同步阻塞开发模型中，服务端ServerSocket负责IP地址的绑定，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入输出流进行同步阻塞通信。</p><blockquote><p>实现目标：客户端发送消息，服务端接收消息</p><p>服务端</p><p><img src="https://blog.chasingwind.top/CmAh0f.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CmAh0f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>客户端</p><p><img src="https://blog.chasingwind.top/9rzAmK.png" class="lazyload" data-srcset="https://blog.chasingwind.top/9rzAmK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>先启动服务端  </p><p>可以看到右上角服务端一直在运行中 其实是服务端的线程一直在监听客户端的Socket请求</p><p><img src="https://blog.chasingwind.top/uT7AVF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/uT7AVF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>再启动客户端 这个时候服务端进入了等待客户端的数据的状态</p><p>客户端发完消息之后 就会断开连接</p><p><img src="https://blog.chasingwind.top/sUJ0o3.png" class="lazyload" data-srcset="https://blog.chasingwind.top/sUJ0o3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>服务端等到了客户端的消息  </p><p>由于客户端完成之后连接就断开了  所以服务端完成消息的接受之后，客户端断开，服务端也就断开了</p><p><img src="https://blog.chasingwind.top/wSvXZK.png" class="lazyload" data-srcset="https://blog.chasingwind.top/wSvXZK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在上面的案例中，服务端会一直等待客户端的数据，如果客户端没有发送数据，服务端就会一直等待，也就是一直处于阻塞状态</p></blockquote></li><li><p>多发和多收</p><blockquote><p>服务端 与客户端建立连接之后 while循环一直监听客户端的数据</p><p><img src="https://blog.chasingwind.top/qMmTAn.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qMmTAn.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>客户端 输入消息</p><p>由于客户端并没有断开连接  服务端接收到消息之后 也并没有暂停 而是再次等待客户端的消息</p><p><img src="https://blog.chasingwind.top/XNrntv.png" class="lazyload" data-srcset="https://blog.chasingwind.top/XNrntv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>服务端接收消息之后 还是处于等待客户端消息的状态</p><p><img src="https://blog.chasingwind.top/N1WIg0.png" class="lazyload" data-srcset="https://blog.chasingwind.top/N1WIg0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>上面的案例只是一个服务端对应一个接客户端，那么如何接收多个客户端的消息通信请求呢？</p><blockquote><p>这个时候我们就需要在服务端引入多线程了，也就是说客户端发起一个请求，服务端就创建一个新的线程来处理这个客户端的请求，这就实现了一个客户端一个线程的模型</p><p><img src="https://blog.chasingwind.top/k7BlE4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/k7BlE4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>分析之前的代码  为何服务端只能接受一个客户端发来的请求？</p><p><img src="https://blog.chasingwind.top/GIpOs3.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GIpOs3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以服务端就需要对每个客户端都创建一个线程单独处理每个客户端的通信需求</p><p><img src="https://blog.chasingwind.top/DTCY5W.png" class="lazyload" data-srcset="https://blog.chasingwind.top/DTCY5W.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>启动多个客户端</p><p>首先需要配置允许并发运行</p><p><img src="https://blog.chasingwind.top/08YBKi.png" class="lazyload" data-srcset="https://blog.chasingwind.top/08YBKi.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>启动两个客户端  可以发现服务端都可以接受到</p><p><img src="https://blog.chasingwind.top/qCBt1o.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qCBt1o.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看线程  每个客户端请求都单独创建了一个线程进行处理</p><p><img src="https://blog.chasingwind.top/fBQ0O7.png" class="lazyload" data-srcset="https://blog.chasingwind.top/fBQ0O7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>总结</p><ol><li>每个Socket被服务端接收，都会创建一个线程，那么线程之间的竞争、切换都会影响性能</li><li>每个线程都会占用栈空间以及CPU资源</li><li>并不是每个Socket都进行IO操作，但是线程还是需要进行等待</li><li>客户端和服务器之间是一对一的线程开销，客户端访问量越大，服务器端将有可能发生线程栈溢出，线程创建失败。最终导致进程宕机或者僵死，无法对外提供服务</li></ol></li></ul><h3 id="伪异步IO编程"><a href="#伪异步IO编程" class="headerlink" title="伪异步IO编程"></a>伪异步IO编程</h3><ul><li><p>在上述传统的BIO中，客户端和服务器之间的线程是一对一的，随着客户端的增多，服务端线程也需要相应的增加，就有可能导致栈溢出的情况</p></li><li><p>伪异步IO通信可以解决这个问题，在服务端维护一个线程池，固定服务端线程的数量；</p></li><li><p>伪异步IO通信框架，使用线程池和任务队列来实现，当客户端接入时，将客户端的Socket封装成一个Task（实现Runnable接口）交给后端的线程池中进行处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中的Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机</p><blockquote><p><img src="https://blog.chasingwind.top/7OXdMi.png" class="lazyload" data-srcset="https://blog.chasingwind.top/7OXdMi.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>但是有一个问题就是这种情况支持的客户端的数量是有限的，除非客户端完成任务之后释放连接对应的线程，可以让线程执行其他的任务</p></li><li><p>服务端代码</p><blockquote><p>创建线程池 存放消息队列</p><p><img src="https://blog.chasingwind.top/KHFt7X.png" class="lazyload" data-srcset="https://blog.chasingwind.top/KHFt7X.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试</p><p>当我们开3个客户端的时候都是可以的</p><p><img src="https://blog.chasingwind.top/IurYAX.png" class="lazyload" data-srcset="https://blog.chasingwind.top/IurYAX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>开第四个的时候是无法执行的  因为我们在创建线程池的时候 规定了核心线程数是3，只能处理3个任务，第4个进入到任务队列中进行等待</p><p>当关闭其中一个客户端之后  线程就被释放了 接着处理消息队列中的任务</p></blockquote></li><li><p>伪异步IO使用线程池实现，虽然避免了为每一个请求创建一个独立线程造成线程资源耗尽的问题，但是底层依然采用的是同步阻塞模型，因此无法从根本上解决问题</p></li><li><p>如果单个消息处理的缓慢，或者线程池中的全部线程都被阻塞，那么后续Socket中的IO消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。</p></li></ul><h3 id="基于BIO形式下的文件上传"><a href="#基于BIO形式下的文件上传" class="headerlink" title="基于BIO形式下的文件上传"></a>基于BIO形式下的文件上传</h3><ul><li><p>客户端</p><blockquote><p>上传<strong>任意文件类型</strong>给服务器端进行保存，由于支持上传各种类型的文件，就需要服务器端知道上传的是什么类型的文件，所以客户端既需要告诉服务端文件类型，还需要传输文件本身</p><p><img src="https://blog.chasingwind.top/GqGk4k.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GqGk4k.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>服务端</p><blockquote><p>需要根据客户端的上传类型来接收</p><p><img src="https://blog.chasingwind.top/qJzuxh.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qJzuxh.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>接收完成之后，其实服务端还在一直等待客户端的数据  我们可以在客户端告诉服务端当前数据已经发送完成  返回-1给服务端，服务端就不需要一直循环等待了 而是结束文件的接收</p><p><img src="https://blog.chasingwind.top/mJLpNg.png" class="lazyload" data-srcset="https://blog.chasingwind.top/mJLpNg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="BIO模式下的端口转发思想"><a href="#BIO模式下的端口转发思想" class="headerlink" title="BIO模式下的端口转发思想"></a>BIO模式下的端口转发思想</h3><ol><li><p>什么是端口转发</p><ul><li><p>之前的BIO案例都是客户端发送消息给服务端，服务端接收消息并进行处理。但是像QQ这种，并不是将消息发送给服务端就完事了，这种其实是客户端与客户端之间的通信，当然中间需要经过服务器转发消息，这就是端口转发</p><blockquote><p>将一个客户端的消息发送给所有的客户端（类比群聊功能）</p><p>客户端需要实现发送消息的功能以及接收消息的功能</p><p>服务端需要建立与客户端的连接，并且存储在线的Socket集合以便知道转发给哪些客户端</p><p><img src="https://blog.chasingwind.top/PXsFVv.png" class="lazyload" data-srcset="https://blog.chasingwind.top/PXsFVv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>服务端实现</p><blockquote><p><img src="https://blog.chasingwind.top/Ag1Y6a.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Ag1Y6a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="NIO基本介绍"><a href="#NIO基本介绍" class="headerlink" title="NIO基本介绍"></a>NIO基本介绍</h3><ul><li>Java NIO与之前的IO有同样的作用，用于数据传输或者通信。</li><li>NIO是非阻塞IO，线程在IO期间可以做其他的事情，比如调用socket.read()时，如果服务器一直没有传输数据，NIO可以让线程处理其他的事情，从而是非阻塞的。</li><li>NIO相关的类都在java.nio包下，并对原有的java.io包下的很多类进行了改写</li><li>NIO三大核心部分：<strong>Channel（通道）、Buffer（缓冲区）、Selector（选择器）</strong></li><li>Java NIO的非阻塞模式，使一个线程从某通道发出请求或读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时 ，就什么都不会获取，而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待他完全写入，这个线程同时可以去处理别的事情。</li><li>通俗来说：NIO是可以做到用一个线程来处理多个操作的。比如有1000个请求过来，NIO可以分配10或者80个线程来处理。不像之前的阻塞IO那样，需要一个线程对应一个请求。</li></ul><h3 id="NIO和BIO的比较"><a href="#NIO和BIO的比较" class="headerlink" title="NIO和BIO的比较"></a>NIO和BIO的比较</h3><ul><li>BIO底层是以流的方式来处理数据的，比如字节或者字符输入输出流，而NIO是以块的方式来处理数据的，块IO效率比流IO高得多</li><li>BIO是阻塞式IO，而NIO是非阻塞式IO</li><li>BIO基于字节或者字符流进行操作，而NIO是基于Channel（通道）和Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入到通道。Selector（选择器）用于监听多个通道的事件（比如：连接请求、数据到达等等），因此就可以做到一个线程处理多个客户端的请求（通过监听通道中是否有客户端的请求）</li></ul><h3 id="NIO三大核心"><a href="#NIO三大核心" class="headerlink" title="NIO三大核心"></a>NIO三大核心</h3><ul><li><p>Buffer 缓冲区</p><ul><li>缓冲区本质上是一块<strong>可以写入数据，可以从中读取数据的内存</strong>。这块内存被包装成了NIO Buffer对象，并提供了一组方法，用来方便的访问该内存块。</li></ul></li><li><p>Channel 通道</p><ul><li>通道既支持从中读取数据，同时也支持将数据写入到其中（区别于流，是单向的，比如输入流，输出流）。通道可以非阻塞读取和写入通道，也支持读取和写入缓冲区，也支持异步地读写</li></ul></li><li><p>Selector选择器</p><ul><li>Selector是一个Java NIO组件，<strong>可以检查一个或者多个通道，并确定哪些通道已经准备好进行读取或写入</strong>。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率。</li></ul><blockquote><p><img src="https://blog.chasingwind.top/xVJ551.png" class="lazyload" data-srcset="https://blog.chasingwind.top/xVJ551.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol><li>每个Channel都会对应一个Buffer</li><li>一个线程对应一个Selector，一个Selector对应多个Channel</li><li>程序切换到哪个Channel是由事件决定的</li><li>Selector会根据不同的事件，在各个通道上切换</li><li><strong>Channel负责传输数据，Buffer负责存取数据。</strong></li></ol></blockquote></li></ul><h3 id="NIO缓冲区"><a href="#NIO缓冲区" class="headerlink" title="NIO缓冲区"></a>NIO缓冲区</h3><ul><li><p>NIO中的Buffer是一个用于特定基本数据类型的容器，由java.nio包定义的，<strong>所有缓冲区都是Buffer抽象类的子类</strong>。Java NIO中的Buffer主要用于与NIO通道进行交互，数据是从通道读入缓冲区，从缓冲区写入到通道中</p><blockquote><p><img src="https://blog.chasingwind.top/vDY7DZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/vDY7DZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Buffer类及其子类：Buffer就像一个数组，可以保存多个相同类型的数据。根据数据类型的不同，有以下<strong>Buffer常用子类</strong>：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer，这些Buffer类及其子类都有相似的方法进行数据的操作，比如都使用如下静态方法来获取一个缓冲区</p><blockquote><pre><code class="java"> //创建一个容量为10的存储Byte类型的缓冲区        ByteBuffer byteBuffer = ByteBuffer.allocate(10);        //创建一个容量为10的存储Char类型的缓冲区        CharBuffer charBuffer = CharBuffer.allocate(10);        //.......</code></pre></blockquote></li><li><p>缓冲区的属性</p><ol><li><p>容量（capacity）：作为一个内存块，Buffer具有一定的大小，也称为容量，缓冲区容量不能为负，<strong>并且创建之后不能进行修改</strong></p></li><li><p>限制（limit）：表示缓冲区中可以操作的数据的大小（limit后的数据不能进行读写操作）。缓冲区的限制不能为负，并且不能大于容量。写入模式，limit设置为容量；读取模式，limit设置为写入的数据量。</p></li><li><p>位置（position）：下一个要读取或写入数据的索引，不能为负，并且不能大于limit</p></li><li><p>标记（remark）和重置（reset）：标记是一个索引，通过Buffer中的mark()方法指定Buffer中的一个特定的position，之后可以通过调用reset()方法恢复到这个position</p><blockquote><p><img src="https://blog.chasingwind.top/U6fRrP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/U6fRrP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Buffer中常用API</p><ol><li><p>​    clear：清空缓冲区并返回缓冲区的引用，可以准备写入，但是使用get读取数据还是可以读取到的，一般我们使用clear之后，需要写入数据对原数据进行覆盖。</p><blockquote><p><img src="https://blog.chasingwind.top/VNPlyg.png" class="lazyload" data-srcset="https://blog.chasingwind.top/VNPlyg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>flip：position置为0，并且limit设置为当前缓冲区中最后一个数据的position，我的理解是切换为读取数据模式</p><blockquote><p><img src="https://blog.chasingwind.top/OaS0mg.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OaS0mg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>capacity：获取缓冲区的容量大小</p><blockquote><p><img src="https://blog.chasingwind.top/6F4OLj.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6F4OLj.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>hasRemaining：缓冲区中是否还有元素</p><blockquote><p><img src="https://blog.chasingwind.top/4BynjL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4BynjL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>limit：返回Buffer中的limit位置</p><blockquote><p><img src="https://blog.chasingwind.top/1r4Rqu.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1r4Rqu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>limit(int n)：设置缓冲区界限为n，并且新的limit不能大于容量，不能为负，同时注意mark以及position</p><blockquote><p><img src="https://blog.chasingwind.top/itTNIT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/itTNIT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>mark()：对缓冲区设置标记，标记位置就是当前缓冲区的position</p><blockquote><p><img src="https://blog.chasingwind.top/Pshcyl.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Pshcyl.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>position()：返回缓冲区中当前的position</p><blockquote><p><img src="https://blog.chasingwind.top/t0X9yT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/t0X9yT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>position()：设置当前缓冲区的position，不能大于limit，并且不能为负数，同时如果新的position大于mark，mark置为-1</p><blockquote><p><img src="https://blog.chasingwind.top/TxP01S.png" class="lazyload" data-srcset="https://blog.chasingwind.top/TxP01S.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>remaining()：表示缓冲区中还有多少位置可以进行读写</p><blockquote><p><img src="https://blog.chasingwind.top/K6B8SN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/K6B8SN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>reset()：将position设置到标记mark</p><blockquote><p><img src="https://blog.chasingwind.top/A3SYld.png" class="lazyload" data-srcset="https://blog.chasingwind.top/A3SYld.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>rewind()：重置mark并且position置为0</p><blockquote><p><img src="https://blog.chasingwind.top/eMMfhx.png" class="lazyload" data-srcset="https://blog.chasingwind.top/eMMfhx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>get()：读取数据，除了根据索引读取数据，其他读取数据的时候，position会改变为已读取数据的下一个位置</p><blockquote><pre><code class="java">        //读取单个字节        byte b = byteBuffer.get();        //批量读取字节到byte数组中        ByteBuffer byteBuffer1 = byteBuffer.get(new byte[10]);        //读取指定索引位置的字节        byte b1 = byteBuffer.get(5);        //从索引位置5开始读取5字节数据到byte数组中        byteBuffer.get(new byte[10], 5, 5);</code></pre></blockquote></li><li><p>put()：写入数据</p><blockquote><p>与get读取类似</p><p><img src="https://blog.chasingwind.top/9swmWF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/9swmWF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>使用Buffer读写数据步骤</p><ol><li>写入数据到Buffer</li><li>调用flip方法，转换为读取模式</li><li>从Buffer中读取数据</li><li>调用clear方法或者compact方法清除缓冲区</li></ol></li><li><p>直接缓冲区和非直接缓冲区</p><ul><li><p><code>ByteBuffer</code>可以有两种方式创建，一种是基于直接内存（操作系统的内存），一种是基于非直接内存（JVM中的堆内存），对于直接内存来说，性能更高，因为比非直接内存少了从本进程内存到直接内存的步骤</p><blockquote><pre><code class="java">        //适用直接内存创建缓冲区        ByteBuffer byteBuffer2 = ByteBuffer.allocateDirect(1024);        //查看当前缓冲区是否使用的是直接内存        System.out.println(byteBuffer2.isDirect());</code></pre><p>使用直接内存的话，创建的时候比较耗时</p><p>一般来说，如果不是能带来明显的性能提升，推荐使用非直接内存</p></blockquote></li><li><p>从数据流的角度来看</p><ul><li>直接内存：本地IO–&gt;直接内存–&gt;本地IO</li><li>非直接内存：本地IO–&gt;直接内存–&gt;非直接内存–&gt;直接内存–&gt;本地IO</li></ul></li><li><p>适用场景</p><ul><li>直接内存适用于：有很大的数据需要存储，并且生命周期很长</li><li>频繁IO操作，比如网络并发场景</li></ul></li></ul></li></ul><h3 id="NIO通道"><a href="#NIO通道" class="headerlink" title="NIO通道"></a>NIO通道</h3><ul><li><p>通道（Channel）：定义在java.nio.channels包下，Channel表示IO源与目标打开的连接。Channel类似于传统的“流”。只不过Channel本身不直接访问数据，需要通过Buffer与数据进行交互</p></li><li><p>NIO中的Channel与BIO中流的区别</p><ol><li>通道可以同时进行读写，是双向的。流只能读或者只能写，是单向的</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲区读数据，也可以向缓冲区中写入数据</li></ol></li><li><p>Channel在NIO中是一个接口，以下是常见的实现类</p><ol><li>FileChannel：用于读取、写入、映射和操作文件的通道</li><li>DataGramChannel：通过UDP读写网络中的数据通道</li><li>SocketChannel：通过TCP读写网络中的数据</li><li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个新的ServerChannel</li></ol></li><li><p>FileChannel的用法</p><blockquote><p>将数据写入到文件中</p><p><img src="https://blog.chasingwind.top/6XSD4Z.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6XSD4Z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>获取通道的方式：可以通过使用支持通道的对象调用getChannel方法，支持通道的类如下：</p><p>FileInPutStream，FileOutPutStream，RandomAccessFile，DatagramSocket，Socket，ServerSocket；还可以通过Files类的静态方法<code>newByteChannel()</code>获取字节通道；还可以通过通道的静态方法open()打开并返回指定通道。</p></blockquote><blockquote><p>读取本地文件中的内容</p><p><img src="https://blog.chasingwind.top/FiaX9M.png" class="lazyload" data-srcset="https://blog.chasingwind.top/FiaX9M.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>完成文件的复制</p><p><img src="https://blog.chasingwind.top/pjQqgK.png" class="lazyload" data-srcset="https://blog.chasingwind.top/pjQqgK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>分散和聚集</p><blockquote><p>分散读取（Scatter）：是指把Channel通道的数据读入到<strong>多个缓冲区</strong>中去</p><p>聚集写入（Gathering）：是指把<strong>多个Buffer中</strong>的数据聚集到Channel中</p><p><img src="https://blog.chasingwind.top/d2WR27.png" class="lazyload" data-srcset="https://blog.chasingwind.top/d2WR27.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>transferForm和transferTo方法</p><blockquote><p>在通道之间复制数据</p><p>最终生成data01.txt</p><p><img src="https://blog.chasingwind.top/Iw7ajY.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Iw7ajY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="NIO选择器"><a href="#NIO选择器" class="headerlink" title="NIO选择器"></a>NIO选择器</h3><h2 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础</title>
      <link href="2020/11/02/Docker%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/02/Docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><a id="more"></a><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><ol><li><p>为什么会出现Docker</p><ul><li>在我们日常开发中，可能会出现这样的问题。在我们本机跑是可以正常执行的，但是发布到测试环境的时候，同一份代码就会出现错误。这就是运行的环境的不同导致的。</li><li>一款产品从开发到上线，从操作系统、到运行环境、再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，在多个版本迭代之后，不同版本对环境的兼容性，都是需要考虑的问题</li><li>Docker的出现就是为了解决上述类似的问题。开发人员给运维人员的不再是单独的jar包，而是包含代码、配置、系统以及数据的整体可运行的软件，也就是带运行环境的软件（Docker镜像）。</li></ul></li><li><p>Docker理念</p><ul><li>Docker是基于Go语言实现的云开源项目</li><li>Docker的主要目标是“Build,Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以说是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”</li><li><strong>Docker是在Linux容器的基础上实现的</strong>，将应用运行在Docker容器上面，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到其他的机器上面一键部署，简化操作</li><li><strong>Docker是解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</strong></li></ul></li><li><p>Docker能做什么</p><ul><li><p>虚拟机技术</p><ul><li><p>虚拟机技术就是一种带环境安装的一种解决方案，比如在本机上通过虚拟机安装Linux来充当服务器，运行之后就跟真正的服务器没有区别。</p><blockquote><p><img src="https://blog.chasingwind.top/26JNgN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/26JNgN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>虚拟机的缺点：资源占用多、启动慢、需要模拟硬件来创建“真正可用”的系统</p></li></ul></li><li><p>容器虚拟化技术</p><ul><li><p>在介绍容器虚拟化技术之前，需要了解另一种虚拟化技术：Linux容器（Linux Containers，缩写LXC）</p><blockquote><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需要的库资源和设置。系统因此变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p><p><img src="https://blog.chasingwind.top/aGSccY.png" class="lazyload" data-srcset="https://blog.chasingwind.top/aGSccY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>Docker和传统虚拟化的不同</p><ol><li><p>传统虚拟技术是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上再运行需要的应用进程</p></li><li><p>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核（如上图中的Kernel），而且也没有进行硬件模拟。因此更加轻便</p></li><li><p>虚拟化技术的每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</p><blockquote><p><img src="https://blog.chasingwind.top/GoZjKi.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GoZjKi.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>hypervisor</code>: 虚拟机监控程序</p></blockquote></li></ol></li><li><p>开发/运维（DevOps）</p></li></ul></li></ol><ul><li><p>更快速的应用交付和部署</p><ul><li>更便捷的升级和扩缩容</li><li>更简单的系统运维</li><li>更高效的计算资源利用</li></ul></li><li><p>企业级使用针对短时高峰访问进行动态扩缩容等等</p></li></ul><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ol><li><p>Docker安装</p><blockquote><p>Docker架构图</p><p><img src="https://blog.chasingwind.top/ajaUeD.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/ajaUeD.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Docker的基本组成</p><ol><li><p>镜像（image）</p><ul><li>Docker镜像就是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</li></ul></li><li><p>容器（container）</p><ul><li><p>Docker利用容器独立运行一个或一组应用。容器是用镜像创建的运行实例。</p></li><li><p>容器可以被启动、开始、停止、删除。每个容器之间都是相互隔离的、保证安全的平台。</p></li><li><p>可以将容器看作是一个<strong>简易的Linux环境</strong>（包含root用户权限、进程空间、用户空间和网络空间等）和<strong>运行在其中的应用程序</strong>。</p><blockquote><p><img src="https://blog.chasingwind.top/zxkIoW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/zxkIoW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>类比</p><p><img src="https://blog.chasingwind.top/tmhDI6.png" class="lazyload" data-srcset="https://blog.chasingwind.top/tmhDI6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>仓库（repository）</p><ul><li>仓库是集中存放镜像文件的场所。</li><li>仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</li><li>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</li><li>最大的仓库是<a href="https://hub.docker.com/">Docker Hub</a>，存放了数量庞大的镜像供用户下载。国内公开的仓库包括阿里云、网易云等等。</li></ul></li><li><p>小总结</p><ul><li><strong>Docker本身是一个容器运行载体或称之为管理引擎</strong>。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看做是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</li><li>image文件生成的容器实例，本身也是一个文件，称为镜像文件。</li><li>一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器。</li><li>至于仓储，就是一个放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中下载就可以了。</li></ul></li></ol></li><li><p>安装步骤（CentOS）：<a href="https://www.runoob.com/docker/centos-docker-install.html">链接</a></p></li><li><p>HelloWorld</p><ol><li><p>启动Docker命令：<code>systemctl start docker</code></p></li><li><p>运行Hello World：<code>docker run hello-world</code></p><blockquote><p><img src="https://blog.chasingwind.top/2Zz8ny.png" class="lazyload" data-srcset="https://blog.chasingwind.top/2Zz8ny.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行过程分析</p><blockquote><p>Docker run</p><p><img src="https://blog.chasingwind.top/G7wRI2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/G7wRI2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>底层原理</p><ol><li><p>Docker是怎么工作的</p><ul><li><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机的容器上。容器，是一个运行环境，也就是Docker图标中的集装箱。</p><blockquote><p><img src="https://blog.chasingwind.top/exDV0y.png" class="lazyload" data-srcset="https://blog.chasingwind.top/exDV0y.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>为什么Docker比VM快</p><ol><li><p>Docker比虚拟机有更少的抽象层。Docker不需要像虚拟机一样虚拟化硬件资源，运行在Docker容器上的程序都是直接使用的实际物理机的硬件资源。因此在CPU、内存利用率上Docker将会有更加明显的优势。</p></li><li><p>Docker利用的是宿主机的内核。因此，当新建一个容器时，不需要像虚拟机一样重新加载一个操作系统内核。因此减少了加载内核系统这一浪费时间的过程，Docker省略了这个过程，所以创建Docker容器时秒级的。</p><blockquote><p><img src="https://blog.chasingwind.top/g7gtG4.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/g7gtG4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Docker Engine直接代替了虚拟机监控进程（Hypervisor）以及Guest OS，直接使用宿主机的内核。</p></blockquote></li></ol></li></ol></li></ol><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><ol><li><p>帮助命令</p><ul><li><code>docker version</code></li><li><code>docker info</code></li><li><code>docker --help</code></li></ul></li><li><p>镜像命令</p><ul><li><p><code>docker images</code>：列出本地主机上的镜像信息</p><blockquote><p><img src="https://blog.chasingwind.top/NjZ5xN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/NjZ5xN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>REPOSITORY：表示镜像的仓库源</p><p>TAG：镜像的标签</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像创建时间</p><p>VIRTUAL SIZE：镜像大小</p><hr><p>同一个仓库源中可以有多个TAG，用来区分仓库源中的不同版本，可以使用REPOSITORY:TAG来区分不同版本的镜像</p><p>如果不指定镜像的版本标签，Docker默认使用的是latest版本</p><hr><p><code>docker images -a</code>：列出本地所有的镜像（含中间映像层）</p><p><code>docker images -qa</code>：显示所有的镜像ID</p><p><code>docker images --digests</code>：显示镜像的摘要信息</p><p><code>docker images --no-trunc</code>：显示镜像的完整信息</p></blockquote></li><li><p><code>docker search xxx</code>：从Docker Hub查找镜像</p><blockquote><p><img src="https://blog.chasingwind.top/7My6OZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/7My6OZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>docker search -s 30 tomcat</code>：查找STARS在30以上的tomcat镜像</p><p><img src="https://blog.chasingwind.top/gpEzdO.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gpEzdO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>docker pull xxx</code>：下载镜像</p><blockquote><p><code>docker pull xxx:TAG</code>：下载指定版本的镜像</p><p>不写TAG的话 默认使用的是latest</p><p><img src="https://blog.chasingwind.top/oKoGrt.png" class="lazyload" data-srcset="https://blog.chasingwind.top/oKoGrt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>docker rmi xxx</code>：删除某个镜像</p><blockquote><p><img src="https://blog.chasingwind.top/3anT87.png" class="lazyload" data-srcset="https://blog.chasingwind.top/3anT87.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>无法删除正在运行中的镜像文件</p><p><code>docker rmi -f hello-world</code>：强制删除</p><p><img src="https://blog.chasingwind.top/tPeBzU.png" class="lazyload" data-srcset="https://blog.chasingwind.top/tPeBzU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>图中显示 不带TAG删除的话 默认是latest</p><hr><p><code>docker rmi -f 镜像1 镜像2</code>：删除多个镜像</p><p><code>docker rmi -f $(docker images -qa)</code>：删除全部镜像</p></blockquote></li></ul></li><li><p>容器命令</p><p>有镜像才能创建容器，以下都是运行在Docker上的CentOS为例进行的（<code>docker pull centos</code>）</p><blockquote><p><img src="https://blog.chasingwind.top/VhR31Z.png" class="lazyload" data-srcset="https://blog.chasingwind.top/VhR31Z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p><code>docker run</code>：新建并启动容器</p><blockquote><p>运行Docker上的CentOS</p><p>-i，-t可以写成-it，表示以交互模式运行  下图中命令行的用户已经不是阿里云的CentOS了，已经是Docker中的CentOS了</p><p><img src="https://blog.chasingwind.top/WpiLt1.png" class="lazyload" data-srcset="https://blog.chasingwind.top/WpiLt1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>OPTIONS说明</p><p>– name=”容器名”，为容器指定一个名字</p><p>-d：后台运行容器，并返回容器ID，也即启动守护式容器</p><p>-i：以交互模式运行容器</p><p>-t：为容器重新分配一个伪输入终端</p><p>-P：随机端口映射</p><p>-p：指定端口映射，有以下4中格式</p><p>​    ip:hostPort:containerPort</p><p>​    ip::containerPort</p><p>​    hostPort:containerPort</p><p>​    containerPort</p></blockquote></li><li><p><code>docker ps</code>列出当前所有正在运行的容器</p><blockquote><p><img src="https://blog.chasingwind.top/Dig2UP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Dig2UP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>-a：列出当前所有正在运行的容器+历史上运行过的容器</p><p>-l：显示最近创建的容器</p><p>-n：显示最近n个创建的容器</p><p>-q：静默模式，只显示容器编号</p><p>–np-trunc：不截断输出（就是显示完整的容器信息）</p></blockquote></li><li><p>退出容器</p><ol><li>exit：容器退出且停止</li><li>Ctrl+P+Q：容器退出不停止</li></ol></li><li><p><code>docker start</code>：启动容器</p></li><li><p><code>docker restart</code>：重启容器</p></li><li><p><code>docker stop</code>：停止容器</p></li><li><p><code>docker kill</code>：强制停止容器</p></li><li><p><code>docker rm</code>：删除已经停止的容器</p></li></ul></li><li><p>容器命令（重要）</p><ol><li><p>启动守护式容器</p><blockquote><p><code>docker run -d xxx</code></p><p><img src="https://blog.chasingwind.top/CAcocH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CAcocH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>后台启动的容器却没有在运行？</p><p>因为：Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是一直挂起的命令（比如运行top，tail），就是会自动退出的</p><p>这是Docker的机制问题造成的，后台运行的容器启动后，会立即kill掉，因为Docker觉得后台运行的程序无事可做。</p><p>所以，最佳的解决方案是将运行的程序以前台进程的形式运行</p></blockquote></li><li><p>查看容器日志</p><blockquote><p><code>docker logs -f -t --tail 容器id</code></p><p>-t：加入时间戳</p><p>-f：跟随最新的日志打印</p><p>–tail 数字：显示最后多少条</p></blockquote></li><li><p>查看容器内运行的进程</p><blockquote><p><code>docker top 容器id</code></p></blockquote></li><li><p>查看容器内部细节（详细信息）</p><blockquote><p><code>docker inspect 容器ID</code></p></blockquote></li><li><p>进入正在运行的容器并以命令行交互</p><blockquote><p><code>docker attach 容器ID</code></p><p><code>docker exec -it 容器ID 命令操作</code></p><p><img src="https://blog.chasingwind.top/1XrkYh.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1XrkYh.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>两个命令的区别</p><p>attach：进入到Docker，之后再在Docker里面进行操作</p><p>exec：在宿主机对Docker进行操作</p></blockquote></li><li><p>从容器内拷贝文件到主机上</p><blockquote><p><code>docker cp 容器ID：容器内路径 目的主机路径</code></p></blockquote></li></ol></li></ol><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包含代码以及运行环境。</p><ol><li><p>UnionFS（Union File System）：联合文件系统，是一种分层、轻量级并且高性能的文件系统，<strong>它支持对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下。<strong>UnionFS是Docker镜像的基础</strong>。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像，可以制作各种具体的应用镜像。<strong>特性</strong>就是一次同时加载多个文件系统，但从外面看起来，<strong>只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统包含所有的文件和目录</strong>。</p></li><li><p>Docker镜像加载原理</p><ul><li>bootfs（boot filesystem）：主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就存在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统会卸载bootfs。</li><li>rootfs（root filesystem）：在bootfs之上。包含典型的Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同操作系统发行版，比如Ubuntu，CentOS等</li><li>解释为什么Docker中的CentOS那么小（200M左右）<ul><li>由于Docker中的CentOS运行在Docker之上，Docker是一个精简的Linux系统，rootfs可以很小，只需要包含最基本的命令、工具和程序库就可以，因为底层直接使用的是宿主机的Kernel，自己只需要提供rootfs就可以了。由此可见对于不同发行版的系统，bootfs基本是一致的，只需要提供对应的rootfs即可。</li></ul></li></ul></li><li><p>分层镜像</p><blockquote><p>比如下图中我们从仓库中下载nginx镜像，发现下载的不仅仅是最终的镜像</p><p><img src="https://blog.chasingwind.top/PDPO5t.png" class="lazyload" data-srcset="https://blog.chasingwind.top/PDPO5t.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>过程中还下载了其他的文件</p><p><img src="https://blog.chasingwind.top/653QOS.png" class="lazyload" data-srcset="https://blog.chasingwind.top/653QOS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>也就是说这个镜像是多层构成的</p><p>这就解释了在Docker中tomcat为什么需要400+M</p><p>因为tomcat需要运行的环境：</p><p>Kernel–&gt;CentOS–&gt;jdk–&gt;tomcat，虽然我们最后看到的是tomcat，但是他需要这么多文件的支持，这就导致Docker上的tomcat比较大。</p></blockquote></li><li><p>Docker为什么采用分层结构</p><ul><li><strong>共享资源</strong>，比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了。而且镜像的每一层都可以被共享。（UnionFS分层继承）</li></ul></li></ol></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>Docker镜像都是<strong>只读</strong>的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为“容器层”，“容器层”之下的都叫做“镜像层”。</li></ul><h3 id="Docker镜像commit"><a href="#Docker镜像commit" class="headerlink" title="Docker镜像commit"></a>Docker镜像commit</h3><ul><li><p>之前运行的容器，我们<code>docker run</code>使用的都是默认的镜像配置，当我们需要使用我们自定义的配置的时候，就需要修改镜像文件，然后commit之后生成新的镜像，运行新的镜像就是我们自定义配置的镜像了。</p></li><li><p>演示案例</p><p>tomcat为例，删除tomcat的文档系统，commit生成新的tomcat镜像文件</p><ol><li><p>运行Docker中的comcat</p><blockquote><p><code>-p 主机端口：docker容器端口</code></p><p><img src="https://blog.chasingwind.top/krI5mL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/krI5mL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>首先，需要在阿里云的安全组中配置8888端口，否则的话 是不能进行访问的此端口的</p><p><img src="https://blog.chasingwind.top/cXRWm7.png" class="lazyload" data-srcset="https://blog.chasingwind.top/cXRWm7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们访问的时候的地址</p><p><img src="https://blog.chasingwind.top/3PT7Zw.png" class="lazyload" data-srcset="https://blog.chasingwind.top/3PT7Zw.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>出现404错误，我们进入到Docker中tomcat的目录，发现 wenapps目录是空的</p><p><code>docker exec -it 容器ID /bin/bash</code></p><p><img src="https://blog.chasingwind.top/Dq8Fmj.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Dq8Fmj.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>而webapps下面还有一个webapps.dist  原来tomcat的文件都存放在这个目录下</p><p><img src="https://blog.chasingwind.top/nGSaZY.png" class="lazyload" data-srcset="https://blog.chasingwind.top/nGSaZY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>重命名 webapps.dist为webapps</p><p><img src="https://blog.chasingwind.top/8qIhsd.png" class="lazyload" data-srcset="https://blog.chasingwind.top/8qIhsd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>本地进行访问</p><p><img src="https://blog.chasingwind.top/5qVcGq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/5qVcGq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>-p以及-P的区别</p><p>-p：指定端口</p><p>-P：随机端口</p><p>在运行一个tomcat</p><p><img src="https://blog.chasingwind.top/21dnhT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/21dnhT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看正在运行的容器</p><p><img src="https://blog.chasingwind.top/TtsZTC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/TtsZTC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>删除docs目录  commit生成我们自定义的镜像</p><blockquote><p>未删除之前 可以访问到 并且在webapps目录下有docs文件夹</p><p><img src="https://blog.chasingwind.top/uQSuyK.png" class="lazyload" data-srcset="https://blog.chasingwind.top/uQSuyK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>删除docs目录</p><p><img src="https://blog.chasingwind.top/CmOeZb.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CmOeZb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>commit容器副本 生成我们自定义的镜像文件</p><blockquote><p>提交<strong>容器副本</strong>使之成为一个<strong>新的镜像</strong></p><p><img src="https://blog.chasingwind.top/OgtWeV.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OgtWeV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看镜像</p><p><img src="https://blog.chasingwind.top/8MidwP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/8MidwP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>运行我们自定义的镜像生成的容器</p><p><img src="https://blog.chasingwind.top/y8HejJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/y8HejJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>再次访问镜像的时候发现已经找不到文档了</p><blockquote><p><img src="https://blog.chasingwind.top/arn6JD.png" class="lazyload" data-srcset="https://blog.chasingwind.top/arn6JD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>后台运行</p><blockquote><p><code>-d</code> 后台运行</p><p><code>-it</code> 交互式运行</p><p><img src="https://blog.chasingwind.top/AD4gDT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/AD4gDT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><ul><li>在Docker的使用过程中，往往需要<strong>对数据进行持久化</strong>，或者需要<strong>在多个容器之间进行数据共享</strong>，所以这就涉及到Docker容器的数据操作。 容器中数据管理主要有两种方式：<strong>数据卷</strong>和<strong>数据卷容器</strong>。</li><li>数据卷就是数据(一个文件或者文件夹)。数据卷是特殊的目录，可以绕过联合文件系统，为一个或多个容器提供访问。数据卷<strong>设计的目的</strong>是数据的永久化，是完全独立于容器的生命周期，不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理。</li></ul><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ol><li>容器数据持久化</li><li>容器之间继承+共享数据</li></ol><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="容器内添加"><a href="#容器内添加" class="headerlink" title="容器内添加"></a>容器内添加</h4><ul><li><p>直接命令添加</p><ol><li><p>创建数据卷</p><blockquote><p><code>docker run -it -v 宿主机路径:容器内路径 镜像名</code></p><p><code>-v</code>：volume n. 量；体积；卷；音量；大量；册</p><p>上述命令表示（或者理解为）：在宿主机的宿主机目录创建一个文件夹和镜像生成的容器目录下创建一个文件夹，这连个文件夹可以完成宿主机和容器的数据共享。</p><hr><p>演示  </p><p>未创建数据卷之前 Docker中的CentOS根目录的文件夹</p><p><img src="https://blog.chasingwind.top/uLjuOR.png" class="lazyload" data-srcset="https://blog.chasingwind.top/uLjuOR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>未创建数据卷之前 阿里云宿主机的CentOS根目录</p><p><img src="https://blog.chasingwind.top/LTwSH6.png" class="lazyload" data-srcset="https://blog.chasingwind.top/LTwSH6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>创建数据卷</p><p><img src="https://blog.chasingwind.top/UynFMx.png" class="lazyload" data-srcset="https://blog.chasingwind.top/UynFMx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看宿主机根目录  已经创建文件夹HostVolume</p><p><img src="https://blog.chasingwind.top/SW65jq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/SW65jq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在Docker中运行的CentOS容器的根目录下也已经创建出DockerVolume</p><p><img src="https://blog.chasingwind.top/htTfLZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/htTfLZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看容器是否挂载成功</p><blockquote><p><code>docker inspect 容器ID</code></p><p><img src="https://blog.chasingwind.top/CMWHaC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CMWHaC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>容器和宿主机之间共享数据</p><blockquote><p>宿主机中添加文件 查看容器中是否也同步添加了文件</p><p>在宿主机目录下创建一个文件</p><p><img src="https://blog.chasingwind.top/Bk1JB6.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Bk1JB6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看容器中的挂载的目录下  我们在宿主机创建的问价也已经存在于容器中挂载的目录下</p><p><img src="https://blog.chasingwind.top/qjMYEE.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qjMYEE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>容器中挂载的文件修改 宿主机同步修改的数据</p><p><img src="https://blog.chasingwind.top/OWqvja.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OWqvja.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在宿主机中查看文件  发现文件修改也已经同步了</p><p><img src="https://blog.chasingwind.top/CujUZq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CujUZq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>当容器停止运行之后 我们在宿主机对文件进行修改 那么容器中的文件会同步进行修改吗</p><p>停止运行容器</p><p><img src="https://blog.chasingwind.top/OtA4UX.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OtA4UX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在宿主机中创建文件、修改文件</p><p><img src="https://blog.chasingwind.top/31Mbo4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/31Mbo4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/2e3wak.png" class="lazyload" data-srcset="https://blog.chasingwind.top/2e3wak.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>重新启动</strong>之前停止运行的容器（是重新启动而非新建容器）</p><p> 在宿主机创建的文件已经同步了</p><p><img src="https://blog.chasingwind.top/Ptsb5A.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Ptsb5A.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看修改的文件  修改的内容也已经同步</p><p><img src="https://blog.chasingwind.top/FSY5QN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/FSY5QN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建带权限的数据卷</p><blockquote><p>​    <code>docker run -it -v 宿主机路径:容器内路径:ro 镜像名</code></p><p>ro : readonly </p><p>上述命令表示 Docker容器中的路径下文件  只读，不可以修改此路径下的文件内容，同时也不能创建文件（文件夹）</p></blockquote></li></ol></li><li><p>DockerFile添加</p><ol><li><p>是什么</p><ul><li>可以简单理解为镜像的配置文件</li></ul></li><li><p>使用DockFile创建镜像</p><blockquote><p>在宿主机创建目录  用来存放生成的DockerFile</p><p>使用VOLUME指令编写DockerFile</p><p>使用这种方式  无法指定在宿主机中的目录，因为这个配置是可以通用的，如果指定某个具体的宿主机目录，那么使用此DockerFile生成的镜像，可能运行起来之后，在其他宿主机中没有对应的目录就会出错。但是Docker已经考虑了这个问题，在运行镜像生成容器的时候会随机生成目录。</p><p><img src="https://blog.chasingwind.top/8byAMs.png" class="lazyload" data-srcset="https://blog.chasingwind.top/8byAMs.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/ggBYkz.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ggBYkz.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用DockerFile创建镜像</p><p><img src="https://blog.chasingwind.top/h3puqT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/h3puqT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看生成的镜像 并运行生成容器</p><p><img src="https://blog.chasingwind.top/gsgGuU.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gsgGuU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看<strong>容器内数据卷</strong></p><p><img src="https://blog.chasingwind.top/yiWtwq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/yiWtwq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看<strong>宿主机</strong>内的对应所在的目录</p><p><code>docker inspect 容器ID</code></p><p><img src="https://blog.chasingwind.top/Mfyn47.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Mfyn47.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/G6VPKF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/G6VPKF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在 Docker容器中创建文件  在宿主机中查看</p><p>容器中</p><p><img src="https://blog.chasingwind.top/vHIRVD.png" class="lazyload" data-srcset="https://blog.chasingwind.top/vHIRVD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>宿主机中</p><p><img src="https://blog.chasingwind.top/ipAs2N.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ipAs2N.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><ol><li><p>定义</p><blockquote><p>容器挂载数据卷之后，其他容器通过挂载这个容器中的数据卷<strong>实现容器之间的数据共享</strong>，那么被挂载的容器就被称为数据卷容器。</p></blockquote></li><li><p>运行容器doc1，doc2和doc3挂载到doc1上</p><blockquote><p>创建容器并命名为doc1</p><p><img src="https://blog.chasingwind.top/FEKXHS.png" class="lazyload" data-srcset="https://blog.chasingwind.top/FEKXHS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>创建容器doc2，并挂载到doc1中</p><p><code>docker run -it --name doc2 --volumes-from doc1 chasingwind/centos</code></p><p><img src="https://blog.chasingwind.top/6t6dtp.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6t6dtp.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同理 创建doc3 并 挂载到doc1中</p><p><img src="https://blog.chasingwind.top/yez3RG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/yez3RG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>🤔：我们创建的doc2的时候，挂载的目录下存在doc1创建的文件，创建doc3的时候，挂载的目录下存在doc1和doc2创建的文件，那么在doc1中是否存在doc2和doc3创建的文件呢？</p><p>存在。这就说明了Docker容器之间挂载之后，每个容器之间的数据是互通的</p><p><img src="https://blog.chasingwind.top/n1RM8X.png" class="lazyload" data-srcset="https://blog.chasingwind.top/n1RM8X.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>删除父容器doc1，查看doc2，doc3是否可以共享数据</p><blockquote><p>容器doc2，doc3都创建的时候都挂载在容器doc1下，当我们删除容器doc1之后，容器doc2和doc3是否还能正常共享数据？</p><p><img src="https://blog.chasingwind.top/BblgAH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/BblgAH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看容器doc3中是否有容器2创建的文件</p><p><img src="https://blog.chasingwind.top/xqA5r3.png" class="lazyload" data-srcset="https://blog.chasingwind.top/xqA5r3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>总结：容器数据卷被删除之后，挂载的数据卷之间还是可以正常共享数据的。</p></blockquote></li><li><p>总结</p><p>容器之间挂载之后，可以理解为每个容器的数据都来自同一个副本，只要容器还存在（比如容器被rm -f删除），那么数据都是可以继续进行共享的。<strong>数据卷的生命周期一直持续到没有容器使用它为止</strong>。</p></li></ol><h2 id="DockerFile解析"><a href="#DockerFile解析" class="headerlink" title="DockerFile解析"></a>DockerFile解析</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><ol><li><p>DockFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p></li><li><p>构建三步骤：编写DockerFile文件，docker build根据DockerFile生成镜像，docker run运行镜像生成容器</p></li><li><p>以CentOS的DockerFile为例</p><blockquote><p>scratch 类似于Java中的Object，是所有镜像的父类</p><p><img src="https://blog.chasingwind.top/PpGhhb.png" class="lazyload" data-srcset="https://blog.chasingwind.top/PpGhhb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h3><ol><li>DockerFile内容基础知识<ul><li>每条<strong>保留字指令</strong>都必须为大写字母并且后面都至少要跟随一个参数</li><li>指令执行顺序从上到下，顺序执行</li><li>**#**表示注释</li><li><strong>每条指令都会创建一个新的镜像层，并对镜像进行提交</strong></li></ul></li><li>Docker执行DockerFile的大致流程<ol><li>Docker从基础镜像运行一个容器（FROM xxxx）</li><li>执行一条指令并对容器作出修改</li><li>将当前镜像提交生成一个新的镜像层</li><li>Docker再基于刚提交的镜像运行一个新的容器</li><li>执行DockerFile的下一条指令直到所有指令执行完成，生成最终的镜像文件</li></ol></li></ol><h3 id="DockerFile关键字"><a href="#DockerFile关键字" class="headerlink" title="DockerFile关键字"></a>DockerFile关键字</h3><ol><li><p>FROM</p><ul><li>基础镜像，表示当前镜像是基于哪个镜像的</li></ul></li><li><p>MAINTAINER</p><ul><li>镜像作者以及邮箱地址</li></ul></li><li><p>RUN</p><ul><li>容器<strong>构建时</strong>需要运行的命令</li></ul></li><li><p>EXPOSE</p><ul><li>当前容器对外暴露出的端口号</li></ul></li><li><p>WORKDIR</p><ul><li>指定在创建容器后，终端默认登录进入到的工作目录</li></ul></li><li><p>ENV</p><ul><li>用来在构建镜像的过程中设置环境变量</li><li>比如<code>ENV MY_PATH /usr/local</code>，相当于定义了一个变量，这个变量可以在后面的命令中直接使用，比如<code>WORKDIR MY_PATH</code>。</li></ul></li><li><p>ADD</p><ul><li>将宿主机目录下的文件复制进镜像，并且如果是压缩文件，会自动解压缩；如果是URL，也会自动处理</li></ul></li><li><p>COPY</p><ul><li>将从构建上下文中的源路径中的文件/目录复制到新的一层镜像内的目标路径的位置</li><li>举例：COPY src dest，或者COPY[“src”,dest”]</li></ul></li><li><p>VOLUME</p><ul><li>容器数据卷</li></ul></li><li><p>CMD</p><ul><li>指定容器<strong>启动时</strong>要运行的命令</li><li>DockerFile中可以有多个CMD命令，但<strong>只有最后一个生效</strong>。</li><li>CMD会被docker run之后的参数替换</li></ul></li><li><p>ENTRYPOINT</p><ul><li>指定一个容器启动时要运行的命令</li><li>ENTRYPOINT和CMD，都是在指定容器启动程序以及参数</li><li>与RUN不同的是，ENTRYPOINT会<strong>追加命令</strong>而不是覆盖命令</li></ul></li><li><p>ONBUILD</p><ul><li>当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，会触发父镜像的ONBUILD</li></ul></li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol><li><p>Base镜像（scratch）</p><ul><li>Docker Hub中的镜像99%都是在Base镜像的基础上之上安装和配置相关的软件实现的</li></ul></li><li><p>CentOS自定义镜像</p><ol><li><p>阿里云上的Docker镜像是精简版的，其中很多命令都不支持</p><blockquote><p>例如vim和ifconfig两个命令都无法使用</p><p><img src="https://blog.chasingwind.top/EH7VEN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/EH7VEN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写DockerFile，生成我们自定义的CentOS</p><blockquote><p>编写</p><p><img src="https://blog.chasingwind.top/JSj1WG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/JSj1WG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用自定义的DockerFile文件生成自定义的CentOS镜像</p><blockquote><p><img src="https://blog.chasingwind.top/AGeYw4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/AGeYw4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>看到最后几条命令 就是在执行我们DockerFile中的命令</p><p>后面翻车了  启动不运行  原因是因为CMD和ENTRYPOINT的问题</p><p>修改Dockerfile2  重新创建</p><p><img src="https://blog.chasingwind.top/00TnIF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/00TnIF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上面问题出现的原因 <a href="https://blog.csdn.net/u010900754/article/details/78526443">参考</a></p><p>简单来说就是：</p><p>CMD给出的是一个容器的默认的可执行体。也就是容器启动以后，默认的执行的命令。重点就是这个“默认”。意味着，如果docker run没有指定任何的执行命令或者DockerFile里面也没有ENTRYPOINT，那么，就会使用cmd指定的默认的执行命令执行。同时也从侧面说明了ENTRYPOINT的含义，它才是真正的容器启动以后要执行命令。</p><p>所以这句话就给出了CMD命令的一个角色定位，它主要作用是默认的容器启动执行命令。（注意不是“全部”作用）</p><p>这也是为什么大多数网上博客论坛说的“CMD会被覆盖”，其实为什么会覆盖？因为CMD的角色定位就是默认，如果你不额外指定，那么就执行CMD的命令，否则呢？<strong>只要你指定了，那么就不会执行CMD，也就是CMD会被覆盖。</strong></p><hr><p>查看创建成功的镜像</p><p><img src="https://blog.chasingwind.top/pX1GmO.png" class="lazyload" data-srcset="https://blog.chasingwind.top/pX1GmO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行我们的自定义镜像</p><blockquote><p>可见运行之后 默认进入我们指定的目录</p><p><img src="https://blog.chasingwind.top/UD2Ciq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/UD2Ciq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用vim以及ifconfig</p><p><img src="https://blog.chasingwind.top/3OS6um.png" class="lazyload" data-srcset="https://blog.chasingwind.top/3OS6um.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看镜像的变更历史</p><blockquote><p><img src="https://blog.chasingwind.top/qA7tSN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qA7tSN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>ONBUILD命令案例</p><blockquote><p>ONBUILD是在父镜像中定义使用，当有子镜像去继承这个父镜像的时候，子镜像<strong>build</strong>的时候就会触发父镜像中的ONBUILD命令</p><hr><p>父镜像DockerFile</p><p><img src="https://blog.chasingwind.top/ueU5bJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ueU5bJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用此DockerFile创建父镜像文件</p><p><img src="https://blog.chasingwind.top/88qV8j.png" class="lazyload" data-srcset="https://blog.chasingwind.top/88qV8j.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>子镜像文件DockerFile编写 继承自我们刚刚创建的父镜像</p><p><img src="https://blog.chasingwind.top/zuYuud.png" class="lazyload" data-srcset="https://blog.chasingwind.top/zuYuud.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用DockerFileson创建子镜像 </p><p><img src="https://blog.chasingwind.top/vKLm1E.png" class="lazyload" data-srcset="https://blog.chasingwind.top/vKLm1E.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可见在子镜像创建的过程中 执行了父镜像中的ONBUILD命令</p><p><img src="https://blog.chasingwind.top/1Md4tW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1Md4tW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Tomcat自定义镜像</p><ul><li><p>在宿主机上创建好文件夹，放置我们需要的文件</p><blockquote><p>这里有压缩文件也有非压缩文件，用于后面比较ADD和COPY的区别</p><p><img src="https://blog.chasingwind.top/LHvJFB.png" class="lazyload" data-srcset="https://blog.chasingwind.top/LHvJFB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建DockerFile</p><blockquote><p>COPY命令的定义：从<strong>构建上下文中的源路径</strong>中的文件/目录复制到新的一层镜像内的目标路径的位置</p><p>构建上下文的源路径：其实就是DockerFile所在的路径</p><p><img src="https://blog.chasingwind.top/Ymz1jJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Ymz1jJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建镜像</p><blockquote><p><img src="https://blog.chasingwind.top/5Q0E0i.png" class="lazyload" data-srcset="https://blog.chasingwind.top/5Q0E0i.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/9i9K7i.png" class="lazyload" data-srcset="https://blog.chasingwind.top/9i9K7i.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行容器</p><blockquote><p><img src="https://blog.chasingwind.top/I8adeM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/I8adeM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><ol><li><p>8888访问tomcat</p><blockquote><p><img src="https://blog.chasingwind.top/2d2i5b.png" class="lazyload" data-srcset="https://blog.chasingwind.top/2d2i5b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看宿主机的容器数据卷以及安装的Java</p><blockquote><p>Exec 不进入容器实现对容器的操作</p><p><img src="https://blog.chasingwind.top/mPqJsL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/mPqJsL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询截取分析</title>
      <link href="2020/09/01/MySQL%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90/"/>
      <url>2020/09/01/MySQL%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本节主要介绍了MySQL的查询截取分析，针对执行查询过程中出现的问题进行分析，包括查询优化，慢查询日志，批量数据脚本，Show Profile，全局查询日志等等，进一步提高SQL执行的效率。</p><a id="more"></a><h2 id="查询截取分析总体步骤"><a href="#查询截取分析总体步骤" class="headerlink" title="查询截取分析总体步骤"></a>查询截取分析总体步骤</h2><ol><li>慢查询开启并捕获</li><li>explain+慢SQL分析</li><li>show profile查询SQL在MySQL服务器中的执行细节和生命周期情况</li><li>SQL数据库服务器参数调优</li></ol><h2 id="MySQL查询优化"><a href="#MySQL查询优化" class="headerlink" title="MySQL查询优化"></a>MySQL查询优化</h2><h3 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a>小表驱动大表</h3><ul><li><p>也即小的数据集驱动大的数据集</p><blockquote><p><img src="https://blog.chasingwind.top/G9Slj5.png" class="lazyload" data-srcset="https://blog.chasingwind.top/G9Slj5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对于EXISTS的理解：</p><p>SELECT xxx from table WHERE EXISTS(子查询);</p><p>将外层主查询的结果，放到子查询中做条件验证，根据验证结果（TRUE或者FALSE）来决定主查询的结果是否保留</p><hr><p>但实际的使用情况还需要根据实际进行调整，EXISTS其实也就是IN的一种替代</p></blockquote></li></ul><h2 id="ORDER-BY关键字优化"><a href="#ORDER-BY关键字优化" class="headerlink" title="ORDER BY关键字优化"></a>ORDER BY关键字优化</h2><ol><li><p>Order by子句尽量使用Using INDEX排序，最好不要出现Using filesort文件排序。</p><ul><li><p>建立表以及索引</p><blockquote><p><img src="https://blog.chasingwind.top/yBWkkP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/yBWkkP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>分析各个查询中的排序是否会出现Using filesort</p><blockquote><p>复合索引(age,birthday)</p><p>索引排序Using INDEX</p><p><img src="https://blog.chasingwind.top/gSrYVO.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gSrYVO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/FpeW2a.png" class="lazyload" data-srcset="https://blog.chasingwind.top/FpeW2a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当复合索引的最佳左前缀为常量的时候 后面的字段用于排序也是可以的</p><p><img src="https://blog.chasingwind.top/LRjU7y.png" class="lazyload" data-srcset="https://blog.chasingwind.top/LRjU7y.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>出现 Using filesort</p><p><img src="https://blog.chasingwind.top/4cKpgJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4cKpgJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>索引：排好序的快速查找数据结构。这里的排好序，默认是升序（ASC）</p><p><img src="https://blog.chasingwind.top/O5qQmk.png" class="lazyload" data-srcset="https://blog.chasingwind.top/O5qQmk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>但是，如果对索引列同为升序或者同为降序，那么索引还是有作用的</p><p><img src="https://blog.chasingwind.top/rULwwP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/rULwwP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/q4D7A8.png" class="lazyload" data-srcset="https://blog.chasingwind.top/q4D7A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>MySQL支持两种排序，一种是使用INDEX进行排序，另一种就是filesort文件排序。当然，使用INDEX索引进行排序效率高于filesort文件排序。</li></ul></li></ul></li><li><p>尽可能在索引列上完成排序，遵照索引建的最佳左前缀原则</p></li><li><p>如果不在索引列上完成排序，filesort有两种算法</p><ul><li>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li>双路排序：先根据排序的条件去表中取出排序字段以及每一条数据对应的行id，然后再在sort buffer中对排序字段进行排序，此时生成的就是按照排序字段排好序，并且带有未排序之前的表中行的id，然后再次根据这个id去表中取出其他字段</li><li>至于mysql优化器使用双路排序还是单路排序是有自己的算法判断的，如果查询的列字段大于<code>max_length_for_sort_data</code>变量，则会使用<code>双路排序</code>（因此建议查询什么字段就取什么字段，而不是<code>select *</code>），反之则会使用<code>单路排序</code>，<code>单路排序</code>速度是更快的，不过比较占据内存，如果在内存空间允许的情况下想要使用<code>单路排序</code>的话，可以增加<code>max_length_for_sort_data</code>变量的大小，<code>max_length_for_sort_data</code>变量默认为1024字节。</li></ul></li><li><p>使用索引进行排序的情况</p><blockquote><p><img src="https://blog.chasingwind.top/ZlPWWo.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ZlPWWo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="GROUP-BY关键字优化"><a href="#GROUP-BY关键字优化" class="headerlink" title="GROUP BY关键字优化"></a>GROUP BY关键字优化</h2><ol><li>Group by <strong>实质是先排序后分组</strong>，遵循索引的最佳左前缀原则</li><li>无法使用索引列的时候，同样的和order by增加配置文件中参数<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的大小可以提高效率</li><li>where高于having，能在where中进行限定的就不要再having中进行限定了</li></ol><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过给定值的语句，具体是指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中</li><li>long_query_time默认值是10，意思是运行时间10秒</li><li>通过慢查询日志我们可以查看执行时间超过限制的SQL语句。</li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li><p>默认情况下，MySQL是没有开启慢查询日志的。需要我们手动来设置这个参数</p></li><li><p>当然，如果不是调优需要的话，一般不建议开启这个参数。因为开启慢查询多少会影响性能，慢查询日志支持将日志记录写入到文件中</p></li><li><p>查看是否已经开启</p><blockquote><p><code>show variables like &#39;%slow_query_log%&#39;;</code></p><p><img src="https://blog.chasingwind.top/x5n1N1.png" class="lazyload" data-srcset="https://blog.chasingwind.top/x5n1N1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>开启慢查询日志</p><blockquote><p><code>set global slow_query_log = 1;</code></p><p>这个开启只对当前数据库成立，当数据库重启之后就会失效。</p><p><img src="https://blog.chasingwind.top/Pj6TWd.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Pj6TWd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改默认的时长</p><blockquote><p>查看当前时长</p><p><img src="https://blog.chasingwind.top/gqZ0Xw.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gqZ0Xw.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>修改当前时长为3s</p><p><code>set global long_query_time = 3;</code></p><p><img src="https://blog.chasingwind.top/Dgcymo.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Dgcymo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>运行时间<strong>大于</strong>设定的时长才会被记录，等于的不会记录</p><p>tips：修改之后需要重新开启一个sql窗口才能看到修改之后的变化</p></blockquote></li><li><p>查看慢查询日志的内容</p><blockquote><p>测试语句</p><p><code>select sleep(4);</code></p><p>慢查询日志内容</p><p><img src="https://blog.chasingwind.top/gK313m.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gK313m.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看当前慢查询日志中记录的总条数</p><blockquote><p><code>show global status like &#39;%slow_queries%&#39;;</code></p><p><img src="https://blog.chasingwind.top/gWn0PI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gWn0PI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h3><ol><li>此工具可以对慢查询日志进行统计，比如，执行最频繁的SQL语句，执行最耗时的SQL语句等等，避免我们进行人共统计</li><li>详细使用方法可以参考<a href="https://www.cnblogs.com/qianbixueyuan/p/9939088.html">参考</a></li></ol><h2 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h2><p>插入大批量的数据不要使用insert，因为insert事务默认提交。可以批量插入数据，设置为手动提交事务，数据插入完成之后再commit。</p><h2 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h2><p>用于查看SQL语句执行的过程</p><blockquote><p>查看并开启功能</p><p><img src="https://blog.chasingwind.top/Vra78I.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Vra78I.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>运行SQL，并查看运行记录</p><p><img src="https://blog.chasingwind.top/X2o3JH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/X2o3JH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可能会遇到的问题</p><p>Converting HEAP to MyISAM 查询结果太大，内存不够，将数据搬到磁盘</p><p>Creating tmp table 创建零时表</p><p>Copying to tmp table on disk 把内存中的临时表复制到磁盘（危险！！）</p></blockquote><h2 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h2><ul><li><p>记录MySQL执行的所有的SQL历史</p></li><li><p>测试环境可以使用，但也是用的时候开启。</p></li><li><p>Show Profile功能更加强大</p><blockquote><p><img src="https://blog.chasingwind.top/GAUxM4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GAUxM4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引优化分析</title>
      <link href="2020/08/17/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/"/>
      <url>2020/08/17/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本节主要介绍MySQL索引，以及对一些SQL进行优化分析，这一节是重中之重，一定要好好掌握，包括原理以及用法，在以后的工作中起到很大的作用。</p><a id="more"></a><h2 id="SQL执行效率分析"><a href="#SQL执行效率分析" class="headerlink" title="SQL执行效率分析"></a>SQL执行效率分析</h2><ul><li>在SQL语句执行的过程中，常常会遇到SQL语句执行慢的问题，导致的原因通常可以分为以下三个部分：<ol><li>性能下降SQL慢</li><li>执行时间长</li><li>等待时间长</li></ol></li><li>导致以上问题的原因大致包括：<ol><li>查询语句写的🌶🐔</li><li>索引失效</li><li>关联查询太多JOIN（设计缺陷或不得已的需求）</li><li>服务器调优以及各个参数设置（缓冲、线程数等等）</li></ol></li></ul><h2 id="常见的JOIN查询"><a href="#常见的JOIN查询" class="headerlink" title="常见的JOIN查询"></a>常见的JOIN查询</h2><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ol><li><p>我们写的SQL关键字顺序</p><blockquote><p><img src="https://blog.chasingwind.top/4HI18T.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4HI18T.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>数据库的优化器执行时候的关键字顺序</p><blockquote><p><img src="https://blog.chasingwind.top/6iEbGS.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6iEbGS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>总的来说，优化器需要先知道全部的数据源，然后再从中进行查询</p><p><img src="https://blog.chasingwind.top/OwWidk.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OwWidk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><blockquote><p>图中一共有7种Join</p><p><img src="https://blog.chasingwind.top/0uahNZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0uahNZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol><li><p>t_dept表</p><blockquote><p><img src="https://blog.chasingwind.top/me2BP7.png" class="lazyload" data-srcset="https://blog.chasingwind.top/me2BP7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>t_emp表</p><blockquote><p><img src="https://blog.chasingwind.top/CqqAq2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CqqAq2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="7种JOIN"><a href="#7种JOIN" class="headerlink" title="7种JOIN"></a>7种JOIN</h3><ol><li><p>INNER JOIN</p><blockquote><p>取出emp和dept表中的部门id相同的数据  并且两个表的id都不为null</p><p><img src="https://blog.chasingwind.top/1REZIn.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1REZIn.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>LEFT JOIN,RIGHT JOIN与此类似</p><blockquote><p>取出emp表中的所有数据，同时根据emp表的部门id去连接dept表。尽管dept表中不存在第10条记录对应的数据，补为null</p><p><img src="https://blog.chasingwind.top/xKxkZR.png" class="lazyload" data-srcset="https://blog.chasingwind.top/xKxkZR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>LEFT JOIN并且JOIN的表的条件为null</p><blockquote><p>取出emp表的全部数据，同时筛选出其中部门id是null的员工</p><p><img src="https://blog.chasingwind.top/HMl7LP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/HMl7LP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>FULL OUTER JOIN（MySQL不支持）</p><blockquote><p>使用UNION实现， <strong>UNION自带去重功能</strong></p><p>图中的语义就是emp和dept的公共部分加上emp的独有加上dept的独有部分</p><p><img src="https://blog.chasingwind.top/OMPog4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OMPog4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>二者的独有部分联结</p><p><img src="https://blog.chasingwind.top/OAWDFw.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OAWDFw.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h2><ol><li><p>什么是索引？</p><ul><li><p>MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的<strong>数据结构</strong>。可以简单理解为<strong>排好序的快速查找数据结构</strong>，目的在于提高查询效率，可以类比从字典中查找数据。</p><ul><li>比如我们需要查找mysql这个字段，没有索引的时候，需要先从a<del>z中从a开始直到找到m，然后再从剩下的a</del>z中找到y…….</li></ul></li><li><p>索引两大功能，<strong>快速查找和排序</strong>。影响到WHERE后面的条件是否使用了索引和ORDER BY排序后面的条件，也就是说索引会对查找和排序都有影响。</p><blockquote><p><strong>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</strong>下图就是一种可能的索引方式示例：</p><p><img src="https://blog.chasingwind.top/cgjbQZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/cgjbQZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指 针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p></blockquote></li><li><p>索引存储在<code>.myi</code>文件中，文件比较大，存储在磁盘上</p></li><li><p>我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引<strong>默认都是使用B+树索引</strong>，统称索引。当然除了B+树索引外，还有哈希索引（hash index）等。</p></li></ul></li><li><p>索引的优势</p><blockquote><p>排好序的快速查找数据结构</p></blockquote><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul></li><li><p>索引的劣势</p><ul><li><p>实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是占空间的</p></li><li><p>虽然索引大大提高了查询速度，<strong>同时却会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，<strong>MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</strong></p></li><li><p>索引只是提高效率的一个因素，如果数据库中有大量的表，就需要花时间研究建立最优秀的索引，或优化查询</p></li></ul></li><li><p>MySQL索引分类</p><ol><li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引 </li><li>唯一索引：索引列的值必须唯一，但<strong>允许有空值</strong></li><li>主键索引：<strong>设定为主键后数据库会自动建立索引</strong>，innodb为聚簇索引</li><li>复合索引：即一个索引包含多个列</li></ol></li><li><p>索引基本语法</p><ol><li><p>创建</p><pre><code class="sql">CREATE [UNIQUE] INDEX 索引名 ON 表名(表中的列名);  ALTER TABLE 表名 ADD [UNIQUE] INDEX 索引名 (表中的列名);  </code></pre><ul><li><p>中括号<code>[]</code>表示可选择，UNIQUE表示创建的是唯一索引</p></li><li><p>表中的列名，如果是多列的话，就是复合索引；单列的话就是唯一索引</p><blockquote><p>创建索引</p><p><img src="https://blog.chasingwind.top/HZi0Ot.png" class="lazyload" data-srcset="https://blog.chasingwind.top/HZi0Ot.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看索引</p><p>图中第一个索引是 表创建的时候数据库默认创建的主键索引</p><p><img src="https://blog.chasingwind.top/h8ymNt.png" class="lazyload" data-srcset="https://blog.chasingwind.top/h8ymNt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用ALTER创建索引  这里创建的是复合索引</p><p><img src="https://blog.chasingwind.top/05b3xC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/05b3xC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看索引</p><p><img src="https://blog.chasingwind.top/EfIPVp.png" class="lazyload" data-srcset="https://blog.chasingwind.top/EfIPVp.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>删除</p><pre><code class="sql">DROP INDEX 索引名 ON 表名;</code></pre><blockquote><p><img src="https://blog.chasingwind.top/xq44JC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/xq44JC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看</p><pre><code class="sql">SHOW INDEX FROM 表名;</code></pre><blockquote><p><img src="https://blog.chasingwind.top/a3MphU.png" class="lazyload" data-srcset="https://blog.chasingwind.top/a3MphU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>MySQL索引结构</p><ol><li><p>BTree索引</p><ul><li><p>MySQL使用的就是BTree索引。</p></li><li><p>BTree</p><blockquote><p><img src="https://blog.chasingwind.top/4NRzki.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4NRzki.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Btree"></p><p>上图就是一颗BTree，浅蓝色的是磁盘块，深蓝色的是数据项，黄色的是指针</p><p>如磁盘块 1 包含数据项17和 35，包含指针 P1、P2、P3。P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。 </p><p><strong>非叶子结点不存储真实的数据，只存储指引搜索方向的数据</strong>，比如上图中磁盘块1中的17和35，并不真实存在于数据表中。</p><p>真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。</p><hr><p>查找过程</p><p>如果要查找数据项 29，那么<strong>首先会把磁盘块 1 由磁盘加载到内存</strong>，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短（相比磁盘的 IO）可以忽略不计，</p><p>通过磁盘块 1 的 P2 指针的磁盘地址把<strong>磁盘块 3 由磁盘加载到内存，发生第二次 IO</strong>，29 在 26 和 30 之间，</p><p>锁定磁盘块 3 的 P2 指 针，<strong>通过指针加载磁盘块 8 到内存，发生第三次 IO</strong>，同时内存中做二分查找找到 29，结束查询，总计三次 IO。</p><p>也就是说我们<strong>磁盘的IO次数就是树的高度</strong></p><hr><p>3层BTree能存储的数据量</p><p>真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的， </p><p>如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。 </p></blockquote></li></ul></li><li><p>Hash索引</p></li><li><p>full-text全文检索</p></li><li><p>R-Tree索引</p></li></ol></li><li><p>哪些情况需要创建索引</p><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单值/组合索引的选择问题， 组合索引性价比更高</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol></li><li><p>哪些情况不要创建索引</p><ol><li>表记录太少</li><li>经常增删改的表或者字段</li><li>Where 条件里用不到的字段不创建索引 </li><li>数据重复且分布平均的表字段不适合建索引，就是说，如果某个字段值重复率太高，就不适合建索引。比如，100万条数据中，某个字段只有T和F两种，这两个值分布都是在50%，那么这个字段就没必要创建索引，不会提高查询的效率。</li></ol></li></ol><h2 id="EXPLAIN性能分析"><a href="#EXPLAIN性能分析" class="headerlink" title="EXPLAIN性能分析"></a>EXPLAIN性能分析</h2><p>在MySQL Query Optimizer（优化器）和MySQL数据库硬件以及配置都稳定的情况下，通过EXPLAIN来分析SQL的性能。</p><ol><li><p>EXPLAIN是什么</p><ul><li>使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈。 </li></ul></li><li><p>EXPLAIN可以做什么</p><ol><li>表的读取顺序（id）</li><li>数据读取操作的操作类型（select_type）</li><li>哪些索引可以使用(possible_keys)</li><li>哪些索引被实际使用(keys)</li><li>表之间的引用（ref）</li><li>每张表有多少行被优化器查询（rows）</li></ol></li><li><p>EXPLAIN怎么使用</p><ul><li>EXPLAIN+SQL语句</li></ul></li><li><p>解释各个字段的含义</p><p>执行EXPLAIN+SQL语句的结果</p><blockquote><p><img src="https://blog.chasingwind.top/GgOYfS.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GgOYfS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol><li><p>id：select查询序列号，是一组数字，表示查询中执行select子句或者操作表的顺序</p><ul><li><p>id相同：按照table列的顺序，由上到下的顺序执行</p><blockquote><p><img src="https://blog.chasingwind.top/Ia4m8A.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Ia4m8A.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>id不同：id越大，优先级越高，越先被执行</p><blockquote><p><img src="https://blog.chasingwind.top/XTcmBI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/XTcmBI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>id既有相同，又有不同的，二者同时存在</p><blockquote><p><img src="https://blog.chasingwind.top/AJBAcm.png" class="lazyload" data-srcset="https://blog.chasingwind.top/AJBAcm.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>DERIVED，衍生</p><p>上图中，首先执行的就是id为2的组（只有一个）中的t3，然后再在id为1的组中根据table列的顺序由上到下执行，先执行derived2，再执行t2。</p><p>derived2表示：derived2这个临时表是根据id为2的表t3衍生出来的。就是上图中的s1</p></blockquote></li></ul></li><li><p>select_type：查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询</p><ul><li>SIMPLE：简单的select查询，查询中不包含子查询或者UNION</li><li>PRIMARY：查询中若包含任何复杂的子部分，则最外层被标记为PRIMARY</li><li>SUBQUERY：在select或where列表中包含了子查询</li><li>DERIVED：在from列表中包含的子查询被标记为DERIVED（衍生），MYSQL会递归执行这些子查询，把结果放在临时表中</li><li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION被包含在FROM子句的子查询中，外层SELECT则被标记为DERIVED</li><li>UNION RESULT：从UNION表获取结果的SELECT</li></ul></li><li><p>table：显示这一行数据是关于哪张表的</p></li><li><p>type：访问类型排列</p><blockquote><p>最好到最差的排列顺序：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><p>一般来说：查询至少达到range级别，最好达到ref级别</p></blockquote><ul><li><p>system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计</p></li><li><p>const： 表示通过索引一次就能找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p><blockquote><p><img src="https://blog.chasingwind.top/9Qep2m.png" class="lazyload" data-srcset="https://blog.chasingwind.top/9Qep2m.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p><blockquote><p><img src="https://blog.chasingwind.top/EpH02X.png" class="lazyload" data-srcset="https://blog.chasingwind.top/EpH02X.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里好比 t1是员工表，t2是部门表</p><p>查出来的是全公司唯一的总裁</p></blockquote></li><li><p>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。</p><blockquote><p><img src="https://blog.chasingwind.top/0cyQdh.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0cyQdh.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这就好比，查找一个公司职位是程序员的人，查出来的是多个</p></blockquote></li><li><p>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</p><blockquote><p><img src="https://blog.chasingwind.top/4PwwBt.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4PwwBt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>index：Full Index Scan，index和ALL的区别就在于index类型只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但是index是从索引中读取，而all是从硬盘中读取）</p></li><li><p>ALL：Full Table Scan，遍历全表找到匹配行</p></li></ul></li><li><p>possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。</p></li><li><p>keys：实际使用的索引。如果为NULL，则没有使用索引，存在的情况有多种，比如索引没有建立，索引失效等等。还有一种就是如果存在多个索引，那么实际使用的是哪一个索引。</p><blockquote><p>查询中若使用了覆盖索引，则该索引仅出现在key列中，possible_keys理论上使用的索引为null</p><p>覆盖索引：select后面查询的列和索引列相对应（个数和顺序都一样）</p><p><img src="https://blog.chasingwind.top/EiN8Dz.png" class="lazyload" data-srcset="https://blog.chasingwind.top/EiN8Dz.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<strong>在不损失精确性的情况下，长度越短越好。</strong></p><blockquote><p>Key_len显示的是索引字段的最大可能长度，并非实际使用长度，即key_len是<strong>根据表定义计算而得到的</strong>，不是通过表内检索出来的</p><p><img src="https://blog.chasingwind.top/4aQKqo.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4aQKqo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第一个13是如何计算得到的：UTF-8，一个char占3个字节，同时，col1 DEFALUT是NULL，MySQL需要使用一个字节来标记NULL，也就是4 * 3  + 1 = 13。</p><p>同理，下面的26也是这样计算所得</p></blockquote></li><li><p>ref：显示索引的哪一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。</p><blockquote><p><img src="https://blog.chasingwind.top/ReliT7.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ReliT7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>执行表t1的时候，explain告诉我们使用到了idx_col1_col2这个索引，并且通过ref知道这个索引用于匹配哪些值</p></blockquote></li><li><p>rows：根据表统计信息以及索引的选用情况，大致估算出找到所需的记录所需要读取的行数。</p><blockquote><p><img src="https://blog.chasingwind.top/SMyql9.png" class="lazyload" data-srcset="https://blog.chasingwind.top/SMyql9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Extra：额外信息（除上述9个之外的信息）</p><ol><li><p>Using filesort：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。</p><blockquote><p>这种情况是需要避免的，否则排序是重新进行的。</p><p><img src="https://blog.chasingwind.top/oai0ZC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/oai0ZC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</p><blockquote><p>所以在我们进行排序和分组查询的时候，条件一定要使用索引顺序，这样的话，效率会高很多；否则就会使用临时表，这其中需要经历创建临时表，对临时表进行操作，删除临时表的过程，是很耗费时间的。</p><p><img src="https://blog.chasingwind.top/Xi7cxR.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Xi7cxR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Using INDEX：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行。直接通过查找索引而定位到数据，效率可以的！</p><blockquote><ul><li>如果同时出现Using where，表明索引被用来执行索引键值的查找；</li><li>如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作。</li></ul><p><img src="https://blog.chasingwind.top/qej2Ej.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qej2Ej.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>再说覆盖索引，</p><p>覆盖索引：select数据列只用从索引列中就可以获得，不必读取数据行。MySQL可以根据索引返回select的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p><p>如果要使用覆盖索引，一定要注意select列表中只取出需要的列（与索引列顺序，个数一致），不可以使用select *。否则的话使用的就不是索引覆盖，而仅仅是Using INDEX。</p></blockquote></li><li><p>Using where：表示SQL使用了where条件对数据进行了过滤。</p></li><li><p>USing join buffer：使用了连接缓存，这个就是说join的表太多，可以将配置文件的缓冲区调大一点。</p></li><li><p>impossible where：where子句的值总是false。</p><blockquote><p><img src="https://blog.chasingwind.top/kKNATU.png" class="lazyload" data-srcset="https://blog.chasingwind.top/kKNATU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h3><p><a href="https://blog.csdn.net/qq_42826747/article/details/106674270">建表SQL参考</a></p><ol><li><p>单表</p><blockquote><p>建立文章article表</p><pre><code class="mysql">CREATE TABLE IF NOT EXISTS `article`(`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`author_id` INT(10) UNSIGNED NOT NULL,`category_id` INT(10) UNSIGNED NOT NULL,`views` INT(10) UNSIGNED NOT NULL,`comments` INT(10) UNSIGNED NOT NULL,`title` VARBINARY(255) NOT NULL,`content` TEXT NOT NULL);</code></pre></blockquote><ul><li><p>查询category_id为1且comments大于1的情况下，views最多的article_id。</p><ul><li><p>对查询语句进行EXPLAIN分析</p><blockquote><p><img src="https://blog.chasingwind.top/d4rSQM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/d4rSQM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>分析发现查询不仅遍历了全表查找数据，而且还使用了文件排序。</p><p>并且没有使用到索引，因为我们还没有创建索引。</p></blockquote></li><li><p>尝试建立索引</p><blockquote><p>由于上面的查询使用到了category_id，comments和views，尝试建立这三者的复合索引。</p><p><img src="https://blog.chasingwind.top/I5Kvs0.png" class="lazyload" data-srcset="https://blog.chasingwind.top/I5Kvs0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在建立索引之后再次进行查询的操作</p><p><img src="https://blog.chasingwind.top/GWYUDg.png" class="lazyload" data-srcset="https://blog.chasingwind.top/GWYUDg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>发现虽然解决了全表扫描的问题并且使用了索引，但是还是出现了文件排序</p><p>出现的原因：按照BTree的工作原理，先排序category_id，如果遇到相同的category_id，再排序comments，如果遇到相同的comments再排序views。</p><p>因为where的第二个字段<code>comments&gt;1</code>（range）是一个范围并且处于中间字段，MySQL无法对后面的views部分进行检索，也即<strong>range类型查询字段后面的索引无效</strong>。</p></blockquote></li><li><p>重新建立索引</p><blockquote><p>首先需要将之前的索引删除</p><p><img src="https://blog.chasingwind.top/Gogj0H.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Gogj0H.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>尝试跳过comments建立索引</p><p><img src="https://blog.chasingwind.top/pTb3oI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/pTb3oI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>进行查询分析 不仅使用了索引，并且访问类型也变成了ref，同时文件排序也不存在了。</p><p><img src="https://blog.chasingwind.top/ALy6RL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ALy6RL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul></li><li><p>两表</p><blockquote><p>创建两张表，class和book表，两个表之间的联系就是card列对应相等</p><p><img src="https://blog.chasingwind.top/sSqJoY.png" class="lazyload" data-srcset="https://blog.chasingwind.top/sSqJoY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>那么问题就出现了，两张表我们建立索引，建立在哪张表上面呢？class.card还是book.card？</p></blockquote><ul><li><p>未创建索引的时候</p><blockquote><p><img src="https://blog.chasingwind.top/shVuLo.png" class="lazyload" data-srcset="https://blog.chasingwind.top/shVuLo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果出现了全表扫描的情况，效率比较低</p></blockquote></li><li><p>在左连接左表建立索引</p><blockquote><p><img src="https://blog.chasingwind.top/IX33XY.png" class="lazyload" data-srcset="https://blog.chasingwind.top/IX33XY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>再次执行EXPLAIN分析SQL语句，一个是遍历索引，一个是遍历全表的数据，并且rows还是全表</p><p><img src="https://blog.chasingwind.top/pFmk6Q.png" class="lazyload" data-srcset="https://blog.chasingwind.top/pFmk6Q.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在左连接右表上建立索引</p><blockquote><p>首先删除之前的索引</p><p><img src="https://blog.chasingwind.top/ar8Hen.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ar8Hen.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在book表上建立索引</p><p><img src="https://blog.chasingwind.top/bONg4s.png" class="lazyload" data-srcset="https://blog.chasingwind.top/bONg4s.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>再次执行相同的SQL，发现在book表的时候type为ref，非唯一性索引扫描；并且rows行也是1。</p><p><img src="https://blog.chasingwind.top/QFkN3t.png" class="lazyload" data-srcset="https://blog.chasingwind.top/QFkN3t.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>总结就是：左连接需要在右边的表建立索引；右连接需要在左边的表建立索引。</p><blockquote><p>拿左连接举例来说：</p><p>LEFT JOIN 条件用于确认如何从右表搜索行，左边的表中的数据全都有。所以，右边的表是我们的关键点，需要建立索引。</p></blockquote></li></ul></li><li><p>三表</p><blockquote><p>创建phone表，其中也有card字段。</p><p><img src="https://blog.chasingwind.top/Ze74rE.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Ze74rE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>未建立索引的时候</p><blockquote><p>三张表都是全表扫描（ALL）</p><p><img src="https://blog.chasingwind.top/FWMcM9.png" class="lazyload" data-srcset="https://blog.chasingwind.top/FWMcM9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在左连接的右表建立索引</p><blockquote><p>分别在两个左连接的右表创建索引  再次执行EXPLAIN分析，发现之前的两个全表扫描已经变成了非唯一性索引扫描（ref），相比之前的ALL，效率提高很多。</p><p><img src="https://blog.chasingwind.top/gUeJS6.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gUeJS6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>JOIN语句的优化</p><ol><li>用小结果集驱动大的结果集，比如说LEFT JOIN，右表的表结果应该比左边的表结果小。</li><li>优先优化内层嵌套的查询，比如JOIN一个表，先优化JOIN的表，而不是主表</li><li>保证JOIN语句中被驱动表上JOIN条件字段已经被索引</li><li>当无法保证被驱动表的JOIN字段被索引且内存资源充足的情况下，可以修改JoinBuffer的设置。</li></ol></li></ul></li></ol><h3 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h3><ul><li><p>创建staffs表并插入数据</p><blockquote><p><img src="https://blog.chasingwind.top/B97zCT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/B97zCT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>建立索引</p><blockquote><p>查看索引中字段的顺序</p><p><img src="https://blog.chasingwind.top/QR4wbg.png" class="lazyload" data-srcset="https://blog.chasingwind.top/QR4wbg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>案例</p><blockquote><p>使用索引中的NAME作为条件进行查找</p><p><img src="https://blog.chasingwind.top/MAQKYy.png" class="lazyload" data-srcset="https://blog.chasingwind.top/MAQKYy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用索引中的NAME，age作为条件进行查找数据</p><p><img src="https://blog.chasingwind.top/UMjdwa.png" class="lazyload" data-srcset="https://blog.chasingwind.top/UMjdwa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用NAME，age，pos作为条件进行查找</p><p><img src="https://blog.chasingwind.top/LnSXj1.png" class="lazyload" data-srcset="https://blog.chasingwind.top/LnSXj1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见，要想结果更加精确，那么是需要付出更多的代价的（key_len）。</p></blockquote><ol><li><p>最佳左前缀法则</p><blockquote><p>当我们去掉NAME，使用age和pos作为条件进行查询的时候</p><p>发现并没有用到索引  而且是全表扫描</p><p><img src="https://blog.chasingwind.top/sFoqtD.png" class="lazyload" data-srcset="https://blog.chasingwind.top/sFoqtD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们仅仅使用pos作为条件的时候 结果也是如此</p><p><img src="https://blog.chasingwind.top/pJH37H.png" class="lazyload" data-srcset="https://blog.chasingwind.top/pJH37H.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/A9neoq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/A9neoq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们跳过中间的索引age，直接使用第一个索引NAME和第三个索引age的时候，我们会发现，key_len是74，仅仅是索隐列NAME的长度，ref也只有一个。也就是说<strong>索引只使用了一部分（NAME），pos索引并没有使用到</strong>。所以，最佳左前缀法则还有一点就是不能跳过索引的中间列。</p><hr><p>最佳左前缀法则：如果索引使用了多个列（复合索引），要遵守最佳左前缀法则，就是说查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong>。</p><p>比如上面的案例，要么使用NAME；要么使用NAME，age；要么使用NAME，age，pos。这样的话索引才不会失效。</p></blockquote></li><li><p>不要在索引列上做任何的操作（计算，函数，类型转换），会导致索引失效而转向全表扫描</p><blockquote><p><img src="https://blog.chasingwind.top/Pk65hC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Pk65hC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>对索引列进行计算 下图中的LEFT(NAME,4)表示取得NAME值的前4个</p><p><img src="https://blog.chasingwind.top/fPaHW2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/fPaHW2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见，对索引列进行计算的话。索引并没有起作用，导致了索引失效。</p></blockquote></li><li><p>存储引擎不能使用索引中范围条件右边的列（范围之后全失效）</p><blockquote><p>全值匹配</p><p><img src="https://blog.chasingwind.top/g4hKnG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/g4hKnG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当age使用范围之后，范围之后的索引全部失效。</p><p>下图中可以看出，key_len是78，说明使用到了索引中的NAME和range。</p><p>但是NAME和range其实还是有区别的，<strong>NAME是用于检索，而age却用在排序</strong>。</p><p><img src="https://blog.chasingwind.top/Zckwe2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Zckwe2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>尽量使用覆盖索引（索引列和查询列一致），减少<code>select *</code>的使用</p><blockquote><p>当我们使用<code>select *</code></p><p><img src="https://blog.chasingwind.top/zI8jhu.png" class="lazyload" data-srcset="https://blog.chasingwind.top/zI8jhu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>而我们只取索引列的数据</p><p>Using INDEX 表示相应的select操作中使用了覆盖索引，避免访问了表的数据行</p><p><img src="https://blog.chasingwind.top/3p29De.png" class="lazyload" data-srcset="https://blog.chasingwind.top/3p29De.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>MySQL在使用不等于（!=或者&lt;&gt;）的时候会无法使用索引导致全表扫描</p></li><li><p>IS NULL或者IS NOT NULL也无法使用索引</p></li><li><p>LIKE以通配符开头（’%abc…’）,MySQL索引失效变成全表扫描</p><blockquote><p>前后都有通配符  全表扫描</p><p><img src="https://blog.chasingwind.top/jb8MAt.png" class="lazyload" data-srcset="https://blog.chasingwind.top/jb8MAt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>前面有通配符  依旧是全表扫描</p><p><img src="https://blog.chasingwind.top/rAHp3R.png" class="lazyload" data-srcset="https://blog.chasingwind.top/rAHp3R.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当通配符只出现在后面的时候  发现是 范围扫描</p><p><img src="https://blog.chasingwind.top/4MFkKW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4MFkKW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>还有一个就是 当我们like以常量开头，之后无论有没有%都不会影响索引， 索引都可以正常使用</p><p><img src="https://blog.chasingwind.top/fGi3YF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/fGi3YF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>但是 问题就是 我们在实际问题中或许还是需要使用前后都有通配符的情况的，这该怎么解决呢？</p></blockquote><ul><li><p>解决<code>like(&#39;%abc...%&#39;)</code>索引失效的问题</p><blockquote><p>如果两边都有%，我们可以<strong>通过覆盖索引来提升性能</strong></p><p>创建tbl_user表</p><p><img src="https://blog.chasingwind.top/yznSJm.png" class="lazyload" data-srcset="https://blog.chasingwind.top/yznSJm.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>未创建索引之前，全部都是全表扫描</p><p><img src="https://blog.chasingwind.top/WIM27p.png" class="lazyload" data-srcset="https://blog.chasingwind.top/WIM27p.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>创建索引NAME，age，email</p><p><img src="https://blog.chasingwind.top/vKGRVF.png" class="lazyload" data-srcset="https://blog.chasingwind.top/vKGRVF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同样的上面的所有的查询语句 type已经变成了扫描索引，提升效率。</p><p><img src="https://blog.chasingwind.top/r2kZYP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/r2kZYP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>但是 如果我们查询的列比覆盖索引的列多，那么还是会全表扫描</p></blockquote></li></ul></li><li><p>字符串不加单引号索引失效</p><blockquote><p>我们向tbl_user表中添加一个数据 NAME为2000</p><p><img src="https://blog.chasingwind.top/YMvqSy.png" class="lazyload" data-srcset="https://blog.chasingwind.top/YMvqSy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当2000带单引号  能查出来数据</p><p><img src="https://blog.chasingwind.top/4iMgfW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4iMgfW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当2000不带单引号  也能查出来数据</p><p><img src="https://blog.chasingwind.top/tLyvaY.png" class="lazyload" data-srcset="https://blog.chasingwind.top/tLyvaY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这是因为MySQL在优化分析的时候，因为我们创建的表结构NAME是varchar类型的数据，MySQL拿到数字类型的时候，会将数字类型转换为varchar类型。这期间存在着<strong>隐式类型转换</strong>。</p><hr><p>执行EXPLAIN分析  当使用字符串的时候，使用到了索引，并且type是ref类型</p><p><img src="https://blog.chasingwind.top/qrZiON.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qrZiON.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用数字类型的时候 NAME这个索引就失效了  变成了全表扫描 </p><p>结合第2点 不要在索引上做任何操作（类型转换） 同时理解</p><p><img src="https://blog.chasingwind.top/sFJvMm.png" class="lazyload" data-srcset="https://blog.chasingwind.top/sFJvMm.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>少用or，用它连接时索引失效</p></li></ol></li></ul><h3 id="练习题分析"><a href="#练习题分析" class="headerlink" title="练习题分析"></a>练习题分析</h3><ol><li><p>建表</p><blockquote><p><img src="https://blog.chasingwind.top/0LaGcW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0LaGcW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>建立索引</p><blockquote><p><img src="https://blog.chasingwind.top/jTLVxc.png" class="lazyload" data-srcset="https://blog.chasingwind.top/jTLVxc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>分析</p><blockquote><p>当where条件为常量并且顺序和索引的顺序一致的时候，毫无疑问，4个索引都用到了</p><p><img src="https://blog.chasingwind.top/vilWFN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/vilWFN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当where条件为常量的时候，但是顺序和索引顺序完全颠倒或者说不一致的时候，4个索引还是全部都使用到了</p><p><img src="https://blog.chasingwind.top/DO8zDQ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/DO8zDQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>原因：MySQL查询优化器会自动对我们的SQL进行优化，因为上面的4个<strong>都是常量</strong>，所以顺序无关，MySQL会优化成与我们创建的索引的顺序相同。</p></blockquote><blockquote><p>使用到了<strong>3</strong>个索引，范围之后全失效。c1,c2用来索引数据，c3用来对数据进行排序</p><p><img src="https://blog.chasingwind.top/yEBTRw.png" class="lazyload" data-srcset="https://blog.chasingwind.top/yEBTRw.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这里用到了<strong>4</strong>个索引  </p><p><img src="https://blog.chasingwind.top/mzJXvN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/mzJXvN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>分析：首先 优化器对SQL进行优化 优化成按照索引的顺序 也就是等同于下图  由于范围c4是最后一个字段 后面已经没有了  所以4个索引都使用到了</p><p><img src="https://blog.chasingwind.top/U6GeOu.png" class="lazyload" data-srcset="https://blog.chasingwind.top/U6GeOu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>ordey by后面会有更加详细的介绍</p><p>这里使用到了两个索引  其实c3也用到了  只不过是用于排序而非查找，没有统计到explain的keys中</p><p><img src="https://blog.chasingwind.top/mfNRmv.png" class="lazyload" data-srcset="https://blog.chasingwind.top/mfNRmv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>去掉c4  还是只使用到了两个索引 同样c3也是用于排序</p><p><img src="https://blog.chasingwind.top/MoTJkN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/MoTJkN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>order by c4</p><p>相比上面的ordey by c3，这里多出了文件排序</p><p><img src="https://blog.chasingwind.top/0yfevH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0yfevH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>order by c2,c3，并且前面的where条件有c1的时候  <strong>Extra并没有出现 Using filesort</strong></p><p><img src="https://blog.chasingwind.top/6dJ54c.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6dJ54c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们直接使用c2,c3进行排序的时候  <strong>就会出现Using filesort</strong></p><p><img src="https://blog.chasingwind.top/mH6CDZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/mH6CDZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>为了避免出现文件排序 那么where条件和ordey by顺序要衔接上，比如我们要order by c2,c3，那么where中要有使用到<strong>有效的索引c1</strong>就不会出现文件排序</p><p>有效的索引 不会导致后面的排序用的字段的索引失效</p><p><img src="https://blog.chasingwind.top/0wJwOJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0wJwOJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>下图中的索引c2,c3就失效了 出现了文件排序</p><p><img src="https://blog.chasingwind.top/ChfCXC.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ChfCXC.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>order by顺序的问题</p><p>order by c3,c2  出现了Using filesort 文件排序</p><p><img src="https://blog.chasingwind.top/10gX0m.png" class="lazyload" data-srcset="https://blog.chasingwind.top/10gX0m.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>同样是order by c3,c2  这里却没有出现文件排序</p><p><img src="https://blog.chasingwind.top/RHwryz.png" class="lazyload" data-srcset="https://blog.chasingwind.top/RHwryz.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>原因：因为在where条件中c2就是一个常量， 所以在order by c3,c2的时候 ,MySQL优化器会将order by优化成order by c3,常量值。也就是说排序已经不受c2的影响，等同于ordey by c3。</p></blockquote><blockquote><p>group by 分组</p><p>按照索引的顺序进行分组</p><p><img src="https://blog.chasingwind.top/UcJpjN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/UcJpjN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>出现了Using temporary</p><p><img src="https://blog.chasingwind.top/MgpbPz.png" class="lazyload" data-srcset="https://blog.chasingwind.top/MgpbPz.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>group by分组 ， 分组之前必排序。所以说group by和order by索引优化几乎是一致的</p><p>group by分组如果索引没用起来的话，那么就会有临时表产生，影响效率（Using temporary）</p></blockquote></li></ol><h3 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h3><ol><li>对于单值索引，尽量选择对于当前查询过滤性更好的索引</li><li>对于复合索引的选择，当前查询中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>对于复合索引的选择，尽量选择可以能够包含当前查询中的where子句中更多字段的索引。</li><li>尽可能通过分析统计信息和调整查询的写法来达到选择合适索引的目的。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/b_x_p/article/details/86434387">深入理解MySQL索引之B+Tree</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="2020/08/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>2020/08/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>本节介绍Java8的一些新特性，包括Stream流的操作，其中包括并行流和串行流；Lambda表达式的基础语法和用法，以便在工作中更好地进行使用。</p><a id="more"></a><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h2><blockquote><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁，更灵活的代码。作为一种更紧凑的代码风格，使Java语言表达能力得到提升。</p></blockquote><h2 id="Lambda表达式解决的问题"><a href="#Lambda表达式解决的问题" class="headerlink" title="Lambda表达式解决的问题"></a>Lambda表达式解决的问题</h2><ol><li><p>匿名内部类</p><blockquote><p>以前我们实现比较器的时候，使用匿名内部类来实现比较</p><p><img src="https://blog.chasingwind.top/6YlY2t.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6YlY2t.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们分析一下 可以发现在比较器中真正有用的只是return这句话</p><p><img src="https://blog.chasingwind.top/Y78E2r.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Y78E2r.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用Lambda表达式解决</p><p><img src="https://blog.chasingwind.top/8Xh3AO.png" class="lazyload" data-srcset="https://blog.chasingwind.top/8Xh3AO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>减少代码冗余</p><blockquote><p>假设目前有一个员工对象</p><p><img src="https://blog.chasingwind.top/QhJiIK.png" class="lazyload" data-srcset="https://blog.chasingwind.top/QhJiIK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们的需求是筛选出列表中年龄大于35岁的员工的时候，可以采用如下代码实现</p><p><img src="https://blog.chasingwind.top/ICBNAz.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ICBNAz.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们改变需求  筛选出工资大于4000元的员工的时候</p><p><img src="https://blog.chasingwind.top/dvS5pK.png" class="lazyload" data-srcset="https://blog.chasingwind.top/dvS5pK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以这样的处理方式 代码的冗余度比较高</p><hr><p>优化1：使用策略设计模式</p><p>首先，创建一个通用接口</p><p><img src="https://blog.chasingwind.top/m8tIPD.png" class="lazyload" data-srcset="https://blog.chasingwind.top/m8tIPD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>然后，根据需求实现创建对应的类实现接口</p><p>比如，这里的需求是筛选出年龄大于35的员工</p><p><img src="https://blog.chasingwind.top/izyKJQ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/izyKJQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>最后，调用方法时直接传入相应的实现类</p><p><img src="https://blog.chasingwind.top/QirKNe.png" class="lazyload" data-srcset="https://blog.chasingwind.top/QirKNe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>如果 当我们改变需求  我们只需要根据需求写一个接口的实现类，使用的时候调用filter传入对应的实现类即可，而不需要修改其他的代码。</p><hr><p>上面的代码还可以进行优化，因为在上面的代码中，如果我们又新增了一个需求，那么我们还需要创建一个类，麻烦并且多余，这个时候，就可以使用匿名内部类来实现。</p><p>这就又出现了代码冗余度高的问题</p><p><img src="https://blog.chasingwind.top/XCIekk.png" class="lazyload" data-srcset="https://blog.chasingwind.top/XCIekk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Lambda表达式简化</p><blockquote><p><img src="https://blog.chasingwind.top/vdmZrW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/vdmZrW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Lambda表达式的基础语法"><a href="#Lambda表达式的基础语法" class="headerlink" title="Lambda表达式的基础语法"></a>Lambda表达式的基础语法</h2><ol><li><p>操作符：<code>-&gt;</code>，操作符将Lambda表达式拆分成两部分，左侧是Lambda表达式的参数列表，右侧（称为Lambda体）是Lambda表达式中所需要执行的功能（也即对接口中方法的实现）。</p></li><li><p>左侧参数列表从哪里来</p><blockquote><p>需要实现的接口的参数列表</p></blockquote></li><li><p>右侧功能又是根据什么实现</p><blockquote><p>接口功能的实现</p></blockquote></li><li><p>语法格式</p><ul><li><p>无参无返回值类型</p><blockquote><p><img src="https://blog.chasingwind.top/Ds03Vi.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Ds03Vi.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用匿名内部类和Lambda表达式</p><p><img src="https://blog.chasingwind.top/k7b1ZQ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/k7b1ZQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>有一个参数，并且无返回值</p><blockquote><p><img src="https://blog.chasingwind.top/U2LsPg.png" class="lazyload" data-srcset="https://blog.chasingwind.top/U2LsPg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/FTgANV.png" class="lazyload" data-srcset="https://blog.chasingwind.top/FTgANV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>如果方法只有一个参数  小括号可以省略</p><p><img src="https://blog.chasingwind.top/raMAj2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/raMAj2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>方法有多个参数，有返回值，并且Lambda体中有多条语句</p><blockquote><p><img src="https://blog.chasingwind.top/OzAs0N.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OzAs0N.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/oCWFW1.png" class="lazyload" data-srcset="https://blog.chasingwind.top/oCWFW1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当实现的方法中 有多个参数，有返回值，但是Lambda体中只有一条语句的时候，可以将<code>&#123;&#125;</code>和<code>return</code>省略</p><p><img src="https://blog.chasingwind.top/WD4Iyq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/WD4Iyq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>类型推断</p><blockquote><p>在上面的案例中我们可以发现，我们在参数列表中并没有写参数的数据类型</p><p>当然也可以写上</p><p><img src="https://blog.chasingwind.top/PCaxjH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/PCaxjH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>那么不写的时候，编译器是怎样知道数据类型的呢？</p><p>JVM编译器经过上下文推断，得出参数列表的数据类型。比如上图中的，是根据<code>Comparator&lt;Integer&gt;</code>来推断出来的数据类型</p></blockquote></li></ul></li></ol><h2 id="什么时候可以用Lambda表达式"><a href="#什么时候可以用Lambda表达式" class="headerlink" title="什么时候可以用Lambda表达式"></a>什么时候可以用Lambda表达式</h2><ul><li>Lambda表达式的使用需要<strong>函数式接口</strong>的支持</li></ul><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><ul><li><p>接口中只有一个抽象方法的接口称为函数式接口（JDK1.8之后，接口中的方法可以有普通方法，使用default可以修饰普通方法）。</p><blockquote><p>那么为什么在Comparator接口中有两个”抽象方法“呢</p><p>我们实现接口的时候发现 只需要实现compare接口就可以了</p><p>实际上，接口完全有可能重新声明Object类的方法，如toString或clone，这些声明有可能会让方法<strong>不再是抽象的</strong>。（java API中的一些接口会重新声明Object方法来附加javadoc注释。Comparator API就是这样一个例子）</p><p><img src="https://blog.chasingwind.top/Aok8ld.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Aok8ld.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>函数式接口可以使用注解<code>@FunctionalInterface</code>来进行检查当前接口是否是函数式接口</p></li><li><p>Java内置函数式接口</p><ol><li><p>消费型接口</p><blockquote><p>接收一个参数，无返回值</p><p><img src="https://blog.chasingwind.top/LHsznO.png" class="lazyload" data-srcset="https://blog.chasingwind.top/LHsznO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>供给型接口</p><blockquote><p>无参数 有返回值</p><p><img src="https://blog.chasingwind.top/dQTX5F.png" class="lazyload" data-srcset="https://blog.chasingwind.top/dQTX5F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>函数型接口</p><blockquote><p>有参数  有返回值</p><p><img src="https://blog.chasingwind.top/Y14ckf.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Y14ckf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>断言型接口</p><blockquote><p>对参数进行判断  返回布尔类型</p><p><img src="https://blog.chasingwind.top/ZUSJhU.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ZUSJhU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>以上接口还有许多子接口，可以根据需要进行调用</p></li></ol></li></ul><h1 id="方法引用和构造器引用（了解）"><a href="#方法引用和构造器引用（了解）" class="headerlink" title="方法引用和构造器引用（了解）"></a>方法引用和构造器引用（了解）</h1><ul><li>我觉得这种代码可阅读性太差了 了解就好了</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol><li><p>什么是方法引用</p><ul><li>若Lambda体中的内容已经有方法已经实现了，那么我们直接进行引用而不需要重新实现。可以理解为Lambda表达式的另一种表现形式</li></ul></li><li><p>方法引用的语法格式</p><ol><li><p><code>对象::实例方法名</code></p><blockquote><p><img src="https://blog.chasingwind.top/N2PsEZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/N2PsEZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>println方法的参数和返回值</p><p><img src="https://blog.chasingwind.top/sFpI9V.png" class="lazyload" data-srcset="https://blog.chasingwind.top/sFpI9V.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Consumer接口中方法的参数和返回值</p><p><img src="https://blog.chasingwind.top/bOluGQ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/bOluGQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>类::静态方法名</code></p><blockquote><p><img src="https://blog.chasingwind.top/qn36dN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qn36dN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Comparator接口</p><p><img src="https://blog.chasingwind.top/TZHbp4.png" class="lazyload" data-srcset="https://blog.chasingwind.top/TZHbp4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Integer类中的compare静态方法</p><p><img src="https://blog.chasingwind.top/D2R5N3.png" class="lazyload" data-srcset="https://blog.chasingwind.top/D2R5N3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>类::实例方法名</code></p><blockquote><p><img src="https://blog.chasingwind.top/K7oEWB.png" class="lazyload" data-srcset="https://blog.chasingwind.top/K7oEWB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这种形式算是一种特例，当Lambda表达式中第一个参数作为方法的调用方，第二个参数作为方法的参数列表的时候，就可以使用<code>类::实例方法名</code>实现方法的引用</p></blockquote></li></ol></li><li><p>注意事项</p><ol><li>方法的参数列表和返回值需要与接口中方法的参数参数列表和返回值一致</li><li>当Lambda表达式中第一个参数作为方法的调用方，第二个参数作为方法的参数列表的时候，就可以使用<code>类::实例方法名</code>实现方法的引用</li></ol></li></ol><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><ol><li><p>语法格式：<code>类名::new</code></p></li><li><p>使用</p><blockquote><p><img src="https://blog.chasingwind.top/Mmrehw.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Mmrehw.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在Employee类中  既有无参构造器  又有多个参数的构造器  那么，使用构造器引用的时候使用的是哪一个构造方法呢</p><p><img src="https://blog.chasingwind.top/IR47A5.png" class="lazyload" data-srcset="https://blog.chasingwind.top/IR47A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>其实，使用的构造器的参数列表需要和接口中方法的参数列表一致</p><p>Supplier接口中的方法</p><p><img src="https://blog.chasingwind.top/RWxlgb.png" class="lazyload" data-srcset="https://blog.chasingwind.top/RWxlgb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以上述的构造器引用使用的是无参构造</p></blockquote><blockquote><p>调用有参数的构造器</p><p><img src="https://blog.chasingwind.top/JDvBYT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/JDvBYT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这次使用的构造器引用使用的就是有一个参数的构造</p><p><img src="https://blog.chasingwind.top/YfQaKv.png" class="lazyload" data-srcset="https://blog.chasingwind.top/YfQaKv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>因为Function接口中的方法就是</p><p><img src="https://blog.chasingwind.top/CtyiY2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CtyiY2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><ul><li><p>什么是Stream</p><blockquote><p>Stream称为流，它是数据渠道，用于操作数据源（集合、数组等等）所生成的元素序列。集合讲的是数据，流讲的是计算。</p><p>而Java8中的Stream，用来对集合进行操作，产生一个新的流，并且<strong>数据源（数组，列表等等）不会发生任何变化，而是产生一个新的流。</strong></p><p><img src="https://blog.chasingwind.top/DTQi4B.png" class="lazyload" data-srcset="https://blog.chasingwind.top/DTQi4B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Stream的特点</p><ol><li>Stream自己不会存储元素</li><li>Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</li><li>Stream操作是<strong>延迟执行</strong>的，也就是说他们会等到需要结果的时候才会执行。</li></ol></li><li><p>Stream操作的3个步骤</p><ol><li>创建Stream：通过数据源（集合、数组等等）获取流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作：一个终止操作，执行中间操作链，并产生结果</li></ol></li></ul><h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><ul><li><p>常见的创建流的方法</p><blockquote><p>可以通过集合、数组以及流提供的方法获取</p><p><img src="https://blog.chasingwind.top/1vvgVP.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1vvgVP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><ul><li>多个中间操作可以连接起来形成一个流水线，除非流水线触发终止操作，否则中间操作不会执行任何的处理，而<strong>在终止操作时一次性全部处理</strong>，称为惰性求值。</li></ul><ol><li><p>筛选与切片</p><ul><li><p>filter：接收Lambda，从流中排除某些元素</p><blockquote><p><img src="https://blog.chasingwind.top/iaWyBX.png" class="lazyload" data-srcset="https://blog.chasingwind.top/iaWyBX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/fPtPLi.png" class="lazyload" data-srcset="https://blog.chasingwind.top/fPtPLi.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们没有执行终止操作的时候  stream是不会执行的</p><p><img src="https://blog.chasingwind.top/hhH6S6.png" class="lazyload" data-srcset="https://blog.chasingwind.top/hhH6S6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>还可以发现 stream会对list进行内部迭代</p><p><img src="https://blog.chasingwind.top/CHZQoN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/CHZQoN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>limit：截断流，使其元素不超过给定数量</p><blockquote><p><img src="https://blog.chasingwind.top/gpMGE2.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gpMGE2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>limit短路效果  当stream找到满足条件的数据之后，就不再继续执行，可以提高效率</p><p><img src="https://blog.chasingwind.top/AiNlIf.png" class="lazyload" data-srcset="https://blog.chasingwind.top/AiNlIf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>skip(n)：跳过元素，返回一个去除前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补</p><blockquote><p><img src="https://blog.chasingwind.top/0XfD5K.png" class="lazyload" data-srcset="https://blog.chasingwind.top/0XfD5K.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>distinct：筛选流中的元素，根据流所生成元素的hashCode()和equals()去除重复元素</p><blockquote><p>使用之前，必须重写元素的hashCode()和equals()</p><p><img src="https://blog.chasingwind.top/ilIKrr.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ilIKrr.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>映射</p><ul><li><p>map：接收Lambda，将元素转换成其他形式或提取信息。接收一个方法作为参数，该方法会被应用到每个元素上，并将其映射成一个新的元素。</p><blockquote><p>map方法的参数是一个Function函数型接口</p><p><img src="https://blog.chasingwind.top/Df617E.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Df617E.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/NaVmY8.png" class="lazyload" data-srcset="https://blog.chasingwind.top/NaVmY8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/x985Xn.png" class="lazyload" data-srcset="https://blog.chasingwind.top/x985Xn.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</p><blockquote><p><img src="https://blog.chasingwind.top/IL90MX.png" class="lazyload" data-srcset="https://blog.chasingwind.top/IL90MX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里在执行终止操作的时候其实生成了多个流，<img src="https://blog.chasingwind.top/oqjClH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/oqjClH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用flatMap，将多个流串联成一个流</p><p>也就是说，使用flatMap后生成一个流{a,a,a,s,s,s,s,…..}</p><p><img src="https://blog.chasingwind.top/8ii2JZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/8ii2JZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>map和flatMap类比add和addAll</p><p><img src="https://blog.chasingwind.top/LmORyl.png" class="lazyload" data-srcset="https://blog.chasingwind.top/LmORyl.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>排序</p><ul><li><p>sorted()：自然排序（使用Comparable接口中的compareTo方法进行排序）</p><blockquote><p>比如String，其中就实现了Comparable接口，重写了其中的CompareTo方法</p><p><img src="https://blog.chasingwind.top/6Px0fz.png" class="lazyload" data-srcset="https://blog.chasingwind.top/6Px0fz.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/Qp2VPR.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Qp2VPR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>sorted(Comparator com)：自定义排序（使用自定义的Comparator进行排序）</p><blockquote><p><img src="https://blog.chasingwind.top/rcLqCk.png" class="lazyload" data-srcset="https://blog.chasingwind.top/rcLqCk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><ul><li>终止操作会从流的流水线生成结果，其结果可以是任何不是流的值。例如：List、Integer，甚至是void。</li></ul><ol><li><p>查找与匹配</p><ul><li><p>allMatch：检查经过中间操作的结果集中的元素是否都满足</p><blockquote><p><img src="https://blog.chasingwind.top/n9Yn4C.png" class="lazyload" data-srcset="https://blog.chasingwind.top/n9Yn4C.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>anyMatch：检查经过中间操作的结果集中的元素是否至少有一个满足</p><blockquote><p><img src="https://blog.chasingwind.top/G7jwDq.png" class="lazyload" data-srcset="https://blog.chasingwind.top/G7jwDq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>noneMatch：检查经过中间操作的结果集中的元素一个都不满足</p><blockquote><p><img src="https://blog.chasingwind.top/SctjDX.png" class="lazyload" data-srcset="https://blog.chasingwind.top/SctjDX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>findFirst：返回经过中间操作的结果集中的第一个元素</p><blockquote><p><img src="https://blog.chasingwind.top/nA8IFh.png" class="lazyload" data-srcset="https://blog.chasingwind.top/nA8IFh.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>返回的是Optional，是一个容器类，是Java8为了解决空指针异常设置的类。</p><p>在这里findFirst可能存在为空的情况，所以将结果放到容器Optional中</p></blockquote></li><li><p>findAny：返回经过中间操作的结果集中的任意元素</p><blockquote><p><img src="https://blog.chasingwind.top/qfiohj.png" class="lazyload" data-srcset="https://blog.chasingwind.top/qfiohj.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>count：返回经过中间操作的结果集中的元素总个数</p><blockquote><p><img src="https://blog.chasingwind.top/ebihrM.png" class="lazyload" data-srcset="https://blog.chasingwind.top/ebihrM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>max：返回经过中间操作的结果集中的元素最大值</p><blockquote><p><img src="https://blog.chasingwind.top/gbqd4G.png" class="lazyload" data-srcset="https://blog.chasingwind.top/gbqd4G.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>min：返回经过中间操作的结果集中的元素最小值</p><blockquote><p><img src="https://blog.chasingwind.top/PKKUSU.png" class="lazyload" data-srcset="https://blog.chasingwind.top/PKKUSU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>forEach：内部迭代</p></li></ul></li><li><p>归约</p><ul><li><p>reduce：将流中元素反复结合起来，得到一个值。</p><blockquote><p>使用归约进行累加操作</p><p><img src="https://blog.chasingwind.top/lw67yE.png" class="lazyload" data-srcset="https://blog.chasingwind.top/lw67yE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上图中，使用的接口</p><p><img src="https://blog.chasingwind.top/EP8uKZ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/EP8uKZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>运行过程是这样的，第一次在二元运算中，x是初始值0，y是asList中的元素1，运行一次后x为1，y为asList中的元素2……..直到最后累加完成</p><hr><p>计算所有员工的工资总和</p><p>Map-reduce模型：先从所有的数据中获取值，然后进行归约操作</p><p><img src="https://blog.chasingwind.top/57jzLo.png" class="lazyload" data-srcset="https://blog.chasingwind.top/57jzLo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>而这次返回值是Optional，上面的返回值是Integer。因为在计算工资的时候，可能存在所有的员工都没有值的情况，所以结果有可能为空。但是在上面计算加和的时候，是有初始值0的，所以最终的结果不可能为空。</p></blockquote></li></ul></li><li><p>收集</p><ul><li><p>collection：将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。</p><blockquote><p>collection中的参数是Collector接口，其中的方法实现决定了我们究竟对流执行什么样的收集操作（如收集到List、Set、Map），同时Collectors为我们提供了静态方法，方便我们创建常见的收集器实例</p><p><img src="https://blog.chasingwind.top/coLc71.png" class="lazyload" data-srcset="https://blog.chasingwind.top/coLc71.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>转换为List</p><p><img src="https://blog.chasingwind.top/bzAv1M.png" class="lazyload" data-srcset="https://blog.chasingwind.top/bzAv1M.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>转换为HashSet</p><p><img src="https://blog.chasingwind.top/62dtMf.png" class="lazyload" data-srcset="https://blog.chasingwind.top/62dtMf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>对收集的元素进行<strong>汇总</strong>操作</p><p><img src="https://blog.chasingwind.top/J1xOBs.png" class="lazyload" data-srcset="https://blog.chasingwind.top/J1xOBs.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>对元素进行<strong>分组</strong>操作</p><p><img src="https://blog.chasingwind.top/TKeXeK.png" class="lazyload" data-srcset="https://blog.chasingwind.top/TKeXeK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>多级分组</p><p><img src="https://blog.chasingwind.top/JNVqWN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/JNVqWN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><strong>分区</strong></p><p>满足条件的分在一个区，不满足条件的分在一个区。</p><p><img src="https://blog.chasingwind.top/MNvTLR.png" class="lazyload" data-srcset="https://blog.chasingwind.top/MNvTLR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>对结果进行分析，形成一个对象，对象中包含之前我们介绍的汇总的方法</p><p><img src="https://blog.chasingwind.top/eDdoyT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/eDdoyT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>将结果连接</p><p><img src="https://blog.chasingwind.top/dVpc9k.png" class="lazyload" data-srcset="https://blog.chasingwind.top/dVpc9k.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="并行流和串行流"><a href="#并行流和串行流" class="headerlink" title="并行流和串行流"></a>并行流和串行流</h2><ul><li>在Java8中对于并行的处理效率高了很多，更加充分利用了CPU的效率</li><li><a href="https://blog.csdn.net/YCJ_xiyang/article/details/83652954">参考文章</a></li></ul><h1 id="接口中的默认方法和静态方法"><a href="#接口中的默认方法和静态方法" class="headerlink" title="接口中的默认方法和静态方法"></a>接口中的默认方法和静态方法</h1><ul><li>在Java8中的接口中，可以拥有实现的方法，称为默认方法（default修饰）。</li><li>除了默认方法，还可以有静态方法。</li></ul><h1 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h1><ul><li><p>以前的时间日期API是线程不安全的，而新的时间日期API是线程安全的。</p></li><li><p>新时间日期API中常用的方法</p><ol><li><p>LocalDate、LocalTime、LocalDateTime</p><blockquote><p>这三个类的实例是不可变对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</p><p>这三个类的使用方法类似</p><p>往后推日期</p><p><img src="https://blog.chasingwind.top/J1HPkY.png" class="lazyload" data-srcset="https://blog.chasingwind.top/J1HPkY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>往前推日期</p><p><img src="https://blog.chasingwind.top/OkFzUj.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OkFzUj.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>获取日期和时间</p><p><img src="https://blog.chasingwind.top/3BPYyD.png" class="lazyload" data-srcset="https://blog.chasingwind.top/3BPYyD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Instant：时间戳（以Unix元年：1970年1月1日 00：00：00之间的毫秒值）</p><blockquote><p><img src="https://blog.chasingwind.top/OcTuoL.png" class="lazyload" data-srcset="https://blog.chasingwind.top/OcTuoL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Duration、Period</p><blockquote><p>Duration：计算两个时间之间的间隔</p><p><img src="https://blog.chasingwind.top/XahR0I.png" class="lazyload" data-srcset="https://blog.chasingwind.top/XahR0I.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/g4WhGH.png" class="lazyload" data-srcset="https://blog.chasingwind.top/g4WhGH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Period：计算两个日期之间的间隔</p><p><img src="https://blog.chasingwind.top/VMblqo.png" class="lazyload" data-srcset="https://blog.chasingwind.top/VMblqo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>时间校正器</p><blockquote><p><img src="https://blog.chasingwind.top/zkm4HT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/zkm4HT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用withXxx()方法进行日期的修改操作</p><p><img src="https://blog.chasingwind.top/j68seT.png" class="lazyload" data-srcset="https://blog.chasingwind.top/j68seT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用时间校正器类进行日期的修改操作</p><p>with方法可以传入一个时间校正器<code>TemporalAdjuster</code>的实例，而<code>TemporalAdjusters</code>则为我们提供了更加快捷的方式创建实例。</p><p><img src="https://blog.chasingwind.top/dlSlBI.png" class="lazyload" data-srcset="https://blog.chasingwind.top/dlSlBI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/bj1dRW.png" class="lazyload" data-srcset="https://blog.chasingwind.top/bj1dRW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>时间日期格式化</p><blockquote><p>DateTimeFormatter</p><p><img src="https://blog.chasingwind.top/EbNE1P.png" class="lazyload" data-srcset="https://blog.chasingwind.top/EbNE1P.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/4WtTfN.png" class="lazyload" data-srcset="https://blog.chasingwind.top/4WtTfN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Generator工具的使用</title>
      <link href="2020/07/16/MyBatis-Generator%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2020/07/16/MyBatis-Generator%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>工欲善其事必先利其器，善于使用工具可以大大提高工作效率，再现今社会效率就是王道。事情都是怎么简单怎么做，偷懒使社会进步。一些琐碎的事情，能交给工作去做就使用工具做，只有从琐碎的重复的劳动中摆脱出来，才能有时间专注其他，才能更好的思考业务，更好的做设计，才能提高代码质量，做出好的产品！</p><a id="more"></a><h2 id="MyBatis-Generator插件简介"><a href="#MyBatis-Generator插件简介" class="headerlink" title="MyBatis-Generator插件简介"></a>MyBatis-Generator插件简介</h2><ul><li>为什么会使用到这个插件？<ol><li>可以根据配置帮我们生成简单的PO类，能生成mapper映射文件（其中包括基本的增删改查功能）、能生成mapper接口。</li><li>在工作中遇到的使用Example类来实现的动态SQL查询，其中使用的就是通过插件生成的xxExample类</li></ol></li></ul><h2 id="MYBatis-Generator插件在IDEA中的配置"><a href="#MYBatis-Generator插件在IDEA中的配置" class="headerlink" title="MYBatis-Generator插件在IDEA中的配置"></a>MYBatis-Generator插件在IDEA中的配置</h2><ol><li><p>首先，在项目的pom.xml配置文件中添加MyBatis-Generator插件</p><pre><code class="xml">&lt;plugins&gt;            &lt;!-- mybatis代码生成插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置--&gt;                    &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                        &lt;version&gt;1.3.2&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;</code></pre></li><li><p>根据pom.xml文件中配置的配置文件的位置以及文件名生成配置文件</p><ul><li><code>&quot;https://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</code>报红的话，可以先不用管，后面把配置文件中的配置完成后，就可以使用插件了</li><li>建议把这个配置文件生成IDEA模板，方便以后在新的项目中使用</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--mysql 连接数据库jar 这里选择自己本地位置;    如果不知道maven本地仓库地址，可以使用EveryThing工具全局搜索mysql-connector-java，找到jar包位置；    也可以手动下载一个jar放在指定位置，进行引用。    --&gt;    &lt;classPathEntry location=&quot;/usr/local/maven_repo/mysql/mysql-connector-java/8.0.19/mysql-connector-java-8.0.19.jar&quot;/&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释,true：是,false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://116.62.48.203:3306/forest_blog&quot;                        userId=&quot;root&quot;                        password=&quot;xxxxxxx&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和           NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- 指定javaBean生成的位置            targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；            targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录         --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.liuyanzhao.ssm.blog.dto&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false；如果多个数据库改为true分目录 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!--  指定mapper映射文件生成的位置           targetPackage、targetProject同javaModelGenerator中作用一样--&gt;        &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 指定mapper接口生成的位置         targetPackage、targetProject同javaModelGenerator中作用一样         --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.liuyanzhao.ssm.blog.mapper&quot;                             targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表        domainObjectName：生成的domain类的名字,当表名和domain类的名字有差异时一定要设置，如果不设置，直接使用表名作为domain类的名字；        可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；        --&gt;        &lt;table tableName=&quot;link&quot; domainObjectName=&quot;LinkDetailDto&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>使用Maven运行插件</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200716142858962.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200716142858962.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看生成的实体类，Mapper接口以及映射文件</p><ul><li><p>实体类</p><blockquote><p>查看实体类 其中各个属性就是数据库中对应表的字段，以及对应的getter和setter方法</p><p><img src="https://blog.chasingwind.top/image-20200716143008397.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200716143008397.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>xxxExample类</p><blockquote><p>Example类包含一个内部静态类 Criteria，利用Criteria我们可以在类中根据自己的需求动态生成sql where字句，不用我们自己再修改mapper文件添加或者修改sql语句了，能节省很多写sql的时间。</p><p>其中方法包括对各个属性的sql的基础操作，我们可以按照需要使用</p><p><img src="https://blog.chasingwind.top/image-20200716143617489.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200716143617489.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Mapper接口</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200716143746101.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200716143746101.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>映射文件</p><blockquote><p>其中包括基础的增删改查的操作</p><p><img src="https://blog.chasingwind.top/image-20200716144151254.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200716144151254.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="Example类的使用"><a href="#Example类的使用" class="headerlink" title="Example类的使用"></a>Example类的使用</h2><ul><li><p>Example类可以帮我们实现简单的查询的操作，而不需要去创建对应的Mapper以及映射文件，省去了很多麻烦</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200716145723404.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200716145723404.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 代码生成工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构介绍</title>
      <link href="2020/07/14/MySQL%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/07/14/MySQL%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h2><ul><li><p>我的服务器上是通过RPM的方式安装的MySQl，配置文件是在<code>/etc</code>目录下的<code>my.cnf</code>文件</p><ul><li><p>二进制日志log-bin：主要用于记录主从日志</p></li><li><p>错误日志log-err：默认关闭，记录严重的警告和错误信息，每次启动和关闭的详细信息等</p></li><li><p>查询日志log：默认关闭，记录查询的sql语句，如果开启会降低MySQL的整体性能，因为记录日志也是需要消耗系统资源的</p><blockquote><p><img src="https://blog.chasingwind.top/bABtQo.png" class="lazyload" data-srcset="https://blog.chasingwind.top/bABtQo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>数据文件：数据库所在的位置</p><blockquote><p><img src="https://blog.chasingwind.top/Vpyy0q.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Vpyy0q.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>进入到对应的数据库中</p><p><img src="https://blog.chasingwind.top/oIhKn1.png" class="lazyload" data-srcset="https://blog.chasingwind.top/oIhKn1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>frm文件:</code>存放当前表的表结构</p><p><code>myd文件</code>：当前表的数据</p><p><code>myi文件</code>：当前表的索引</p></blockquote></li></ul></li></ul><h2 id="MySQL逻辑架构介绍"><a href="#MySQL逻辑架构介绍" class="headerlink" title="MySQL逻辑架构介绍"></a>MySQL逻辑架构介绍</h2><ul><li><p>MySQL分层设计</p><blockquote><p><img src="https://blog.chasingwind.top/bVj8fJ.png" class="lazyload" data-srcset="https://blog.chasingwind.top/bVj8fJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><ol><li><p>连接层</p><p>最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层</p><p><img src="https://blog.chasingwind.top/c9ZnkG.png" class="lazyload" data-srcset="https://blog.chasingwind.top/c9ZnkG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>引擎层</p><p>存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p></li><li><p>存储层</p><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p></li></ol></blockquote></li><li><p>优点：插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。<strong>这种架构可以根据业务的需求实际的需要选择合适的存储引擎</strong>。</p></li></ul><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><ul><li><p>比较常用的两个分别是MYISAM，InnoDB。</p></li><li><p>使用 <code>show engines;</code>命令可以查看支持的引擎类型</p><blockquote><p>默认使用的是InnoDB</p><p><img src="https://blog.chasingwind.top/5RGgOa.png" class="lazyload" data-srcset="https://blog.chasingwind.top/5RGgOa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用<code>show variables like &quot;%storage_engine%&quot;;</code>可以查看当前是数据库使用的引擎</p><blockquote><p><img src="https://blog.chasingwind.top/Nr5RsX.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Nr5RsX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>MyISAM和InnoDB的对比</p><blockquote><p><img src="https://blog.chasingwind.top/tVEnu3.png" class="lazyload" data-srcset="https://blog.chasingwind.top/tVEnu3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL架构 </tag>
            
            <tag> MySQL高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot与Web开发</title>
      <link href="2020/07/03/SpringBoot%E4%B8%8EWeb%E5%BC%80%E5%8F%91/"/>
      <url>2020/07/03/SpringBoot%E4%B8%8EWeb%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>本节介绍了SpringBoot开发Web的流程，使用模板引擎来开发前端页面，动态展示后台返回的数据，再次加深SpringMVC自动配置和扩展，理解SpringBoot默认配置的思想，掌握SpringBoot的错误处理机制，以及配置嵌入式的Servlet容器等等。</p><a id="more"></a><h1 id="使用SpringBoot开发Web的流程"><a href="#使用SpringBoot开发Web的流程" class="headerlink" title="使用SpringBoot开发Web的流程"></a>使用SpringBoot开发Web的流程</h1><ol><li>创建SpringBoot应用，选择我们需要使用到的模块</li><li>SpringBoot已经帮我们完成了许多默认的配置，我们只需要修改一小部分就可以使用了</li><li>编写自己的业务代码</li></ol><h1 id="SpringBoot对静态资源的映射规则"><a href="#SpringBoot对静态资源的映射规则" class="headerlink" title="SpringBoot对静态资源的映射规则"></a>SpringBoot对静态资源的映射规则</h1><ol><li><p>以前在使用SpringMVC框架的时候，<strong>静态资源</strong>是放在src/main/web-app目录下的，然后配置视图解析器，对方法的返回值进行解析，返回对应的视图</p><blockquote><p>SpringMVC中的静态文件存储的路径</p><p><img src="https://blog.chasingwind.top/image-20200601105820635.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601105820635.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>但是在SpringBoot中的web项目中并没有这个目录</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200601110257375.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601110257375.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>那么SpringBoot是怎样将静态资源映射到SpringMVC中的呢？</p></blockquote></li><li><p>查看SpringMVC的自动配置类，当浏览器访问路径是<code>/webjars/**</code></p><blockquote><p><img src="https://blog.chasingwind.top/image-20200601115106291.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601115106291.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>红框中表示的意思就是</p><p>所有/webjars/下面的请求，都在都去 classpath:/META-INF/resources/webjars/ 找资源</p><hr><p><a href="https://www.webjars.org/">webjars</a>：以jar包的方式引入静态资源，而不是像以前我们把静态资源文件自己导入到web-app目录下</p><p><img src="https://blog.chasingwind.top/image-20200601115509484.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601115509484.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>而且导入这些jar包，可以通过使用Maven依赖的方式</p><p>比如，我们导入jquery</p><p><img src="https://blog.chasingwind.top/image-20200601132847304.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601132847304.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对比这个目录和前面的SpringMVC找<strong>资源的路径</strong>是一致的</p><p>那么 <strong>请求的路径</strong>就应该是（这里以请求jquery.js文件为例）</p><p><img src="https://blog.chasingwind.top/image-20200601133326149.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601133326149.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>同时，还可以在配置文件中设置和静态资源有关的参数</p><p><img src="https://blog.chasingwind.top/image-20200601134123372.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601134123372.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看SpringMVC的自动配置类，当浏览器访问路径是<code>/**</code></p><blockquote><p><img src="https://blog.chasingwind.top/image-20200601134507442.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601134507442.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>进入到这个方法中</p><p><img src="https://blog.chasingwind.top/image-20200601134526015.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601134526015.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看staticPathPattern，得知访问路径是<code>/**</code></p><p><img src="https://blog.chasingwind.top/image-20200601134545134.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601134545134.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><pre><code class="java">/** 表示访问当前项目的任何资源，如果没有其他的处理器（比如上面的webjars会处理 /webjar/** ）处理，就去图中的位置找资源</code></pre><p><img src="https://blog.chasingwind.top/image-20200601135006349.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601135006349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>进入<code>getResourceLocations(this.resourceProperties.getStaticLocations())</code>方法中，这个方法就是获取资源路径的</p><p>查看其中的参数  最终看到的路径是</p><p><img src="https://blog.chasingwind.top/image-20200601140155784.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601140155784.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>另外还有一个是当前项目的根路径<code>/</code></p><p>classpath：类路径，包括main下面的java和resources目录</p><p>所以，可以保存静态资源的目录如下图</p><p><img src="https://blog.chasingwind.top/image-20200601140617682.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601140617682.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>上面的几个文件夹就是静态资源文件夹，表示，你访问的静态资源的路径如果没有人处理的话，就会去这些路径下找这些静态资源</p><p>比如，静态资源的路径</p><p><img src="https://blog.chasingwind.top/image-20200601140956464.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601140956464.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>访问路径localhost:/xxx 就会去静态资源文件夹中找xxx</p><p><img src="https://blog.chasingwind.top/image-20200601140930769.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601140930769.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置欢迎页映射</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200601142017495.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601142017495.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>欢迎页默认的文件名是index.html，在静态资源目录下</p></blockquote></li><li><p>在配置文件中也可以指定我们自己定义的静态文件存放的目录</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200601142926928.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601142926928.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样配置之后，那么SpringBoot中默认的配置的静态资源的路径就失效了</p></blockquote></li></ol><h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><p>上面的介绍都是<strong>请求的静态资源</strong>，不方便后面展示数据（不像JSP，可以对查出来的数据进行遍历展示），但是SpringBoot默认是jar包的打包方式并且使用的嵌入式的Tomcat，所以默认不支持JSP，这就有了模板引擎。</p><ol><li><p>模板引擎简介</p><blockquote><p>常见的模板引擎</p><p>JSP、Velocity、Freemarker、Thymeleaf</p><hr><p>模板引擎的原理</p><p>解析模板中的表达式，将数据填充进去，生成一个最终的文件</p><p><img src="https://blog.chasingwind.top/image-20200601143851506.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601143851506.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Thymeleaf模板引擎</p><ul><li><p>SpringBoot推荐的Thymeleaf；语法更简单，功能更强大；</p></li><li><p>使用Thymelaf</p><ol><li><p>引入依赖</p><blockquote><pre><code class="xml">&lt;!--引入模板引擎Thymeleaf--&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;     &lt;/dependency&gt;</code></pre></blockquote></li><li><p>Thymeleaf如何使用</p><ol><li><p>查看SpringBoot自动配置类中的关于Thymeleaf的类</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200601160803944.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601160803944.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200601160820313.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601160820313.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置类</p><p><img src="https://blog.chasingwind.top/image-20200601160844585.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601160844585.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>表示的意思就是</p><p><strong>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</strong></p><p><img src="https://blog.chasingwind.top/image-20200603143143045.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603143143045.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ul><ol start="2"><li><p>Thymeleaf入门<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">官方文档</a></p><ol><li><p>在HTML页面中引入Thymeleaf的命名空间</p><blockquote><p><code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;https://www.thymeleaf.org&quot;&gt;</code></p></blockquote></li><li><p>演示</p><blockquote><p>Controller层</p><p><img src="https://blog.chasingwind.top/image-20200601161920558.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601161920558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>加入Thymeleaf组件之后，return不再去static静态资源目录下找对应的页面了</p><p>而是去templates目录下找对应的页面</p><hr><p>success.html页面需要放在templates目录下</p><p><img src="https://blog.chasingwind.top/image-20200601162009913.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601162009913.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>th:text</code>的作用是将标签中的内容设置为表达式中的内容</p><hr><p>访问页面  获取到数据了</p><p><img src="https://blog.chasingwind.top/image-20200601162139954.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601162139954.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>Thymeleaf的语法规则</p><ol><li><p>th:html的任意属性，用来替换原生属性的值</p><blockquote><p>比如</p><p><img src="https://blog.chasingwind.top/image-20200601162731101.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601162731101.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>那么我们访问的额页面中的各个属性就是Thymeleaf替换过后的值</p><p><img src="https://blog.chasingwind.top/image-20200601162900572.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601162900572.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>常用的属性有<br><img src="https://blog.chasingwind.top/image-20200601163654161.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601163654161.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>表达式语法</p><ol><li><p><code>$&#123;...&#125;</code>：获取变量值，支持OGNL表达式</p><ol><li><p>获取对象的属性、调用方法</p></li><li><p>使用内置的基本对象：</p><blockquote><p><code>ctx</code> : the context object.<br><code>vars</code>: the context variables.<br><code>locale</code> : the context locale.<br><code>request</code> : (only in Web Contexts) the HttpServletRequest object.<br><code>response</code> : (only in Web Contexts) the HttpServletResponse object.<br><code>session </code>: (only in Web Contexts) the HttpSession object.<br>servletContext : (only in Web Contexts) the ServletContext object.</p><hr><p>使用示例：$(seeeion.id)</p></blockquote></li><li><p>内置的一些工具对象</p><blockquote><p><code>execInfo</code> : information about the template being processed.<br><code>messages</code> : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.<br><code>uris</code> : methods for escaping parts of URLs/URIs<br><code>conversions</code> : methods for executing the configured conversion service (if any).<br><code>dates</code> : methods for java.util.Date objects: formatting, component extraction, etc.<br><code>calendars </code>: analogous to #dates , but for java.util.Calendar objects.<br><code>numbers</code> : methods for formatting numeric objects.<br><code>strings</code> : methods for String objects: contains, startsWith, prepending/appending, etc.<br><code>objects </code>: methods for objects in general.<br><code>bools</code> : methods for boolean evaluation.<br><code>arrays</code> : methods for arrays.<br><code>lists </code>: methods for lists.<br><code>sets</code> : methods for sets.<br><code>maps</code> : methods for maps.<br><code>aggregates</code> : methods for creating aggregates on arrays or collections.<br><code>ids</code> : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</p></blockquote></li></ol></li><li><p><code>*&#123;...&#125;</code>：选择表达式：和<code>$&#123;...&#125;</code>在功能上是一样；</p><blockquote><p><code>*&#123;...&#125;</code>算是在<code>$&#123;...&#125;</code>功能的基础上进行的增强</p><p><img src="https://blog.chasingwind.top/image-20200601165942518.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601165942518.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>不使用<code>*&#123;...&#125;</code>的话 需要这样写</p><p><img src="https://blog.chasingwind.top/image-20200601170026604.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601170026604.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p> <code>@&#123;...&#125;</code>：定义URL；</p></li><li><p><code>~&#123;...&#125;</code>：片段引用表达式</p></li></ol></li></ol></li></ol><h1 id="SpringMVC自动配置以及扩展"><a href="#SpringMVC自动配置以及扩展" class="headerlink" title="SpringMVC自动配置以及扩展"></a>SpringMVC自动配置以及扩展</h1><p>SpringBoot中已经自动配置好了SpringMVC，我们可以直接使用，用法参考<a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/spring-boot-features.html#boot-features-developing-web-applications">官方文档</a></p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602153425121.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602153425121.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>SpringBoot对SpringMVC做的自动配置</p><p><img src="https://blog.chasingwind.top/image-20200602153657796.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602153657796.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h2 id="分析SpringBoot对SpringMVC的自动配置"><a href="#分析SpringBoot对SpringMVC的自动配置" class="headerlink" title="分析SpringBoot对SpringMVC的自动配置"></a>分析SpringBoot对SpringMVC的自动配置</h2><p>SpringBoot自动配置好了SpringMVC，以下是SpringBoot对SpringMVC的默认配置：</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602153657796.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602153657796.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>SpringMVC的自动配置类<code>WebMvcAutoConfiguration</code></p><p><img src="https://blog.chasingwind.top/image-20200602220359493.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602220359493.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>其实实现自动配置的功能是他的内部类<code>WebMvcAutoConfigurationAdapter</code>（自动配置适配器）中的方法实现的</p><p><img src="https://blog.chasingwind.top/image-20200602221827033.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602221827033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>根据官方文档进行分析</p><ol><li><p>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>。</p><ul><li><p>自动配置了ViewResolver（视图解析器），视图解析器的作用就是根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发或者重定向）</p><blockquote><p>可以看到自动配置类中<code>viewResolver</code>方法的返回值就是<code>ContentNegotiatingViewResolver</code>视图解析器对象，上面的注解<code>@Bean</code>将这个对象注入到容器中</p><p>这个方法是自动配置类的内部类中的方法</p><p><img src="https://blog.chasingwind.top/image-20200602220625720.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602220625720.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>那么<code>ContentNegotiatingViewResolver</code>视图解析器是如何解析视图的呢？</p><p><img src="https://blog.chasingwind.top/image-20200602155335107.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602155335107.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>先看第1步获取候选的视图对象的方法<code>getCandidateViews(viewName, locale, requestedMediaTypes)</code></p><p><img src="https://blog.chasingwind.top/image-20200602155557544.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602155557544.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以，<code>ContentNegotiatingViewResolver</code>的作用就是：<strong>组合所有的视图解析器的；</strong></p></blockquote><blockquote><p>回到自动配置类的内部类中，查看配置视图解析器的逻辑</p><p>首先，创建了一个视图解析器对象</p><p><img src="https://blog.chasingwind.top/image-20200602160407973.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602160407973.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看这个视图解析器类</p><p>其中用到了视图解析器，那么这些视图解析器是如何获取的呢</p><p><img src="https://blog.chasingwind.top/image-20200602160616298.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602160616298.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200602160837230.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602160837230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200602161016252.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602161016252.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>那么viewSolvers变量中存储的就是所有的视图解析器了</p></blockquote><blockquote><p>所以，如果我们自己需要定制视图解析器的话，<strong>我们就可以向容器中添加一个视图解析器，那么<code>ContentNegotiatingViewResolver</code>就会将这个视图解析器自动组合进来</strong></p><p>测试自己添加视图解析器</p><p><img src="https://blog.chasingwind.top/image-20200602161733759.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602161733759.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们发送的任何请求，都会先经过DispatcherServlet中的doDispatch方法中，在这个方法处打断点，查看DispatcherServlet中使用到的视图解析器是什么</p><p><img src="https://blog.chasingwind.top/image-20200602161859183.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602161859183.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Debug启动，使用浏览器发送一个请求</p><p>可以看到我么自定义的ViewResolver也被添加进去了</p><p><img src="https://blog.chasingwind.top/image-20200602162917435.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602162917435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>支持静态资源的访问，包括对Webjars的支持</p></li><li><p>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code>类。</p><ul><li><p>Converter：转换器，用于类型转换</p><blockquote><p>比如，我们的请求中携带的数据是一个对象的JSON数据，但是方法中是一个对象，那么如何将String类型的数据转换为一个对象呢？</p><p>这种场景就使用到了转换器，SpringBoot已经帮我们配置好了转换器</p></blockquote></li><li><p>Formatter：格式化器</p><blockquote><p>页面带来的数据转换为对应的格式，比如需要将请求中的2020.06.02转换为2020/06/02的形式。</p><p>这里涉及到两步，首先需要对类型进行转换，然后再对格式进行转换。</p></blockquote></li><li><p>对于转换器和格式化器，如果需要自定义的话，我们只需要将其加入到容器中即可</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602165243865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602165243865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>支持<code>HttpMessageConverters</code></p><ul><li><p>消息转换器：用来转换SpringMVC中消息请求和响应的数据格式的，比如方法的返回值是一个对象，如何转换为JSON数据返回呢</p><blockquote><p>这个小的配置类中只有一个有参构造方法，所以这些参数都是从容器中获取的，其中<code>ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider</code>变量中存储的就是<code>HttpMessageConverters</code></p><p><img src="https://blog.chasingwind.top/image-20200602171737513.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602171737513.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看这个HttpMessageConverters</p><p><img src="https://blog.chasingwind.top/image-20200602171949555.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602171949555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200602172647059.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602172647059.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>也就是说，HttpMessageConverter是从容器中获取的</p></blockquote></li><li><p>如果我们需要自定义HttpMessageConverter，我们只需要将其加入到容器中即可</p><blockquote><p>官方文档中也是如此</p><p><img src="https://blog.chasingwind.top/image-20200602172957082.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602172957082.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>自动注册<code>MessageCodesResolver</code>：用于定义错误代码生成规则</p></li><li><p>自动使用<code>ConfigurableWebBindingInitializer</code>：用于初始化Web数据绑定器，比如将请求中的数据绑定到JavaBean，其中功能包括，格式转换以及格式化</p></li><li><p>以上只是SpringBoot对web中的MVC进行配置，我们可以到SpringBoot的自动配置类中查看对web模块的所有配置</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602174418843.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602174418843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>通过上面对于web中MVC模块的分析，我们可以得到一个修改SpringBoot中默认配置的模式</p><ul><li>SpringBoot在自动配置很多组件的时候，<strong>先看容器中有没有用户自己配置的</strong>（@Bean、@Component）<ul><li>如果有就用用户配置的，如果没有，才自动配置；</li><li>如果有些组件可以有多个（比如ViewResolver）将用户配置的和自己默认的<strong>组合起来</strong>；</li></ul></li></ul></li></ol><h2 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h2><ul><li><p>继续查看官方文档中的内容</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602200254012.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602200254012.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如果需要更多的功能，我们可以编写一个配置类（Configuration），是<code>WebMvcConfigurer</code>类型的，但是不添加<code>@EnableWebMvc</code>，通过这个方法对SpringMVC进行功能上的扩展，<strong>这样既保留了自动配置的功能，同时还可以使用我们扩展的功能</strong></p></blockquote></li><li><p>实现一个自定义的配置</p><ol><li><p>创建一个配置类，使用注解<code>@Configuration</code>表明当前类是一个配置类，同时这个类还需要是<code>WebMvcConfigurer</code>（接口）类型的</p><blockquote><p>由于Spring5.0之后（或者SpringBoot2.x）开始支持Java接口的默认实现，所以这里有些不一样的地方</p><hr><p>在更新之前</p><p>我们使用的是<code>WebMvcConfigurer</code>的抽象的实现类<code>WebMvcConfigurerAdapter</code></p><p><img src="https://blog.chasingwind.top/image-20200602201724843.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602201724843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们在自定义的配置类中就可以通过继承<code>WebMvcConfigurerAdapter</code>来实现我们需要的功能</p><p><img src="https://blog.chasingwind.top/image-20200602201850527.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602201850527.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>由于Java的版本更新，在Java 8中，可以使用<strong>default</strong>关键词为接口添加默认的方法，查看接口中的方法，其实是与上面的抽象类中的方法一样</p><p><img src="https://blog.chasingwind.top/image-20200602202305959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602202305959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在更新之后，可以直接实现<code>WebMvcConfigurer</code>这个接口</p><p><img src="https://blog.chasingwind.top/image-20200602201946679.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602201946679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>下面都以更新之后进行举例，其实大体上二者差别不大</p></blockquote></li><li><p>需要扩展什么功能，就实现什么方法</p><blockquote><p>比如这里我们扩展视图控制器</p><p>当我们请求/test的时候，也跳转到success页面</p><p><img src="https://blog.chasingwind.top/image-20200602203038835.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602203038835.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200602203015155.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602203015155.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>扩展实现的原理</p><ol><li><p><code>WebMvcAutoConfiguration</code>是WebMVC的自动配置类</p></li><li><p>在这个自动配置类中内部类<code>WebMvcAutoConfigurationAdapter</code>实现了<code>WebMvcConfigurer</code>这个接口，也就是上面我们自定义的配置类实现的接口。</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602205403018.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602205403018.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>顺便说一句话，我们之前的静态资源映射就是调用的这个内部类中的方法实现的</p><p><img src="https://blog.chasingwind.top/image-20200602205742797.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602205742797.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看上面的内部类的注解<code>@Import(EnableWebMvcConfiguration.class)</code>，也就是说在做自动配置的时候（包括SpringBoot的自动配置和我们自定义的配置），会导入<code>EnableWebMvcConfiguration</code>这个类</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602205925485.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602205925485.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看这个<code>EnableWebMvcConfiguration</code>类，又是一个自动配置类的内部类</p><p><img src="https://blog.chasingwind.top/image-20200602210035037.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602210035037.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看这个内部类的父类</p><p><code>@Autowired</code>作用在方法上表示方法的参数需要去容器中获取</p><p><img src="https://blog.chasingwind.top/image-20200602224035061.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602224035061.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这个方法表示将容器中所有的类型为<code>WebMvcConfigurer</code>的bean存储在这个列表中</p><p>然后调用的是<code>WebMvcConfigurerComposite</code>类中对应的方法</p><p><img src="https://blog.chasingwind.top/image-20200602224241886.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602224241886.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这些方法都是遍历容器中的所有的<code>WebMvcConfigurer</code>，然后调用每个<code>WebMvcConfigurer</code>里面对应的方法，从而让这些配置生效</p><p><img src="https://blog.chasingwind.top/image-20200602224601704.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602224601704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>比如说，我们有两个自定义的配置类都实现了<code>WebMvcConfigurer</code>接口，其中都有addViewControllers这个方法，那么上图中就会调用addViewControllers这个方法将我们定义的两个配置类中的方法生效。</p></blockquote></li><li><p>在SpringMVC的自动配置类中，也实现了<code>WebMvcConfigurer</code>这个接口，所以上面的<code>@Import(EnableWebMvcConfiguration.class)</code>不仅会把我们自定义的配置生效，同时自动配置也会生效</p></li><li><p>总的来说，就是SpringMVC自动配置和我们自定义的配置都会生效</p></li></ol></li></ul><h2 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h2><ul><li><p>在我们自定义的配置类上加上注解<code>@EnableWebMvc</code>，SpringMVC的自动配置全部失效，使用的都是我们自定义的配置</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602230221733.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602230221733.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>原理分析</p><ol><li><p>查看<code>@EnableWebMvc</code>这个注解</p><blockquote><p>导入了<code>DelegatingWebMvcConfiguration</code>这个类</p><p><img src="https://blog.chasingwind.top/image-20200602230625353.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602230625353.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>继承自<code>WebMvcConfigurationSupport</code></p><p><img src="https://blog.chasingwind.top/image-20200602230714773.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602230714773.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>再看自动配置类</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200602230843110.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200602230843110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>表示如果容器中没有<code>WebMvcConfigurationSupport</code>这个组件那么配置就生效</p><p>但是我们使用的<code>@EnableWebMvc</code>这个注解已经间接向容器中导入了这个组件，所以自动配置就失效了</p></blockquote></li><li><p>导入的<code>WebMvcConfigurationSupport</code>中包含了SpringMVC最基本的功能；</p></li></ol></li></ul><h1 id="修改SpringBoot默认配置的思想"><a href="#修改SpringBoot默认配置的思想" class="headerlink" title="修改SpringBoot默认配置的思想"></a>修改SpringBoot默认配置的思想</h1><ul><li>通过上面对于web中MVC模块的分析，我们可以得到一个修改SpringBoot中默认配置的模式<ol><li>SpringBoot在自动配置很多组件的时候，<strong>先看容器中有没有用户自己配置的</strong>（@Bean、@Component）<ul><li>如果有就用用户配置的，如果没有，才自动配置；</li><li>如果有些组件可以有多个（比如ViewResolver）将用户配置的和自己默认的<strong>组合起来</strong>；</li></ul></li><li>在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</li><li>在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</li></ol></li></ul><h1 id="Restful风格-CRUD练习"><a href="#Restful风格-CRUD练习" class="headerlink" title="Restful风格 CRUD练习"></a>Restful风格 CRUD练习</h1><h2 id="引入静态资源"><a href="#引入静态资源" class="headerlink" title="引入静态资源"></a>引入静态资源</h2><ol><li><p>引入资源</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200603151441721.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603151441721.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="> </p></blockquote></li><li><p>访问首页</p><blockquote><p>没有引入Thymeleaf依赖的时候<br><img src="https://blog.chasingwind.top/image-20200603153920357.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603153920357.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>引入Thymeleaf进来之后</p><p><img src="https://blog.chasingwind.top/image-20200603154101906.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603154101906.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用我们之前的扩展MVC的方式来实现页面的跳转</p><p><img src="https://blog.chasingwind.top/image-20200603155147574.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603155147574.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试 两个访问路径都可以访问到页面</p><p><img src="https://blog.chasingwind.top/image-20200603155327249.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603155327249.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>静态资源中的href和th:href，其他src也是同理</p><blockquote><p>比如：<code>&lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/sgin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;</code></p><p>在<strong>默认项目路径为空（ContextPath）时</strong>，打jar包单独运行时，二者效果一致。</p><p>在使用Maven内嵌Tomcat或打war包部署到Servlet容器（Tomcat服务器），或者在项目内执行App启动类，<strong>且有配置项目路径时</strong>。</p><p>二者区别如下：</p><p><strong>href始终从端口开始作为根路径</strong>，如<code>https://localhost:8080/asserts/css/signin.css</code></p><p><strong>th:href会寻找项目路径作为根路径</strong>，如<code>https://localhost:8080/自动添加项目路径/asserts/css/signin.css</code></p><p>不使用th:xxx的时候 虽然设置了contextPath，但是这个资源的路径还是使用的是相对路径</p><p><img src="https://blog.chasingwind.top/image-20200603194141208.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603194141208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>添加th:xxx之后 路径会自动带上contextPath</p><p><img src="https://blog.chasingwind.top/image-20200603201849202.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603201849202.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200603202220492.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603202220492.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="国际化配置"><a href="#国际化配置" class="headerlink" title="国际化配置"></a>国际化配置</h2><ul><li><p>国际化功能使页面显示的信息不仅可以通过浏览器的默认语言进行设置，还可以通过页面中的中英文进行切换</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200603222352775.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603222352775.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>SpringMVC中的国际化实现</p><ol><li>编写国际化配置文件</li><li>使用ResourceBundleMessageSource管理国际化资源文件</li><li>在jsp页面使用fmt:message取出国际化内容</li></ol></li><li><p>SpringBoot中的国际化实现（以登录页面为例）</p><ol><li><p>编写国际化配置文件，将页面中需要国际化显示的消息抽取出来</p><ol><li><p>创建properties配置文件，在resources目录下创建i18n目录，创建默认的配置文件<code>login.properties</code>中文配置文件<code>login_zh_CN.properties</code>和英文配置文件<code>login_en_US.properties</code></p><blockquote><p>创建默认的配置文件和中文的配置文件之后，IDEA会识别我们是在做国际化，会将目录生成用于配置国际化的设置</p><p><img src="https://blog.chasingwind.top/image-20200603223202106.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603223202106.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将<code>login.html</code>页面中需要国际化的消息抽取出来</p><blockquote><p>使用IDEA提供的Resource Bundle视图来配置不同语言的国际化消息</p><p><code>login.properties</code>是当没有指定语言的配置信息时，默认显示的</p><p><img src="https://blog.chasingwind.top/image-20200603223440400.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603223440400.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>抽取页面中的消息并进行配置</p><p><img src="https://blog.chasingwind.top/image-20200603231131752.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603231131752.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>查看SpringBoot为我们自动配置的处理国际化的自动配置类</p><ol><li><p>查看类<code>MessageSourceAutoConfiguration</code></p><blockquote><p>basename就是去除国家和语言的基础名</p><p><img src="https://blog.chasingwind.top/image-20200603232300783.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603232300783.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>进入配置类中可以发现basenamem默认是messages</p><p><img src="https://blog.chasingwind.top/image-20200603232347733.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603232347733.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>所以，其实我们的配置文件可以直接放在类路径下叫messages.properties；这样我们就可以在不需要做任何配置的情况下使用国际化功能了</p><hr><p>我们的配置文件放在/resources/i18n目录下了，可以通过配置来指定国际化配置</p><p><img src="https://blog.chasingwind.top/image-20200603232740054.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603232740054.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>在页面中设置国际化内容</p><blockquote><p>Thymeleaf中使用<code>#&#123;...&#125;</code>获取国际化内容</p><p><img src="https://blog.chasingwind.top/image-20200603233339471.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603233339471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行程序</p><blockquote><p>因为浏览器默认使用的语言是中文  可见 使用的并不是默认配置 而是中文语言的配置</p><p><img src="https://blog.chasingwind.top/image-20200603233436797.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603233436797.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>将浏览器的语言设置为英文  使用的就是英文国际化的配置</p><p><img src="https://blog.chasingwind.top/image-20200603234053523.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603234053523.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>通过页面中的按钮来实现国际化</p><blockquote><p>上面的效果是根据浏览器的语言信息来实现国际化的功能的，那么如何实现通过点击页面中<code>中文  English</code>来实现对应的国际化的显示呢</p><p><strong>实现原理</strong>：SpringMVC中的Locale（区域信息对象）中的LocaleResolver（区域信息解析器）</p><p>查看Mvc自动配置类中的LocaleResolver</p><p><img src="https://blog.chasingwind.top/image-20200603235509178.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603235509178.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看<code>AcceptHeaderLocaleResolver</code>类中处理区域信息解析器的方法，根据请求头中的<code>Accept-language</code>来获取国际化环境</p><p><img src="https://blog.chasingwind.top/image-20200603235746110.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603235746110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看请求头</p><p><img src="https://blog.chasingwind.top/image-20200603235907786.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603235907786.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>也就是说 SpringBoot默认的区域信息解析器是通过从请求头中获取区域信息的</p></blockquote></li><li><p>所以我们如果通过按钮来切换国际化的话，我们就需要使用自定义的区域信息解析器</p><blockquote><p>首先，根据我们点击不同的按钮中携带不同的参数来区分当前是哪个区域信息</p><p>使用Thymeleaf之后，需要这样写</p><p><img src="https://blog.chasingwind.top/image-20200604000622163.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604000622163.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击按钮 查看浏览器中的路径</p><p><img src="https://blog.chasingwind.top/image-20200604000652855.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604000652855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>实现自定义的区域信息解析器</p><p><img src="https://blog.chasingwind.top/image-20200604001218309.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604001218309.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>如何使用自定义的区域信息解析器</p><blockquote><p>查看自动配置类</p><p><img src="https://blog.chasingwind.top/image-20200604001341761.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604001341761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以 我们只需要将我们自定义的区域信息解析器注入到容器中</p><p>注意这个方法名 必须为localeResolver  因为不配置Bean的名字的话，默认是方法名注入到容器中。只有这样，自动配置类中的<code>@ConditionalMissingBean</code>才能生效</p><p><img src="https://blog.chasingwind.top/image-20200604001932627.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604001932627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><p>提示：当我们修改了页面之后，不重新启动程序，实时显示页面的话</p><blockquote><ol><li><p>禁用Thymeleaf的缓存</p><p><img src="https://blog.chasingwind.top/image-20200604091318715.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604091318715.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>重新编译</p><p>Command+F9，重新编译</p></li></ol></blockquote><ol><li><p>修改<code>login.html</code>页面中表单提交到的路径</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200604092633198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604092633198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写LoginController</p><blockquote><p>这里是简单模拟登录，用户名不为空，密码为123456即可</p><p><img src="https://blog.chasingwind.top/image-20200604092821306.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604092821306.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击登录之后 看到请求路径是/user/login</p><p><img src="https://blog.chasingwind.top/image-20200604093202866.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604093202866.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>点击登录</p><blockquote><p>登录成功 页面样式未加载</p><p><img src="https://blog.chasingwind.top/image-20200604094758208.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604094758208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>登录失败 需要将msg显示在页面上</p><p><img src="https://blog.chasingwind.top/image-20200604095227394.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604095227394.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>登录失败的时候 重新回到login页面 并显示错误提示信息</p><p><img src="https://blog.chasingwind.top/image-20200604095237905.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604095237905.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>解决表单重复提交的问题</p><blockquote><p>当登录成功之后，在页面刷新  出现的问题就是 表单会重复提交</p><p>这样出现的原因就是 在发送请求的时候是POST请求 然后转发到dashboard页面的 所以刷新的时候会重新发送这个请求 那么表单就重复提交了</p><p><img src="https://blog.chasingwind.top/image-20200604095654908.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604095654908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>解决方法：重定向到dashboard页面 </p><p><img src="https://blog.chasingwind.top/image-20200604102021289.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604102021289.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>然后将main.html映射到dashboard</p><p><img src="https://blog.chasingwind.top/image-20200604102108461.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604102108461.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看页面 样式也正常显示</p><p><img src="https://blog.chasingwind.top/image-20200604102126537.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604102126537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用拦截器进行登录检查</p><blockquote><p>上面虽然解决了表单重复提交的问题 但是我们直接在其他浏览器直接请求</p><p><code>https://localhost:8080/main.html</code>的时候，也可以成功访问，这样就跳过了登录验证</p><p>那么 如何验证用户已经登录呢</p><p>在login方法中存储登录的用户的session</p><p><img src="https://blog.chasingwind.top/image-20200604104924309.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604104924309.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>创建拦截器类 并添加到容器中</p><p><img src="https://blog.chasingwind.top/image-20200604105047873.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604105047873.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200604105108985.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604105108985.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>将自定义的拦截器添加到容器中 并设置拦截路径</p><p><img src="https://blog.chasingwind.top/image-20200604110047586.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604110047586.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>直接复制登录之后的链接到另一个浏览器中  由于没有session信息 那么就会被拦截</p><p><img src="https://blog.chasingwind.top/image-20200604110139468.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604110139468.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="员工列表CRUD（Restful风格实现）"><a href="#员工列表CRUD（Restful风格实现）" class="headerlink" title="员工列表CRUD（Restful风格实现）"></a>员工列表CRUD（Restful风格实现）</h2><ol><li><p>Restful方式实现的增删改查和以前用的请求的区别</p><p>URI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作</p><p><img src="https://blog.chasingwind.top/crud01.png" class="lazyload" data-srcset="https://blog.chasingwind.top/crud01.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>Restful CRUD请求参考</p><p><img src="https://blog.chasingwind.top/crud02.png" class="lazyload" data-srcset="https://blog.chasingwind.top/crud02.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>页面的公共部分抽取</p><blockquote><p>图中的红色框中的部分是每个页面都重复的部分</p><p>我们可以抽取出来 然后再在每个需要使用的地方插入公共部分即可</p><p><img src="https://blog.chasingwind.top/image-20200604154539201.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604154539201.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>参考<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#template-layout">Thymeleaf</a></p><p>抽取公共代码片段</p><p><img src="https://blog.chasingwind.top/image-20200604154932640.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604154932640.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>插入公共代码片段 其中<code>~&#123;&#125;</code>可以省略</p><p><img src="https://blog.chasingwind.top/image-20200604155144736.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604155144736.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>插入片段的语法规则</p><p>~{templatename::selector}：模板名::选择器<br>~{templatename::fragmentname}:模板名::片段名</p><p><img src="https://blog.chasingwind.top/image-20200604160530838.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604160530838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>插入片段的三种方式和各自的区别</p><p><strong>th:insert</strong>：将公共片段整个插入到声明引入的元素中</p><p><strong>th:replace</strong>：将声明引入的元素替换为公共片段</p><p><strong>th:include</strong>：将被引入的片段的内容包含进这个标签中</p><pre><code class="html">公共片段&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;-----------------------------------引入方式&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;-----------------------------------引入方式&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;-----------------------------------引入方式&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;</code></pre><hr><p>审查dashboard获取页面的侧边栏 抽取topbar作为公共代码片段</p><p>这里使用的方式<code>~&#123;templatename::fragmentname&#125;:模板名::片段名</code></p><p><img src="https://blog.chasingwind.top/image-20200604163700999.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604163700999.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在list.html页面引用公共片段</p><p><img src="https://blog.chasingwind.top/image-20200604163755872.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604163755872.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>审查元素</p><p><img src="https://blog.chasingwind.top/image-20200604163852741.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604163852741.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>审查元素抽取侧边栏   这里使用的方式<code>~&#123;templatename::selector&#125;：模板名::选择器</code></p><p><img src="https://blog.chasingwind.top/image-20200604164626029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604164626029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在list页面使用选择器插入公共代码片段<br><img src="https://blog.chasingwind.top/image-20200604164755117.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604164755117.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>dashboard.html页面请求</p><p><img src="https://blog.chasingwind.top/image-20200604163122542.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604163122542.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>对应的Contoller 以及转发到的页面</p><p><img src="https://blog.chasingwind.top/image-20200604163214122.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604163214122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>引入片段的时候传入参数</p><blockquote><p>可参数化的片段签名</p><p><img src="https://blog.chasingwind.top/image-20200604193805669.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604193805669.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在上面的功能中还存在一个问题，当我们点击员工列表的时候，没有高亮显示</p><p><img src="https://blog.chasingwind.top/image-20200604191931167.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604191931167.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查看dashboard.html页面 DashBoard高亮显示是由于这个class中的active</p><p><img src="https://blog.chasingwind.top/image-20200604192027864.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604192027864.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>为了更加简便 把所有的公共部分单独放在一个页面中</p><p><img src="https://blog.chasingwind.top/image-20200604192956410.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604192956410.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在list和dashboard都引入topbar和sidebar  这样大大简化了代码</p><p><img src="https://blog.chasingwind.top/image-20200604193101498.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604193101498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>高亮显示实现</p><p>在bar.thml中抽取的片段中根据参数来动态修改class属性值</p><p><img src="https://blog.chasingwind.top/image-20200604194752469.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604194752469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200604194813871.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604194813871.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>然后在引用的时候带上不同的参数</p><p><img src="https://blog.chasingwind.top/image-20200604194936203.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604194936203.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200604195006903.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604195006903.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="将查询到的员工数据展示在页面上"><a href="#将查询到的员工数据展示在页面上" class="headerlink" title="将查询到的员工数据展示在页面上"></a>将查询到的员工数据展示在页面上</h3><ol><li><p>查看之前的Controller</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200604201150477.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604201150477.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在页面上进行展示</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200604201115128.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604201115128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="员工添加"><a href="#员工添加" class="headerlink" title="员工添加"></a>员工添加</h3><ol><li><p>首先点击添加按钮，来到添加页面</p><blockquote><p>点击添加按钮 发送请求</p><p><img src="https://blog.chasingwind.top/image-20200604203924936.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604203924936.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>转发到add.html页面</p><p><img src="https://blog.chasingwind.top/image-20200604204012125.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604204012125.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在页面中获取select标签的option</p><p><img src="https://blog.chasingwind.top/image-20200604204147105.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604204147105.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200604204043337.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604204043337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>填写数据，然后提交，进行员工的添加</p><ol><li><p>修改页面，使用post提交表单，同时name属性值需要与Employee中的属性对应，这样在Controller中才能正确封装（不额外使用注解）</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200604214406690.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604214406690.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller</p><blockquote><p>保存用户，并重定向到之前的用户列表页面</p><p><img src="https://blog.chasingwind.top/image-20200604214457524.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604214457524.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200604214231922.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604214231922.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200604214548634.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604214548634.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>存在的问题</p><blockquote><p>日期格式</p><p><img src="https://blog.chasingwind.top/image-20200604214628221.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604214628221.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果报错400 是因为提交的日期格式不正确</p><hr><p>日期的格式化：SpringBoot已经自动配置了日期格式化器 我们可以在配置文件中设置，默认是yyyy/MM/dd</p><p><img src="https://blog.chasingwind.top/image-20200604215051851.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604215051851.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h3 id="员工修改"><a href="#员工修改" class="headerlink" title="员工修改"></a>员工修改</h3><ol><li><p>点击编辑按钮，来到修改页面</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200604224542924.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604224542924.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>然后 在Controller中根据用户的id查询用户封装到request域中 然后转发到编辑页面</p><p><img src="https://blog.chasingwind.top/image-20200604224726889.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604224726889.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>通过 <strong>@PathVariable</strong> 可以将 <strong>URL</strong> 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {<strong>xxx</strong>} 占位符可以通过@PathVariable(“<strong>xxx</strong>“) 绑定到操作方法的入参中。</p><p>比如上图中的方法参数id域请求中的id绑定在一起</p></blockquote></li><li><p>在编辑页面显示员工的数据</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200604225457550.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604225457550.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200604225515631.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604225515631.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改用户 并提交</p><blockquote><p>由于form表单只支持post和get的方式</p><p>这里的请求需要的是put方式</p><p>如何在页面发送put请求呢？</p><ol><li>SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的，我们在配置文件中开启就可以使用了<code>spring.mvc.hiddenmethod.filter.enabled=true</code>），功能就是<strong>将请求转为指定的方式</strong></li><li>页面创建一个post表单</li><li>创建一个input项，name=”_method”;value就是我们指定的请求方式</li></ol><p><img src="https://blog.chasingwind.top/image-20200604233402605.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604233402605.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200604231754846.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604231754846.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote></li><li><p>修改用户的方法</p><blockquote><p>我们实现的save方法来实现用户的修改</p><p><img src="https://blog.chasingwind.top/image-20200604232526913.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604232526913.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>由于需要知道修改的用户的id，而表单中没有这个字段，所以添加一个id字段</p><p><img src="https://blog.chasingwind.top/image-20200604232408846.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604232408846.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>修改用户</p><p><img src="https://blog.chasingwind.top/image-20200604232634617.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200604232634617.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试可以成功修改</p></li></ol><h3 id="员工删除"><a href="#员工删除" class="headerlink" title="员工删除"></a>员工删除</h3><ol><li><p>页面发送delete请求</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200605084523887.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200605084523887.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller中删除，并重定向到员工列表页</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200605084606940.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200605084606940.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>优化</p><blockquote><p>使用js动态添加form</p><p><img src="https://blog.chasingwind.top/image-20200605093526821.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200605093526821.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200605093535126.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200605093535126.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h1 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h1><h2 id="SpringBoot默认错误处理"><a href="#SpringBoot默认错误处理" class="headerlink" title="SpringBoot默认错误处理"></a>SpringBoot默认错误处理</h2><ol><li><p>当我们使用浏览器请求不存在的资源时</p><blockquote><p>默认错误页面</p><p><img src="https://blog.chasingwind.top/image-20200605094252881.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200605094252881.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>当我们使用Postman发送请求的时候</p><blockquote><p>SpringBoot为我们响应的是JSON数据</p><p><img src="https://blog.chasingwind.top/image-20200605094407844.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200605094407844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看SpringBoot的默认配置类</p><blockquote></blockquote></li></ol><h1 id="配置嵌入式Servlet容器"><a href="#配置嵌入式Servlet容器" class="headerlink" title="配置嵌入式Servlet容器"></a>配置嵌入式Servlet容器</h1><h1 id="使用外置的Servlet容器"><a href="#使用外置的Servlet容器" class="headerlink" title="使用外置的Servlet容器"></a>使用外置的Servlet容器</h1>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot日志</title>
      <link href="2020/07/03/SpringBoot%E6%97%A5%E5%BF%97/"/>
      <url>2020/07/03/SpringBoot%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot的日志框架包含多种多样，我们在比较各种日志门面和日志实现之后，一般选用SLF4J来作为日志门面实现系统的日志功能，我们需要理解日志门面和日志实现之间的区别。</p><a id="more"></a><h2 id="日志框架介绍"><a href="#日志框架介绍" class="headerlink" title="日志框架介绍"></a>日志框架介绍</h2><ol><li><p>日志是什么</p><blockquote><p>日志：记录系统实时运行状态的信息。</p></blockquote></li><li><p>日志门面和日志实现</p><blockquote><p>日志门面：是日志实现的抽象层。</p><p>日志实现：具体的日志功能的实现。</p><hr><p>对比JDBC和数据库驱动的关系</p><p>日志框架中的日志门面就相当于JDBC</p><p>而各种数据库驱动就相当于各种日志实现</p><p><img src="https://blog.chasingwind.top/image-20200531164114108.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531164114108.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>为什么不直接使用日志实现，而是又弄了一个叫日志门面的东西？</p><blockquote><p>为了在应用中屏蔽掉底层日志框架的具体实现。这样的话，即使有一天要更换代码的日志框架，只需要修改jar包，最多再改改日志输出相关的配置文件就可以了。这就是解除了应用和日志框架之间的耦合。</p></blockquote></li></ol><p>常见的日志框架包含：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <br /><strong><del>jboss-logging</del></strong></td><td>Log4J<br />JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>我们选用的是日志门面的是SLF4J；选择的日志实现是Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；</p><ul><li><p><strong>SpringBoot选用 SLF4j和Logback；</strong></p></li><li><p>我们在使用的时候直<strong>接使用日志门面</strong>而避免使用日志实现。</p></li></ul><h2 id="SLF4J的使用"><a href="#SLF4J的使用" class="headerlink" title="SLF4J的使用"></a>SLF4J的使用</h2><ol><li><p>如何使用SLF4J？</p><blockquote><p>参考<a href="https://www.slf4j.org/manual.html">SLF4J官方文档</a></p><p><img src="https://blog.chasingwind.top/image-20200531165353533.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531165353533.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200531170056618.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531170056618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>由于每一种日志实现都有自己的配置文件，使用SLF4J日志门面后，<strong>配置文件中需要配置的是日志实现的配置。</strong></p></blockquote></li><li><p>遗留问题</p><blockquote><p>在以前的各种框架中，使用的日志系统都是不一样的，那么怎样统一呢</p><p>比如，系统使用的日志框架（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis</p></blockquote><ul><li><p>如何将日志都统一到slf4j？</p><blockquote><ol><li>将系统中其他日志框架的依赖先排除出去（比如，使用Spring框架的时候，让他不导入commons-logging，但是不导入的话就运行不起来了，所以需要第2步）</li><li>用中间包来替换原有的日志框架（包名和类名与之前的都是一样的，但是底层已经换成了SLF4J的实现）</li><li>我们导入slf4j其他的实现</li></ol></blockquote><blockquote><p><a href="https://www.slf4j.org/legacy.html">参考</a></p><p>对于JCL，Log4J和JUL来说，</p><p><img src="https://blog.chasingwind.top/image-20200531171849761.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531171849761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>commons-logging和java.util.logging</p><p><img src="https://blog.chasingwind.top/image-20200531171919725.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531171919725.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>commons-logging和log4j</p><p><img src="https://blog.chasingwind.top/image-20200531171930205.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531171930205.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="SpringBoot中的日志关系"><a href="#SpringBoot中的日志关系" class="headerlink" title="SpringBoot中的日志关系"></a>SpringBoot中的日志关系</h2><ol><li><p>SpringBoot中日志功能的底层依赖关系</p><blockquote><p>在pom.xml中右键</p><p><img src="https://blog.chasingwind.top/image-20200531212716384.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531212716384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看依赖之间的关系</p><p><img src="https://blog.chasingwind.top/image-20200531213424154.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531213424154.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>黄框中可以看出：jul和log4j都是借用适配层的jar文件作为中间者，最后依赖抽象层log4j</p></blockquote><p>总结：</p><ol><li><p>SpringBoot底层使用的是slf4j日志门面和logback日志实现来进行日志的记录功能</p></li><li><p>SpringBoot也把其他的日志通过中间替换包都转换为slf4j</p></li><li><p>中间替换包</p><blockquote><p>比如，查看jul-toslf4j.jar中的SLF4JBridgehandler</p><p><img src="https://blog.chasingwind.top/image-20200531221934949.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531221934949.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Adds a SLF4JBridgeHandler instance to jul’s root logger.</p><p>表示将SLF4JBridgeHandler作为jul的实例，也就是说jul这个时候其实已经是SLF4J了</p></blockquote></li><li><p>如果引入其他框架，一定要把这个框架中的默认日志依赖移除</p><blockquote><p>因为不移除的话，引入的框架中的jar包的包名和类名都会和中间替换包的包名和类名相同，这样的话就会出现依赖冲突</p><hr><p>Spring框架使用的是commons-logging，查看他的依赖</p><p>exclusion：移除依赖</p><p>也就是说，当我们引入其他框架的时候，首先需要把其中自带的日志依赖移除</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;commons-logging&lt;/groupId&gt;                    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;</code></pre><hr><p>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</p></blockquote></li></ol></li></ol><h2 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h2><ol><li><p>使用SpringBoot的默认配置</p><blockquote><p>不需要任何配置，直接使用</p><p><img src="https://blog.chasingwind.top/image-20200531231807905.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531231807905.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>日志级别：由低到高排序为，   trace&lt;debug&lt;info&lt;warn&lt;error</p><p><strong>日志级别可以进行调整，调整之后，日志只会输出这个级别以及比这个级别高级别的日志。</strong></p><p>日志级别的使用场景：当我们在上线应用的时候，调整输出的日志级别为info，这样日志中就不显示trace和debud的日志信息</p><hr><p>测试SpringBoot的日志级别</p><p><img src="https://blog.chasingwind.top/image-20200531232335604.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531232335604.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>发现<strong>SpringBoot的默认日志级别是info</strong></p><hr><p>调整默认日志级别，在配置文件中设置<code>edu.ahnu</code>包下的日志级别为trace</p><p>没有指定级别的就用SpringBoot默认规定的级别；root级别（info）</p><p>可见，trace也已经输出</p><p><img src="https://blog.chasingwind.top/image-20200531232554481.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531232554481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>上面的配置的话 只能将日志信息打印在控制台</p><p>通过配置文件配置日志的输出路径以及文件名</p><p><img src="https://blog.chasingwind.top/image-20200531233833590.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531233833590.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>还可以配置日志的输出格式</p><p>没有配置之前的格式</p><p><img src="https://blog.chasingwind.top/image-20200531234146439.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531234146439.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置控制台和日志文件中的格式</p><p><img src="https://blog.chasingwind.top/image-20200531234249692.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531234249692.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>配置之后的控制台的日志格式</p><p><img src="https://blog.chasingwind.top/image-20200531234235085.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531234235085.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>配置格式参考</p><pre><code class="properties"> 日志输出格式：        %d表示日期时间，        %thread表示线程名，        %-5level：级别从左显示5个字符宽度        %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。         %msg：日志消息，        %n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</code></pre><hr><p>查看默认配置</p><p><img src="https://blog.chasingwind.top/image-20200531234740794.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531234740794.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>指定配置文件</p><blockquote><p>参考<a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/spring-boot-features.html#boot-features-logging">官方文档</a></p><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><p><img src="https://blog.chasingwind.top/image-20200601000339904.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601000339904.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>不同日志实现使用的配置文件的命名</p><p><img src="https://blog.chasingwind.top/logger.png" class="lazyload" data-srcset="https://blog.chasingwind.top/logger.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Spring更加推荐的命名是：使用<code>日志实现-spring.xml</code>命名的配置文件</p><p><img src="https://blog.chasingwind.top/image-20200531235635415.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531235635415.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>原因如下（以日志实现logback为例）：</p><p>logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，<strong>由SpringBoot解析日志配置</strong>，可以使用SpringBoot的高级Profile功能（比如指定当前的运行环境）</p><p>如在logback-spring.xml使用springProfile标签指定不同环境时候的日志样式：</p><pre><code class="xml">&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;  &lt;!-- 日志输出格式：            %d表示日期时间，            %thread表示线程名，               %-5level：级别从左显示5个字符宽度               %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。             %msg：日志消息，            %n是换行符  --&gt;  &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;      &lt;springProfile name=&quot;dev&quot;&gt;          &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;         &lt;/springProfile&gt;         &lt;springProfile name=&quot;!dev&quot;&gt;             &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;         &lt;/springProfile&gt;     &lt;/layout&gt;   &lt;/appender&gt;</code></pre><hr><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 <code>no applicable action for [springProfile]</code></p></blockquote></li></ol><h2 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h2><ul><li><p>SpringBoot默认使用的是SLF4J+logback的日志框架（以下切换全都不推荐，只是用来明白切换的原理）</p><ol><li><p>slf4j+log4j</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200601001452883.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200601001452883.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>首先 分析整个依赖树，排除默认使用的logback</p><p>然后 去除 log4j-over-slf4j.jar的依赖（因为我们现在需要换成这个）</p><p>到现在为止，就把其他的日志门面转换为了slf4j</p><p>然后 导入适配层slf4j-log4j12.jar，适配层的依赖同时也把日志实现的log4j的依赖导入了</p><p>加入loa4j.properties在resources中即可使用</p></blockquote></li><li><p>slf4j+log4j2</p><blockquote><p>默认的日志starter使用的是<code>spring-boot-starter-logging</code></p><p>先把默认的日志starter排除，然后直接添加依赖<code>spring-boot-starter-log4j2</code>的依赖</p></blockquote></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="2020/07/03/SpringBoot%E5%9F%BA%E7%A1%80/"/>
      <url>2020/07/03/SpringBoot%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>本节介绍了SpringBoot的基础内容，包括对SpringBoot的简介，以及配置的介绍。主要包括SpringBoot是如何实现自动配置的，这是必须要掌握的内容。</p><a id="more"></a><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><ol><li><p><a href="https://spring.io/">SpringBoot</a>官网</p></li><li><p>SpringBoot简化Spring的开发流程，可以整合各种框架，来完成企业级开发</p></li><li><p>SpringBoot帮我们自动配置好相关环境，我们只需要简单配置即可</p></li><li><p>SpringBoot的优点</p><blockquote><ol><li>快速创建独立运行的Spring项目以及主流框架的集成，配置很简单</li><li>使用嵌入式的Servlet，不需要像之前一样安装Tomcat服务器，打成war包才能运行，而是打包成jar包，直接使用java -jar命令运行程序</li><li>starters启动器帮助我们完成自动依赖和版本控制，比如：我们需要使用JDBC，就不需要我们导入各种相关的jar的依赖，而是使用starters即可</li><li>大量的自动配置。简化开发，也可以修改默认值</li><li>无需配置XML，无代码生成，开箱即用</li><li>准生产环境的运行时应用监控</li><li>与云计算的天然集成</li></ol></blockquote></li><li><p>与Spring的关系</p><blockquote><p>SpringBoot帮助我们整合各种框架，我们作为用户直接使用SpringBoot即可，但是需要我们掌握Spring的相关知识</p><p><img src="https://blog.chasingwind.top/image-20200529145235047.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529145235047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>微服务（MicroServices）架构风格</p><ol><li><p>单体应用程序</p><blockquote><p>传统的应用的优点：开发，测试，部署以及负载均衡比较容易</p><p>但是缺点也很明显：随着需求的增长，软件会越来越大，并且如果某一块有问题了，那么整个应用就需要重新打包，再进行部署</p><p><img src="https://blog.chasingwind.top/image-20200529150310213.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529150310213.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>微服务应用</p><blockquote><p>一个应用应该是一组小型服务，每个服务之间通过HTTP来进行互通</p><p>每一个功能单元之间是相互独立的，每一个服务都是可以替换和独立升级的单元</p><p><img src="https://blog.chasingwind.top/image-20200529150529455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529150529455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>缺点就是：部署和运维比较困难，其实这个就相当于是一个大的分布式应用</p></blockquote></li></ol></li><li><p>SpringBoot构建微服务</p><ol><li><p>使用SpringBoot构建我们的应用</p></li><li><p>使用SpringCloud来完成服务之间的互连，来完成分布式</p></li><li><p>SpringCloud Data来完成数据的流式处理</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200529152041501.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529152041501.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h3 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h3><ol><li><p>创建Maven项目，这里创建的是简单的Java项目（后面会直接使用SpringBoot Initializer来快速创建）</p></li><li><p>导入依赖，这里依赖的版本是统一管理的</p><blockquote><pre><code class="xml"> &lt;!--统一为SpringBoot的启动器约定版本信息--&gt; &lt;parent&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;     &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt; &lt;/dependencies&gt;</code></pre></blockquote></li><li><p>编写主程序，启动SpringBoot应用</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200529154836404.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529154836404.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写相关的Controller和Service</p><blockquote><p>我们不需要再进行相关的配置</p><p>编写Controller</p><p><img src="https://blog.chasingwind.top/image-20200529155338076.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529155338076.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>@ResponseBody注解</p><p>@ResponseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。<br><strong>注意</strong>：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</p></blockquote></li><li><p>启动主程序</p><blockquote><p>我们不需要配置Tomcat就可以进行访问</p><p>在启动日志中可以发现 Tomcat已经默认配置好的</p><p><img src="https://blog.chasingwind.top/image-20200529155649879.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529155649879.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>访问hello</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200529155741776.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529155741776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="部署程序"><a href="#部署程序" class="headerlink" title="部署程序"></a>部署程序</h3><ol><li><p>在pom.xml中添加SpringBoot的Maven插件</p><blockquote><pre><code class="xml"> &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt;     &lt;plugins&gt;         &lt;plugin&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt;</code></pre></blockquote></li><li><p>使用package插件打包</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200529160353207.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529160353207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行jar包</p><blockquote><p>使用命令<code>java -jar</code></p><p><img src="https://blog.chasingwind.top/image-20200529160721431.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529160721431.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200529160747908.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529160747908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>我们本地并没有安装Tomcat服务器，这个程序是怎么运行并可以访问的？</p><blockquote><p>我们打开这个jar包</p><p>在BOOT-INF目录下</p><p><img src="https://blog.chasingwind.top/image-20200529161212182.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529161212182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>classes目录下是我们编写的程序</p><p><img src="https://blog.chasingwind.top/image-20200529161257393.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529161257393.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>lib目录下 是相关的jar包 其中就有SpringBoot嵌入式的Tomcat以及Tomcat</p><p><img src="https://blog.chasingwind.top/image-20200529161435430.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529161435430.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200529161601531.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529161601531.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="入门程序分析"><a href="#入门程序分析" class="headerlink" title="入门程序分析"></a>入门程序分析</h3><ol><li><p>pom.xml中的<code>spring-boot-starter-parent</code>依赖</p><blockquote><p>我们的项目中的pom.xml中依赖的SpringBoot所有启动器（starter）的父项目</p><p><img src="https://blog.chasingwind.top/image-20200529162943900.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529162943900.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击上图中的artifactId的属性值进入 启动器的父项目中</p><p><img src="https://blog.chasingwind.top/image-20200529163109056.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529163109056.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>再点击上图中的artifactId  进入到spring-boot-dependencies中 可以看到使用到的依赖</p><p>其中就规定了使用到的依赖的版本信息 而不需要我们再手动配置</p><p>被称为 <strong>SpringBoot的版本仲裁中心</strong></p><p><img src="https://blog.chasingwind.top/image-20200529163246693.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529163246693.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>以后我们导入依赖默认不需要写版本号</p><p>当然，在dependencies中没有规定的依赖还是需要我们手动配置的</p></blockquote></li><li><p>导入的<code>spring-boot-starter-web</code>依赖</p><ul><li>spring-boot-starter-web：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</li></ul><ol><li><p>spring-boot-starters</p><blockquote><p>当我们点击进去之后</p><p>可以发现<code>spring-boot-starter-web</code>依赖的父项目是<code>spring-boot-startes</code>（SpringBoot版本为1.5.9，版本2.3.0中没有这个依赖）</p><p>Spring-boot-starts中有许多模块，详细的介绍看下面的第3点</p><p><img src="https://blog.chasingwind.top/image-20200529165044964.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529165044964.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>spring的web相关的依赖</p><blockquote><p>同时还依赖web相关</p><p><img src="https://blog.chasingwind.top/image-20200529165316973.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529165316973.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Spring-boot-starters介绍</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/using-spring-boot.html#using-boot-starter">官网文档</a></p><p><img src="https://blog.chasingwind.top/image-20200529165632402.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529165632402.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器，其中，版本由SpringBoot统一控制</p></blockquote></li><li><p>主程序类</p><ol><li><p><strong>@SpringBootApplication</strong></p><blockquote><p><img src="https://blog.chasingwind.top/image-20200529165951198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200529165951198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>@SpringBootApplication</code>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><hr><p>进入到这个注解中 发现其中包含很多注解，其中两个重要的注解见图</p><p><img src="https://blog.chasingwind.top/image-20200530094040105.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530094040105.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>@SpringBootConfiguration</strong></p><blockquote><p><code>@SpringBootConfiguration</code>：Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类；</p><p>进入到这个注解中  发现其中还有一个我们比较熟悉的注解</p><p><code>@Configuration</code>：标注当前类为配置类，使用注解的方式替换以前的配置文件</p><p><img src="https://blog.chasingwind.top/image-20200530094338212.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530094338212.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点进去注解  发现其实**@Configuration** 就是容器中的一个组件</p><p><img src="https://blog.chasingwind.top/image-20200530094634459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530094634459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>@EnableAutoConfiguration</strong></p><blockquote><p><code>@EnableAutoConfiguration</code>：开启自动配置的功能，以前我们需要配置的东西，SpringBoot帮我们自动配置</p><p>进入到注解中 其中有    </p><p><img src="https://blog.chasingwind.top/image-20200530095339938.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530095339938.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol><li><p><strong>@AutoConfigurationPackage</strong></p><blockquote><p>注解<code>@AutoConfigurationPackage</code>：自动配置包，作用就是：<strong>将主配置类（<code>@SpringBootApplication</code>标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</strong></p><p>进入到这个注解中</p><p><img src="https://blog.chasingwind.top/image-20200530095430404.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530095430404.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注解<code>@Import(AutoConfigurationPackages.Registrar.class)</code>：Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class来判断该导入哪些组件；</p><p>进入到<code>Registrar</code>类中</p><p><img src="https://blog.chasingwind.top/image-20200530100737792.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530100737792.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Debug启动 查看获取到的结果</p><p><img src="https://blog.chasingwind.top/image-20200530100841024.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530100841024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200530101122140.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530101122140.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用IDEA的计算功能  计算参数<code>new PackageImport(metadata).getPackageName()</code></p><p><img src="https://blog.chasingwind.top/image-20200530101234735.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530101234735.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200530101341493.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530101341493.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>由此可得：<code>@AutoConfigurationPackage</code>注解的作用就是将<strong>主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包</strong>里面的所有组件扫描到Spring容器；</p><p>同时，如果类不在主配置类所在的包及其子包下的话 即使使用了IoC容器的注解  也是无法扫描到的</p></blockquote></li><li><p>@Import(EnableAutoConfigurationImportSelector.class)</p><blockquote><p>给容器中导入EnableAutoConfigurationImportSelector.class这个类选择的组件</p><p>EnableAutoConfigurationImportSelector：导入组件选择器，选择导入哪些组件</p><p>查看他的父类</p><p><img src="https://blog.chasingwind.top/image-20200530103636712.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530103636712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>父类中的方法<code>selectImports()</code>  返回一个String数组，其中存储的就是组件的全类名</p><p>作用就是告诉Spring容器导入哪些组件</p><p><img src="https://blog.chasingwind.top/image-20200530103732713.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530103732713.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Debug查看数组中有哪些组件</p><p><img src="https://blog.chasingwind.top/image-20200530104039516.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530104039516.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>发现组件名都是（xxxAutoConfiguration） 自动配置类，作用就是给容器中导入这个场景所需要的组件，并进行自动配置</p><p>有了这些自动配置类，就免去了我们手动编写配置注入组件等工作</p></blockquote></li><li><p>这些自动配置类从哪里得到的</p><blockquote><p>上面的<code>selectImports()</code>  方法中调用的方法<code>getCandidateConfigurations</code> 获取候选的配置文件</p><p><img src="https://blog.chasingwind.top/image-20200530105248489.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530105248489.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>进入到此方法中  其中调用的方法（第一个参数的值就是EnableAutoConfiguration.class）</p><p><img src="https://blog.chasingwind.top/image-20200530105335250.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530105335250.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><pre><code class="java">SpringFactoriesLoader.loadFactoryNames(        EnableAutoConfiguration.class,getBeanClassLoader());</code></pre><p>进入到<code>loadFactoryNames</code></p><p><img src="https://blog.chasingwind.top/image-20200530110237948.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530110237948.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>那么 这个第一步中的资源 在哪里呢</p><p><img src="https://blog.chasingwind.top/image-20200530110305713.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530110305713.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看类路径下的配置文件</p><p><img src="https://blog.chasingwind.top/image-20200530110712978.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530110712978.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>仔细观察发现  这里的自动配置的类与我们之前Debug时候的<code>selectImports</code>方法获取的组件的数组是一样的</p><p><img src="https://blog.chasingwind.top/image-20200530110848738.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530110848738.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以<code>SpringFactoriesLoader.loadFactoryNames</code>这个方法的作用就是从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的工厂名。</p><p>在此基础之上，然后将这些获取到的工厂名作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们实现；</p><hr><p>这些自动配置类所在的包</p><p><img src="https://blog.chasingwind.top/image-20200530111655127.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530111655127.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200530111707766.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530111707766.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>各个注解之间的关系</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200603110020500.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200603110020500.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="快速创建SpringBoot应用"><a href="#快速创建SpringBoot应用" class="headerlink" title="快速创建SpringBoot应用"></a>快速创建SpringBoot应用</h3><ol><li><p>选择使用Spring Initializer创建项目，并选择JDK版本</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530141800307.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530141800307.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>设置相关的信息</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530142114374.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530142114374.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>选择需要使用的模块</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530142317904.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530142317904.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>设置项目名，就可以完成整个项目的创建</p></li><li><p>查看pom文件</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530142847688.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530142847688.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530143255560.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530143255560.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200530143145067.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530143145067.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>删除用不到的文件</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530143526267.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530143526267.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在测试的Controller中</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530143921359.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530143921359.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>上面的两个注解可以使用一个注解代替</p><p><img src="https://blog.chasingwind.top/image-20200530144007601.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530144007601.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点进去查看</p><p><img src="https://blog.chasingwind.top/image-20200530144032678.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530144032678.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看项目的资源文件夹（resources）</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530144447534.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530144447534.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>static：保存所有的静态资源； js css  images；</p><p>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</p><p>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</p></blockquote></li></ol><h2 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>SpringBoot使用一个全局配置文件，在resources目录下，<strong>配置文件的名称是固定的，但是有两种文件格式都可以使用</strong><ol><li>application.properties</li><li>application.yml</li></ol></li><li>配置文件的作用是<strong>修改SpringBoot自动配置的默认值</strong></li></ul><h4 id="YAML简介"><a href="#YAML简介" class="headerlink" title="YAML简介"></a>YAML简介</h4><ul><li><p>YAML：YAML <strong>Ain’t</strong> Markup Language</p><ul><li>YAML  <strong>A</strong> Markup Language：是一个标记语言</li><li>YAML   <strong>isn’t</strong> Markup Language：不是一个标记语言；</li></ul></li><li><p>XML和YAML对比</p><blockquote><p>YAML</p><pre><code class="yaml">server:  port: 8081</code></pre><p>XML</p><pre><code class="xml">&lt;server&gt;    &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt;</code></pre><hr><p>YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件，不用带标签名；</p></blockquote></li></ul><h4 id="YAML基本语法"><a href="#YAML基本语法" class="headerlink" title="YAML基本语法"></a>YAML基本语法</h4><ol><li><p>基本语法</p><p>key:（空格） value  来表示一对键值对（必须有空格）</p><p>以空格的缩进来表示层级关系，只要是左对齐的一列数据，都是同一层级的</p><blockquote><pre><code class="yaml">server:  port: 8081 path: /hello</code></pre><p>这里的port和path表示的就是同一层级</p><p>同时 属性和值都是大小写敏感的</p></blockquote></li><li><p>值的分类</p><ol><li><p>字面量：普通的值（数字，字符串，布尔类型）</p><blockquote><p>key：value，字面值直接写</p><p>字符串类型不需要写引号，如果写的话，单引号和双引号的表示意义是不一样的</p><p>单引号：会转义特殊字符，<strong>特殊字符最终只是一个普通的字符串数据</strong></p><pre><code>            name:   ‘zhangsan \n lisi’：输出；zhangsan **\n**  lisi</code></pre><p>双引号：不会转义字符串里面的特殊字符；特<strong>殊字符会作为本身想表示的意思</strong></p><pre><code>            name:   &quot;zhangsan \n lisi&quot;：输出；zhangsan **换行**  lisi</code></pre></blockquote></li><li><p>对象、Map（键值对）</p><blockquote><p>缩进写法</p><pre><code class="yaml">friends:        lastName: zhangsan        age: 20</code></pre><p>行内写法</p><pre><code class="yaml">friends: &#123;lastName: zhangsan,age: 18&#125;</code></pre></blockquote></li><li><p>数组（List、Set）</p><blockquote><p>缩进写法</p><pre><code class="yaml">pets: - cat - dog - pig</code></pre><p>行内写法</p><pre><code class="yaml">pets: [cat,dog,pig]</code></pre></blockquote></li></ol></li></ol><h4 id="使用YAML配置文件注入值"><a href="#使用YAML配置文件注入值" class="headerlink" title="使用YAML配置文件注入值"></a>使用YAML配置文件注入值</h4><ol><li><p>创建一个对象，其中包含各种类型的数据</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530165851852.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530165851852.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200530165907888.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530165907888.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写application.yml，其中设置person的各种属性的值</p><blockquote><p>导入配置文件处理器，以便在编写配置文件的时候有提示信息  在下面的第3步配置完成后 重新启动SpringBoot的主程序才能有提示</p><pre><code class="xml">     &lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;         &lt;optional&gt;true&lt;/optional&gt;     &lt;/dependency&gt;</code></pre><p><img src="https://blog.chasingwind.top/image-20200530170643032.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530170643032.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将配置文件中的属性值映射到Person中</p><blockquote><p>由于这个配置文件是SpringBoot的全局配置文件，我们要怎样把其中的属性值映射到Person类中的属性上呢？</p><ul><li>@ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</li><li>参数prefix = “xxxx” 将配置文件中的xxx属性（第一层级）下的值进行一一映射，因为配置文件中可能不止一个配置信息，比如上面的配置中包含server和person，所以需要指定注入哪个数据</li></ul><p><img src="https://blog.chasingwind.top/image-20200530171205770.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530171205770.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同时 只有在容器中的组件才能使用Spring中提供的组件</p><p>所以这个类还必须加入到容器中</p><p><img src="https://blog.chasingwind.top/image-20200530171958256.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530171958256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试 获取设置的属性值</p><blockquote><p>可以正确获取到属性值</p><p><img src="https://blog.chasingwind.top/image-20200530172630274.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530172630274.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="使用properties配置文件注入值"><a href="#使用properties配置文件注入值" class="headerlink" title="使用properties配置文件注入值"></a>使用properties配置文件注入值</h4><ol><li><p>编写配置文件，设置属性值</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530175059550.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530175059550.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行测试类</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530175134931.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530175134931.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>发现中文乱码</p></blockquote></li><li><p>解决中文乱码的问题</p><blockquote><p>由于IDEA默认使用的是utf-8</p><p>而properties之前使用的都是ASCII码</p><p>所以修改一下运行时的编码方式就可以了</p><p>表示的是需不需要把properties文件在运行的时候转换为ASCII码</p><p><img src="https://blog.chasingwind.top/image-20200530175428215.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530175428215.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>重新测试</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530175832971.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530175832971.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="使用-Value注解的方式注入值"><a href="#使用-Value注解的方式注入值" class="headerlink" title="使用@Value注解的方式注入值"></a>使用@Value注解的方式注入值</h4><ol><li><p>@Value注解</p><blockquote><p>以前在xml文件中  为属性注入值</p><pre><code class="xml">&lt;bean class=&quot;Person&quot;&gt;  &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><hr><p>在类中使用的话</p><p><img src="https://blog.chasingwind.top/image-20200530194547972.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530194547972.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>@Value和@ConfigurationProperties对比</p><blockquote><p><img src="https://blog.chasingwind.top/configuration.png" class="lazyload" data-srcset="https://blog.chasingwind.top/configuration.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>松散语法：</p><p>比如为Person类中的成员变量firstName注入值</p><p><img src="https://blog.chasingwind.top/image-20200530195621499.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530195621499.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>以下三种方式都是可以的  </p><p><img src="https://blog.chasingwind.top/image-20200530195322043.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530195322043.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200530195353363.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530195353363.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200530195500001.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530195500001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>JSR303数据校验</p><p>首先 加入依赖</p><pre><code class="xml">      &lt;!--添加JSR303依赖 用于校验功能--&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;     &lt;/dependency&gt;</code></pre><p>然后 在类上面使用@Validated注解  在需要校验的参数上使用需要校验的类型</p><p>比如 我们在firstName上使用注解@Email  就会对注入的值进行校验 当发现注入的值不是邮箱类型的时候  就会报错<br><img src="https://blog.chasingwind.top/image-20200530201843952.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530201843952.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>两个注解我们如何进行选择</p><blockquote><ul><li><p>我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p></li><li><p>我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p></li></ul></blockquote></li></ol><h4 id="PropertySource和-ImportResource"><a href="#PropertySource和-ImportResource" class="headerlink" title="@PropertySource和@ImportResource"></a>@PropertySource和@ImportResource</h4><p>在前面为Person类注入的时候，使用的注解@ConfigurationProperties默认使用的是全局配置文件，但是这个全局配置文件中并不适合把所有的配置信息都放在里面。所以我们可以把与SpringBoot无关的配置单独放在其他的配置文件中，然后使用下面的注解指定配置文件对数据进行注入。</p><ol><li><p>@PropertySource：加载指定的配置文件</p><blockquote><p>我们把application.yml中的配置删除之后，将其中的配置放在一个新的配置文件中</p><p><img src="https://blog.chasingwind.top/image-20200530204713438.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530204713438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；此注解标注在一个配置类上</p><blockquote><p>SpringBoot中没有Spring的配置文件，同时我们自己编写的配置文件也不能使用</p><p>之前我们使用配置文件的方式向IoC容器中加入组件</p><p><img src="https://blog.chasingwind.top/image-20200530210523523.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530210523523.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试查看IoC容器中没有注入的组件</p><p><img src="https://blog.chasingwind.top/image-20200530210615680.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530210615680.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>在配置类上使用@ImportSource</strong> 测试 发现IoC容器中已经注入了我们需要的组件</p><p><img src="https://blog.chasingwind.top/image-20200530210803671.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530210803671.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用配置类来实现给容器中添加组件</p><blockquote><p>SpringBoot并不推荐使用@ImportSource来实现组件的注入，而更加推荐使用配置类来实现 </p><p>把@ImportSource注解注释掉之后</p><p>创建config配置类文件夹，创建配置类，使用@Bean注解将方法的返回值作为对象添加到IoC容器中，发现成功在IoC容器中注入组件了</p><p><img src="https://blog.chasingwind.top/image-20200530212011435.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530212011435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h4><ol><li><p>随机数</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530220237819.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530220237819.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200530220301477.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530220301477.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试</p><p><img src="https://blog.chasingwind.top/image-20200530220345647.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530220345647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用占位符获取在此之前已经配置的值，如果没有的话使用：指定默认值</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200530220503017.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530220503017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试</p><p><img src="https://blog.chasingwind.top/image-20200530220535288.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530220535288.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="配置文件的加载顺序"><a href="#配置文件的加载顺序" class="headerlink" title="配置文件的加载顺序"></a>配置文件的加载顺序</h3><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><p>Profile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境，比如我们在项目中可能使用到的有开发环境，生产环境以及线上环境，而这些配置是不同的，那么就可以使用下面的方式来进行环境的切换</p><ol><li><p>多个profile+激活指定的profile</p><blockquote><p>我们可以在resources目录下编写多个生产环境的profile文件，其中，profile的命名规则如下：<strong>application-xxx.properties</strong>或者<strong>application-xxx.yml</strong></p><p><img src="https://blog.chasingwind.top/image-20200530222000037.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530222000037.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>并在主配置文件中指定需要使用的profile是哪一个</p><p><img src="https://blog.chasingwind.top/image-20200530222140336.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530222140336.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>yml多个文档块+激活指定的profile</p><blockquote><p>文档块：yml文件中使用<code>---</code>分隔开的配置信息</p><p><img src="https://blog.chasingwind.top/image-20200530222649204.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530222649204.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>激活指定的profile 其中的配置才能生效</p><p><img src="https://blog.chasingwind.top/image-20200530222828184.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530222828184.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>命令行的方式指定</p><blockquote><p>对于已经打成jar包的 可以在使用命令行运行的时候指定profile</p><p>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=xxx（比如：dev）；</p><hr><p>在测试的时候，配置传入命令行参数</p><p><img src="https://blog.chasingwind.top/image-20200530224051624.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530224051624.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用命令行的方式会覆盖之前的激活的profile中的配置</p></blockquote></li><li><p>虚拟机参数</p><blockquote><p>-D是固定开头</p><p><img src="https://blog.chasingwind.top/image-20200530224303198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530224303198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="配置文件的加载位置以及优先级"><a href="#配置文件的加载位置以及优先级" class="headerlink" title="配置文件的加载位置以及优先级"></a>配置文件的加载位置以及优先级</h4><ul><li><p>SpringBoot启动会扫描以下位置的application.properties或者application.yml文件作为Spring Boot的默认配置文件</p><ol><li>–file:./config/：项目文件夹下的config文件夹下的配置文件</li><li>–file:./：项目文件夹下的配置文件</li><li>–classpath:/config/：类路径下的config文件夹下的配置文件</li><li>–classpath:/：类路径下的配置文件</li></ol><blockquote><p><strong>优先级由高到底，高优先级的配置会覆盖低优先级的配置；同时，所有的配置文件之间是互补的关系。</strong></p><p>这里并不是说 高优先级中有的配置就不会再去加载低优先级的配置了</p><p>SpringBoot会将所有优先级的配置加载进来，如果有相同的配置信息的话，使用的是高优先级中的配置；</p><p>如果低优先级中有的配置在高优先级中没有的话，那么这个低优先级中的配置也会生效，也就是说这些配置文件之间是<strong>互补</strong>的关系。</p><p><img src="https://blog.chasingwind.top/image-20200530225215879.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530225215879.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>还可以运行jar包的时候使用spring.config.location来改变默认的配置文件的位置</p><blockquote><p>在运维的时候可能使用的比较多 我们在服务器的本地编写好配置文件</p><p>在运行项目的jar包的时候改变默认的配置文件</p><p>比如，</p><p>java -jar 项目名.jar –spring.config.location=配置文件所在的磁盘路径/application.properties</p><hr><p>同样的，<strong>指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p></blockquote></li></ul><h4 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h4><ul><li><p>在上面的配置中，都是在开发的时候指定的配置文件，当我们开发好之后也是可以通过在jar包外指定配置文件的</p></li><li><p>SpringBoot也可以从以下位置加载配置；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</p></li><li><p>优先级从高到低</p><ol><li><p><strong>命令行参数</strong></p><blockquote><p>项目打包的时候 只打包src目录下的文件 而项目下的除了src目录中的内容是不会打包的  </p><p>那么可能就存在配置文件在这些目录中的情况  这样的话 就不会生效了</p><p>可以使用命令行参数的方式改变配置，比如，修改端口号和访问路径</p><p><code>java -jar 项目名.jar --server.port=8087  --server.context-path=/abc</code></p><p>多个配置用空格分开； <code>--配置项=值</code></p></blockquote></li><li><p>来自java:comp/env的JNDI属性</p></li><li><p>Java系统属性（System.getProperties()）</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.*属性值</p></li><li><p><strong>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p></li><li><p><strong>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><blockquote><p>6 7 8 9 如何记？</p><p>优先加载带profile的，都有perofile的，优先使用jar包外的application.properties</p><p>jar包外的配置文件，二者在同一个目录下</p><p><img src="https://blog.chasingwind.top/image-20200530232909549.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200530232909549.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>运行的时候直接使用<code>java -jar 项目名.jar</code> ，不需要输入任何参数，那么优先使用的配置文件就是这个外部的application.properties</p></blockquote></li><li><p>@Configuration注解类上的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol></li></ul><h3 id="自动配置原理（☆☆☆☆☆）"><a href="#自动配置原理（☆☆☆☆☆）" class="headerlink" title="自动配置原理（☆☆☆☆☆）"></a>自动配置原理（☆☆☆☆☆）</h3><p>在配置文件application.properties和application.yml中可以配置哪些属性呢？</p><ul><li>可以参考官方文档中给出的<a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/appendix-application-properties.html#common-application-properties">配置</a></li><li>其实能写在配置文件中的配置都是有依据的，通过对自动配置原理进行分析可以得知</li></ul><h4 id="自动配置原理分析（重点）"><a href="#自动配置原理分析（重点）" class="headerlink" title="自动配置原理分析（重点）"></a>自动配置原理分析（重点）</h4><ol><li><p>SpringBoot启动的时候加载主配置类，开启了自动配置功能**@EnableAutoConfiguration**</p><blockquote><p><strong>@EnableAutoConfiguration</strong>的功能</p><p><img src="https://blog.chasingwind.top/image-20200531140440441.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531140440441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>@AutoConfigurationPackage：将SpringBoot主程序所在的包及其子包中的组件扫描进IoC容器中</p></li><li><p>@Import(AutoConfigurationImportSelector.class)：使用AutoConfigurationImportSelector为容器中导入组件</p><ol><li><p>AutoConfigurationImportSelector类中的方法selectImports</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200531141426675.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531141426675.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>selectImports方法调用同一个类中的getCandidateConfigurations方法</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200531141505153.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531141505153.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>getCandidateConfigurations方法获取候选配置,其中使用<code>SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());</code>来获取配置</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200531141613793.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531141613793.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());</code></p><blockquote><p>SpringFactoriesLoader.loadFactoryNames()<br>扫描所有jar包类路径下  META-INF/spring.factories<br>把扫描到的这些文件的内容包装成properties对象</p><p><img src="https://blog.chasingwind.top/image-20200531142051400.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531142051400.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在第4步已经将META-INF/spring.factories中的内容包装成Properties对象之后</p><blockquote><p>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中<br>查看META-INF/spring.factories中的EnableAutoConfiguration.class类</p><p><img src="https://blog.chasingwind.top/image-20200531142520531.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531142520531.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看这些值</p><blockquote><p>都是xxxxAutoConfiguration，也就是自动配置类，这样的每一个类都是一个组件，被加入到容器中，进行自动配置</p><p><img src="https://blog.chasingwind.top/image-20200531143128874.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531143128874.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><hr><p>一句话总结：<code>@EnableAutoConfiguration</code>注解的功能就是，<strong>将类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；之后，完成自动配置的功能</strong></p></blockquote></li><li><p>每一个自动配置类完成自动配置的功能</p><ul><li><p>这里以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200531144133936.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531144133936.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进入到这个自动配置类中</p><blockquote><p>首先看类上面的注解</p><p><img src="https://blog.chasingwind.top/image-20200531144223112.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531144223112.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>@Configuration：表示当前类是一个配置类，代替我们以前使用的配置文件，可以向容器中添加组件</p><hr><p>@EnableConfigurationProperties(ServerProperties.class)：启用ServerProperties.class类的ConfigurationProperties功能，<strong>并将配置文件中的值和ServerProperties的属性绑定起来。并且把ServerProperties加入到IoC容器中</strong></p><p>查看ServerProperties.class类：</p><p>其中的<code>@ConfigurationProperties</code>注解的功能就是：<strong>从配置文件中获取指定的值和当前类中的属性进行绑定</strong></p><p><img src="https://blog.chasingwind.top/image-20200531145132595.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531145132595.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>所以说，<strong>在配置文件中可以进行的所有的配置都可以追溯到某一个Properties类中，比如这里的（ServerProperties类）</strong></p><hr><p>@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)：判断当前应用是否是Web应用，如果是的话，那么这个配置类就会生效；否则不生效</p><blockquote><p>底层使用的是Spring的@Conditional注解，根据不同的条件判断当前配置是否生效，如果满足指定的条件，整个配置类里面的配置就会生效； </p><p><img src="https://blog.chasingwind.top/image-20200531145940724.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531145940724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><hr><p>@ConditionalOnClass(CharacterEncodingFilter.class)：判断当前项目有没有CharacterEncodingFilter这个类以此来决定是否启用这个自动配置类；此类是SpringMVC中进行乱码解决的过滤器；</p><hr><p>@ConditionalOnProperty(prefix = “server.servlet.encoding”, value = “enabled”, matchIfMissing = true)：判断配置文件中是否存在某个配置  spring.http.encoding.enabled（prefix+value）；如果不存在，判断也是成立的（matchIfMissing = true）</p></blockquote></li><li><p>一句话总结：自动配置类会根据当前不同的条件判断，决定这个配置类是否生效。</p><blockquote><p>一旦这个配置类生效，这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p></blockquote></li></ul></li><li><p>SpringBoot的总结</p><ol><li><p><strong>SpringBoot启动会加载大量的自动配置类</strong></p></li><li><p><strong>我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p></li><li><p><strong>如果有对应的自动配置类，我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p></li><li><p><strong>给容器中自动配置类添加组件的时候，会从对应的xxxProperties类中获取某些属性。这些属性我们就可以在配置文件中进行配置；</strong></p></li><li><p>通过分析，我们可以看到每一个组件的命名都是统一的</p><blockquote><p>xxxxAutoConfigurartion：自动配置类；给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p></blockquote></li></ol></li></ol><h4 id="Conditional注解"><a href="#Conditional注解" class="headerlink" title="@Conditional注解"></a>@Conditional注解</h4><ul><li><p>在上面分析的过程中，有很多@ConditionalOnXxx注解，底层使用的都是Spring的@Conditional注解，表示必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效；</p></li><li><p>常见的@ConditionalOnXxx注解</p><blockquote><p><img src="https://blog.chasingwind.top/condition.png" class="lazyload" data-srcset="https://blog.chasingwind.top/condition.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Conditional注解"></p></blockquote></li><li><p>META-INF/spring.factories中的那么多自动配置类并不是都生效的，在这些自动配置类上几乎都有@ConditionalOnXxx注解进行条件的判断，满足的话才能生效</p></li><li><p>那么，我们怎么知道哪些自动配置类生效了？</p><blockquote><p>启用SpringBoot的Debug模式生成自动配置报告来了解哪些自动配置类生效了，哪些没有生效</p><p>在配置文件中配置Debug模式</p><p><img src="https://blog.chasingwind.top/image-20200531153200943.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531153200943.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>启动SpringBoot主程序，查看控制台</p><p>启用的：</p><p><img src="https://blog.chasingwind.top/image-20200531153310647.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531153310647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>没有启用的：</p><p><img src="https://blog.chasingwind.top/image-20200531153318229.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531153318229.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>不满足条件的：</p><p><img src="https://blog.chasingwind.top/image-20200531153400120.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200531153400120.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch</title>
      <link href="2020/07/03/ElasticSearch/"/>
      <url>2020/07/03/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<p>一个基于Lucene开发的全文检索服务器。简称es,es是一个开源的高扩展性的分布式全文检索引擎，实时性的存储、检索数据是它的最大的特点。</p><a id="more"></a><h2 id="ElasticSearch基本介绍"><a href="#ElasticSearch基本介绍" class="headerlink" title="ElasticSearch基本介绍"></a>ElasticSearch基本介绍</h2><ol><li><p>ElasticSearch简介</p><ul><li>一个基于Lucene开发的全文检索<strong>服务器</strong>。简称es,es是一个开源的高扩展性的分布式全文检索引擎，实时性的存储、检索数据是它的最大的特点。</li></ul></li><li><p>ElasticSearch使用案例</p><ul><li>Github在2013年抛弃Solr而转为使用ElasticSearch来处理PB级别的数据搜索</li><li>新浪处理实时日志</li><li>阿里构建自己的日志分析和分析体系</li></ul></li><li><p>ElasticSearch对比Solr</p><ul><li>Solr利用ZooKeeper进行分布式管理，而ElasticSearch使用的是自带的分布式协调管理功能</li><li>Solr支持更多的数据格式，而ElasticSearch仅支持json格式</li><li>Solr官方提供的功能更多，而ElasticSearch更注重核心的功能，高级功能可以通过插件进行扩展</li><li>Solr在传统的搜索应用中表现好于ElasticSearch，而在处理实时搜索的时候，ElasticSearch表现更加优秀</li></ul></li><li><p>查询的原理（倒排索引）</p><ol><li><p>首先，在ES服务器中对文档内容进行分词，并且将分词的内容存储在一个单独的分词库中</p></li><li><p>当用户去查询数据的时候，会将用户的查询内容进行分词</p></li><li><p>根据分词的结果去<strong>分词库</strong>中匹配内容，最终得到的是文档的id</p></li><li><p>根据id表示去存放数据的地方获取数据</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200528105728245.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528105728245.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="ElasticSearch安装"><a href="#ElasticSearch安装" class="headerlink" title="ElasticSearch安装"></a>ElasticSearch安装</h2><ol><li><p>ElasticSearch在Linux服务器上的安装</p><ol><li><p>下载<code>.tar.gz</code>文件， 使用<a href="tps://mirrors.huaweicloud.com/">华为镜像</a>进行下载更快</p></li><li><p>解压安装包到安装目录</p><blockquote><p>注意一点的是 ElasticSearch使用的是Java开发的，所以需要JDK的支持</p><p>7.7.0需要JDK至少为11版本</p><p><code>tar -xvzf elasticsearch-7.7.0-linux-x86_64.tar.gz</code></p><p>解压之后的目录</p><p><img src="https://blog.chasingwind.top/image-20200523104254435.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523104254435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在lib目录下可以看到，ElasticSearch其实底层使用的是Lucene</p><p><img src="https://blog.chasingwind.top/image-20200523104609039.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523104609039.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改config文件夹中的配置文件<code>elasticsearch.yml</code></p><blockquote><p>阿里云服务器的话  必须使用内网ip而不是公网ip  不然启动的时候会报错</p><p>同时需要创建data文件夹存储索引库</p><p>logs文件夹作为日志文件夹</p><pre><code class="yaml"># ---------------------------------- Cluster -----------------------------------## Use a descriptive name for your cluster:#配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。cluster.name: my-application## ------------------------------------ Node ------------------------------------## Use a descriptive name for the node:#节点名称node.name: node-1# ----------------------------------- Paths ------------------------------------## Path to directory where to store the data (separate multiple locations by comma):#索引库存储路径path.data: /usr/local/src/https://blog.chasingwind.top/data## Path to log files:#日志存储路径path.logs: /usr/local/src/https://blog.chasingwind.top/logs## ----------------------------------- Memory -----------------------------------## Lock the memory on startup:##bootstrap.memory_lock: true## Make sure that the heap size is set to about half the memory available# on the system and that the owner of the process is allowed to use this# limit.## Elasticsearch performs poorly when the system is swapping the memory.## ---------------------------------- Network -----------------------------------## Set the bind address to a specific IP (IPv4 or IPv6):#设置外网访问network.host: 阿里云服务器的内网ip## Set a custom port for HTTP:#对外服务端口号http.port: 9200transport.tcp.port: 9300## For more information, consult the network module documentation.## --------------------------------- Discovery ----------------------------------## Pass an initial list of hosts to perform discovery when this node is started:# The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]##discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]## Bootstrap the cluster using an initial set of master-eligible nodes:#cluster.initial_master_nodes: [&quot;node-1&quot;]</code></pre></blockquote></li><li><p>启动</p><blockquote><p>到bin目录下启动elasticsearch</p></blockquote></li><li><p>启动过程中遇到的错误</p><ol><li><p>启动过程中被Killed，查看日志，发现内存不够，由于ES是运行在JVM上，JVM本身除了分配的heap内存以外，还会用到一些堆外(off heap)内存。 在小内存的机器上跑ES，如果heap划分过多，累加上堆外内存后，总的JVM使用内存量可能超过物理内存限制。 如果swap又是关闭的情况下，就会被操作系统oom killer杀掉。</p><blockquote><p>修改ES中config目录下的<strong>jvm.options</strong>文件</p><p>vim jvm.options<br>将<br>-Xms1g<br>-Xmx1g<br>改为<br>-Xms256m<br>-Xmx256m<br>就启动成功了</p><hr><p>内存大小看你自己的情况 </p><p>我的虚拟机2G的内存 后面安装Kibana的话 给的是256 否则无法启动</p></blockquote></li><li><p>启动成功无法访问</p><blockquote><p>为阿里云的实例添加安全组策略</p><p><img src="https://blog.chasingwind.top/image-20200523163949166.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523163949166.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>进行访问，使用阿里云的<code>公网ip:9200</code></p><blockquote><p><img src="https://blog.chasingwind.top/image-20200523164055565.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523164055565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>ElasticSearch安装界面化工具</p><ul><li><p>使用同为ElasticSearch旗下的页面管理工具Kibana</p><ol><li><p>下载安装，直接使用命令<code>wget https://mirrors.huaweicloud.com/kibana/7.7.0/kibana-7.7.0-linux-x86_64.tar.gz</code></p></li><li><p>修改配置文件</p><blockquote><p>配置的是阿里云的私网ip，但是访问的时候，依然使用的是公网ip</p><p>同时配置实例的安全组策略</p><p><img src="https://blog.chasingwind.top/image-20200523172011505.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523172011505.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>启动bin目录下的kibana</p><blockquote><p>注意 需要在ElasticSearch已经启动的情况下启动 否则无法访问</p></blockquote></li><li><p>访问页面</p><blockquote><p>通过公网ip访问Kibana  目前没有索引库中的数据 后面需要进行添加的操作。</p><p><img src="https://blog.chasingwind.top/image-20200523172458912.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523172458912.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>设置中文</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200523172809750.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523172809750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200523183804664.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523183804664.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li><li><p>ElasticSearch和Kibana后台启动</p><blockquote><p>使用./elasticsearch和./kibana命令启动的话，把启动命令页面关闭，那么服务也随之关闭</p><p>使用后台启动的方式启动服务</p><p>ElasticSearch：<code>./bin/elasticsearch -d</code></p><p>Kibana：<code>nohup /usr/local/src/Kibana/bin/kibana &amp;</code></p></blockquote></li><li><p>ElasticSearch相关概念</p><ul><li><p>和关系型数据库进行对比</p><blockquote><p>ElasticSearch是面向文档的</p><hr><p>关系型数据库 →DataBases（多个数据库）→Tables→Rows→Columns</p><p>ElasticSearch →Indexes（多个索引库）→Types→Documents→Fields</p></blockquote></li><li><p>映射Mapping</p><blockquote><p>Mapping映射类似于<strong>数据库中表结构的定义</strong>，主要作用如下：</p><ul><li>定义索引库中的Field域的名字</li><li>定义字段类型，比如数值型、布尔型、浮点型等等</li><li>定义倒排索引相关的设置，比如，是否索引，是否存储，是否分析</li></ul></blockquote></li></ul></li></ol><h2 id="ElasticSearch索引库维护"><a href="#ElasticSearch索引库维护" class="headerlink" title="ElasticSearch索引库维护"></a>ElasticSearch索引库维护</h2><p>在ElasticSearch 7.x版本中移除了Type，参考<a href="https://blog.csdn.net/wangzhen3798/article/details/89503707">移除Type的原因参考</a></p><h3 id="PostMan发送http请求创建索引库"><a href="#PostMan发送http请求创建索引库" class="headerlink" title="PostMan发送http请求创建索引库"></a>PostMan发送http请求创建索引库</h3><ol><li><p>使用PostMan发送http请求创建索引库，并设置Field的Mapping</p><blockquote><p>查看官网示例后发现 7.4 默认不在支持指定索引类型（上面的Type），默认索引类型是_doc（隐含：include_type_name=false）</p><p><img src="https://blog.chasingwind.top/image-20200523211320642.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523211320642.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以我的服务器安装的7.7的请求是这样的</p><p>同时type的名字就是默认的<code>_doc</code></p><p><img src="https://blog.chasingwind.top/image-20200523213839784.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523213839784.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用Kibana查看创建的index索引库</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200523214516686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523214516686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见索引库的type是默认的<code>_doc</code></p><p><img src="https://blog.chasingwind.top/image-20200523214542416.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200523214542416.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="使用PostMan向索引库添加Document"><a href="#使用PostMan向索引库添加Document" class="headerlink" title="使用PostMan向索引库添加Document"></a>使用PostMan向索引库添加Document</h3><ol><li><p>指定Document的id</p><blockquote><p>请求的链接中的Type使用默认的<code>_doc</code>，并且为Document指定唯一的id </p><p><img src="https://blog.chasingwind.top/image-20200524091906716.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524091906716.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>执行成功  可以看到指定的id在索引库中的字段变为”_id”</p><p><img src="https://blog.chasingwind.top/image-20200524092809481.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524092809481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>不指定Document的id</p><blockquote><p>不指定id的话，ElasticSearch会自动帮我们生成Document的唯一的id</p><p><img src="https://blog.chasingwind.top/image-20200524094121248.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524094121248.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="使用Kibana查看索引库中的Document"><a href="#使用Kibana查看索引库中的Document" class="headerlink" title="使用Kibana查看索引库中的Document"></a>使用Kibana查看索引库中的Document</h3><ol><li><p>创建索引模式</p><blockquote><p>创建索引模式</p><p><img src="https://blog.chasingwind.top/image-20200524092936995.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524092936995.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>选择index索引库</p><p><img src="https://blog.chasingwind.top/image-20200524093044618.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524093044618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200524093104533.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524093104533.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在这里可以修改Mapping配置</p><p><img src="https://blog.chasingwind.top/image-20200524093132826.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524093132826.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote></li><li><p>查看索引库中的Document</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524093246346.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524093246346.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200524093327652.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524093327652.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="使用PostMan删除Document"><a href="#使用PostMan删除Document" class="headerlink" title="使用PostMan删除Document"></a>使用PostMan删除Document</h3><ul><li><p>根据Document文档的唯一id删除文档</p><blockquote><p>PostMan发送DELETE请求</p><p><img src="https://blog.chasingwind.top/image-20200524101449464.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524101449464.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>删除之前</p><p><img src="https://blog.chasingwind.top/image-20200524101400694.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524101400694.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>删除之后</p><p><img src="https://blog.chasingwind.top/image-20200524101543805.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524101543805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="使用PostMan修改文档"><a href="#使用PostMan修改文档" class="headerlink" title="使用PostMan修改文档"></a>使用PostMan修改文档</h3><ul><li><p>由于ElasticSearch底层使用的就是Lucene，所以和Lucene的原理是相同的。先删除文档，而后添加一个新的文档</p><blockquote><p>根据id直接修改文档的内容</p><p><img src="https://blog.chasingwind.top/image-20200524105130407.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524105130407.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="使用PostMan进行查询"><a href="#使用PostMan进行查询" class="headerlink" title="使用PostMan进行查询"></a>使用PostMan进行查询</h3><ol><li><p>根据Document的id进行查询</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524110346660.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524110346660.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>根据关键词进行查询</p><blockquote><p>域Lucene中的TermQuery功能相同</p><p>请求体中需要指定关键词所在的域和关键词本身</p><p>目前使用的是标准分析器 对于中文的话，一个汉字是一个关键词</p><p><img src="https://blog.chasingwind.top/image-20200524114347772.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524114347772.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>响应结果</p><p><img src="https://blog.chasingwind.top/image-20200524114439141.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524114439141.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>带分析功能的查询</p><blockquote><p>在ElasticSearch中使用QueryString进行查询，先将查询的语句使用分析器进行分析，之后再根据分析器分析的结果在默认的搜索域中进行查询</p><p>功能和Lucene中的QueryParser功能类似</p><p><img src="https://blog.chasingwind.top/image-20200524114837327.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524114837327.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200524114906521.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524114906521.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="使用PostMan查看分析器的分析效果"><a href="#使用PostMan查看分析器的分析效果" class="headerlink" title="使用PostMan查看分析器的分析效果"></a>使用PostMan查看分析器的分析效果</h3><ul><li><p>通过指定请求中的分析器类型和待分析的语句，在响应中可以查看分析之后的结果</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524120357865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524120357865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="ElasticSearch集成IK-Analyzer中文分析器"><a href="#ElasticSearch集成IK-Analyzer中文分析器" class="headerlink" title="ElasticSearch集成IK-Analyzer中文分析器"></a>ElasticSearch集成IK-Analyzer中文分析器</h2><ol><li><p>下载<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">IK-Analyzer插件</a>,选择和ElasticSearch对应的版本</p></li><li><p>将插件解压缩，上传到ElasticSearch目录的plugins目录下，并且重启ElasticSearch即可</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524141031816.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524141031816.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看分析效果</p><blockquote><p>IK-Analyzer提供两种分词算法：</p><p>ik_smart：最少切分</p><p><img src="https://blog.chasingwind.top/image-20200524150607746.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524150607746.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>ik_max_word：最细粒度划分 对可以分词的词语再次进行切分</p><p><img src="https://blog.chasingwind.top/image-20200524150528333.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524150528333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建索引库并配置IK-Analyzer作为分析器</p><blockquote><p>配置IK-Analyzer作为分析器</p><p><img src="https://blog.chasingwind.top/image-20200524151543427.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524151543427.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Document文档</p><p><img src="https://blog.chasingwind.top/image-20200524152636901.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524152636901.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查询结果</p><p><img src="https://blog.chasingwind.top/image-20200524152613718.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524152613718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="ElasticSearch集群"><a href="#ElasticSearch集群" class="headerlink" title="ElasticSearch集群"></a>ElasticSearch集群</h2><h3 id="ElasticSearch集群架构以及概念说明"><a href="#ElasticSearch集群架构以及概念说明" class="headerlink" title="ElasticSearch集群架构以及概念说明"></a>ElasticSearch集群架构以及概念说明</h3><ol><li><p>为什么需要搭建集群（Cluster）？</p><ol><li>高可用性：减少服务的不可用时间，使得服务在任何时候都可以使用，不能因为单个节点挂掉，而影响到整个服务</li><li>扩大存储空间：多台服务器可以扩大存储空间</li></ol></li><li><p>ElasticSearch的信息存储机制</p><ol><li><p>分片（Shard）</p><blockquote><p>分片，英文叫做 Shard，顾名思义，分片就是对数据切分成了多个部分。我们知道 Elasticsearch 中一个索引（Index）相当于是一个数据库，如存某网站的用户信息，我们就建一个名为 user 的索引。但索引存储的时候并不是整个存一起的，它是被分片存储的，Elasticsearch 默认会把一个索引分成五个分片，当然这个数字是可以自定义的。分片是数据的容器，数据保存在分片内，分片又被分配到集群内的各个节点里。当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里，所以相当于一份数据被分成了多份并保存在不同的主机上。</p></blockquote></li><li><p>副本（Replica）</p><blockquote><p>副本，英文叫做 Replica，同样顾名思义，副本就是对原分片的复制，和原分片的内容是一样的，Elasticsearch 默认会生成一份副本，所以相当于是五个原分片和五个分片副本，相当于一份数据存了两份，并分了十个分片，当然副本的数量也是可以自定义的。这时我们只需要将某个分片的副本存在另外一台主机上，这样当某台主机宕机了，我们依然还可以从另外一台主机的副本中找到对应的数据。所以从外部来看，数据结果是没有任何区别的。</p></blockquote></li></ol><ul><li>一般来说，Elasticsearch 会尽量把一个索引的不同分片存储在不同的主机上，分片的副本也尽可能存在不同的主机上，这样可以提高容错率，从而提高高可用性。</li></ul></li><li><p>节点的分类</p><ol><li>主节点：即 Master 节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。默认情况下任何一个集群中的节点都有可能被选为主节点。索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择。虽然主节点也可以协调节点，路由搜索和从客户端新增数据到数据节点，但最好不要使用这些专用的主节点。一个重要的原则是，尽可能做尽量少的工作。</li><li>数据节点：即 Data 节点。数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对 CPU、内存、IO 要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</li><li>负载均衡节点：也称作 Client 节点，也称作客户端节点。当一个节点既不配置为主节点，也不配置为数据节点时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。</li><li>预处理节点：也称作 Ingest 节点，在索引数据之前可以先对数据做预处理操作，所有节点其实默认都是支持 Ingest 操作的，也可以专门将某个节点配置为 Ingest 节点。</li></ol><ul><li>一个节点其实可以对应不同的类型，如一个节点可以同时成为主节点和数据节点和预处理节点，但如果一个节点既不是主节点也不是数据节点，那么它就是负载均衡节点。具体的类型可以通过具体的配置文件来设置。</li></ul></li></ol><h3 id="ElasticSearch集群搭建"><a href="#ElasticSearch集群搭建" class="headerlink" title="ElasticSearch集群搭建"></a>ElasticSearch集群搭建</h3><ul><li>通过配置每台ElasticSearch的配置文件，设置同一个集群名和各自的ip、端口以及配置其他节点的ip和端口，节点名就可以搭建一个集群，<a href="https://www.jianshu.com/p/15d6241e7844">节点配置参考</a></li></ul><h2 id="Java操作索引库增删改"><a href="#Java操作索引库增删改" class="headerlink" title="Java操作索引库增删改"></a>Java操作索引库增删改</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><ol><li><p>导入相关的依赖</p><blockquote><pre><code class="xml">&lt;dependency&gt;&lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;&lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;&lt;version&gt;7.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;&lt;artifactId&gt;transport&lt;/artifactId&gt;&lt;version&gt;7.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--ElasticSearch的高级API 在7.x版本中使用--&gt;&lt;dependency&gt;&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;version&gt;7.7.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></blockquote></li><li><p>在ElasticSearch7.x之前使用</p><blockquote><ol><li>创建Settings对象，配置集群的名字</li><li>创建client对象，配置节点的信息</li><li>使用client对象创建索引库</li><li>关闭client</li></ol><p><img src="https://blog.chasingwind.top/image-20200524173608096.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524173608096.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意：</p><p>端口使用的是TCP端口 9300</p></blockquote></li><li><p>在ElasticSearch 7.x版本之后</p><blockquote><ol><li>创建Settings对象。指定分片数和备份数</li><li>创建CreateIndexRequest对象，通常把这个方法封装成static方法</li><li>将Settings对象封装为Request对象</li><li>通过Client对象连接并创建索引</li></ol><p><img src="https://blog.chasingwind.top/image-20200524211703211.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524211703211.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意：</p><p>使用的端口是Http端口9200</p></blockquote></li><li><p>使用Kibana查看创建的索引库</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524212152063.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524212152063.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="设置索引的Mappings"><a href="#设置索引的Mappings" class="headerlink" title="设置索引的Mappings"></a>设置索引的Mappings</h3><ul><li><p>通过XContentBuilder设置Mappings的值并封装到Request对象中</p><blockquote><p>index属性表示当前Field是否可以作为条件进行查询  默认是true</p><p>store属性表示是否需要额外存储，默认是false， 他其实表示的是在源文档（_source）之外，在倒排索引中为这个字段单独存储，这样可以提高效率</p><p><img src="https://blog.chasingwind.top/image-20200524214740436.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524214740436.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="检查索引是否存在以及删除索引"><a href="#检查索引是否存在以及删除索引" class="headerlink" title="检查索引是否存在以及删除索引"></a>检查索引是否存在以及删除索引</h3><ol><li><p>检查索引是否存在</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524220651260.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524220651260.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>删除索引</p><blockquote><p>索引不存在的话 抛出异常</p><p><img src="https://blog.chasingwind.top/image-20200524221439290.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524221439290.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="向索引中添加文档"><a href="#向索引中添加文档" class="headerlink" title="向索引中添加文档"></a>向索引中添加文档</h3><ol><li><p>创建一个Person索引</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524224745334.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524224745334.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Person实体类，以便进行将数据转换为JSON</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524225129079.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524225129079.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>添加文档</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524224632931.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524224632931.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查看结果</p><blockquote><p>索引person和id使我们指定的  当然 type我们也可以指定</p><p><img src="https://blog.chasingwind.top/image-20200524225310078.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524225310078.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="修改和删除文档"><a href="#修改和删除文档" class="headerlink" title="修改和删除文档"></a>修改和删除文档</h3><ol><li><p>修改文档中的内容</p><blockquote><p>可以直接修改文档中的内容 而不需要删除再创建</p><p><img src="https://blog.chasingwind.top/image-20200524230503271.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524230503271.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/image-20200524230533984.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524230533984.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>根据id删除文档</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524230941966.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524230941966.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>已删除</p><p><img src="https://blog.chasingwind.top/image-20200524231008453.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524231008453.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>delete-by-query，删除符合查询条件的文档</p><blockquote><p>删除根据term，match查询的得到的文档</p><ul><li>如果需要删除索引库中的大部分内容，不推荐这个方式，因为这种方式底层还是根据id去一个一个删除对应的文档，推荐的做法是向一个新的索引库中添加不需要删除的文档</li></ul><hr><p><img src="https://blog.chasingwind.top/image-20200525223226858.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525223226858.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><ul><li><p>增删改查都是可以批量操作的</p><blockquote><p>使用BulkRequest对象 其中可以添加其他的request对象</p><p><img src="https://blog.chasingwind.top/image-20200524232444400.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524232444400.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现批量添加</p><blockquote><p>实现批量添加</p><p><img src="https://blog.chasingwind.top/image-20200524232414455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524232414455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查看结果</p><p><img src="https://blog.chasingwind.top/image-20200524232644214.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524232644214.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现批量删除</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200524232937344.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524232937344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/image-20200524232957572.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200524232957572.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="Java操作索引库查询"><a href="#Java操作索引库查询" class="headerlink" title="Java操作索引库查询"></a>Java操作索引库查询</h2><h3 id="创建索引库并添加文档"><a href="#创建索引库并添加文档" class="headerlink" title="创建索引库并添加文档"></a>创建索引库并添加文档</h3><ol><li><p>数据的实体类</p><blockquote><p>需要注意的一点就是 这里的格式规定需要与Field中规定的格式一致</p><p><img src="https://blog.chasingwind.top/image-20200525091500543.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525091500543.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建索引</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525091933658.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525091933658.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>添加文档</p><blockquote><p>使用BulkRequest批量添加文档</p><p><img src="https://blog.chasingwind.top/image-20200525092001188.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525092001188.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="Term查询"><a href="#Term查询" class="headerlink" title="Term查询"></a>Term查询</h3><ul><li><p>根据关键词进行查询，并且这个关键词不进行分词</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525104424801.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525104424801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200525105601766.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525105601766.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>关于获取响应数据的</p><p>查看响应格式</p><p><img src="https://blog.chasingwind.top/image-20200525104500992.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525104500992.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="Terms查询"><a href="#Terms查询" class="headerlink" title="Terms查询"></a>Terms查询</h3><ul><li><p>terms查询的功能类似于数据库查询中的in条件，可以有多个关键词</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525105454070.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525105454070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200525105520577.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525105520577.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/image-20200525105533742.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525105533742.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h3><ul><li>match查询会根据查询的字段类型不同，采取不同的查询方式<ul><li>查询的是日期或者是数值的话，match查询会将查询条件字符串转换为日期或者数值对待</li><li>如果查询的是一个不能被分词的内容（keyword），match查询不会对查询条件进行拆分</li><li>如果查询的是一个可以分词的内容（text），那么match会根据你的查询内容根据一定的方法分词，并去分词库中进行匹配</li></ul></li><li>match查询底层是多个Term查询</li></ul><ol><li><p>match_all：查询全部的数据，不需要指定条件。默认返回的结果中是10条数据,通过size可以设置</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525144623233.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525144623233.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>match</p><blockquote><p>先把查询的内容进行分词，然后再去分词库进行查找</p><p><img src="https://blog.chasingwind.top/image-20200525155658006.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525155658006.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>带Boolean类型的match</p><blockquote><p>AND 既包括A，又包括B</p><p><img src="https://blog.chasingwind.top/image-20200525160304208.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525160304208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>包含A或者B都可以</p><p><img src="https://blog.chasingwind.top/image-20200525160501031.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525160501031.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>multiMatch</p><blockquote><p>在多个字段中查询包含指定关键词的内容</p><p><img src="https://blog.chasingwind.top/image-20200525160951247.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525160951247.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="id查询"><a href="#id查询" class="headerlink" title="id查询"></a>id查询</h3><ul><li><p>根据Document的id进行查询</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525162130103.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525162130103.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="prefix前缀查询"><a href="#prefix前缀查询" class="headerlink" title="prefix前缀查询"></a>prefix前缀查询</h3><ul><li><p>查询的Field的前缀包含关键词的条目</p><blockquote><p>与百度提示的功能类似</p><p><img src="https://blog.chasingwind.top/image-20200525162455572.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525162455572.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200525162916503.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525162916503.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="fuzzy模糊查询"><a href="#fuzzy模糊查询" class="headerlink" title="fuzzy模糊查询"></a>fuzzy模糊查询</h3><ul><li><p>ElasticSearch根据输入的查询条件的内容的大概去匹配</p><blockquote><p>这个查询不稳定</p><p><img src="https://blog.chasingwind.top/image-20200525163556611.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525163556611.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="wildcard查询"><a href="#wildcard查询" class="headerlink" title="wildcard查询"></a>wildcard查询</h3><ul><li><p>功能和MySQL中的like功能相同，可以在查询的字符串中指定通配符*和占位符？</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525164607451.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525164607451.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>？的话  一个?是一个占位符</p></blockquote></li></ul><h3 id="针对数值类型的range查询"><a href="#针对数值类型的range查询" class="headerlink" title="针对数值类型的range查询"></a>针对数值类型的range查询</h3><ul><li><p>查询的字段必须是数值类型</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525165128813.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525165128813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="regexp正则表达式查询"><a href="#regexp正则表达式查询" class="headerlink" title="regexp正则表达式查询"></a>regexp正则表达式查询</h3><ul><li><p>使用正则表达式去匹配</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525165822373.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525165822373.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h3><h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4><blockquote><p>should：查询的结果中包括条件其中的一个即可，相当于或者or</p><p>must：查询的结果中必须包括，相当于and</p><p>must_not：查询的结果中不能包括，相当于not</p><p><img src="https://blog.chasingwind.top/image-20200525224848991.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525224848991.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h4 id="boosting查询"><a href="#boosting查询" class="headerlink" title="boosting查询"></a>boosting查询</h4><ul><li><p>boosting查询可以帮助我们去影响文档的score，从而改变结果的排序</p><blockquote><ol><li><p>positive：只有匹配上positive的查询的文档，才会放在结果集中</p></li><li><p>negative：如果匹配上了positive，并且也匹配上了negative，那么就可以降低score</p></li><li><p>negative_boost：指定系数，小于1.0。在第2种情况下乘以这个系数实现降低score的功能</p></li></ol></blockquote></li><li><p>在查询的时候，score是如何得到的</p><ol><li>搜索的关键字在文档中出现的频次越高，score越高</li><li>关键字占文档的比例越高，score越高</li><li>关键词被分词的时候，分词在分词库中匹配的越多，score越高</li></ol></li><li><p>Java实现</p><blockquote><p>表达的意思就是   在smsContent中包含安徽省的情况下 ，如果 smsContent中还包含芜湖  那么这个文档的score就乘以0.5</p><p><img src="https://blog.chasingwind.top/image-20200525230627250.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525230627250.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="filter过滤查询"><a href="#filter过滤查询" class="headerlink" title="filter过滤查询"></a>filter过滤查询</h3><ul><li><p>query与filter的对比</p><blockquote><p>query：根据查询条件，去计算文档的匹配度，得到一个score，依此进行文档的排序，并且是<strong>不进行缓存</strong>的。</p><p>filter：根据查询条件去查询文档，不计算分数，而且filter对经常过滤的数据进行缓存。</p><hr><p>当查询的数据不需要进行排序的时候，选择filter的效率更高</p></blockquote></li><li><p>Java实现</p><blockquote><p>可见，所有的score都是0  效率比query高</p><p><img src="https://blog.chasingwind.top/image-20200525232235280.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525232235280.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h3><ul><li><p>高亮查询就是将用户输入的关键字，以一定的样式展示给用户，让用户知道这个结果为什么被检索出来</p></li><li><p>高亮的数据，是Field自带的属性，在响应的数据中，单独作为一个字段返回</p></li><li><p>ES提供了一个highlight属性，和query同级别</p><blockquote><p>fields：指定哪些Field字段以高亮形式返回</p><p>Fragment_size：指定高亮数据展示多个字符回来</p><p>Pre_tags：指定前缀标签</p><p>Post_tags：指定后缀标签</p></blockquote></li><li><p>Kibana实现</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525233719877.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525233719877.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>响应数据</p><p><img src="https://blog.chasingwind.top/image-20200525233741711.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525233741711.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Java实现</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525234654842.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525234654842.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><ul><li>聚合查询（aggregation）的功能和MySQL中的聚合查询的功能相似，而且更加强大</li></ul><h4 id="cardinality去重计数查询"><a href="#cardinality去重计数查询" class="headerlink" title="cardinality去重计数查询"></a>cardinality去重计数查询</h4><ol><li><p>先将返回的文档中的一个指定的field去重</p></li><li><p>在去重之后统计一共有多少条数据</p><blockquote><p>比如，我要统计所有的文档中的province字段一共有几种</p><p>RESTful请求  其中agg这个Name是与结果中相对应的 可以自己任意取</p><p><img src="https://blog.chasingwind.top/image-20200528082716376.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528082716376.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Java实现</p><p><img src="https://blog.chasingwind.top/image-20200528084229630.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528084229630.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="range范围统计"><a href="#range范围统计" class="headerlink" title="range范围统计"></a>range范围统计</h4><ul><li>统计一定范围内出现的文档个数，比如，针对某一个Field值在0-100，100-200，200-300之间出现的文档的个数</li><li>范围统计可以针对普通的数值（range），针对时间的类型（date_range），针对ip类型（ip_range）都可以做相应的统计</li></ul><ol><li><p>数值查询</p><blockquote><p>from包含等于的情况 to不包含等于的情况</p><p>RESTful实现</p><p><img src="https://blog.chasingwind.top/image-20200528085136370.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528085136370.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Java代码实现</p><p><img src="https://blog.chasingwind.top/image-20200528092403857.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528092403857.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/image-20200528092610909.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528092610909.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>时间范围统计</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200528085755730.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528085755730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Java实现</p><p><img src="https://blog.chasingwind.top/image-20200528092644668.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528092644668.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/image-20200528092657302.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528092657302.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>ip范围统计</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200528090151602.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528090151602.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/image-20200528093018155.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528093018155.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="extended-stats聚合查询"><a href="#extended-stats聚合查询" class="headerlink" title="extended_stats聚合查询"></a>extended_stats聚合查询</h4><ul><li><p>查询指定Field的最大值，最小值，平均值和平方和等等</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200528101040129.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528101040129.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Java实现</p><p><img src="https://blog.chasingwind.top/image-20200528101711724.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528101711724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h4 id="其他聚合查询"><a href="#其他聚合查询" class="headerlink" title="其他聚合查询"></a>其他聚合查询</h4><ul><li>查看官网中的文档<a href="https://www.elastic.co/guide/en/https://blog.chasingwind.top/reference/current/search-aggregations.html">Aggregations</a></li></ul><h2 id="深分页Scroll"><a href="#深分页Scroll" class="headerlink" title="深分页Scroll"></a>深分页Scroll</h2><h3 id="分页功能比较"><a href="#分页功能比较" class="headerlink" title="分页功能比较"></a>分页功能比较</h3><ul><li><p>from+size实现分页的功能</p><blockquote><ol><li>将用户指定的关键词进行分词</li><li>根据分词结果去索引库中进行查询，获得文档的id</li><li>去每个库中拉取分片获取数据</li><li>根据匹配程度score进行排序</li><li>根据from的值，将查询到的数据抛去一部分</li><li>返回结果</li></ol><hr><p>在第4步和第5步是比较耗时的</p><p>如果需要下一页的数据  那么就需要重新执行上面的过程</p></blockquote></li><li><p>Scroll+size实现分页的功能</p><blockquote><ol><li>将用户指定的关键词进行分词</li><li>根据分词结果去分词库中进行检索，获得文档的id</li><li>将文档的id存储在ES的上下文中（可以理解为内存），id已经排序，可忽略</li><li>根据用户指定的size去ES的上下文中拿去指定个数的id，拿完之后，这些id就从上下文中移除了</li><li>如果还需要下一页的数据，直接在ES的上下文中，找后续的内容</li></ol><hr><p>此方法不适合实时数据，因为除了第一次，都是在上下文中取文档的id</p><p>用户需要下一页的数据，不需要重新执行整个过程，只需要重复第4步和第5步，直到上下文中的数据全部拿空</p></blockquote></li></ul><h3 id="使用Kibana实现Scroll分页"><a href="#使用Kibana实现Scroll分页" class="headerlink" title="使用Kibana实现Scroll分页"></a>使用Kibana实现Scroll分页</h3><ol><li><p>查询全部的数据，并为文档的id创建上下文</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200525213822392.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525213822392.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>响应回来的有scrollId</p><p><img src="https://blog.chasingwind.top/image-20200525213942324.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525213942324.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>下一页</p><blockquote><p>我们只需要指定上下文的id以及时长即可</p><p>size的话 还是根据第一次的size来的</p><p><img src="https://blog.chasingwind.top/image-20200525214412033.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525214412033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>不指定时长的话  默认为0 也就是这个scrollId就会被删除</p></blockquote></li><li><p>删除scrollId</p><ul><li><blockquote><p>只需要指定scrollId即可</p><p><img src="https://blog.chasingwind.top/image-20200525214711424.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525214711424.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>响应结果</p><p><img src="https://blog.chasingwind.top/image-20200525214721843.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525214721843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>删除之后再查询下一页 就报错</p><p><img src="https://blog.chasingwind.top/image-20200525214830015.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525214830015.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h3 id="使用Java实现深分页"><a href="#使用Java实现深分页" class="headerlink" title="使用Java实现深分页"></a>使用Java实现深分页</h3><ol><li><p>实现首页，下一页以及最后一页的功能</p><blockquote><p>需要注意的一点是 除了最后一次 都需要设置ScrollId的存活时长</p><p><img src="https://blog.chasingwind.top/image-20200525221653649.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200525221653649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h1 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h1><h2 id="SpringData-ElasticSearch简介"><a href="#SpringData-ElasticSearch简介" class="headerlink" title="SpringData ElasticSearch简介"></a>SpringData ElasticSearch简介</h2><blockquote><p>Spring Data Elasticsearch基于Spring Data API简化ElasticSearch的操作，将原始的ElasticSearch的客户端API进行封装，项目将核心Spring概念应用于使用Elasticsearch搜索引擎开发解决方案。为我们提供了一个“模板”作为高级抽象，用于存储、查询、排序和面对文档。<a href="https://spring.io/projects/spring-data-elasticsearch">Spring Data ElasticSearch</a></p></blockquote><h2 id="Spring-Data-ElasticSearch入门"><a href="#Spring-Data-ElasticSearch入门" class="headerlink" title="Spring Data ElasticSearch入门"></a>Spring Data ElasticSearch入门</h2><ol><li><p>导入相关依赖</p><blockquote><pre><code class="xml"> &lt;dependency&gt;   &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;   &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt;   &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre><hr><p>版本信息的话 可以去官网查看对应的版本</p></blockquote></li><li><p>创建配置文件</p><blockquote><pre><code class="xml">&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:elasticsearch=&quot;https://www.springframework.org/schema/data/elasticsearch&quot;    xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans    https://www.springframework.org/schema/beans/spring-beans-3.1.xsd    https://www.springframework.org/schema/data/elasticsearch    https://www.springframework.org/schema/data/https://blog.chasingwind.top/spring-elasticsearch-1.0.xsd&quot;&gt; &lt;!--ES 客户端配置--&gt; &lt;elasticsearch:transport-client id=&quot;esClient&quot; cluster-name=&quot;my-application&quot; cluster-nodes=&quot;xinhuacloud.tech:9200&quot;&gt;&lt;/elasticsearch:transport-client&gt; &lt;!--配置包扫描器  扫描接口所在的包--&gt; &lt;elasticsearch:repositories base-package=&quot;edu.ahnu.repository&quot;&gt;&lt;/elasticsearch:repositories&gt; &lt;!----&gt; &lt;bean id=&quot;elasticsearchTemplate&quot; class=&quot;org.springframework.data.elasticsearch.core.ElasticsearchTemplate&quot;&gt;     &lt;constructor-arg name=&quot;client&quot; ref=&quot;esClient&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><p>在官网中的约束文件</p><p><img src="https://blog.chasingwind.top/image-20200528161634183.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528161634183.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h2><ol><li><p>创建一个实体类，实体类中的字段就是Document中的Field的内容</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200528163930800.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528163930800.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建一个接口，继承ElasticSearchRepository接口</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200528164141550.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528164141550.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>CrudRepository接口</p><p><img src="https://blog.chasingwind.top/image-20200528172345896.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528172345896.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>其中的方法</p><p><img src="https://blog.chasingwind.top/image-20200528172412231.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528172412231.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写测试代码</p><blockquote><p>需要添加spring相关的包</p><pre><code class="xml"> &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;   &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-test&lt;/artifactId&gt;   &lt;version&gt;4.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;   &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre><hr><p><img src="https://blog.chasingwind.top/image-20200528171709194.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528171709194.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h2><ul><li><p>CrudRepository接口中的save方法</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200528203005735.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200528203005735.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene</title>
      <link href="2020/07/03/Lucene/"/>
      <url>2020/07/03/Lucene/</url>
      
        <content type="html"><![CDATA[<p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎.</p><a id="more"></a><h2 id="全文检索的概念"><a href="#全文检索的概念" class="headerlink" title="全文检索的概念"></a>全文检索的概念</h2><ol><li><p>数据的分类</p><ol><li><p>结构化数据</p><blockquote><p>指具有固定格式或有限长度的数据，如数据库，元数据等</p></blockquote></li><li><p>非结构化数据</p><blockquote><p>指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件,HTML文件等等</p></blockquote></li></ol></li><li><p>数据的查询</p><ol><li><p>结构化数据的查询</p><blockquote><p>结构化查询语言，也就是SQL</p></blockquote></li><li><p>非结构化数据的查询</p><ol><li><p>顺序扫描法：比如顺序匹配字符串</p></li><li><p>全文检索：先建立索引，再对索引进行搜索的过程。索引的建立虽然比较耗时，但是一旦创建好索引之后，后面就可以一直使用，所以，表现上就是每次查询的速度都很快。</p><blockquote><p><strong>将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</strong>这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。</p></blockquote></li></ol></li></ol></li><li><p>全文检索的应用场景</p><ol><li>搜索引擎</li><li>站内搜索</li><li>电商搜索</li><li>只要是有搜索的地方都可以使用全文搜索</li></ol></li></ol><h2 id="Lucene实现全文检索的流程"><a href="#Lucene实现全文检索的流程" class="headerlink" title="Lucene实现全文检索的流程"></a>Lucene实现全文检索的流程</h2><ol><li><p>Lucene简介</p><blockquote><p>Lucene是Apache基金会下的开源的全文检索引擎工具包，<strong>但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构</strong>，提供完整的查询引擎和索引引擎，部分文本分析引擎（英文和德文）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。</p></blockquote></li><li><p>Lucene实现全文检索的流程</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522093002849.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522093002849.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>绿色表示<strong>索引过程</strong>，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：</p><p>确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档</p><p>红色表示<strong>搜索过程</strong>，从索引库中搜索内容，搜索过程包括：</p><p>用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果</p></blockquote><ol><li><p>获得原始文档</p><p>原始文档：要基于哪些数据进行搜索，那么这些数据就是原始文档</p></li><li><p>构建文档对象</p><p>对每个原始文档创建Document（文档）对象，文档对象中包含多个键值对形式的Field（域）。每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同）</p><p>每个文档都有一个唯一的编号，就是文档id。</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522093930948.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522093930948.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>分析文档（分词的过程），这里拿英文进行举例</p><ol><li><p>根据空格进行字符串拆分，得到一个单词列表</p></li><li><p>把单词统一转换为小写</p></li><li><p>去除标点符号</p></li><li><p>去除停用词</p><blockquote><p>停用词：无意义的词，比如：a，the，and等等</p></blockquote></li><li><p>将每个关键词封装成一个Term对象</p><blockquote><p>Term对象包含两部分：</p><ol><li>关键词所在的域（Field）</li><li>关键词本身</li></ol><hr><p>不同的域中拆分出来的相同的关键词不是同一个Term对象</p></blockquote></li></ol></li><li><p>创建索引</p><p>基于关键词列表创建一个索引，保存到索引库（磁盘上的文件，一次创建可以多次使用）中。</p><p>索引库中的内容：</p><ol><li><p>索引：最终实现通过搜索被索引的关键词从而找到Document对象。</p></li><li><p>Document对象</p></li><li><p>关键词和文档的对应关系</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522101241266.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522101241266.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol start="4"><li>倒排索引结构：根据关键词找到对应的文档，而不是像传统的先找到文档，再在文档中进行搜索</li></ol><blockquote><p>根据内容找文档，使用的是链表的实现方式</p><p>图中的链表中的数字表示的就是文档的id</p><p><img src="https://blog.chasingwind.top/image-20200522101509207.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522101509207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>查询索引</p><ol><li><p>用户查询接口：用户输入查询条件的地方，比如百度的搜索框</p></li><li><p>将用户的输入封装成一个查询对象</p><p>查询对象中包括：要查询的域以及要搜索的关键词</p></li><li><p>执行查询</p><ol><li><p>根据要查询的关键词到对应的域中进行搜索</p></li><li><p>找到关键词，根据关键词找到对应的文档id（倒排索引结构）</p><blockquote><p>比如搜索语法为“fileName:lucene”表示搜索出fileName域中包含lucene的文档。</p><p>搜索过程就是在索引上查找域为fileName，并且关键字为Lucene的term，并根据term找到文档id列表。</p></blockquote></li></ol></li><li><p>渲染结果</p><p>根据查询出来的文档的id，将内容渲染出来展示给用户</p></li></ol></li></ol></li></ol><h2 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h2><p>实现读取磁盘上的多个文件，在这多个文件中进行全文检索。</p><ol><li><p>环境搭建</p><blockquote><p>Maven依赖</p><pre><code class="xml">&lt;dependency&gt;   &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;   &lt;artifactId&gt;lucene-core&lt;/artifactId&gt;   &lt;version&gt;8.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;   &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;   &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt;   &lt;version&gt;8.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--用于io--&gt; &lt;dependency&gt;   &lt;groupId&gt;commons-io&lt;/groupId&gt;   &lt;artifactId&gt;commons-io&lt;/artifactId&gt;   &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></blockquote></li><li><p>创建索引</p><ol><li><p>创建一个Directory对象，指定索引库保存的位置</p></li><li><p>基于Directory对象创建一个IndexWriter对象，参数为索引库保存的位置和IndexWriterConfig对象</p></li><li><p>读取磁盘上的文件，对应每个文件创建一个Document对象</p></li><li><p>向Document文档对象中添加域</p></li><li><p>把Document文档对象写入到索引库</p></li><li><p>关闭IndexWriter对象</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522143545686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522143545686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行结果</p><blockquote><p>运行生成的文件如图</p><p><img src="https://blog.chasingwind.top/image-20200522143702109.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522143702109.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以使用luke来查看索引库中的内容</p></blockquote></li></ol></li><li><p>查询索引库</p><ol><li><p>创建Directory对象，指定索引库的位置</p></li><li><p>创建IndexReader对象</p></li><li><p>创建IndexSearcher对象，构造方法中的参数是IndexReader对象</p></li><li><p>创建Query对象，这里使用最简单的TermQuery</p></li><li><p>执行查询，得到结果TopDocs对象</p></li><li><p>取出查询结果的总记录数，毕竟不能把所有的数据都查询出来，有的数据几万条，使用分页来处理</p></li><li><p>取出文档列表</p></li><li><p>打印文档中的内容</p></li><li><p>关闭IndexReader对象</p><blockquote><p>查询索引库中content域中的spring</p><p><img src="https://blog.chasingwind.top/image-20200522151343330.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522151343330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行结果</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522151645649.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522151645649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="中文分析器"><a href="#中文分析器" class="headerlink" title="中文分析器"></a>中文分析器</h2><ol><li><p>分析器对象分析效果查看</p><ul><li><p>分析器是将域对象（Field）中的内容分解为索引表中的最基本的Term单元，上面默认使用的是StandardAnalyzer对象</p><blockquote><p>StandardAnalyzer对象在哪里使用的呢？</p><pre><code class="java">IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig());</code></pre><p>IndexWriterConfig对象的无参构造中默认设置的默认分析器</p><pre><code class="java">public IndexWriterConfig() &#123;     this(new StandardAnalyzer()); &#125;</code></pre></blockquote></li><li><p>查看分析器的分析效果</p><p>使用所有分析器的顶层抽象父类Analyzer中的<code>analyzer.tokenStream()</code>方法返回TokenStream对象，该对象中就包含了最终的分析结果</p></li><li><p>实现步骤</p><ol><li><p>创建一个Analyzer对象</p></li><li><p>使用分析器对象的tokenStream方法获取TokenStream对象</p></li><li><p>为TokenStream对象设置一个引用，便于遍历</p></li><li><p>调用TokenStream对象reset方法，将指针指向初始的位置</p></li><li><p>使用while循环遍历TokenStream对象</p></li><li><p>关闭TokenStream对象</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522155625073.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522155625073.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>分析的内容</p><pre><code>The Spring Framework provides a comprehensive programming and configuration model.</code></pre><hr><p>分析结果</p><p><img src="https://blog.chasingwind.top/image-20200522155725396.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522155725396.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li><li><p>中文分析器</p><ul><li><p>上述的标准分析器对于中文的分析效果</p><blockquote><p>英文分析出来了，但是中文的话，是一个字一个字进行拆分</p><p><img src="https://blog.chasingwind.top/image-20200522160029173.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522160029173.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的问题就是 当我们要去索引库查询，比如 查询 “分析器”这个单词 那么命中的结果就是0 因为索引库中根本就不存在这个关键词</p></blockquote></li><li><p>第三方中文分析器IK-Analyser</p><ol><li><p>导入pom依赖</p><pre><code class="xml"> &lt;!--中文分析器--&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.github.magese&lt;/groupId&gt;      &lt;artifactId&gt;ik-analyzer&lt;/artifactId&gt;      &lt;version&gt;8.3.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre></li><li><p>可以配置分析器使用的扩展词典和停用词词典，我这里没有配置使用的是默认的词典</p></li><li><p>分析结果</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522161211996.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522161211996.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>在创建索引库的时候设置使用IK-Analyser</p><blockquote><p>设置IndexWriterConfig对象</p><p><img src="https://blog.chasingwind.top/image-20200522161844520.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522161844520.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="索引库维护"><a href="#索引库维护" class="headerlink" title="索引库维护"></a>索引库维护</h2><p>虽然索引库已经建立，但是索引库并不是一成不变的，后期可能会对索引库进行增删改的操作，所以需要对索引库进行维护。</p><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><p>与创建索引的过程相同，之前是一次添加好多个原始文档，这里的添加是添加需要的文档。</p><ol><li><p>常用的Field域对象的使用，不同类型的数据该用哪一种Field域对象进行存储</p><blockquote><p><strong>是否分析</strong>：<strong>是否对域的内容进行分词处理</strong>。前提是我们要对域的内容进行查询。将数据进行分词并存储到Field域中就是在这个时候进行的。</p><p><strong>是否索引</strong>：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。</p><p><strong>是否存储</strong>：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。<strong>是否存储的标准：是否要将内容展示给用户</strong></p><p><img src="https://blog.chasingwind.top/image-20200522173402124.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522173402124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>之前的程序改造</p><blockquote><p>对于文件的路径和文件的大小</p><p><img src="https://blog.chasingwind.top/image-20200522192918305.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522192918305.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>添加文档</p><blockquote><p>添加文档到索引库中，并不会把之前的索引覆盖</p><p>存储与否并不影响查询，知识影响我们能不能把值取出来</p><p><img src="https://blog.chasingwind.top/image-20200522202510955.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522202510955.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><ol start="0"><li><p>初始化</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522203335728.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522203335728.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>删除全部文档</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522203401300.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522203401300.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>根据查询删除</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522203413198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522203413198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><ul><li><p>修改的原理：先删除原来的文档，然后添加一个新的文档，原先文档的id并不会被占用。</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522212001993.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522212001993.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>执行过后，索引库中不再有name中包含spring的文档 ，然后增加一个文档</p></blockquote></li></ul><h2 id="索引库的查询"><a href="#索引库的查询" class="headerlink" title="索引库的查询"></a>索引库的查询</h2><ol><li><p>TermQuery：根据关键词进行查询，需要指定查询的域以及关键词</p></li><li><p>数值范围查询</p><blockquote><p>可以查询出使用LongPoint，IntPoint存储数值类型的数据</p><p><img src="https://blog.chasingwind.top/image-20200522214615355.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522214615355.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>QueryParser：先将需要查询的语句进行分词，之后基于分词的结果再进行查询操作</p><blockquote><p>比如，要去搜索引擎搜索一句话，那么显然不能使用TermQuery进行查询的操作</p><p>使用QueryParser先对查询的内容进行分词，然后再进行查询的操作</p></blockquote><ol><li><p>添加依赖</p><blockquote><pre><code class="xml">&lt;!--queryparser--&gt; &lt;dependency&gt;   &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;   &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt;   &lt;version&gt;8.3.0&lt;/version&gt; &lt;/dependency&gt; </code></pre></blockquote></li><li><p>使用步骤</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522220214071.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522220214071.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>结果</p><blockquote><p><img src="https://blog.chasingwind.top/image-20200522220315967.png" class="lazyload" data-srcset="https://blog.chasingwind.top/image-20200522220315967.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lucene </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后台管理系统功能实现(二)</title>
      <link href="2019/10/16/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B02/"/>
      <url>2019/10/16/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B02/</url>
      
        <content type="html"><![CDATA[<p>本节主要完成用户操作，角色操作，资源权限操作以及权限关联与控制的操作。另外，还对用户的操作加入了日志，使用AOP的方式实现日志的操作，并存储到数据库中。</p><a id="more"></a><h2 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h2><ul><li>在上一节中我们完成了用户的登录与退出，这一节我们完成其他的关于用户的操作</li></ul><h3 id="用户的查询"><a href="#用户的查询" class="headerlink" title="用户的查询"></a>用户的查询</h3><ul><li><p>查询所有用户的流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571237033868.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571237033868.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>当我们点击菜单中的用户管理 执行对应的Controller</p><blockquote><p><img src="https://blog.chasingwind.top/1571237092656.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571237092656.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller层中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571238397099.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571238397099.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service层</p><blockquote><p><img src="https://blog.chasingwind.top/1571238415349.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571238415349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao层中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571238439245.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571238439245.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>设置账号的状态</p><blockquote><p><img src="https://blog.chasingwind.top/1571238465345.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571238465345.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>成功展示</p></li></ul><h3 id="用户的添加"><a href="#用户的添加" class="headerlink" title="用户的添加"></a>用户的添加</h3><ul><li><p>添加用户的流程分析</p><blockquote><ul><li>添加完成后跳转的页面</li><li>添加密码的时候将密码存储到数据库中的时候密码是加密的</li></ul><p><img src="https://blog.chasingwind.top/1571238536704.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571238536704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>关于密码加密  在之前的Service中  我们将UserInfo转换为User的时候 密码前面需要添加<code>&quot;&#123;noop&#125;&quot;</code>就是对密码进行加密  如果我们处理了密码加密  那么在后续的Service中转换的时候就不需要<code>&quot;&#123;noop&#125;&quot;</code>这个字段了</p><p><img src="https://blog.chasingwind.top/1571238716267.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571238716267.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在user-add.jsp页面完成添加</p><blockquote><p>添加用户的信息的表单</p><p><img src="https://blog.chasingwind.top/1571276067858.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571276067858.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>添加用户的Controller</p><blockquote><p><img src="https://blog.chasingwind.top/1571276611385.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571276611385.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>添加用户的Service</p><blockquote><p><img src="https://blog.chasingwind.top/1571276627958.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571276627958.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>添加用户的Dao</p><blockquote><p><img src="https://blog.chasingwind.top/1571276648961.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571276648961.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>对密码进行加密（配置文件的方式）</p><blockquote><p>在Service中对密码进行加密</p><p>使用SpringSecurity为我们提供的<code>BCryptPasswordEncoder</code>类来完成加密的操作</p><p>我们可以在配置文件中来完成配置</p><p>首先，在配置文件中将加密类交给IoC来进行管理</p><p><img src="https://blog.chasingwind.top/1571276931726.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571276931726.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在Service中对密码进行加密  这样在Dao中拿到的就是加密之后的密码</p><p><img src="https://blog.chasingwind.top/1571276992405.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571276992405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p><img src="https://blog.chasingwind.top/1571278592704.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571278592704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>保存成功</p></blockquote></li><li><p>新添加的用户的登录</p><blockquote><p>我们在向数据库中添加用户的时候 对密码进行了加密处理</p><p>而我们在登录的时候  需要从数据库中查询进行验证的过程中，需要对密码进行解密处理  这样才能成功登录</p><p>我们可以在配置文件中告诉Service  密码是加密的</p><p><img src="https://blog.chasingwind.top/1571278854261.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571278854261.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样 在我们登录的过程中  密码就会进行解密  然后进行验证</p><hr><p>另外还有一点就是 我们已经对密码进行了加密  这个时候就不需要“{noop}”了</p><p><img src="https://blog.chasingwind.top/1571278943032.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571278943032.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用新用户登录 可以登录成功</p><p>另外 还需要对之前的用户的密码进行加密 将加密之后的结果存储在数据库中</p></blockquote></li></ul><h3 id="用户详情"><a href="#用户详情" class="headerlink" title="用户详情"></a>用户详情</h3><ul><li>查询用户的所有信息</li></ul><ol><li><p>用户详情流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571279894865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571279894865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>需要在查询用户的时候将用户的Role以及Role关联的Permission同时查询出来</p><p>并且要将这些信息都展示在页面上</p></blockquote></li><li><p>user-list.jsp向Controller发送请求</p><blockquote><p>向user/findById发送请求  并且携带用户的id进行请求</p><p><img src="https://blog.chasingwind.top/1571280090358.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571280090358.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller层处理请求</p><blockquote><p><img src="https://blog.chasingwind.top/1571286074481.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571286074481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service层</p><blockquote><p><img src="https://blog.chasingwind.top/1571286093103.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571286093103.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao层</p><blockquote><p>我们需要根据用户的id查询出用户的信息(UserInfo) , 以及Role的信息(Role),还有Role关联的权限(Permission)的信息</p><p>首先是UserInfo实体类  其中有Role的引用</p><p><img src="https://blog.chasingwind.top/1571286200502.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571286200502.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在UserDao中进行封装</p><p><img src="https://blog.chasingwind.top/1571286276872.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571286276872.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Role实体类中包含Permission的引用</p><p><img src="https://blog.chasingwind.top/1571286356670.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571286356670.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>RoleDao中  需要封装Permission的信息</p><p><img src="https://blog.chasingwind.top/1571288401826.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571288401826.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>PermissionDao中的方法  根据Role的id查询Permission</p><p><img src="https://blog.chasingwind.top/1571286390033.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571286390033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>效果演示</p><blockquote><p>因为我还没有给用户添加权限  所以用户的角色没有下拉框的内容</p><p><img src="https://blog.chasingwind.top/1571379584508.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571379584508.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="角色操作"><a href="#角色操作" class="headerlink" title="角色操作"></a>角色操作</h2><h3 id="查询所有角色"><a href="#查询所有角色" class="headerlink" title="查询所有角色"></a>查询所有角色</h3><ol><li><p>流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571379840037.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571379840037.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在页面左侧点击角色管理 向Controller发送请求  展示所有的角色</p><blockquote><p><img src="https://blog.chasingwind.top/1571380045193.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571380045193.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller层</p><blockquote><p>页面中用的是roleList来接收数据的</p><p><img src="https://blog.chasingwind.top/1571380886120.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571380886120.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service层</p><blockquote><p><img src="https://blog.chasingwind.top/1571380920690.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571380920690.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao层 查找所有的角色</p><blockquote><p><img src="https://blog.chasingwind.top/1571380944025.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571380944025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="角色的添加"><a href="#角色的添加" class="headerlink" title="角色的添加"></a>角色的添加</h3><ol><li><p>流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571381241886.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571381241886.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在role-list.jsp页面中点击新建跳转页面到role-add.jsp</p><blockquote><p><img src="https://blog.chasingwind.top/1571381302692.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571381302692.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>role-add.jsp页面中</p><blockquote><p>​    提交到的路径</p><p><img src="https://blog.chasingwind.top/1571381420892.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571381420892.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller中的方法save用来保存角色</p><blockquote><p>重定向到findAll</p><p><img src="https://blog.chasingwind.top/1571382039705.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571382039705.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service</p><blockquote><p><img src="https://blog.chasingwind.top/1571382055426.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571382055426.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao</p><blockquote><p><img src="https://blog.chasingwind.top/1571382071265.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571382071265.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p><img src="https://blog.chasingwind.top/1571381964801.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571381964801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们新建  输入信息之后 保存 然后测试成功</p></blockquote></li></ol><h2 id="资源权限操作"><a href="#资源权限操作" class="headerlink" title="资源权限操作"></a>资源权限操作</h2><h3 id="查询所有资源权限"><a href="#查询所有资源权限" class="headerlink" title="查询所有资源权限"></a>查询所有资源权限</h3><ol><li><p>点击页面左边菜单的资源权限管理 向Controller发送请求</p><blockquote><p><img src="https://blog.chasingwind.top/1571383310152.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571383310152.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller</p><blockquote><p>跳转到permission-list.jsp</p><p><img src="https://blog.chasingwind.top/1571385148012.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385148012.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service</p><blockquote><p><img src="https://blog.chasingwind.top/1571385168815.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385168815.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao</p><blockquote><p><img src="https://blog.chasingwind.top/1571385182909.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385182909.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="添加资源权限"><a href="#添加资源权限" class="headerlink" title="添加资源权限"></a>添加资源权限</h3><ol><li><p>点击新建跳转到permi-add.jsp</p><blockquote><p><img src="https://blog.chasingwind.top/1571385235006.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385235006.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>单击保存时执行的Controller中的方法</p><p><img src="https://blog.chasingwind.top/1571385337803.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385337803.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571385377014.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385377014.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571385395432.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385395432.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571385416673.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385416673.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试成功</p><blockquote><p><img src="https://blog.chasingwind.top/1571385438589.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571385438589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="权限关联与控制"><a href="#权限关联与控制" class="headerlink" title="权限关联与控制"></a>权限关联与控制</h2><h3 id="用户关联角色"><a href="#用户关联角色" class="headerlink" title="用户关联角色"></a>用户关联角色</h3><ol><li><p>流程分析</p><blockquote><ol><li><p>先根据用户的id查询出这个用户的信息（在user-role-add.jsp中需要使用）</p></li><li><p>根据用户的id查询出此用户还没有的角色信息</p></li><li><p>向user_role表中插入数据</p><p><img src="https://blog.chasingwind.top/1571387758263.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571387758263.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li><li><p>在user-list.jsp页面中添加对用户的角色</p><blockquote><p>点击用户后面的添加角色按钮</p><p><img src="https://blog.chasingwind.top/1571387815201.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571387815201.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>跳转到的页面是Controller中的findUserByIdAndAllRole方法  传递的是用户的id </p><p><img src="https://blog.chasingwind.top/1571408694792.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571408694792.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller中的findUserByIdAndAllRole方法</p><blockquote><p>根据用户的id查询用户的信息 以及根据用户的id查询用户没有的角色信息</p><p>最后将这些数据转发到user-role-add.jsp页面中进行展示</p><p><img src="https://blog.chasingwind.top/1571408173197.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571408173197.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service层</p><blockquote><p>因为findAll在之前已经实现过了  这里只需要实现查询没有的角色信息就行了</p><p><img src="https://blog.chasingwind.top/1571409363835.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571409363835.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao层</p><blockquote><p>根据用户的id查询用户没有的角色信息</p><p><img src="https://blog.chasingwind.top/1571409450459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571409450459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>user-role-add.jsp页面效果</p><blockquote><p>点击添加角色后 就会将用户的信息以及用户还没有的角色的信息转发到此页面  在这个页面中进行展示</p><p><img src="https://blog.chasingwind.top/1571409530785.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571409530785.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>给用户添加角色，向users_role表中添加数据</p><blockquote><p>当我们点击保存的时候</p><p>就会执行addRoleToUser方法  可以根据name属性传递参数</p><p><img src="https://blog.chasingwind.top/1571408489968.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571408489968.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller层中的addRoleToUser方法  </p><blockquote><p>在此方法中  我们可以使用注解@Param获取页面中传递来的name属性</p><p>并且  我们可以给用户添加多个角色信息  所以使用的是数组来存储Role的id</p><p>因为在向数据库中的表users_role表中添加数据的时候 需要userId和roleId</p><p><img src="https://blog.chasingwind.top/1571409871111.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571409871111.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service中的方法</p><blockquote><p>通过遍历来向users_role表中添加多条数据</p><p><img src="https://blog.chasingwind.top/1571409983098.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571409983098.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao中的方法</p><blockquote><p>@Param注解 <strong>当方法中有多个参数的时候需要使用@param注解进行匹配</strong></p><p><img src="https://blog.chasingwind.top/1571410061817.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571410061817.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试成功 用户可以正常添加角色信息</p></li></ol><h3 id="角色关联权限"><a href="#角色关联权限" class="headerlink" title="角色关联权限"></a>角色关联权限</h3><ol><li><p>流程分析</p><blockquote><ol><li>先查询出这个角色的权限</li><li>查询这个角色还没有的权限</li><li>向role_permission表中插入数据</li></ol></blockquote></li><li><p>流程是与上面的相同的，这里不做介绍</p></li></ol><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><h4 id="服务器端方法级别权限控制"><a href="#服务器端方法级别权限控制" class="headerlink" title="服务器端方法级别权限控制"></a>服务器端方法级别权限控制</h4><ul><li><p>在服务器端我们可以通过Spring Security提供的注解对方法来进行权限控制。Spring Security在方法的权限控制上支持三种类型的注解，<strong>JSR-250注解</strong>、**@Secured注解<strong>和</strong>支持表达式的注解<strong>，这三种注解</strong>默认都是没有启用的**，需要 </p><p>单独通过<strong>global-method-security</strong>元素的对应属性进行启用 </p></li></ul><h5 id="JSR-250注解"><a href="#JSR-250注解" class="headerlink" title="JSR-250注解"></a>JSR-250注解</h5><ol><li><p>首先在pom.xml中添加依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1571450541709.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571450541709.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>首先需要在spring-security.xml中开启注解支持</p><blockquote><p><img src="https://blog.chasingwind.top/1571450220439.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571450220439.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在<strong>指定的方法上</strong>使用注解</p><blockquote><p>JSR-250中的注解</p><ol><li><p><strong>@RolesAllowed</strong>：表示<strong>访问对应方法时所应该具有的角色</strong></p><blockquote><p>@RolesAllowed({“USER”, “ADMIN”}) 该方法只要具有”USER”, “ADMIN”任意一种权限就可以访问。<strong>这里可以省略前缀ROLE_</strong>，实际的权限可能是ROLE_ADMIN </p><p>就是说我们虽然在spring-security.xml配置的角色是</p><p><img src="https://blog.chasingwind.top/1571451611077.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451611077.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>但是我们还是可以将ROLE_省略的</p></blockquote></li><li><p><strong>@PermitAll</strong>：表示<strong>允许所有的角色进行访问</strong>，也就是说不进行权限控制</p></li><li><p><strong>@DenyAll</strong>是和PermitAll相反的，表示<strong>无论什么角色都不能访问</strong></p></li></ol><hr><p><img src="https://blog.chasingwind.top/1571450811770.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571450811770.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>admin用户具有的角色有ADMIN和USER</p><p><img src="https://blog.chasingwind.top/1571451014960.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451014960.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以访问产品管理页</p><hr><p>tiger用户只有USER角色</p><p><img src="https://blog.chasingwind.top/1571451085070.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451085070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当访问产品管理页的时候 出现403Forbidden(权限不足)</p><p><img src="https://blog.chasingwind.top/1571451122797.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451122797.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们可以在页面中进行配置权限不足的页面</p><p>在web.xml中配置错误页面</p><p><img src="https://blog.chasingwind.top/1571451267755.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451267755.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在webapp目录下创建403.jsp页面</p><p><img src="https://blog.chasingwind.top/1571451296661.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451296661.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h5 id="Secured注解"><a href="#Secured注解" class="headerlink" title="@Secured注解"></a>@Secured注解</h5><ol><li><p>@Secured是SpringSecurity本身提供的注，不需要导入依赖</p></li><li><p>首先在spring-security.xml中开启注解支持</p><blockquote><p><img src="https://blog.chasingwind.top/1571451808522.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451808522.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在对应的方法上使用（<strong>权限不能省略前缀</strong>）</p><blockquote><p>我们在订单管理页上使用注解</p><p><img src="https://blog.chasingwind.top/1571451904894.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571451904894.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>admin用户可以进行访问</p><p>tiger用户没有ADMIN权限  403权限不足</p><p><img src="https://blog.chasingwind.top/1571452088274.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571452088274.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h5 id="支持表达式的注解"><a href="#支持表达式的注解" class="headerlink" title="支持表达式的注解"></a>支持表达式的注解</h5><ul><li><p>Spring Security允许我们在<strong>定义URL访问或方法访问所应有的权限时使用Spring EL表达式，在定义所需的访问权限时如果对应的表达式返回结果为true则表示拥有对应的权限，反之则无</strong></p></li><li><p>常用表达式</p><blockquote><p><img src="https://blog.chasingwind.top/1571453833128.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571453833128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><ol><li><p>开启支持</p><blockquote><p><img src="https://blog.chasingwind.top/1571453640406.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571453640406.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在方法上使用注解</p><blockquote><p><strong>@PreAuthorize</strong>： 在<strong>方法调用之前,基于表达式的计算结果来限制对方法的访问</strong></p><p>@PostAuthorize： 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常</p><p>@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果</p><p>@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值</p></blockquote></li><li><p>使用</p><blockquote><p><img src="https://blog.chasingwind.top/1571456082017.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571456082017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当使用admin用户登录的时候  可以访问用户管理页面</p><p>当使用tiger用户登录的时候  权限不足</p><hr><p>使用表达式进行权限控制</p><p>这里是对某个特定的用户授权  标识只有tiger用户才能添加用户</p><p><img src="https://blog.chasingwind.top/1571457370961.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571457370961.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当使用admin用户访问的时候  权限不足</p><p><img src="https://blog.chasingwind.top/1571457310802.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571457310802.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="页面端标签控制权限"><a href="#页面端标签控制权限" class="headerlink" title="页面端标签控制权限"></a>页面端标签控制权限</h4><ol><li><p>在pom.xml中导入依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1571457866510.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571457866510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在对应的jsp页面中导入</p><blockquote><p><code>&lt;%@taglib uri=&quot;https://www.springframework.org/security/tags&quot; prefix=&quot;security&quot;%&gt;</code></p><p><img src="https://blog.chasingwind.top/1571458188833.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571458188833.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>常用的标签<code>authentication</code></p><blockquote><p><code>authentication</code>：代表的是当前认证对象，可以获取当前认证对象信息，例 </p><p>如用户名</p><p>在之前的页面中 用户登录的时候显示的用户名都是固定的xxx</p><p><img src="https://blog.chasingwind.top/1571458301709.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571458301709.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571458310123.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571458310123.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们可以使用authentication标签来获取用户名</p><p><img src="https://blog.chasingwind.top/1571458380253.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571458380253.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在对应的位置使用<strong>标签获取用户名</strong></p><p><img src="https://blog.chasingwind.top/1571458493933.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571458493933.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571458504611.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571458504611.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>常用标签<code>authorize</code></p><blockquote><p><code>authorize</code>：用来判断普通权限的，通过<strong>判断用户是否具有对应的权限而控制其所包含内容的显示</strong>，<strong>根据用户的权限是否显示页面中内容</strong></p><p><img src="https://blog.chasingwind.top/1571458648868.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571458648868.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>比如说 我们让具有ADMIN角色的用户才能看到用户管理页</p><p><img src="https://blog.chasingwind.top/1571459300532.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571459300532.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571459255473.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571459255473.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>需要开启使用表达式</p><p><img src="https://blog.chasingwind.top/1571459093290.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571459093290.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="AOP日志"><a href="#AOP日志" class="headerlink" title="AOP日志"></a>AOP日志</h2><ul><li>用于记录用户的在系统中的每一步操作，将操作的信息存储到数据库中</li></ul><h3 id="创建表以及实体类"><a href="#创建表以及实体类" class="headerlink" title="创建表以及实体类"></a>创建表以及实体类</h3><ol><li><p>日志表sysLog</p><blockquote><p><img src="https://blog.chasingwind.top/1571465685418.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571465685418.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建表sysLog</p><blockquote><pre><code class="sql">CREATE TABLE sysLog(     id VARCHAR2(32) default SYS_GUID() PRIMARY KEY,              visitTime timestamp,     username VARCHAR2(50),     ip VARCHAR2(30),     url VARCHAR2(50),     executionTime int,     method VARCHAR2(200) )</code></pre></blockquote></li><li><p>创建实体类SysLog</p><blockquote><p><img src="https://blog.chasingwind.top/1571465940236.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571465940236.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="基于AOP来处理日志信息"><a href="#基于AOP来处理日志信息" class="headerlink" title="基于AOP来处理日志信息"></a>基于AOP来处理日志信息</h3><ul><li>使用前置通知和后置通知来获取用户操作的信息，然后将这些信息插入到数据库中</li></ul><ol><li><p>创建日志AOP</p><ul><li><p>前置通知</p><blockquote><p>前置通知  用来获取操作开始的时间，执行的类以及执行的方法</p><p><img src="https://blog.chasingwind.top/1571470572027.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571470572027.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在前置通知中已经完成了SysLog类中的</p><p><img src="https://blog.chasingwind.top/1571470644023.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571470644023.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>后置通知</p><blockquote><p><strong>后置通知</strong></p><p>用于获取操作者，访问的ip，执行的URL，执行时长</p><ol><li><p>获取用户访问的URL</p><p><img src="https://blog.chasingwind.top/1571472118498.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571472118498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>获取用户的ip地址</p><p><strong>通过request对象可以轻易获取</strong>，我们可以使用原生的RequestServlet来获取，首先需要在web.xml中配置<code>RequestContextListener</code></p><p><img src="https://blog.chasingwind.top/1571472210756.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571472210756.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>然后在LogAop中注入</p><p><img src="https://blog.chasingwind.top/1571472277562.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571472277562.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571472344449.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571472344449.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>获取当前正在操作的用户的用户名</p><p>可以通过SecurityContext中获取</p><p><img src="https://blog.chasingwind.top/1571472687592.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571472687592.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>还可以使用Session来获取  从属性值<code>SPRING_SECURITY_CONTEXT</code>中获取SecurityContext对象</p><p><img src="https://blog.chasingwind.top/1571472907612.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571472907612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>获取执行持续的时间</p><p>这里不是报错</p><p><img src="https://blog.chasingwind.top/1571473871876.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571473871876.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li></ul></li><li><p>将数据封装为SysLog类  并调用Service</p><blockquote><p><img src="https://blog.chasingwind.top/1571474780523.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571474780523.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service层</p><blockquote><p><img src="https://blog.chasingwind.top/1571474818486.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571474818486.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao层 向数据库中存储</p><blockquote><p><img src="https://blog.chasingwind.top/1571474842665.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571474842665.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>当我们进行访问的时候  数据库中正常存入了数据</p><p><img src="https://blog.chasingwind.top/1571474899984.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571474899984.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们访问订单数据的时候  报错了</p><p><img src="https://blog.chasingwind.top/1571474940959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571474940959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>因为我们在获取方法参数的时候  结果是对象类型的数组</p><p><img src="https://blog.chasingwind.top/1571474979491.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571474979491.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>而在fuindAll方法中参数是int     需要改成Integer，可以正常访问  并且数据库中正确存入数据</p><p><img src="https://blog.chasingwind.top/1571475024767.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571475024767.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="查询日志信息"><a href="#查询日志信息" class="headerlink" title="查询日志信息"></a>查询日志信息</h3><ol><li><p>流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571477282471.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571477282471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>点击菜单中的  访问日志  执行Controller中测方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571477341087.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571477341087.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>SysLogController中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571478143890.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571478143890.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571478160222.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571478160222.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1571478181972.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571478181972.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>可以正常查询到日志信息</p><p><img src="https://blog.chasingwind.top/1571478251894.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571478251894.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后台管理系统功能实现(一)</title>
      <link href="2019/10/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B01/"/>
      <url>2019/10/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B01/</url>
      
        <content type="html"><![CDATA[<p>本节主要讲述了添加商品的操作，以及订单的相关的操作，主要的是SpringSecurity的使用，用来验证以及授权用户从在用户登录的时候完成用户的验证。</p><a id="more"></a><h2 id="产品操作"><a href="#产品操作" class="headerlink" title="产品操作"></a>产品操作</h2><ul><li><p>在上一节的基础上，其实还存在一些小问题。</p><blockquote><p>在页面中，出发时间状态一栏中没有数据  但是在数据库中存储的时候是存储了数据的</p><p><img src="https://blog.chasingwind.top/1571037025503.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571037025503.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>数据库中存储的数据</p><p><img src="https://blog.chasingwind.top/1571037242191.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571037242191.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>而在product-list.jsp页面中显示的是String类型的 departTimeStr和String类型的productStatusStr</p><p><img src="https://blog.chasingwind.top/1571037399799.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571037399799.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以  我们需要做的就是在Product类中将departureTime转换为字符串形式的departureTimeStr以及将productStatus转换为productStatusStr</p><p><img src="https://blog.chasingwind.top/1571037497102.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571037497102.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>设置状态</p><p><img src="https://blog.chasingwind.top/1571037770195.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571037770195.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>设置时间  我们可以做成一个工具类来实现 在子模块中ssm_utils</p><p><img src="https://blog.chasingwind.top/1571038109604.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571038109604.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在Product类中进行转换</p><p><img src="https://blog.chasingwind.top/1571039774129.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571039774129.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在页面中显示出了数据</p><p><img src="https://blog.chasingwind.top/1571039794287.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571039794287.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>注意：每次执行之前都需要先clean，install父工程，然后clean，install子模块web项目之后，才能运行Tomcat</p></li></ul><h3 id="主页main-jsp"><a href="#主页main-jsp" class="headerlink" title="主页main.jsp"></a>主页main.jsp</h3><ul><li><p>在默认的首页index.jsp中我们将它转发到新的页面main.jsp</p><blockquote><p><img src="https://blog.chasingwind.top/1571040372827.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571040372827.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571040402091.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571040402091.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们再次运行的时候  访问的是index.jsp</p><p><img src="https://blog.chasingwind.top/1571040468953.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571040468953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="添加商品"><a href="#添加商品" class="headerlink" title="添加商品"></a>添加商品</h3><ul><li><p>添加商品的流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571042086141.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571042086141.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>从product-list.jsp页面跳转到product-add.jsp</p></li><li><p>在product-add.jsp中点击新建按钮输入商品信息</p><blockquote><p><img src="https://blog.chasingwind.top/1571048874930.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571048874930.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>表单提交到的路径</p><p><img src="https://blog.chasingwind.top/1571048598391.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571048598391.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571048897522.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571048897522.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Controller层</p><blockquote><p><img src="https://blog.chasingwind.top/1571048635593.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571048635593.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service层</p><blockquote><p><img src="https://blog.chasingwind.top/1571053365720.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571053365720.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao层执行的SQL语句</p><blockquote><pre><code class="java">@Insert(&quot;insert into product(productNum,productName,cityName,departureTime,productPrice,productDesc,productStatus) values(#&#123;productNum&#125;,#&#123;productName&#125;,#&#123;cityName&#125;,#&#123;departureTime&#125;,#&#123;productPrice&#125;,# &#123;productDesc&#125;,#&#123;productStatus&#125;) &quot;)    public void save(Product product);</code></pre><p>事务管理已经在Service层中使用注解的方式实现了</p></blockquote></li><li><p>当我们点击保存的时候</p><blockquote><p><img src="https://blog.chasingwind.top/1571048929566.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571048929566.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>出现了400客户端错误   造成错误的原因是日期格式类型转换异常</p><p><img src="https://blog.chasingwind.top/1571048755815.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571048755815.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571048942779.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571048942779.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>因为在页面提交到服务器端的时候日期对应的是字符串类型的</p><p>而在Product类中我们需要的是Date类型的</p><p>所以就会出现类型转换异常</p></blockquote></li><li><p>类型转换</p><blockquote><ol><li><p>可以使用在SpringMVC中自定义类型转换器来实现</p></li><li><p>使用注解<code>@DateTimeFormat</code></p><p><img src="https://blog.chasingwind.top/1571052991089.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571052991089.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></li><li><p>执行成功  跳转到findAll的页面</p><p><img src="https://blog.chasingwind.top/1571053750422.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571053750422.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li></ul><h2 id="订单操作"><a href="#订单操作" class="headerlink" title="订单操作"></a>订单操作</h2><h3 id="查询所有订单"><a href="#查询所有订单" class="headerlink" title="查询所有订单"></a>查询所有订单</h3><ol><li><p>订单查询流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571102346473.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571102346473.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建表</p><blockquote><p>创建Member表</p><pre><code class="sql">CREATE TABLE member( id varchar2(32) default SYS_GUID() PRIMARY KEY, NAME VARCHAR2(20), nickname VARCHAR2(20), phoneNum VARCHAR2(20), email VARCHAR2(20) );insert into MEMBER (id, name, nickname, phonenum, email) values (&#39;E61D65F673D54F68B0861025C69773DB&#39;, &#39;张三&#39;, &#39;小三&#39;, &#39;18888888888&#39;, &#39;zs@163.com&#39;);</code></pre><p><img src="https://blog.chasingwind.top/1571104797466.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571104797466.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>创建Traveller表</p><pre><code class="sql">CREATE TABLE traveller( id varchar2(32) default SYS_GUID() PRIMARY KEY, NAME VARCHAR2(20), sex VARCHAR2(20), phoneNum VARCHAR2(20), credentialsType INT, credentialsNum VARCHAR2(50), travellerType INT );insert into TRAVELLER (id, name, sex, phonenum, credentialstype, credentialsnum, travellertype) values (&#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;, &#39;张龙&#39;, &#39;男&#39;, &#39;13333333333&#39;, 0, &#39;123456789009876543&#39;, 0);insert into TRAVELLER (id, name, sex, phonenum, credentialstype, credentialsnum, travellertype) values (&#39;EE7A71FB6945483FBF91543DBE851960&#39;, &#39;张小龙&#39;, &#39;男&#39;, &#39;15555555555&#39;, 0, &#39;987654321123456789&#39;, 1);</code></pre><p><img src="https://blog.chasingwind.top/1571104848780.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571104848780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>创建Order表</p><pre><code class="sql">CREATE TABLE orders( id varchar2(32) default SYS_GUID() PRIMARY KEY, orderNum VARCHAR2(20) NOT NULL UNIQUE, orderTime timestamp, peopleCount INT, orderDesc VARCHAR2(500), payType INT, orderStatus INT, productId varchar2(32), memberId varchar2(32), FOREIGN KEY (productId) REFERENCES product(id), FOREIGN KEY (memberId) REFERENCES member(id) );insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;0E7231DC797C486290E8713CA3C6ECCC&#39;, &#39;12345&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;,&#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;676C5BD1D35E429A8C2E114939C5685A&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;);insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;5DC6A48DD4E94592AE904930EA866AFA&#39;, &#39;54321&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;676C5BD1D35E429A8C2E114939C5685A&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;2FF351C4AC744E2092DCF08CFD314420&#39;, &#39;67890&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;A0657832D93E4B10AE88A2D4B70B1A28&#39;, &#39;98765&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;E4DD4C45EED84870ABA83574A801083E&#39;, &#39;11111&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;96CC8BD43C734CC2ACBFF09501B4DD5D&#39;, &#39;22222&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;55F9AF582D5A4DB28FB4EC3199385762&#39;, &#39;33333&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;9F71F01CB448476DAFB309AA6DF9497F&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;CA005CF1BE3C4EF68F88ABC7DF30E976&#39;, &#39;44444&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;9F71F01CB448476DAFB309AA6DF9497F&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;3081770BC3984EF092D9E99760FDABDE&#39;, &#39;55555&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;9F71F01CB448476DAFB309AA6DF9497F&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;);</code></pre><p><img src="https://blog.chasingwind.top/1571104878467.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571104878467.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>订单与旅客中间表</p><pre><code class="sql">-- 订单与旅客中间表drop table order_traveller;CREATE TABLE order_traveller(  orderId varchar2(32),  travellerId varchar2(32),  PRIMARY KEY (orderId,travellerId),  FOREIGN KEY (orderId) REFERENCES orders(id),  FOREIGN KEY (travellerId) REFERENCES traveller(id))insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;0E7231DC797C486290E8713CA3C6ECCC&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;2FF351C4AC744E2092DCF08CFD314420&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;3081770BC3984EF092D9E99760FDABDE&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;55F9AF582D5A4DB28FB4EC3199385762&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;5DC6A48DD4E94592AE904930EA866AFA&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;96CC8BD43C734CC2ACBFF09501B4DD5D&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;A0657832D93E4B10AE88A2D4B70B1A28&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;CA005CF1BE3C4EF68F88ABC7DF30E976&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;);insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;E4DD4C45EED84870ABA83574A801083E&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;);</code></pre></blockquote></li><li><p>创建实体类</p><blockquote><p>实体类Member 并提供get/set方法</p><p><img src="https://blog.chasingwind.top/1571105927992.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571105927992.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>实体类Traveller  并提供get/set方法</p><p><img src="https://blog.chasingwind.top/1571105940802.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571105940802.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>实体类Orders  并提供get/set方法</p><p><img src="https://blog.chasingwind.top/1571108452855.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571108452855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Controller</p><blockquote><p><img src="https://blog.chasingwind.top/1571105816612.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571105816612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Service接口以及实现类</p><blockquote><p><img src="https://blog.chasingwind.top/1571106027022.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571106027022.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Dao接口  实现查询所有的方法  因为查询Orders的时候 还需要产品信息（一对一）</p><blockquote><p>这里使用的是注解的形式实现的  在这里我们封装的是Status而非对应的StatusStr的形式 但是在页面中显示的时候需要的是对应的Str的形式  所以我们需要在Orders实体类中进行转换</p><p><img src="https://blog.chasingwind.top/1571107274900.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571107274900.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Orders类中的信息转换</p><p><img src="https://blog.chasingwind.top/1571108556394.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571108556394.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571108567303.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571108567303.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571108577866.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571108577866.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>因为需要在查询订单的时候查询产品的信息 那么就需要指定封装到的Orders中对应的属性与数据库中的列 并且封装Product产品信息的时候 需要调用ProductDao中的方法</p><p><img src="https://blog.chasingwind.top/1571107406578.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571107406578.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>流程梳理</p><blockquote><ol><li><p>点击菜单页面的订单管理 执行orders/findAll方法</p><p><img src="https://blog.chasingwind.top/1571106729384.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571106729384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>执行对应的Controller中的方法</p><p><img src="https://blog.chasingwind.top/1571107732201.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571107732201.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>orders-list.jsp页面中取出数据  这里取出的就是对应的Str形式的数据</p><p><img src="https://blog.chasingwind.top/1571107764454.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571107764454.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>Controller调用Service中方法</p></li><li><p>Service调用Dao中的方法</p></li><li><p>Dao中的方法</p></li></ol></blockquote></li></ol><h3 id="订单分页"><a href="#订单分页" class="headerlink" title="订单分页"></a>订单分页</h3><ul><li><p>PageHelper是国内非常优秀的一款开源的MyBatis分页插件，它支持基本主流与常用的数据库。</p></li><li><p>PageHelper的使用</p><ol><li><p>导入Maven依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1571122817028.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571122817028.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在Spring的配置文件applicationContext.xml中进行配置</p><blockquote><p><img src="https://blog.chasingwind.top/1571123081073.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571123081073.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置参数解释</p><blockquote><p> helperDialect ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver201 </p><hr><p> reasonable ：分页合理化参数，默认值为 false 。<strong>当该参数设置为 true 时， pageNum&lt;=0 时会查询第一页， pageNum&gt;pages （超过总数时），会查询最后一页</strong>。默认 false 时，直接根据参数进行查询。</p></blockquote></li><li><p>基本使用</p><blockquote><p><strong>一定在执行数据库中的查询之前 进行分页</strong></p><p>中间不能执行其他的任何操作 不然分页就失效了</p><p>PageHelper的原理就是 在执行查询之前会在查询语句的后面拼接分页条件</p><p><img src="https://blog.chasingwind.top/1571123273132.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571123273132.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改页面<code>aside.jsp</code></p><blockquote><p>请求的时候需要携带当前页的页码以及当前页显示的条数</p><p><img src="https://blog.chasingwind.top/1571125252017.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571125252017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改Controller</p><blockquote><p>限定请求参数以及默认值  携带分页的参数</p><p><img src="https://blog.chasingwind.top/1571125545482.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571125545482.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改Service</p><blockquote><p>参数中需要携带请求的分页的参数</p><p><img src="https://blog.chasingwind.top/1571125586729.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571125586729.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改Controller</p><blockquote><p>上面还没有进行数据的存储以及页面的跳转</p><p>我们存储的数据不仅仅是数据库中的数据，还需要存储分页相关的数据，比如，分页的总页数，分页的当前页码等等 </p><p>所以，我们可以使用PageHelper提供的PageInfo这个Bean来存储信息</p><p>PageInfo类中存储的不仅仅是分页的数据  还可以将我们数据库中的数据存储进去</p><p><img src="https://blog.chasingwind.top/1571125883087.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571125883087.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们将页面跳转到<code>orders-page-list.jap</code></p><p><img src="https://blog.chasingwind.top/1571126007168.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571126007168.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改页面<code>orders-page-list.jap</code></p><blockquote><p>我们接收的就是</p><p><img src="https://blog.chasingwind.top/1571126246328.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571126246328.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样就完成了默认情况下的分页</p></blockquote></li><li><p>完成首页下一页等等</p><blockquote><p>使用PageInfo中封装的数据来完成</p><p><img src="https://blog.chasingwind.top/1571127602721.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571127602721.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>控制每页展示的条数</p><blockquote><p>当我们选择的时候 就会请求服务器</p><p><img src="https://blog.chasingwind.top/1571127958932.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571127958932.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们选择的时候 会调用函数  传递size</p><p><img src="https://blog.chasingwind.top/1571127777816.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571127777816.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571127878264.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571127878264.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h3 id="订单详情"><a href="#订单详情" class="headerlink" title="订单详情"></a>订单详情</h3><ul><li><p>流程分析</p><blockquote><p><img src="https://blog.chasingwind.top/1571140675753.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571140675753.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在orders-list.jsp页面中点击详情 跳转到指定的Controller中的方法中</p><blockquote><p>点击的时候 携带订单的Id信息</p><p><img src="https://blog.chasingwind.top/1571140835798.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571140835798.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>完成Controller</p><blockquote><p>这里还没有完成页面的跳转</p><p><img src="https://blog.chasingwind.top/1571148179366.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571148179366.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>完成Service</p><blockquote><p><img src="https://blog.chasingwind.top/1571148250687.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571148250687.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>完成Dao</p><blockquote><p>封装到Orders</p><p><img src="https://blog.chasingwind.top/1571148350776.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571148350776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>订单对应多个游客信息</p><p>在TravellerDao中借助订单号查询  借助的是中间表进行的查询</p><p><img src="https://blog.chasingwind.top/1571148390627.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571148390627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>完成页面的跳转</p><blockquote><p>页面详情页面使用的是<code>orders-show.jsp</code>,并且在页面中使用的是orders</p><p>所以完成Controller</p><p><img src="https://blog.chasingwind.top/1571149711953.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571149711953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>页面显示</p><p><img src="https://blog.chasingwind.top/1571149732600.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571149732600.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上面的证件类型 以及 旅客类型是空的  因为 显示的是字符串的类型</p><p>而数据库中存储的是整型的  需要在Traveller类中进行转换</p></blockquote></li></ul><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><h3 id="表以及实体类的创建"><a href="#表以及实体类的创建" class="headerlink" title="表以及实体类的创建"></a>表以及实体类的创建</h3><ol><li><p>表结构</p><blockquote><p>表与表之间的关系</p><p><img src="https://blog.chasingwind.top/1571151288026.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571151288026.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>用户表Users（根据后面的需要 修改成了UserInfo类，用于SpringSecurity框架的认证）</p><p><img src="https://blog.chasingwind.top/1571151305920.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571151305920.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>角色表Role</p><p><img src="https://blog.chasingwind.top/1571151324970.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571151324970.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>权限表Permission</p><p><img src="https://blog.chasingwind.top/1571151349175.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571151349175.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在数据库中创建表以及中间表</p><blockquote><pre><code class="sql">-- 用户表CREATE TABLE users(id varchar2(32) default SYS_GUID() PRIMARY KEY,email VARCHAR2(50) UNIQUE NOT NULL,username VARCHAR2(50),PASSWORD VARCHAR2(50),phoneNum VARCHAR2(20),STATUS INT)-- 角色表CREATE TABLE role(id varchar2(32) default SYS_GUID() PRIMARY KEY,roleName VARCHAR2(50) ,roleDesc VARCHAR2(50))-- 用户角色关联表CREATE TABLE users_role(userId varchar2(32),roleId varchar2(32),PRIMARY KEY(userId,roleId),FOREIGN KEY (userId) REFERENCES users(id),FOREIGN KEY (roleId) REFERENCES role(id))-- 资源权限表CREATE TABLE permission(id varchar2(32) default SYS_GUID() PRIMARY KEY,permissionName VARCHAR2(50) ,url VARCHAR2(50))-- 角色权限关联表CREATE TABLE role_permission(permissionId varchar2(32),roleId varchar2(32),PRIMARY KEY(permissionId,roleId),FOREIGN KEY (permissionId) REFERENCES permission(id),FOREIGN KEY (roleId) REFERENCES role(id))</code></pre></blockquote></li><li><p>创建相应的实体类，并提供对应的get/set方法</p><blockquote><p>User实体类</p><p><img src="https://blog.chasingwind.top/1571151631765.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571151631765.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Role实体类</p><p><img src="https://blog.chasingwind.top/1571151648309.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571151648309.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Permission实体类</p><p><img src="https://blog.chasingwind.top/1571151671354.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571151671354.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="SpringSecurity框架简单入门"><a href="#SpringSecurity框架简单入门" class="headerlink" title="SpringSecurity框架简单入门"></a>SpringSecurity框架简单入门</h3><ul><li><p>Spring Security  ，是 Spring 项目组中用来提供安全认证服务的框架。</p><blockquote><p><strong>认证</strong> : 简单来说，就是判断用户的用户名和密码是否和数据库（或者说正确的用户名和面）中相等，比如说，在登录过程中，验证用户名和密码是否正确</p><p><strong>授权</strong>：简单来说，<strong>就是用户是否有权限执行某些功能，而这些权限我们已经在数据库中进行了描述或者在配置文件中进行了声明</strong></p></blockquote></li><li><p>Spring Security可以通过数据库或者配置文件进行使用，也就是说我们可以将用户配置在配置文件中，从配置文件或者数据库中获取用户</p></li><li><p>基于配置文件的SpringSecurity入门案例</p><ol><li><p>创建新的项目</p></li><li><p>在pom.xml中添加依赖</p><blockquote><p>坐标依赖以及插件</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;      &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;      &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;      &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.1.0&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;!-- java编译插件 --&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;version&gt;3.2&lt;/version&gt;        &lt;configuration&gt;          &lt;source&gt;1.8&lt;/source&gt;          &lt;target&gt;1.8&lt;/target&gt;          &lt;encoding&gt;UTF-8&lt;/encoding&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;configuration&gt;          &lt;!-- 指定端口 --&gt;          &lt;port&gt;8080&lt;/port&gt;          &lt;!-- 请求路径 --&gt;          &lt;path&gt;/&lt;/path&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;</code></pre></blockquote></li><li><p>在web.xml中配置filter</p><blockquote><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;https://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;https://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;         version=&quot;2.5&quot;&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;filter&gt;    //必须是springSecurityFilterChain这个名字    &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre></blockquote></li><li><p>在resources目录下创建spring-security.xml</p><blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot;       xmlns:security=&quot;https://www.springframework.org/schema/security&quot;       xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd https://www.springframework.org/schema/security https://www.springframework.org/schema/security/spring-security.xsd&quot;&gt;    &lt;security:http auto-config=&quot;true&quot;                   use-expressions=&quot;false&quot;&gt; &lt;!-- intercept-url定义一个过滤规则 pattern表示对哪些url进行权限控制，ccess属性表示在请求对应 的URL时需要什么权限， 默认配置时它应该是一个以逗号分隔的角色列表，请求的用户只需拥有其中的一个角色就能成功访问对应 的URL --&gt;        &lt;security:intercept-url pattern=&quot;/**&quot;                                access=&quot;ROLE_USER&quot;/&gt; &lt;!-- auto-config配置后，不需要在配置下面信息 &lt;security:form-login /&gt; 定义登录表单信息 &lt;security:http-basic /&gt; &lt;security:logout /&gt; --&gt;    &lt;/security:http&gt;    &lt;security:authentication-manager&gt;        &lt;security:authentication-provider&gt;            &lt;security:user-service&gt;                &lt;security:user name=&quot;user&quot; password=&quot;&#123;noop&#125;user&quot; authorities=&quot;ROLE_USER&quot;/&gt;                &lt;security:user name=&quot;admin&quot; password=&quot;&#123;noop&#125;admin&quot; authorities=&quot;ROLE_ADMIN&quot;/&gt;            &lt;/security:user-service&gt;        &lt;/security:authentication-provider&gt;    &lt;/security:authentication-manager&gt;&lt;/beans&gt;</code></pre><hr><p><img src="https://blog.chasingwind.top/1571154351207.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571154351207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>表示所有的资源都会被拦截，只有用户“ROLE_USER”才能进行访问资源</p><hr><p>配置用户的用户名和密码 以及角色(在这真正的开发中是在数据库中的，这里是进行演示)</p><p><img src="https://blog.chasingwind.top/1571154488608.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571154488608.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行 在终端输入命令<code>tomcat7:run</code></p><blockquote><p>默认进入到的是localhost:配置的端口号  但其实是一个登陆页面</p><p>在配置文件中  默认提供的<img src="https://blog.chasingwind.top/1571154611033.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571154611033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>用户名和密码错误  zhangsan 123</p><p><img src="https://blog.chasingwind.top/1571154561305.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571154561305.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用user user  访问到的是index.jsp</p><p><img src="https://blog.chasingwind.top/1571154673254.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571154673254.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用admin  admin  没有权限访问（403）</p><p><img src="https://blog.chasingwind.top/1571154721049.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571154721049.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p> 因为在配置中我们配置的是只有”ROLE_USER”角色才能访问资源</p><p><img src="https://blog.chasingwind.top/1571154748320.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571154748320.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>错误和正确的页面 可以进行自定义</p><blockquote><p>使用配置文件进行配置</p><p><img src="https://blog.chasingwind.top/1571208274736.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571208274736.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h3 id="Spring-Security使用数据库认证"><a href="#Spring-Security使用数据库认证" class="headerlink" title="Spring Security使用数据库认证"></a>Spring Security使用数据库认证</h3><ul><li><p>在Spring Security中如果想要使用数据进行认证操作，有很多种操作方式，这里我们介绍<strong>使用UserDetails、 UserDetailsService来完成操作</strong>。 </p></li><li><p>UserDetails是一个接口，我们可以认为<strong>UserDetails作用是用于封装当前进行认证的用户信息</strong>，但由于其是一个接口，所以我们可以对其进行实现，<strong>也可以使用Spring Security提供的一个UserDetails的实现类User来完成操作</strong> </p></li><li><p>UserDetailsService也是一个接口，其中只有一个方法<code>loadUserByUsernam</code>用于规范认证的方法</p><blockquote><p>UserDetails接口   </p><p><img src="https://blog.chasingwind.top/1571208945093.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571208945093.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>User类实现了UserDetails接口  其中的一些属性如图  这是SpringSecurity为我们提供的</p><p><img src="https://blog.chasingwind.top/1571210348555.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571210348555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>UserDetailService接口</p><p><img src="https://blog.chasingwind.top/1571210388139.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571210388139.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>UserDetail和UserDetailService用于认证的使用流程</p><blockquote><p>之前我们使用数据库认证登录的流程</p><p><img src="https://blog.chasingwind.top/1571210729780.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571210729780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用SpringSecurity来完成用户的认证</p><p>就不需要使用Controller了 而胡思使用SpringSecurity来当作控制器</p><p>并且在Service中需要实现接口<code>UserDetailService</code>，重写其中的方法</p><p>返回值是UserDeatil，但是我们从数据库周静查询的返回值是User</p><p>这该怎么进行转换呢</p><p><img src="https://blog.chasingwind.top/1571210752123.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571210752123.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用SpringSecurity实现用户登录</p><ol><li><p>导入登录页面以及失败跳转的页面，成功的话跳转到main.jsp页面中</p><blockquote><p>成功跳转到pages/main.jsp也就是我们的主页面</p><p><img src="https://blog.chasingwind.top/1571211146677.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571211146677.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在工程的pom.xml中导入依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1571211262136.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571211262136.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在web.xml中配置filter</p><blockquote><p>在WEB-INF目录下的web.xml中进行配置filter</p><p><img src="https://blog.chasingwind.top/1571211406438.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571211406438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置SpringSecurity的配置文件</p><blockquote><p>在resources目录下创建SpringSecurity配置文件spring-security.xml</p><p><img src="https://blog.chasingwind.top/1571212149037.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571212149037.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>以上的配置说明了</p><p><img src="https://blog.chasingwind.top/1571212325327.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571212325327.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>告诉SpringSecurity框架拿到用户名和密码之后需要访问的是哪一个Service</p><p>配置认证管理器 告诉SpringSecurity框架  这个Service是哪一个</p><p><img src="https://blog.chasingwind.top/1571213386292.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571213386292.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>实创建UserService以及他的实现类</p><p><img src="https://blog.chasingwind.top/1571213566719.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571213566719.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>让UserService继承UserDetailsService</p><p><img src="https://blog.chasingwind.top/1571213612179.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571213612179.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>实现UserService  并将userService交给IOC进行管理  这样SpringSecurity框架就知道了使用我们实现的UserService来完成认证的操作</p><p><img src="https://blog.chasingwind.top/1571213639441.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571213639441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的话我们就完后了图中的内容 </p><p><img src="https://blog.chasingwind.top/1571213700124.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571213700124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>并且在web.xml中加载spring-security.xml</p><p><img src="https://blog.chasingwind.top/1571211633659.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571211633659.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><code>classpath:</code>和<code>classpath*:</code>的区别</p><p><strong>classpath和classpath*区别：</strong> </p><p>classpath：只会到你的class路径中查找找文件。</p><p>classpath*：不仅包含class路径，还包括jar文件中（class路径）进行查找。</p><p>注意： 用classpath*:需要遍历所有的classpath，所以加载速度是很慢的；因此，在规划的时候，应该尽可能规划好资源文件所在的路径，尽量避免使用classpath*。</p></blockquote></li><li><p>完成从数据库查询用户，并进行返回</p><blockquote><p>Service中方法的返回值的是UserDetails对象，而我们从数据库中查询出来的是我们自己的实体类<code>UserInfo</code>，如何将我们自己的实体类UserInfo对象转换为UserDetails对象？</p><p><img src="https://blog.chasingwind.top/1571214298376.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571214298376.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们自己的实体类UserInfo</p><p><img src="https://blog.chasingwind.top/1571214418003.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571214418003.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>实现UserDao接口  我们从数据库中查询出来的是UserInfo对象</p><p><img src="https://blog.chasingwind.top/1571214774192.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571214774192.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>UserService中对UserDao查询的结果进行处理</p><p>UserDao查询的结果是一个UserInfo对象，怎样把UserInfo转换为UserDetails呢？</p><p><strong>UserDetails接口有一个实现类User类  我们可以将UserInfo封装为User</strong></p><p>User类中的属性</p><p><img src="https://blog.chasingwind.top/1571215251045.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571215251045.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们可以使用User类中的构造方法  将我们的UserInfo类转换为User类</p><p> <img src="https://blog.chasingwind.top/1571215313001.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571215313001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571215440018.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571215440018.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这样  就将我们从数据库中查询出来的UserInfo类对象转换为了UserDetails对象</p><hr><p>这样SpringSecurity框架就可以从Service中拿到UserDetails对象，也就是拿到了登录用户的用户名和密码等信息，<strong>框架底层就可以进行认证，完成页面的跳转</strong></p></blockquote></li><li><p>登录测试</p><blockquote><p>进行登录测试</p><p><img src="https://blog.chasingwind.top/1571222836500.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571222836500.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>即使输入正确的用户名和密码输入，也是登录失败  因为 只有角色为只有<code>ROLE_USER,ROLE_ADMIN</code>角色才能进行访问</p><p><img src="https://blog.chasingwind.top/1571223449180.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571223449180.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在上面我们将UserInfo对象转换为User对象的时候  使用的是User的构造函数  第三个参数是authorieties   也就是将UserInfo对象的角色也封装到User对象中</p><p>图中的密码前面加了“{noop}”  因为我们没有配置加密 所以需要这个前缀</p><p><img src="https://blog.chasingwind.top/1571223543333.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571223543333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在这里进行<strong>模仿为用户授权</strong>   （因为在后面 角色还是需要从数据库中进行查询的）</p><p><img src="https://blog.chasingwind.top/1571224111066.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571224111066.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>authorities参数需要的是<code>GrantedAuthority</code>，我们存入的是他的实现类</p><p><code>SimpleGrantedAuthority</code></p><p><img src="https://blog.chasingwind.top/1571224168538.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571224168538.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571224297160.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571224297160.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>从数据库中获取用户角色</p><blockquote><p>在配置文件中 我们配置的是  只有<code>ROLE_USER,ROLE_ADMIN</code>角色才能进行访问</p><p>也就是说 我们<strong>还需要完成从数据库中完成用户角色的查询</strong>  依此来判断用户是否有权限进行访问</p><p><img src="https://blog.chasingwind.top/1571215999401.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571215999401.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>也就是说 当我们获取UserInfo的时候 还需要将Role封装进去</p><p>UserInfo类</p><p><img src="https://blog.chasingwind.top/1571224433280.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571224433280.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们进行UserInfo的封装的时候  也将用户的Role进行封装</p><p>由于一个用户可以具有多个角色 所以是Many</p><p><img src="https://blog.chasingwind.top/1571227136806.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571227136806.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在RoleDao中<strong>根据用户的Id查询用户的角色</strong></p><p><img src="https://blog.chasingwind.top/1571227216964.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571227216964.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>数据库中的User表以及Role表添加数据 以及中间表的关联</p><p><img src="https://blog.chasingwind.top/1571226560480.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571226560480.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1571227459606.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571227459606.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在Service中 我们就可以获取UserInfo中封装的roles角色信息了</p><p><img src="https://blog.chasingwind.top/1571227721901.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571227721901.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>另外  在UserInfo类中还有一个属性status  代表账户是否可用</p><p>0 不可用 1可用</p><p><img src="https://blog.chasingwind.top/1571228196554.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571228196554.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们可以通过User的另一个构造方法  进行设置</p><p><img src="https://blog.chasingwind.top/1571228050018.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571228050018.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1571229054232.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571229054232.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行测试</p><blockquote><p>当用户的状态status是1并且角色是有权限的时候</p><p>是可以登录成功的</p><hr><p>当用户的status是0的时候  即使用户名和密码以及权限都有的话  也会登录失败的</p><p><img src="https://blog.chasingwind.top/1571229320046.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571229320046.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>小注意事项</p><blockquote><p><img src="https://blog.chasingwind.top/1571229003547.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571229003547.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h3 id="用户的退出"><a href="#用户的退出" class="headerlink" title="用户的退出"></a>用户的退出</h3><ul><li>借助SpringSecurity帮助我们完成用户的退出的功能</li></ul><ol><li><p>用户退出的页面</p><blockquote><p><img src="https://blog.chasingwind.top/1571229588922.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571229588922.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在spring-security.xml配置文件中完成配置</p><blockquote><p>配置信息</p><p><img src="https://blog.chasingwind.top/1571229750110.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571229750110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在页面中指定logout</p><blockquote><p>对应的具体的操作 由SpringSecurity来帮我们完成</p><p><img src="https://blog.chasingwind.top/1571229879682.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1571229879682.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试成功</p></li></ol><h3 id="SpringSecurity源码简析"><a href="#SpringSecurity源码简析" class="headerlink" title="SpringSecurity源码简析"></a>SpringSecurity源码简析</h3>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM项目环境搭建</title>
      <link href="2019/10/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2019/10/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>本节主要是进行项目的环境的搭建，介绍了项目的基本内容。主要完成了基本的数据库的搭建还有SSM框架的搭建，编写各种配置文件还有进行环境的测试。最后可以完成测试，完成搭建的目标。</p><a id="more"></a><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>此项目是使用SSM搭建的后台管理系统，其中包括了后台对于产品的操作，订单操作，用户操作，权限管理，权限关联和控制还有最后的AOP日志的实现。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>页面使用的是AdminLTE框架来完成的，数据库使用的是Oracle，框架使用的是Spring+MyBatis+SpringMVC来进行搭建的</p><h2 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h2><ul><li><p>Oracle数据库时是基于用户进行管理数据的，所以首先需要创建一个用户</p><blockquote><p>创建用户</p><p><img src="https://blog.chasingwind.top/1570948291703.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570948291703.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>为用户授权 这里使用的是connect和resource角色</p><p><img src="https://blog.chasingwind.top/1570948322043.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570948322043.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>图中我们设置的是角色权限，是对某一张表的操作权限</p></blockquote></li><li><p>创建product表</p><blockquote><p>使用刚刚创建的用户ssm来登录，创建product表</p><p>表结构</p><p><img src="https://blog.chasingwind.top/1570949900113.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570949900113.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>常见表</p><pre><code class="plsql">CREATE TABLE product(        id varchar2(32) default SYS_GUID() PRIMARY KEY,        productNum VARCHAR2(50) NOT NULL,        productName VARCHAR2(50),        cityName VARCHAR2(50),        DepartureTime timestamp,        productPrice Number,        productDesc VARCHAR2(500),        productStatus INT,        CONSTRAINT product UNIQUE (id, productNum) )</code></pre><p>添加数据   记得添加数据之后需要Commit</p><p>可以看到id这个字段我们是没有进行操作的 也就是insert的时候没有给字段和值  这个会自动添加</p><pre><code class="plsql">insert into PRODUCT  (   productnum,   productname,   cityname,   departuretime,   productprice,   productdesc,   productstatus)values  (   &#39;itcast-002&#39;,   &#39;北京三日游&#39;,   &#39;北京&#39;,   to_timestamp(&#39;10- 10-2018 10:10:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;),   1200,   &#39;不错的旅行&#39;,   1);insert into PRODUCT  (   productnum,   productname,   cityname,   departuretime,   productprice,   productdesc,   productstatus)values  (   &#39;itcast-003&#39;,   &#39;上海五日游&#39;,   &#39;上海&#39;,   to_timestamp(&#39;25- 04-2018 14:30:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;),   1800,   &#39;魔都我来了&#39;,   0);insert into PRODUCT  (   productnum,   productname,   cityname,   departuretime,   productprice,   productdesc,   productstatus)values  (   &#39;itcast-001&#39;,   &#39;北京三日游&#39;,   &#39;北京&#39;,   to_timestamp(&#39;10- 10-2018 10:10:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;),   1200,   &#39;不错的旅行&#39;,   1);</code></pre></blockquote></li></ul><h2 id="搭建Maven工程"><a href="#搭建Maven工程" class="headerlink" title="搭建Maven工程"></a>搭建Maven工程</h2><ol><li><p>创建父工程</p><blockquote><p>创建Project，不使用骨架创建</p></blockquote></li><li><p>创建子模块</p><blockquote><p>创建Module ssm_dao（不使用骨架），指定Module所在的父工程</p><p><img src="https://blog.chasingwind.top/1570952384657.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570952384657.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同理，创建ssm_service</p><p><img src="https://blog.chasingwind.top/1570952478225.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570952478225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同理，创建ssm_domain</p><p><img src="https://blog.chasingwind.top/1570952524126.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570952524126.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同理，创建ssm_utils</p><p><img src="https://blog.chasingwind.top/1570952687866.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570952687866.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>最后，创建ssm_web，使用webapp骨架进行创建</p><p><img src="https://blog.chasingwind.top/1570952788004.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570952788004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>此时的目录结构是这样的  父工程SSM_Project以及各个子模块</p><p><img src="https://blog.chasingwind.top/1570952819209.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570952819209.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>导入jar包的坐标</p><blockquote><p>在<code>&lt;veision&gt;</code>和<code>&lt;module&gt;</code>之间放置</p><pre><code class="xml">    &lt;properties&gt;        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;        &lt;oracle.version&gt;11.2.0.1.0&lt;/oracle.version&gt;        &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;        &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.6.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log start --&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log end --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;c3p0&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.1.2&lt;/version&gt;            &lt;type&gt;jar&lt;/type&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;            &lt;version&gt;5.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle&lt;/groupId&gt;            &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;            &lt;version&gt;$&#123;oracle.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.annotation&lt;/groupId&gt;            &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;pluginManagement&gt;            &lt;plugins&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                    &lt;version&gt;3.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;source&gt;1.8&lt;/source&gt;                        &lt;target&gt;1.8&lt;/target&gt;                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;                        &lt;showWarnings&gt;true&lt;/showWarnings&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;    &lt;/build&gt;</code></pre></blockquote></li><li><p>编写产品实体类</p><blockquote><p>在domain模块下创建Product类 并实现set和get方法</p><p><img src="https://blog.chasingwind.top/1570953581674.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570953581674.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao接口</p><blockquote><p>创建ProductDao接口  创建查询所有的方法</p><p><img src="https://blog.chasingwind.top/1570953748780.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570953748780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意: 在这里需要引入Product依赖</p><p><img src="https://blog.chasingwind.top/1570953809738.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570953809738.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Service接口以及实现类</p><blockquote><p><img src="https://blog.chasingwind.top/1570954319959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570954319959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><ul><li><p>在web模块下面创建java和resources目录</p><blockquote><p><img src="https://blog.chasingwind.top/1570964456197.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570964456197.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建applicationContext.xml和springmvc.xml</p><blockquote><p><img src="https://blog.chasingwind.top/1570964561616.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570964561616.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置applicationContext.xml配置文件</p><blockquote><ul><li>加入约束</li><li>配置扫描Dao和Service，需要在pom.xml中加入Dao和Service的依赖</li><li>Spring整合MyBatis，就是将SqlSession交给Spring来管理</li><li>其中需要注入数据库连接信息，数据库连接池使用的是C3P0，并且在resources目录下创建db.properties存储数据库的连接信息</li><li>将Dao接口生成代理注入Spring容器中</li><li>配置事务管理器</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;https://www.springframework.org/schema/context&quot; xmlns:aop=&quot;https://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;https://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans    https://www.springframework.org/schema/beans/spring-beans.xsd    https://www.springframework.org/schema/context    https://www.springframework.org/schema/context/spring-context.xsd    https://www.springframework.org/schema/aop    https://www.springframework.org/schema/aop/spring-aop.xsd    https://www.springframework.org/schema/tx    https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;!--配置扫描包  扫描Dao和Service  这里需要在web模块的pom.xml中添加依赖--&gt;&lt;context:component-scan base-package=&quot;edu.ahnu.dao&quot;&gt;&lt;/context:component-scan&gt;&lt;context:component-scan base-package=&quot;edu.ahnu.service&quot;&gt;&lt;/context:component-scan&gt;&lt;!--Spring整合MyBatis  也就是让Spring来管理SqlSession对象--&gt;&lt;!--数据库的连接信息  在resources目录--&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;!-- 配置连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;  &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;  &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;  &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;  &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;!-- 把SqlSessionFactory交给IOC管理--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; &lt;!--配置Dao所在的包  将Dao接口生成代理注入Spring--&gt; &lt;bean id=&quot;mapperScannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;     &lt;property name=&quot;basePackage&quot; value=&quot;edu.ahnu.dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置Spring的声明式事务管理 --&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;/beans&gt;</code></pre></blockquote></li><li><p>配置springmvc.xml</p><blockquote><ul><li>加入约束</li><li>配置扫描，这里只扫描Controller</li><li>配置视图解析器</li><li>设置静态资源不过滤（在webapp目录下创建存储静态资源的目录）</li><li>开启SpringMVC对注解的支持</li><li>使用子类实现动态代理</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;https://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;https://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;https://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;           https://www.springframework.org/schema/beans           https://www.springframework.org/schema/beans/spring-beans.xsd           https://www.springframework.org/schema/mvc           https://www.springframework.org/schema/mvc/spring-mvc.xsd           https://www.springframework.org/schema/context           https://www.springframework.org/schema/context/spring-context.xsd           https://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd           &quot;&gt;    &lt;!--只扫描Controller--&gt;    &lt;context:component-scan base-package=&quot;edu.ahnu.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置视图解析器--&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--jsp所在的目录--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot;&gt;&lt;/property&gt;        &lt;!--后缀名--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--设置静态资源不过滤--&gt;    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;    &lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot; /&gt;    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt;    &lt;mvc:resources location=&quot;/plugins/&quot; mapping=&quot;/plugins/**&quot; /&gt;    &lt;!-- 开启对SpringMVC注解的支持 --&gt;    &lt;mvc:annotation-driven /&gt;    &lt;!--  使用cglib进行代理  不需要接口  而是通过子类的方式        支持AOP的注解支持，AOP底层使用代理技术        JDK动态代理，要求必须有接口        cglib代理，生成子类对象，proxy-target-class=&quot;true&quot; 默认使用cglib的方式    --&gt;    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;&lt;/beans&gt;</code></pre></blockquote></li><li><p>配置web.xml</p><blockquote><ul><li>配置加载类路径下的配置文件contextConfigLocation</li><li>配置监听器，用来监听request的创建和销毁</li><li>配置前端控制器</li><li>配置中文乱码过滤器</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;https://xmlns.jcp.org/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;https://xmlns.jcp.org/xml/ns/javaee https://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;    &lt;!-- 配置加载类路径的配置文件 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- 配置监听器 --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- 配置监听器，监听request域对象的创建和销毁的 --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!-- 解决中文乱码过滤器 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!--配置默认加载的页面--&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre></blockquote></li><li><p>配置db.properties数据库连接信息</p><blockquote><p>配置数据库的连接信息</p><pre><code class="properties">jdbc.driver=oracle.jdbc.driver.OracleDriverjdbc.url=jdbc:oracle:thin:@localhost:1521:orcljdbc.username=ssmjdbc.password=xxxxx</code></pre></blockquote></li><li><p>创建控制层</p><blockquote><ul><li><p>创建ProductorController</p><p><img src="https://blog.chasingwind.top/1570972786534.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570972786534.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570972834673.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570972834673.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul><ul><li><p>调用Service层的findAll方法，Service层调用Dao层的方法，在Dao接口上写SQL语句</p><p><img src="https://blog.chasingwind.top/1570972909241.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570972909241.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></blockquote></li><li><p>查询产品的流程图</p><blockquote><p><img src="https://blog.chasingwind.top/1570975823209.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570975823209.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>index.jsp页面和product-list.jsp页面</p><blockquote><p>index.jsp页面</p><p><img src="https://blog.chasingwind.top/1570976109758.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570976109758.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>product-list.jsp使用的是AdminLTE提供的页面，同时还需要导入静态文件</p><p><img src="https://blog.chasingwind.top/1570976230218.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570976230218.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>存储数据以及转发页面</p><blockquote><p>product-list.jsp页面中使用的是productList来存储数据的</p><p><img src="https://blog.chasingwind.top/1570976595107.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570976595107.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在Controller中存储数据以及转发的页面</p><p><img src="https://blog.chasingwind.top/1570976645438.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570976645438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行测试</p><blockquote><p>配置Tomcat  使用Maven中集成的Tomcat插件进行测试</p><p><img src="https://blog.chasingwind.top/1570980384093.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570980384093.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><pre><code class="xml">&lt;plugins&gt;            &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;port&gt;8080&lt;/port&gt;            &lt;/configuration&gt;            &lt;version&gt;2.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;/plugins&gt;</code></pre><p>配置Maven中的Tomcat  配置运行的项目是Web子模块  并且执行的命令是<code>tomcat7:run</code></p><p><img src="https://blog.chasingwind.top/1570980461908.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570980461908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行项目</p><blockquote><p>运行之前的准备</p><p><img src="https://blog.chasingwind.top/1570980605446.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570980605446.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>运行</p><p><img src="https://blog.chasingwind.top/1570980623019.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570980623019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行</p><blockquote><p>到这里 可以成功运行 并且可以从数据库中查出数据</p><p>至此,SSM项目整合成功可以运行</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN</title>
      <link href="2019/10/11/SVN/"/>
      <url>2019/10/11/SVN/</url>
      
        <content type="html"><![CDATA[<p>SVN是subversion的缩写，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理。</p><a id="more"></a><h2 id="SVN的基本介绍"><a href="#SVN的基本介绍" class="headerlink" title="SVN的基本介绍"></a>SVN的基本介绍</h2><ul><li><p>SVN是Subversion的简称，是一个自由<strong>开源的版本控制系统</strong>。 </p><p>Subversion<strong>将文件存放在中心版本库</strong>里，这个版本库很像一个普通的文件服务器，不同的是，它<strong>可以记录每一次文件和目录的修改情况，</strong>这样就可以借此将数据恢复到以前的版本，并可以查看数据的更改细节</p></li><li><p>SVN是一种<strong>集中式管理代码的版本控制系统</strong>，原理就是把代码都保存到一个固定的位置（仓库），每次从这个位置拷贝更新代码，进行编辑；再把修改后的代码提交到该目录中。多人协作开发也是如此。因此需要一个类似Oracle或者Mysql的服务器用于保存和管理库文件（要保存的代码等文件）的服务端——VisualSVN Server。还需要一个用户的操作端，用于提交更新检出代码，常用的有IDEA的SVN插件，以及TortoiseSVN（小乌龟）。 </p></li><li><p>早期版本控制使用的是CVS,后来SVN替代了CVS,随着android兴起，出现Git版本控制工具，后续我们会学到。</p><blockquote><p>中心版本库以及SVN的一些操作</p><p><img src="https://blog.chasingwind.top/1570794320970.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570794320970.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>存在的问题: 怎样让系统允许用户共享信息，而不会让他们因意外而<strong>互相干扰？</strong></p><p>解决方法一：<strong>复制-修改-合并方案（Subversion的默认模式）</strong></p><p>在这种模型里，<strong>每一个客户读取项目配置库建立一个私有工作副本</strong>——版本库中文件和目录的本地映射。<strong>用户并行工作</strong>，修改各自的工作副本，<strong>最终，各个私有的复制合并在一起，成为最终的版本</strong>，这种系统通常可以辅助合并操 </p><p>作，但是<strong>最终要靠人工去确定正误。</strong></p><p>也就是说，如果有人同时修改了同一个部分的代码，还是需要人工手动进行正误的判断的。</p><p>解决方法二：<strong>锁定-修改-解锁方案</strong> </p><p>在这样的模型里，<strong>在一个时间段里配置库的一个文件只允许被一个人修改。</strong> 此模式不适合软件开发这种工作。</p></blockquote></li></ul><h2 id="SVN架构"><a href="#SVN架构" class="headerlink" title="SVN架构"></a>SVN架构</h2><blockquote><p>SVN支持Linux和Windows，更多是安装在Linux下。</p><p><img src="https://blog.chasingwind.top/1570795228779.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570795228779.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>SVN服务器有2种运行方式</strong>：独立服务器和借助apache运行。两种方式各有利弊，用户可以自行选择。</p><p><strong>SVN存储版本数据也有2种方式</strong>：SVN服务器端存储数据的方式</p><p><strong>BDB</strong>一种事务安全型表类型和<strong>FSFS</strong>一种不需要数据库的存储系统。 </p><p>因为BDB方式在服务器中断时，有可能锁住数据，所以<strong>还是FSFS方式更安全一点</strong></p></blockquote><ul><li>在此章节中，使用的操作客户端的工具是TortoiseSVN以及IDEA中SVN插件，SVN服务器使用的是VisualSVN</li></ul><h2 id="VisualSVN"><a href="#VisualSVN" class="headerlink" title="VisualSVN"></a>VisualSVN</h2><ol><li><p>下载</p><ul><li>下载地址：<a href="visualsvn.com/server/download/">SVN</a></li></ul></li><li><p>安装</p><blockquote><p><img src="https://blog.chasingwind.top/1570796950898.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570796950898.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>端口号可能会被占用  修改成不会被占用的就行了</p></blockquote></li><li><p>服务器界面</p><blockquote><p><img src="https://blog.chasingwind.top/1570797102312.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570797102312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建仓库</p><blockquote><p>选择存储数据的方式 这里选择的是FSFS</p><p><img src="https://blog.chasingwind.top/1570797303719.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570797303719.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>填写仓库名</p><p><img src="https://blog.chasingwind.top/1570797373603.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570797373603.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>选择初始化仓库结构是空结构的还是默认结构的  这里选择的是空结构的</p><p><img src="https://blog.chasingwind.top/1570797419578.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570797419578.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>选择权限控制</p><p><img src="https://blog.chasingwind.top/1570797515927.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570797515927.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>进行创建</p><p><img src="https://blog.chasingwind.top/1570797539997.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570797539997.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建用户和组</p><blockquote><p>Users为仓库创建可以访问的用户</p><p><img src="https://blog.chasingwind.top/1570808744434.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570808744434.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Group可以添加用户对用户分组进行管理</p><p><img src="https://blog.chasingwind.top/1570808827351.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570808827351.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>可以对用户和组进行权限管理</p><blockquote><p>在仓库上邮件–&gt;Properties–&gt;进行权限的配置</p><p><img src="https://blog.chasingwind.top/1570808900686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570808900686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>通过浏览器访问服务器（因为是基于Http协议的）</p><blockquote><p>获取访问路径</p><p><img src="https://blog.chasingwind.top/1570808989881.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570808989881.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>登陆之后的界面</p><p><img src="https://blog.chasingwind.top/1570809050192.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570809050192.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在后面，我们还可以通过客户端工具TortoiseSVN进行访问</p></blockquote></li></ol><h2 id="SVN目录结构以及作用"><a href="#SVN目录结构以及作用" class="headerlink" title="SVN目录结构以及作用"></a>SVN目录结构以及作用</h2><blockquote><p>可以创建非空的目录</p><p><img src="https://blog.chasingwind.top/1570864420990.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570864420990.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>目录结构</p><p><img src="https://blog.chasingwind.top/1570864485999.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570864485999.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>trunk 主干目录，此目录下的文件为基准文件 </p><p>branches 用于开发的分支目录 </p><p>tags 用于发布的版本目录 </p><hr><p>假设有一个项目OA,我们完成了1.0版本，这时就可以打一个tags </p><p>后续我们在OA项目上添加一个新的模块(及时通讯),我们就可以开一个分支,又有一个公司需要在我们OA基础上添加 </p><p>财务管理模块，我们又可以打一个分支。 </p><p>我们后续针对OA的1.0版本在升级，我们不需要原来附加功能,就可以在原来的主干上继续开发，形成OA2.0版本， </p><p>开发完成后就可以在打一个tags</p></blockquote><h2 id="TortoiseSVN的基本操作"><a href="#TortoiseSVN的基本操作" class="headerlink" title="TortoiseSVN的基本操作"></a>TortoiseSVN的基本操作</h2><ul><li><p>TortoiseSVN是Windows系统中的SVN客户端的图形化界面</p></li><li><p>TortoiseSVN的使用</p><ol><li><p>下载</p><ul><li>TortoiseSVN：<a href="https://tortoisesvn.net/downloads.html">下载</a></li></ul></li><li><p>安装后需要重启电脑，这样才能够正常显示后面的图标</p><blockquote><p>安装中需要选择  安装本地的svn.exe文件</p><p><img src="https://blog.chasingwind.top/1570848388162.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570848388162.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>浏览仓库</p><blockquote><p>在客户端浏览仓库</p><p><img src="https://blog.chasingwind.top/1570844984216.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570844984216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>输入仓库的访问路径</p><p><img src="https://blog.chasingwind.top/1570845053069.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845053069.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>输入用户名和密码  勾选框是保存认证 下次再去浏览仓库的额时候就不需要再次进行认证了</p><p><img src="https://blog.chasingwind.top/1570845070108.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845070108.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>还可以清除认证信息</p><p><img src="https://blog.chasingwind.top/1570845160607.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845160607.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570845219302.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845219302.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Checkout</p><blockquote><p>当用户连接到服务器之后，可以进行Checkout操作，从服务器第一次下载源代码</p><p><img src="https://blog.chasingwind.top/1570845306662.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845306662.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Checkout的一些选项</p><p><img src="https://blog.chasingwind.top/1570845392973.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845392973.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Checkout之后，文件夹会出现一个隐藏的文件夹<code>.svn</code></p><p><img src="https://blog.chasingwind.top/1570845448534.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845448534.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Add</p><blockquote><p>表示把文件添加到<strong>本地仓库</strong></p><p><img src="https://blog.chasingwind.top/1570845591363.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845591363.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>此时文件上出现的图标</p><p><img src="https://blog.chasingwind.top/1570845610067.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845610067.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意：当前只是在本地仓库中，远程的服务器仓库中并没有这个文件</p></blockquote></li><li><p>Commit</p><blockquote><p>把本地仓库中的文件提交到SVN服务器中</p><p><img src="https://blog.chasingwind.top/1570845715564.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845715564.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570845776424.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845776424.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>成功提交本地仓库中的文件之后  图标变成绿色的了</p><p><img src="https://blog.chasingwind.top/1570845819669.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570845819669.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>切换历史版本</p><blockquote><p><img src="https://blog.chasingwind.top/1570846195388.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570846195388.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>历史版本的选择</p><p><img src="https://blog.chasingwind.top/1570846257686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570846257686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>选择历史版本</p><p><img src="https://blog.chasingwind.top/1570846280954.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570846280954.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击OK  这样就切换到了历史版本</p><p><img src="https://blog.chasingwind.top/1570846298785.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570846298785.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Delete</p><blockquote><p>删除的仅仅是本地仓库中的文件  <strong>服务器中的文件还是存在的</strong></p><p>还需要Commit才能代表服务器端也被删除了</p><p><img src="https://blog.chasingwind.top/1570846378032.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570846378032.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>导入导出</p><blockquote><p>导入是将本地文件导入到SVN中</p><p>导出就是把整个仓库下载下来，和Checkout的区别就是导出项目的时候没有<code>.svn</code>隐藏文件，也就是说他是不受SVN的控制的</p></blockquote></li><li><p>TortoiseSVN冲突的产生</p><blockquote><p><strong>多个用户同时操作同一个文件的时候</strong>，就可能产生冲突</p><p>用户A和用户B初始的时候的版本是一致的 比如说当前版本号是1</p><p>用户A修改文件之后Commit，此时服务器中的版本号就是2</p><p>用户B没有Update到最新的版本2，还是在版本1的基础上修改文件之后也进行提交，对应的服务器中的版本号也会是2</p><p>此时就会产生冲突</p><p><img src="https://blog.chasingwind.top/1570847346466.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570847346466.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>解决冲突</p><blockquote><p>对冲突进行编辑</p><p><img src="https://blog.chasingwind.top/1570847495792.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570847495792.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>进行编辑</p><p><img src="https://blog.chasingwind.top/1570847625817.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570847625817.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里就是对比客户端的数据和服务器端的数据，对于不同的数据进行选择，作为最终的数据</p><p><img src="https://blog.chasingwind.top/1570847733856.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570847733856.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以看得到在合并的窗口中是最终版本的数据</p><p>这就是之前所说的  还是需要人工审核的</p><p><img src="https://blog.chasingwind.top/1570847823324.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570847823324.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Save-&gt;Marked as resolved标记已解决冲突</p><p>此时冲突就解决了  可以进行提交</p><hr><p>为了避免冲突的产生，<strong>我们每一次对文件进行修改之前，都把数据更新到最新的版本再进行修改提交</strong></p></blockquote></li></ul><h2 id="IDEA下SVN的使用"><a href="#IDEA下SVN的使用" class="headerlink" title="IDEA下SVN的使用"></a>IDEA下SVN的使用</h2><ul><li><p>前提是我们已经安装了TortoiseSVN</p><blockquote><p>在IDEA中进行配置 需要选择<code>svn.exe</code>可执行文件</p><p><img src="https://blog.chasingwind.top/1570848672259.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570848672259.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将工程提交到SVN服务器端</p><blockquote><p>Share Project  将工程提交到SVN服务器</p><p><img src="https://blog.chasingwind.top/1570848877197.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570848877197.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>添加服务器端仓库的路径</p><p><img src="https://blog.chasingwind.top/1570849062268.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570849062268.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>选择项目存放的位置</p><p><img src="https://blog.chasingwind.top/1570849150527.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570849150527.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Share  然后选择版本</p><p><img src="https://blog.chasingwind.top/1570849198662.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570849198662.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>此时  当前项目已经纳入SVN管理了</p><p><img src="https://blog.chasingwind.top/1570849213063.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570849213063.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>此时只是创建了项目的目录 <strong>还没有进行数据的提交  所以目录中还是空的</strong></p><p><img src="https://blog.chasingwind.top/1570852951154.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570852951154.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>加入管理之后，在上方的状态栏会出现5个SVN图标</p><blockquote><p><img src="https://blog.chasingwind.top/1570852432927.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570852432927.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>依次表示的是</p><ol><li><p>Update Project 更新项目 </p></li><li><p>Commit changes 提交项目上所有变化文件 </p></li><li><p>Compare with the Same Repository Version 当前文件与服务器上该文件的版本的内容进行比较。如果当前编辑的文件没有修改，则是灰色不可点击。 </p></li><li><p>Show history 显示当前文件的历史记录 </p></li><li><p>Revert 还原当前被修改的文件到违背修改的版本状态下（还原到指定的版本）</p></li></ol></blockquote></li><li><p>在下方的状态栏会出现SVN的信息</p><blockquote><p><img src="https://blog.chasingwind.top/1570852699834.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570852699834.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570852756750.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570852756750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol><li><p>Local Changes 本地修改过的文件都会出现在这里 </p></li><li><p>Repository SVN仓库所有提交记录 </p></li><li><p>Incoming 本地还没有更新的别人提交的代码 </p></li></ol></blockquote></li><li><p>Commit操作</p><blockquote><p>上方状态栏的Commit</p><p><img src="https://blog.chasingwind.top/1570853032903.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570853032903.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>下方状态栏的Commit</p><p><img src="https://blog.chasingwind.top/1570853061987.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570853061987.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击项目菜单</p><p><img src="https://blog.chasingwind.top/1570853126521.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570853126521.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Commit界面</p><p><img src="https://blog.chasingwind.top/1570853187094.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570853187094.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>此时，在服务器端才能看到我们提交的数据</p><p><img src="https://blog.chasingwind.top/1570853412017.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570853412017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Add，Update</p><blockquote><p>Add将文件添加到本地仓库</p><p>Update将本地数据更新到服务器端最新版本</p><p><img src="https://blog.chasingwind.top/1570853753286.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570853753286.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Checkout整个项目到IDEA工作空间中</p><blockquote><p><img src="https://blog.chasingwind.top/1570853929864.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570853929864.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>选择项目到IdeaProjects中</p><p><img src="https://blog.chasingwind.top/1570854012981.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570854012981.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Ignored</p><blockquote><p>忽略要提交的文件：并不是在Commit的时候都需要将所有的文件进行提交，比如jar包就不需要进行提交，还有IDEA自身依赖的文件，比如文件夹<code>.idea</code>和<code>.iml</code>文件</p><p>配置忽略上传的文件</p><p><img src="https://blog.chasingwind.top/1570854407243.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570854407243.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以设置忽略上传的文件,文件夹,正则表达式匹配的文件</p><p><img src="https://blog.chasingwind.top/1570854463883.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570854463883.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>解决冲突</p><blockquote><p>当出现冲突的时候</p><p><img src="https://blog.chasingwind.top/1570854929545.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570854929545.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>解决冲突  在这里看差别以及修改  然后提交</p><p><img src="https://blog.chasingwind.top/1570854945085.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570854945085.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="SVN打分支以及主干合并到分支"><a href="#SVN打分支以及主干合并到分支" class="headerlink" title="SVN打分支以及主干合并到分支"></a>SVN打分支以及主干合并到分支</h2><ul><li>分支的定义规则: Project name+日期时间+功能点 </li><li>Tags的定义规则 Project name+版本号 版本号定义为三段数字 编号 xxx.xxx.xxx 第一个:革命性的产品升级版 第二个:新功能版 第三个:修正bug</li></ul><h3 id="SVN打分支"><a href="#SVN打分支" class="headerlink" title="SVN打分支"></a>SVN打分支</h3><blockquote><p>首先将服务器端的数据Checkout下来</p><p><img src="https://blog.chasingwind.top/1570865278003.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570865278003.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>指定分支的路径</p><p><img src="https://blog.chasingwind.top/1570865306146.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570865306146.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这是仓库中的branches目录下就有了对应的分支，打tags同理</p></blockquote><h3 id="主干合并到分支"><a href="#主干合并到分支" class="headerlink" title="主干合并到分支"></a>主干合并到分支</h3><ul><li><p>首先保证主干是最新的（Update），然后在分支这边进行操作</p><blockquote><p><img src="https://blog.chasingwind.top/1570865581651.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570865581651.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>填写对应的路径即可</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven高级</title>
      <link href="2019/10/10/Maven%E9%AB%98%E7%BA%A7/"/>
      <url>2019/10/10/Maven%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>之前讲解的是Maven的基础使用，本节讲解的是Maven的高级应用，主要是Maven项目的拆分与聚合的思想以及实际操作，并且介绍了Maven的远程仓库和私服的概念</p><a id="more"></a><h2 id="Maven基础回顾"><a href="#Maven基础回顾" class="headerlink" title="Maven基础回顾"></a>Maven基础回顾</h2><ul><li><p>Maven是一个项目管理工具</p><blockquote><p>Maven的两个主要的功能</p><ol><li><p>依赖管理</p><blockquote><p>Maven对项目中jar包的管理过程。传统工程我们直接把jar包放置在项目中。<br>Maven工程<strong>真正的jar包放置在仓库中，项目中只用放置jar包的坐标。</strong></p><hr><p>仓库的种类 : 本地仓库，远程仓库【私服】，中央仓库。</p><p>仓库之间的关系：当我们启动一个Maven工程的时候，Maven工程会通过pom文件中jar包的坐标<strong>去本地仓库</strong>找对应jar包。</p><pre><code>  默认情况下，如果本地仓库没有对应jar包，maven工程会自动去中央仓库下载jar包到本地仓库。 在公司中，如果本地没有对应jar包，会先从私服下载jar包，    如果私服没有jar包，可以从中央仓库下载，也可以从本地上传。</code></pre></blockquote></li><li><p>一键构建</p><blockquote><p>Maven自身集成了Tomcat插件，可以对项目进行编译，测试，打包，安装，发布等操作。</p></blockquote></li></ol></blockquote></li></ul><h2 id="Maven中传统的Web工程"><a href="#Maven中传统的Web工程" class="headerlink" title="Maven中传统的Web工程"></a>Maven中传统的Web工程</h2><ol><li><p>环境搭建 </p><blockquote><p>创建数据库maven,创建表</p><p><img src="https://blog.chasingwind.top/1570711577630.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570711577630.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Web工程</p><blockquote><p>pom.xml文件的内容  这里是为了演示后面的效果 将所有的依赖全部删除</p><p><img src="https://blog.chasingwind.top/1570712727552.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570712727552.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Maven导入jar包的冲突的解决</p><blockquote><p>当我们导入jar包的时候,会同时将依赖的jar包也进行导入</p><p>可见 当我们仅仅导入spring-context的时候  实际导入的jar包是左边的</p><p><img src="https://blog.chasingwind.top/1570713288720.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570713288720.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们导入spring-context和spring-beans的时候</p><p><img src="https://blog.chasingwind.top/1570713352695.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570713352695.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以看到导入的两个jar包都会依赖spring-core，这时候因为两个jar包的版本并不相同，那么spring-core究竟会导入哪一个版本的呢???</p><p><img src="https://blog.chasingwind.top/1570713207525.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570713207525.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们把spring-beans放在spring-context上面的时候</p><p>可见导入的spring-core是4.2.8版本的</p><p><img src="https://blog.chasingwind.top/1570713513977.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570713513977.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>直接依赖：项目中直接导入的jar包，就是该项目的直接依赖包。比如上面的spring-beans和spring-context</p><p>传递依赖：项目中没有直接导入的jar包，可以通过项目直接依赖的jar包传递到项目中去。比如上面的spring-core等等…</p><p>当我们直接导入spring-core的jar包的时候，<strong>直接依赖和间接依赖的冲突</strong>？</p><p><img src="https://blog.chasingwind.top/1570714065802.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570714065802.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Maven工程要导入jar包的坐标，就必须解决jar包的冲突</p><p>解决方法1: <strong>声明优先</strong>原则，哪个jar包先声明，那么他的jar包坐标下的依赖包，可以优先进入项目中</p><p>解决方法2：<strong>路径近者优先</strong>原则：直接依赖路径比传递依赖路径近，当有直接依赖和间接依赖同时存在的时候，优先进入项目中的是直接依赖。</p><p>解决方法3：直接排除jar包的依赖包,也就是直接导入直接依赖的jar包,不导入jar包的依赖包</p><p><img src="https://blog.chasingwind.top/1570714755489.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570714755489.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>三大框架的jar包依赖</p><blockquote><pre><code class="xml">    &lt;!-- 统一管理jar包版本 --&gt;    &lt;properties&gt;        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;        &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt;        &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;        &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;        &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;    &lt;/properties&gt;    &lt;!-- 锁定jar包版本 --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-web&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-test&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mybatis&lt;/artifactId&gt;                &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;!-- 项目依赖jar包 --&gt;    &lt;dependencies&gt;        &lt;!-- spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.6.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log start --&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log end --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;c3p0&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.1.2&lt;/version&gt;            &lt;type&gt;jar&lt;/type&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;            &lt;version&gt;5.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.0.9&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 添加tomcat7插件 --&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre></blockquote></li><li><p>pom.xml中的标签介绍</p><blockquote><p><code>&lt;dependencymanagement&gt;</code>标签 : 锁定jar包版本，防止jar包的版本被传递依赖改变，传递依赖指的就是项目A被项目B依赖，那么A项目中的jar包就会传递到B项目中</p></blockquote></li></ol><h2 id="Maven工程拆分与聚合"><a href="#Maven工程拆分与聚合" class="headerlink" title="Maven工程拆分与聚合"></a>Maven工程拆分与聚合</h2><h2 id="私服-远程仓库"><a href="#私服-远程仓库" class="headerlink" title="私服(远程仓库)"></a>私服(远程仓库)</h2><h2 id="安装第三方jar包"><a href="#安装第三方jar包" class="headerlink" title="安装第三方jar包"></a>安装第三方jar包</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库进阶</title>
      <link href="2019/10/09/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/"/>
      <url>2019/10/09/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>本节主要介绍了Oracle数据库的对象,其中包括视图和索引,还有Oracle编程,介绍了PL/SQL编程语言,主要还是存储过程以及存储函数的使用以及使用Java操作数据库。</p><a id="more"></a><h2 id="Oracle对象"><a href="#Oracle对象" class="headerlink" title="Oracle对象"></a>Oracle对象</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li><p>视图就是提供一个查询的窗口，<strong>所有的数据来自于原表</strong>，视图中是不存放数据的。</p><blockquote><p>因为创建视图需要dba权限  </p><p>查询之前的环境使用的是在具有dba权限 的用户下创建的emp表</p><p><img src="https://blog.chasingwind.top/1570588033565.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570588033565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1570588132731.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570588132731.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>修改视图  发现  <strong>除了视图中的数据发生了改变 , 原表中的数据也发生了改变</strong></p><p>因为  <strong>所有的数据来自于原表，视图中是不存放数据的。</strong></p><p><img src="https://blog.chasingwind.top/1570588297328.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570588297328.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>修改视图的操作是不推荐的</p><hr><p>创建只读视图</p><p><img src="https://blog.chasingwind.top/1570588538421.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570588538421.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>视图的作用</p><ol><li><p>视图可以屏蔽表中的敏感字段 不在视图中显示</p><blockquote><p>比如上面的视图 你就无法看到原表中工资的情况</p></blockquote></li><li><p>保证数据的统一</p><blockquote><p>比如说：一个公司，总部的数据和分部的数据需要使用同一个数据，进行统一，给分部一个视图，这样的话，当总部的数据发生改变，分部使用的数据也是改变之后的，这就保证了数据的统一</p></blockquote></li></ol></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>在<strong>表的列上构建一个二叉树</strong>（B-tree，也就是B树），<strong>大幅度提高查询效率</strong>，但是会影响增删改的效率，因为每次增删改，树的结构就会发生变化，B树就需要重新构造以保持平衡的性质</p></li><li><p><strong>单列索引</strong>：构建在单列上的索引</p><blockquote><p><img src="https://blog.chasingwind.top/1570589405111.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570589405111.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>单列索引的触发条件指的是 ：<strong>当查询的条件必须是索引列的原始值的时候，才能够触发索引</strong>，否则的话，使用的只是普通的查询</p><p>单行函数，模糊查询作为条件都会影响索引的触发</p></blockquote></li><li><p><strong>复合索引</strong>：构建在多列上的索引</p><blockquote><p><img src="https://blog.chasingwind.top/1570594433616.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570594433616.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>索引的触发</p><p><img src="https://blog.chasingwind.top/1570594607738.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570594607738.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="Oracle编程"><a href="#Oracle编程" class="headerlink" title="Oracle编程"></a>Oracle编程</h2><h3 id="PL-SQL编程语言"><a href="#PL-SQL编程语言" class="headerlink" title="PL/SQL编程语言"></a>PL/SQL编程语言</h3><ul><li><p>PL/SQL编程语言是对SQL语言的扩展，使得SQL语言具有过程化编程的特性</p></li><li><p>PL/SQL比一般的过程化编程语言，更加灵活高效</p></li><li><p>PL/SQL主要用来<strong>编写存储过程和存储函数等</strong> </p><ol><li><p>PL/SQL中的声明函数</p><blockquote><p>相当于Java中的main方法的作用  执行的开始</p><p><img src="https://blog.chasingwind.top/1570601145474.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570601145474.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>PL/SQL中的变量的定义</p><blockquote><p><strong>基本类型变量</strong></p><p><img src="https://blog.chasingwind.top/1570601536452.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570601536452.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>引用型变量</strong></p><p><img src="https://blog.chasingwind.top/1570601804278.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570601804278.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>记录类型变量</strong></p><p>将表中的一行作为一个变量(相当于一个对象)</p><p><img src="https://blog.chasingwind.top/1570602375254.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570602375254.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>变量的定义:</p><ol><li><code>变量名  变量类型 :=  变量值</code></li><li><code>变量名  表中的列名%type</code></li><li><code>变量名 表%rowtype</code></li></ol><p>变量的赋值:</p><ol><li><code>:=</code></li><li>select中的<code>into 变量名</code></li></ol></blockquote></li><li><p>PL/SQL中的if判断</p><blockquote><p>注意else if  这里是<code>elsif</code></p><p><img src="https://blog.chasingwind.top/1570604660368.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570604660368.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>PL/SQL中的循环loop</p><blockquote><p>while循环</p><p><img src="https://blog.chasingwind.top/1570605045133.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570605045133.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>exit循环</p><p><img src="https://blog.chasingwind.top/1570605272894.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570605272894.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>for循环 </p><p><img src="https://blog.chasingwind.top/1570605404294.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570605404294.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>PL/SQL中的游标</p><blockquote><p>游标就相当于Java中的集合，可以存放多个对象，多行记录。</p><p><img src="https://blog.chasingwind.top/1570606125877.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570606125877.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当定义游标的时候 后面的select语句的条件是需要我们输入的时候</p><p>我们就可以在cur(xx)中定义  在open的时候输入的变量xx</p><p><img src="https://blog.chasingwind.top/1570606896804.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570606896804.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><ul><li><p>存储过程就是已经编译好的PL/SQL,<strong>放置在数据库端的Procedure表中,可以直接被调用</strong>，<strong>一般用于存储固定业务的步骤</strong></p></li><li><p>我们使用Java操作数据库必须先拿到连接Connection，而PL/SQL因为本身就在数据库端，不需要连接就可以直接操作数据库</p><blockquote><p>创建存储过程</p><p><img src="https://blog.chasingwind.top/1570609085315.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570609085315.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当子程序中有错误的时候</p><p><img src="https://blog.chasingwind.top/1570609215440.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570609215440.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>调用存储过程</p><p><img src="https://blog.chasingwind.top/1570609173393.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570609173393.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><ul><li><p>存储函数作用和存储过程是一样的</p><blockquote><p>定义存储函数</p><p><img src="https://blog.chasingwind.top/1570615977386.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570615977386.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>存储函数所在的表是Functions</p><p><img src="https://blog.chasingwind.top/1570616286836.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570616286836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>返回值类型 是不能写成number(xx)的  也就是说不能指定返回值的长度</p><p>但是可以在定义的变量中指定存储的长度</p><hr><p>使用存储函数</p><p><img src="https://blog.chasingwind.top/1570616210921.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570616210921.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>存储过程和存储函数的区别</p><blockquote><p>存储过程 : procedure , <strong>无返回值</strong></p><p>存储函数 : function , <strong>有返回值</strong>,这个特性可以作为自定义函数使用</p><hr><p>存储过程想要实现有返回值的业务, 就需要使用out参数 , 本质上还是这个参数被赋值, 而不是真正的有返回值</p><p>下面这种情况 就不能使用存储过程使用out参数作为输出来使用了</p><p><img src="https://blog.chasingwind.top/1570618744846.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570618744846.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="in和out类型参数"><a href="#in和out类型参数" class="headerlink" title="in和out类型参数"></a>in和out类型参数</h3><ul><li><p>在上面存储过程以及存储函数的使用中，<strong>参数默认都是in</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1570616715316.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570616715316.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>out类型的参数，用来在存储过程中存储执行的结果</p><blockquote><p><img src="https://blog.chasingwind.top/1570617171816.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570617171816.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用存储过程为out参数赋值</p><p><img src="https://blog.chasingwind.top/1570617505460.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570617505460.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>in和out类型参数的区别</p><blockquote><p>凡是涉及到into或者:=赋值操作的参数,都必须使用out修饰</p></blockquote></li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ol><li><p>概念和分类</p><blockquote><p>就是制定一个规则，在我们做<strong>增删改</strong>操作的时候，<strong>只要满足该规则，自动触发，无需调用。</strong></p><hr><p><strong>语句级触发器</strong>： 不包含for each row的触发器</p><p><strong>行级触发器</strong>：包含for each row的触发器</p><p>​     for each row 的作用是可以使用<code>:new</code> 和<code>:old</code>对象或者说是一行记录</p><p><img src="https://blog.chasingwind.top/1570619068299.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570619068299.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>触发器的使用</p><blockquote><p>语句级触发器</p><p><img src="https://blog.chasingwind.top/1570621073198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570621073198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们成功插入一条数据的时候  在控制台输出 ‘插入成功’  </p><p>也就说明触发器执行了</p><p><img src="https://blog.chasingwind.top/1570621117160.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570621117160.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>行级触发器</p><p>当我们需要新的和老的记录的时候使用</p><p><img src="https://blog.chasingwind.top/1570621670307.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570621670307.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上面的<code>raise_application_error(-20001,&#39;不能降薪&#39;);</code></p><p>表示抛出异常  </p><p>第一个参数的范围是-20001到-20999之间, 不能重复 表示异常的编号</p><p>第二个参数表示异常的提示信息</p><hr><p>当我们去执行降薪操作的时候  会弹出异常</p><p>并且表中的数据也没有被修改</p><p><img src="https://blog.chasingwind.top/1570621846345.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570621846345.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>触发器实现主键自增的功能</p><blockquote><p>将序列作为主键</p><p>因为序列的话 <strong>每查询一次都会+1</strong></p><p><img src="https://blog.chasingwind.top/1570622639606.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570622639606.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>下面的两种情况 都可以使用上面的自增长  在序列的基础上自增</p><p><strong>别忘记commit</strong></p><p><img src="https://blog.chasingwind.top/1570622848064.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570622848064.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Java调用存储过程和存储函数"><a href="#Java调用存储过程和存储函数" class="headerlink" title="Java调用存储过程和存储函数"></a>Java调用存储过程和存储函数</h2><ol><li><p>环境准备</p><blockquote><p>Oracle10g版本对应的jar包——————-&gt;ojdbc14.jar</p><p>Oracle11g版本对应的jar包——————-&gt;ojdbc6.jar</p><p><img src="https://blog.chasingwind.top/1570669700841.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570669700841.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用Java连接数据库</p><blockquote><pre><code class="java">String driver = &quot;oracle.jdbc.driver.OracleDriver&quot;;String url = &quot;jdbc:oracle:thin:@ip地址:1521:orcl&quot;;String username = &quot;&quot;;String password = &quot;&quot;;</code></pre><p>使用Java连接Oracle数据库</p><p><img src="https://blog.chasingwind.top/1570670305169.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570670305169.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Java调用存储过程和存储函数</p><blockquote><p>CallableStatement接口</p><p><img src="https://blog.chasingwind.top/1570671049179.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570671049179.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><pre><code class="java">存储函数&#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125;存储过程&#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; </code></pre><hr><p>调用存储过程</p><p><img src="https://blog.chasingwind.top/1570671785932.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570671785932.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>调用存储函数</p><p><img src="https://blog.chasingwind.top/1570672186433.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570672186433.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库基础</title>
      <link href="2019/10/08/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
      <url>2019/10/08/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>本节主要介绍了Oracle数据库的一些基本概念,Oracle数据库的体系结构以及和MySQL数据库的区别,另外还有关于Oracle数据库的一些基本的操作。</p><a id="more"></a><h2 id="Oracle简介"><a href="#Oracle简介" class="headerlink" title="Oracle简介"></a>Oracle简介</h2><p>Oracle是一家软件开发公司，因为开发的名为Oracle数据库而名声大噪。Oracle在中国就是甲骨文公司。</p><p>Oracle数据库以数据存储量大，处理速度快，安全性高，容错性强等出色特征，长期占有全球数据库市场的重要地位。</p><h2 id="Oracle数据库的安装"><a href="#Oracle数据库的安装" class="headerlink" title="Oracle数据库的安装"></a>Oracle数据库的安装</h2><ol><li>安装Oracle数据库</li><li>使用PLSQL图形化界面连接Oracle数据库（需要在配置Oracle数据库连接的基础上）</li></ol><h2 id="Oracle数据库的体系结构"><a href="#Oracle数据库的体系结构" class="headerlink" title="Oracle数据库的体系结构"></a>Oracle数据库的体系结构</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><blockquote><p>Oracle 数据库是数据的物理存储。这就包括（数据文件 ORA 或者 DBF、控制文件、联机日志、参数文件）。</p><p>其实 Oracle 数据库的概念和其它数据库不一样，<strong>这里的数据库是一个操作系统只有一个库</strong>。可以看作是 Oracle 就只有一个大数据库。</p><p><strong>侧重于硬件</strong></p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote><p>一个 Oracle 实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构 </p><p>（Memory Structures)组成。一个数据库可以有 n 个实例。 </p><p>但是<strong>一般一个数据库只运行一个实例</strong></p></blockquote><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><blockquote><p>用户是在实例下建立的。不同实例可以建相同名字的用户</p><p><strong>用户是Oracle管理表的基本单位</strong></p></blockquote><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><blockquote><p>是一个逻辑概念</p><p>每个表空间由同一个磁盘上的一个或多个文件组成,这些文件就是数据文件</p></blockquote><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><blockquote><p><strong>数据文件（.dbf/.ora）</strong>是数据库的物理存储单位，<strong>数据库的数据是存储在表空间中的</strong>，而真正存储是存储在某一个或者多个数据文件中的</p><p>而<strong>一个表空间可以由一个或多个数据文件组成</strong>，一个数据文件只能属于 </p><p>一个表空间。</p><p><strong>一旦数据文件被加入到某个表空间后，就不能删除这个数据文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。</strong></p><hr><p><strong>注: 表的数据，是由用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。</strong></p></blockquote><blockquote><p>图中是一个数据库  </p><p><strong>用户可以对表空间中的数据文件进行操作</strong></p><p>用户可以具有不同的权限</p><p><img src="https://blog.chasingwind.top/1570531172812.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570531172812.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>由于 Oracle 的数据库不是普通的概念，Oracle是由用户和表空间对数据进行管理和存放的。 </p><p>但是表不是由表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！</p></blockquote><h2 id="Oracle数据类型"><a href="#Oracle数据类型" class="headerlink" title="Oracle数据类型"></a>Oracle数据类型</h2><blockquote><p>varchar2  长度是可变的  比如 指定varchar2(10)  就表示存储最多10个字符</p><p>但是你存进去一个汉字的话 取出来的长度是1</p><p>而char(10)  你存进去一个汉字 取出来长度就是10</p><p><img src="https://blog.chasingwind.top/1570533955162.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570533955162.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h2 id="Oracle的基本操作"><a href="#Oracle的基本操作" class="headerlink" title="Oracle的基本操作"></a>Oracle的基本操作</h2><ul><li>Oracle中<strong>除了起别名使用双引号或者直接写别名</strong>，其他的都是使用单引号</li></ul><h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h3><blockquote><p>创建表空间  表空间里面可以创建多个<code>.dbf</code>数据文件</p><p>将来我们的数据 是由用户放入到表空间中 表空间把数据存储到数据文件中的</p><p><img src="https://blog.chasingwind.top/1570532559438.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570532559438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>一旦数据文件被加入到某个表空间后，就不能删除这个数据文件，如果要删除某个数据文件，<strong>只能删除其所属于的表空间才行</strong></p><p><img src="https://blog.chasingwind.top/1570532764653.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570532764653.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>删除表空间</p><p><img src="https://blog.chasingwind.top/1570532848770.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570532848770.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样就可以把数据文件(.dbf)删除了</p></blockquote><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><blockquote><p>创建新的用户</p><p><img src="https://blog.chasingwind.top/1570533319024.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570533319024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>在Oracle中管理表的基本单位是  用户</p><p>而每个用户的权限是不同的  所以我们需要对用户的权限进行设置</p><p>为了便于对用户进行授权  在Oracle数据库中使用角色来存储不同的权限  </p><p><strong>角色就是相关权限的命令集合</strong>，使用角色的主要目的就是为了简化权限的管理。</p><p>connect    用于常见数据库连接</p><p>resource 具有应用开发人员所需要的其它权限，比如建立存储过程、触发器等</p><p>dba   超级管理员角色</p><p><img src="https://blog.chasingwind.top/1570533673268.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570533673268.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><blockquote><p><img src="https://blog.chasingwind.top/1570534212697.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570534212697.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><blockquote><p><img src="https://blog.chasingwind.top/1570534805784.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570534805784.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="增删改数据"><a href="#增删改数据" class="headerlink" title="增删改数据"></a>增删改数据</h3><blockquote><p><strong>需要手动提交数据</strong></p><p>Oracle中文乱码显示问题  首先需要配置系统环境变量  并且需要重启Oracle服务 </p><p><img src="https://blog.chasingwind.top/1570537727364.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570537727364.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><blockquote><p>默认从1开始 依次递增  主要给主键赋值使用</p><p><strong>序列不属于任何一张表   但是可以在逻辑上与表进行绑定</strong></p><p><strong>dual: 虚表  因为在Oracle中查询必须使用from关键字 dual只是为了</strong>补全语法使用的</p><p>查询当前值  必须在由当前值的情况下  虽然是默认从1开始 但是你不执行一次的话 是没有当前值的  所以查询当前值  需要在nextval执行一次后执行</p><p><img src="https://blog.chasingwind.top/1570538167916.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570538167916.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在插入数据的时候使用</p><p><img src="https://blog.chasingwind.top/1570538452347.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570538452347.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>即使rollback了   序列的值也会增加 </p><p>这就会出现不连续的情况  不过也没关系  我们只需要保证主键非空唯一就行了</p></blockquote><h2 id="Oracle的查询"><a href="#Oracle的查询" class="headerlink" title="Oracle的查询"></a>Oracle的查询</h2><h3 id="Scott用户介绍"><a href="#Scott用户介绍" class="headerlink" title="Scott用户介绍"></a>Scott用户介绍</h3><blockquote><p>Scott用户管理的表空间里面的表常常作为示例来使用</p><p>默认密码tiger</p><p>使用之前需要进行进行解锁</p><p><img src="https://blog.chasingwind.top/1570541013405.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570541013405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>用户的表空间中的表</p><p><img src="https://blog.chasingwind.top/1570540760844.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570540760844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570541081318.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570541081318.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>表之间的关系</p><p><img src="https://blog.chasingwind.top/1570541099682.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570541099682.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><ul><li><p>作用于一行，返回一个值</p><ol><li><p>字符函数</p><blockquote><p>大小写控制函数</p><p><img src="https://blog.chasingwind.top/1570541892269.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570541892269.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>字符控制函数</p><p><strong>索引从1开始</strong></p><p><img src="https://blog.chasingwind.top/1570542480472.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570542480472.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>trim的时候 如果有重复的字符(不区分大小写的情况下 )  是无法删除的</p><p>如果没有重复的字符 是区分大小写的</p><p><img src="https://blog.chasingwind.top/1570542584299.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570542584299.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>数值函数</p><blockquote><p><img src="https://blog.chasingwind.top/1570542919908.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570542919908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570543065813.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570543065813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570543106002.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570543106002.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>日期函数</p><blockquote><p>Oracle 中提供了很多和日期相关的函数，包括日期的加减，在日期加减时有一些规律 </p><p>日期 – 数字 = 日期 </p><p>日期 + 数字 = 日期 </p><p>日期 – 日期 = 数字</p><hr><p><img src="https://blog.chasingwind.top/1570543680866.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570543680866.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>转换函数</p><blockquote><p>日期转字符串</p><p><img src="https://blog.chasingwind.top/1570543957435.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570543957435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>字符串转日期</p><p><img src="https://blog.chasingwind.top/1570544060920.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570544060920.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>通用函数</p><blockquote><p>任何数和null进行运算 结果都是null</p><p>nvl(参数1,参数2) 参数1为null的话 就用参数2代替null进行计算</p><p> 相当于MySQL中的ifnull(参数1,参数2)</p><p><img src="https://blog.chasingwind.top/1570544347287.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570544347287.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><ul><li><p>MySQL和Oracle通用的写法</p><blockquote><p><strong>等值判断</strong></p><p>给员工起中文名  这里的作用有点像Java中的case</p><p><img src="https://blog.chasingwind.top/1570547534263.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570547534263.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当<strong>省略else的时候 不匹配的值都是null</strong></p><p><img src="https://blog.chasingwind.top/1570547599557.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570547599557.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><strong>范围判断</strong></p><p>这里1500-3000范围不需要写&lt;3000是因为  只有小于3000才能进入到&gt;1500的判断中来</p><p><img src="https://blog.chasingwind.top/1570547865900.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570547865900.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Oracle特有的写法（不常用）</p><blockquote><p><img src="https://blog.chasingwind.top/1570548260026.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570548260026.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1570548300374.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570548300374.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>起别名  使用单引号的话 会报错的</p></blockquote></li></ul><h3 id="多行函数（聚合函数）"><a href="#多行函数（聚合函数）" class="headerlink" title="多行函数（聚合函数）"></a>多行函数（聚合函数）</h3><ul><li><p>作用于多行，返回一个值</p><ol><li><p>count(1)  查询总数量</p><blockquote><p>count(1)==count(主键)==count(*)</p><p>count(*)底层使用的就是count(1)</p><p><img src="https://blog.chasingwind.top/1570548516615.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570548516615.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>sum()  总和</p></li><li><p>max() 最大值</p></li><li><p>min() 最小值</p></li><li><p>avg() 平均值</p></li></ol></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li><p>分组查询中select后面只能使用分组查询的条件和聚合函数，也就是不可以是某个数据的单独的特性，而应该是整个组的特性</p><blockquote><p>group by</p><p><img src="https://blog.chasingwind.top/1570548912977.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570548912977.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>where  对满足条件的数据进行分组 在group by 之前</p><p><img src="https://blog.chasingwind.top/1570549327624.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570549327624.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>having   对分组之后的数据进行筛选  在group by 之后</p><p><img src="https://blog.chasingwind.top/1570549126144.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570549126144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li><p>笛卡尔积</p><blockquote><p><img src="https://blog.chasingwind.top/1570549554409.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570549554409.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>等值连接(内连接)</p><blockquote><p>为了筛选出笛卡尔积中的有用的数据 使用等值连接</p><p><img src="https://blog.chasingwind.top/1570549657025.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570549657025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>等值连接没出现之前就是使用内连接  他们的作用相同</p><p><img src="https://blog.chasingwind.top/1570549745468.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570549745468.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>左(右)外连接</p><blockquote><p>解决为null的时候 查询不出来的情况</p><p><img src="https://blog.chasingwind.top/1570549860992.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570549860992.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Oracle中特有的外连接(不常用)</p><blockquote><p><img src="https://blog.chasingwind.top/1570550121787.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570550121787.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><ul><li><p>表自身连接 站在不同的角度把一张表看成不同的表</p><blockquote><p><img src="https://blog.chasingwind.top/1570550349611.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570550349611.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>需求   查询员工的姓名  以及员工的领导姓名</p><p><img src="https://blog.chasingwind.top/1570550462770.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570550462770.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1570551023473.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570551023473.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li><p>子查询返回一个值</p><blockquote><p><img src="https://blog.chasingwind.top/1570582146718.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570582146718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里有一个隐患就是 因为ename不保证唯一(因为不是主键)  此时当你使用=的时候 就会出现错误</p><hr><p>保险起见 这里应该使用in   如果保证子查询唯一的话  也是可以使用=的</p><p><img src="https://blog.chasingwind.top/1570582398530.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570582398530.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>子查询返回一个集合</p><blockquote><p><img src="https://blog.chasingwind.top/1570582343391.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570582343391.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>子查询返回一张表</p><blockquote><p><img src="https://blog.chasingwind.top/1570582933314.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570582933314.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>将这里的结果作为一张表 参与查询</p><p><img src="https://blog.chasingwind.top/1570583028718.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570583028718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><blockquote><p>Oracle中的分页  </p><p>行号<strong>rownum</strong>：不属于任何一张表，但是每张表都可以用</p><p>当我们在<strong>select</strong>的时候，每查询出一条记录，就会该行加上一个行号，<strong>行号从1开始，依次递增，不间断</strong>。</p><hr><p><img src="https://blog.chasingwind.top/1570583580208.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570583580208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>解决方法就是 ： 先进行工资排序 ， 再将它作为子表 然后再用rownum</p><p><img src="https://blog.chasingwind.top/1570583974831.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570583974831.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>rownum &lt; 11 and rownum &gt; 5  查询出来的是空表</p><p><img src="https://blog.chasingwind.top/1570584421921.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570584421921.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>原因 : 因为查询的时候 <strong>先执行的是where条件</strong> 再执行select加行号的操作</p><p>rownum初始化的时候是1 ,1 &lt; 11 然后1 并不大于5 条件不满足 </p><p>这样的话 就没有记录  就无法添加行号1  </p><p>上面也说了 行号rownum 从1开始依次递增 不间断</p><p>所以查询就是空的</p><p><strong>结论</strong> : 行号<strong>rownum不能写成大于一个正数</strong></p><hr><p>间接使用 rownum &gt; 5 因为rownum不属于任何一张表  </p><p>所以不能使用<code>表名.rownum</code>的方法  但是可以给行号取别名使用  </p><p>在实际的使用中的范围需要是动态的</p><p><img src="https://blog.chasingwind.top/1570585017314.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570585017314.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2019/09/29/Git/"/>
      <url>2019/09/29/Git/</url>
      
        <content type="html"><![CDATA[<p>Git是一个开源的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。 [1]  Git 是 [Linus Torvalds](<a href="https://baike.baidu.com/item/Linus">https://baike.baidu.com/item/Linus</a> Torvalds/9336769) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</p><a id="more"></a><h2 id="Git概念"><a href="#Git概念" class="headerlink" title="Git概念"></a>Git概念</h2><ul><li>Git是一个开源的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。 [1]  Git 是 [Linus Torvalds](<a href="https://baike.baidu.com/item/Linus">https://baike.baidu.com/item/Linus</a> Torvalds/9336769) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li><li>最初是使用在Linux上的代码版本管理工具的,现在各个系统都有对应的版本.</li></ul><h2 id="Git和SVN的区别"><a href="#Git和SVN的区别" class="headerlink" title="Git和SVN的区别"></a>Git和SVN的区别</h2><ul><li><p>SVN是<strong>集中式</strong>版本管理工具</p><blockquote><p>SVN需要有一台服务器来击中管理代码</p><p><img src="https://blog.chasingwind.top/1575185118831.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575185118831.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575185118831"></p></blockquote></li><li><p>Git是<strong>分布式</strong>版本管理工具, 没有中央服务器</p><blockquote><p>使用Git的用户自己的电脑中就有一个和远程仓库中相同的版本库</p><p><img src="https://blog.chasingwind.top/1575185547959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575185547959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575185547959"></p></blockquote><ul><li><strong>本地仓库</strong>：每一个开发人员的电脑上都有一个本地仓库，实现在本地仓库实现代码的管理，如果开发项目只需要一个人来完成，那么只需要一个本地仓库就足够了</li><li><strong>远程仓库</strong>：多人协作开发一个项目，就需要进行代码的交换，这个时候就需要一个共享版本库（远程仓库），远程仓库和本地仓库的内容是相同的</li></ul></li></ul><h2 id="Git的工作流程"><a href="#Git的工作流程" class="headerlink" title="Git的工作流程"></a>Git的工作流程</h2><ol><li><p>从远程仓库中克隆（<strong>Clone</strong>） Git 资源作为本地仓库。</p></li><li><p>从本地仓库中<strong>Checkout</strong>代码然后进行代码修改</p></li><li><p>在提交（<strong>Add</strong>）前先将代码提交到<strong>暂存区</strong>。</p></li><li><p><strong>提交（Commit）到本地仓库</strong>。本地仓库中保存修改的各个历史版本。</p></li><li><p>在修改完成后，需要和团队成员共享代码时，可以将代码<strong>Push到远程仓库</strong>。</p><blockquote><p>流程图</p><p><img src="https://blog.chasingwind.top/1575186051973.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575186051973.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575186051973"></p></blockquote></li></ol><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><ul><li><p>Windows下安装</p><ul><li><p>直接默认进行安装,一直下一步就行了</p><blockquote><p>安装好之后,右键菜单中就会出现Git</p><p><img src="Git%5C1569764949201.png" class="lazyload" data-srcset="Git%5C1569764949201.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Git GUI  和  Git  Bash</p><p><img src="Git%5C1569765015172.png" class="lazyload" data-srcset="Git%5C1569765015172.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在 Git  Bash中是<strong>支持Linux 命令</strong>的</p></blockquote></li><li><p>由于原生的Git使用起来并不是很方便  ,可以使用<a href="https://tortoisegit.org/download/">tortoisegit</a></p><blockquote><p>安装的时候选择OpenSSH,并且需要执行Git所在的目录,所以需要在安装TortoiseGit之前需要先安装Git </p></blockquote></li></ul></li></ul><h2 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h2><h3 id="使用Git创建版本库-本地仓库"><a href="#使用Git创建版本库-本地仓库" class="headerlink" title="使用Git创建版本库(本地仓库)"></a>使用Git创建版本库(本地仓库)</h3><ul><li><p>在需要的目录下创建本地仓库(Repository),即使<code>.git</code>目录</p><ol><li><p>Git Bush</p><blockquote><p>使用命令git init 创建一个本地仓库</p><p><img src="https://blog.chasingwind.top/1575186926275.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575186926275.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575186926275"></p></blockquote></li><li><p>Git GUI</p><blockquote><p>首先打开Git GUI</p><p><img src="https://blog.chasingwind.top/1575186975927.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575186975927.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575186975927"></p><p>点击创建新的仓库  选择本地仓库的目录</p><p><img src="https://blog.chasingwind.top/1575187012718.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187012718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187012718"></p><p>点击Create之后就会创建本地仓库</p><p><img src="https://blog.chasingwind.top/1575187083010.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187083010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187083010"></p></blockquote></li><li><p>Tortoise Git</p><blockquote><p>在需要的目录点击创建新的本地仓库</p><p><img src="https://blog.chasingwind.top/1575187176935.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187176935.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187176935"></p><p>不勾选点击OK</p><p><img src="https://blog.chasingwind.top/1575187210833.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187210833.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187210833"></p></blockquote></li></ol></li><li><p>查看<code>.git</code>目录中的内容</p><blockquote><p><img src="https://blog.chasingwind.top/1575188252479.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575188252479.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575188252479"></p></blockquote></li></ul><h3 id="向本地仓库添加文件"><a href="#向本地仓库添加文件" class="headerlink" title="向本地仓库添加文件"></a>向本地仓库添加文件</h3><ul><li><p>如果<strong>想向本地仓库添加文件的话, 文件必须在工作目录下</strong></p><ol><li><p>工作目录</p><blockquote><p>这里的工作目录就是包含<code>.git</code>的目录, 这里指的就是repo目录,也就是和<code>.git</code>所在的目录</p><p><img src="https://blog.chasingwind.top/1575187380967.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187380967.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187380967"></p></blockquote></li><li><p>本地仓库目录<code>.git</code></p></li></ol></li><li><p>向本地仓库添加文件</p><blockquote><p>首先,文件需要在工作目录中</p><p>然后,使用<strong>Add</strong>把文件添加到<strong>暂存区</strong>中, 添加完成后文件上就会显示一个+号</p><p><img src="https://blog.chasingwind.top/1575187652283.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187652283.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187652283"></p><p>最后,使用<strong>Commit</strong>将暂存区中Add的文件提交到当前分支中</p><p>Commit的时候需要选择分支, master分支是在创建版本库的时候默认创建的</p><p><img src="https://blog.chasingwind.top/1575187893994.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187893994.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187893994"></p><p>填写日志信息并提交</p><p><img src="https://blog.chasingwind.top/1575187960122.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187960122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187960122"></p><p><img src="https://blog.chasingwind.top/1575187987047.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575187987047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575187987047"></p><p>在工作目录中的文件上显示√</p><p><img src="https://blog.chasingwind.top/1575188019447.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575188019447.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575188019447"></p></blockquote><ul><li><p>可以简单理解为: 需要提交的文件修改通通放到<strong>暂存区</strong>，然后，<strong>一次性提交暂存区的所有修改到本地仓库。</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1575188523633.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575188523633.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575188523633"></p></blockquote></li></ul></li><li><p>使用TortoiseGit查看本地仓库中已经提交的内容</p><blockquote><p>Tortoise–&gt;Repo Broswer</p><p><img src="https://blog.chasingwind.top/1575188661435.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575188661435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575188661435"></p><p>可以查看我们提交的文件</p><p><img src="https://blog.chasingwind.top/1575188703965.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575188703965.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575188703965"></p></blockquote></li><li><p>修改文件并提交</p><blockquote><p>可以直接使用TortoiseGit的提交,这里就<strong>包括了Add+Commit</strong>的两个操作</p><p><img src="https://blog.chasingwind.top/1575188864575.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575188864575.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575188864575"></p><p>填写日志  点击Commit</p><p><img src="https://blog.chasingwind.top/1575188916202.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575188916202.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575188916202"></p></blockquote></li><li><p>查看提交记录,对比修改的内容</p><blockquote><p>在<strong>需要查看的文件</strong>上点击右键  点击Show log查看日志</p><p><img src="https://blog.chasingwind.top/1575189084220.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575189084220.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575189084220"></p><hr><p>选中需要对比的文件  进行比较</p><p><img src="https://blog.chasingwind.top/1575189181373.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575189181373.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575189181373"></p><p>这里就可以查看到修改的内容了</p><p><img src="https://blog.chasingwind.top/1575189210327.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575189210327.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575189210327"></p></blockquote></li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ol><li><p>删除工作目录中的文件并删除本地仓库中的文件</p><blockquote><p>首先,需要在工作目录中的文件删除</p><p><img src="https://blog.chasingwind.top/1575189882624.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575189882624.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575189882624"></p><p>但是此时本地仓库中其实还是存在着这个文件的</p><p><img src="https://blog.chasingwind.top/1575189943096.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575189943096.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575189943096"></p><hr><p>所以,如果我们不小心删除了文件 , 是可以还原回来的</p><p><img src="https://blog.chasingwind.top/1575190056395.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190056395.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190056395"></p><p>点击需要还原的文件就可以还原了</p><p><img src="https://blog.chasingwind.top/1575190080160.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190080160.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190080160">‘</p><hr><p>删除本地仓库中的文件, 其实就是将删除文件的这个修改提交到本地仓库</p><p>直接Commit</p><p><img src="https://blog.chasingwind.top/1575190185868.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190185868.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190185868"></p><p>再次查看就会发现本地仓库中已经不存在了</p><p><img src="https://blog.chasingwind.top/1575190229304.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190229304.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190229304"></p></blockquote></li><li><p>不删除工作目录中的文件删除本地仓库中的文件</p><blockquote><p>当我们需要保留本地的配置文件的时候,就是说把不需要的文件在本地仓库中删除,而在工作目录中保留</p><p>使用删除并保留本地副本</p><p><img src="https://blog.chasingwind.top/1575190484247.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190484247.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190484247"></p><p>但是此时在本地仓库中还是存在文件的</p><p><img src="https://blog.chasingwind.top/1575190535313.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190535313.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190535313"></p><p>提交之后,可以删除本地仓库中的文件,但是在工作目录中还是存在的</p><p><img src="https://blog.chasingwind.top/1575190627935.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190627935.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190627935"></p><p><img src="https://blog.chasingwind.top/1575190655953.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1575190655953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1575190655953"></p></blockquote></li></ol><h3 id="将Java工程添加到本地仓库"><a href="#将Java工程添加到本地仓库" class="headerlink" title="将Java工程添加到本地仓库"></a>将Java工程添加到本地仓库</h3><ul><li>忽略的文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="2019/08/31/SSM%E6%95%B4%E5%90%88/"/>
      <url>2019/08/31/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>前面的三个框架学到这里该来一个整合了，将Spring，SpringMVC还有MyBatis框架搭建成一个完成的开发环境，所以还是很重要的内容。</p><a id="more"></a><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><ol><li><p>整合的思路：使用Spring去整合SpringMVC和MyBatis框架，使用XML+注解的方式进行配置</p></li><li><p>数据库环境的搭建</p><blockquote><p><img src="https://blog.chasingwind.top/1567235251311.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567235251311.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建web项目</p><blockquote><p>导入相关的依赖</p><pre><code class="xml">&lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;        &lt;!--版本锁定--&gt;        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;        &lt;mysql.version&gt;8.0.11&lt;/mysql.version&gt;        &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.6.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--单元测试junit--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--MySQL数据库驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--servlet--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--jsp--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--jstl表达式--&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log start --&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log end --&gt;        &lt;!--MyBatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.0.9&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre></blockquote></li><li><p>创建java和resources文件夹还有三层架构的包以及JavaBean的包</p><blockquote><p>首先需要创建edu.ahnu之类的GroupId</p><p><img src="https://blog.chasingwind.top/1567237320299.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567237320299.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Account的JavaBean</p><blockquote><p><img src="https://blog.chasingwind.top/1567236475960.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567236475960.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Dao</p><blockquote><p>Dao中的方法我们可以不使用实现类来实现</p><p>所以只需要编写AccountDao接口</p><p><img src="https://blog.chasingwind.top/1567236517661.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567236517661.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Service以及实现类</p><blockquote><p><img src="https://blog.chasingwind.top/1567236541660.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567236541660.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1567236555119.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567236555119.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建web层的Controller</p><blockquote><p><img src="https://blog.chasingwind.top/1567236574559.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567236574559.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>整体的目录结构</p><blockquote><p><img src="https://blog.chasingwind.top/1567237352431.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567237352431.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Spring框架代码的编写"><a href="#Spring框架代码的编写" class="headerlink" title="Spring框架代码的编写"></a>Spring框架代码的编写</h2><p>框架的整合是在Spring的基础上进行的，所以我们首先需要完成Spring的搭建</p><blockquote><p> 这里使用applicationContext.xml而不能使用spring.xml</p><p>因为后面的Spring整合SpringMVC的时候需要监听配置文件的加载  监听器只能监听到applicationContext.xml</p></blockquote><ol><li><p>首选在resources目录下创建spring.xml配置文件来管理Service和Dao层</p><blockquote><p>在配置文件中添加约束</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;https://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;https://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;https://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        https://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd        https://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd    https://www.springframework.org/schema/tx     https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;/beans&gt;</code></pre><hr><p> 开启注解扫描，<strong>要扫描的是service和dao层的注解</strong>，要<strong>忽略web层注解</strong>，因为web层让SpringMVC框架去管理</p><p><img src="https://blog.chasingwind.top/1567237549741.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567237549741.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Ctrl+N搜索Controller注解的全路径 然后使用Copy References获取类所在的包的路径</p><p><img src="https://blog.chasingwind.top/1567237450785.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567237450785.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在Service上添加注解</p><blockquote><p><img src="https://blog.chasingwind.top/1567238099761.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567238099761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行测试</p><blockquote><p><img src="https://blog.chasingwind.top/1567238131959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567238131959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>控制台中的信息 是缺少log4j配置文件  在resources中添加配置文件就行了</p></blockquote></li><li><p>至此, Spring框架就可以正常使用了</p></li></ol><h2 id="SpringMVC环境搭建"><a href="#SpringMVC环境搭建" class="headerlink" title="SpringMVC环境搭建"></a>SpringMVC环境搭建</h2><ol><li><p>在web.xml中配置前端控制器和解决中文乱码的过滤器</p><blockquote><p><img src="https://blog.chasingwind.top/1567241487081.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567241487081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在resources目录下创建springmvc.xml</p><blockquote><p>加入约束</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;https://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;https://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        https://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        https://www.springframework.org/schema/mvc        https://www.springframework.org/schema/mvc/spring-mvc.xsd        https://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</code></pre><p>设置静态资源不过滤</p><pre><code class="xml">&lt;!-- 设置静态资源不过滤 --&gt;    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;</code></pre><hr><p><img src="https://blog.chasingwind.top/1567242142113.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567242142113.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试 去请求Controller中的方法</p><blockquote><p>首先 完成jsp文件的编写</p><p>index.jsp</p><p><img src="https://blog.chasingwind.top/1567242652438.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567242652438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>success.jsp</p><p><img src="https://blog.chasingwind.top/1567242666392.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567242666392.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>控制器类</p><p><img src="https://blog.chasingwind.top/1567242687192.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567242687192.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意这里的文件路径的创建</p><p><img src="https://blog.chasingwind.top/1567242725400.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567242725400.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行测试  可以完成页面的跳转</p><blockquote><p><img src="https://blog.chasingwind.top/1567242800761.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567242800761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h2><p>这里的整合需要完成的就是，<strong>启动服务器,加载配置文件,注入Service层方法,在Controller方法中可以调用Service层的方法</strong></p><p>要想在Controller中使用Service对象，就需要依赖注入（DI），但是有一个问题！</p><p>在服务器启动的时候，在web.xml中配置了前端控制器去加载sprngmvc.xml配置文件，在这个配置文件中只扫描Controller注解，别的注解不扫描，也就是说我们的Spring的配置文件就没有加载过，那么其中的扫描就不会生效，那么Service类就不会加入到IoC容器中 ，那么就无法使用依赖注入</p><p>所以，我们需要做的就是<strong>在服务器启动的时候加载Spring的配置文件</strong>，同时扫描就会生效，Service类就会被放到容器中，我们就可以使用依赖注入的方式创建Service对象</p><blockquote><p>Spring整合SpringMVC的原理</p><p><img src="https://blog.chasingwind.top/1567251379907.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567251379907.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>监听器可以使用Spring为我们提供好的Spring-web中的类<code>ContextLoaderListener</code>,使用他来加载我们的配置文件,而我们只需要进行配置就行了</p><p>在web.xml中进行配置Spring的监听器  <strong>但是这个监听器默认只会加载WEB-INF目录下的applicationContext.xml文件</strong></p><p><img src="https://blog.chasingwind.top/1567251936541.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567251936541.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>但是我们的配置文件放在了resources目录下  所以需要告诉监听器加载的文件的路径</p><p><img src="https://blog.chasingwind.top/1567252413262.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567252413262.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这样就完成了Spring的配置文件的加载  也就会进行注解的扫描 创建对应的bean注入到IoC容器中</p><p>可以使用依赖注入的方式来创建对象</p><p>调用Service中的方法</p><p><img src="https://blog.chasingwind.top/1567252609647.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567252609647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>成功执行</p><p><img src="https://blog.chasingwind.top/1567252680731.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567252680731.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h2 id="MyBatis环境搭建"><a href="#MyBatis环境搭建" class="headerlink" title="MyBatis环境搭建"></a>MyBatis环境搭建</h2><p>在这里使用的是注解的形式,当然也可以使用xml的方式来进行配置</p><p>另外还需要核心配置文件SqlMapperConfig.xml来配置数据库的连接信息</p><ol><li><p>在AccountDao的方法上添加注解</p><blockquote><p><img src="https://blog.chasingwind.top/1567255291869.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567255291869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在resources目录编写核心配置文件SqlMapConfig.xml</p><blockquote><p><img src="https://blog.chasingwind.top/1567255690756.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567255690756.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行测试</p><blockquote><p>测试findAll()</p><p><img src="https://blog.chasingwind.top/1567256507128.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567256507128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>成功获取到数据库中的数据</p></blockquote><blockquote><p>测试saveAccount</p><p><img src="https://blog.chasingwind.top/1567256740472.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567256740472.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在数据库中保存成功</p></blockquote></li></ol><h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><h3 id="基础整合"><a href="#基础整合" class="headerlink" title="基础整合"></a>基础整合</h3><p>怎样才能算才算整合成功?</p><ul><li><p>Service层(Spring)调用Dao层(MyBatis)去做相应的操作,执行成功</p><blockquote><p>我们<strong>需要把Dao使用的代理对象存放到容器中,在Service中注入才能使用</strong></p></blockquote></li><li><p>在applicationContext.xml配置文件中进行MyBatis的配置</p><blockquote><p><img src="https://blog.chasingwind.top/1567259672998.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567259672998.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>工厂可以帮我们创建SqlSession对象  SqlSession对象可以帮我们拿到代理对象  </p><p>有了代理对象就可以将代理对象存放在IoC容器中</p><p>配置AccountDao  是为了让Spring直到要帮我们生成哪些接口的代理对象</p><hr><p>在配置完成之后 我们就不再需要SQLMapperConfig.xml文件了  可以将它删除 还有jdbcConfig.properties也不再需要</p></blockquote><blockquote><p>在AccountDao上添加注解 将AccountDao交给IoC来管理</p><p><img src="https://blog.chasingwind.top/1567259802243.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567259802243.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在AccountService中注入AccountDao</p><p><img src="https://blog.chasingwind.top/1567259859953.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567259859953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>进行测试</p><p>在Controller类中 我们将从数据库查询到的数据进行封装 </p><p><img src="https://blog.chasingwind.top/1567259940934.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567259940934.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在页面中获取信息</p><p><img src="https://blog.chasingwind.top/1567259966459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567259966459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果  获取到了我们的数据</p><p><img src="https://blog.chasingwind.top/1567259996039.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567259996039.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><p>配置声明式事务管理</p><blockquote><p><img src="https://blog.chasingwind.top/1567261541172.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567261541172.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>在index.jsp中测试保存用户</p><blockquote><p><img src="https://blog.chasingwind.top/1567261562083.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567261562083.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>在Controller中编写对应的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1567261603540.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567261603540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里我们使用的是重定向到之前的查询所有的方法</p></blockquote><p>测试</p><blockquote><p><img src="https://blog.chasingwind.top/1567261661634.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567261661634.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>查询的结果</p><p><img src="https://blog.chasingwind.top/1567261653594.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567261653594.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC返回值类型和响应数据类型</title>
      <link href="2019/08/29/SpringMVC%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2019/08/29/SpringMVC%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</p><a id="more"></a><h2 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a>响应数据和结果视图</h2><h3 id="响应返回值类型-String"><a href="#响应返回值类型-String" class="headerlink" title="响应返回值类型: String"></a>响应返回值类型: String</h3><p>返回字符串，视图解析器会根据返回的字符串去跳转到对应的页面 </p><ul><li><p>最基本的响应</p><blockquote><p>Controller控制器类中的方法</p><p><img src="https://blog.chasingwind.top/1567130147310.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567130147310.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>点击跳转</p><p><img src="https://blog.chasingwind.top/1567130237300.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567130237300.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>通过页面的跳转完成数据响应到页面上</p><blockquote><p>一般我们用在将我们从数据库中查询到的数据  存放在request域中 跳转到指定的页面之后，可以获取Request域中的数据</p><p><img src="https://blog.chasingwind.top/1567130916807.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567130916807.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在页面中我们可以取出数据进行操作</p><p><img src="https://blog.chasingwind.top/1567130944045.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567130944045.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1567131000685.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567131000685.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="响应返回值类型-void"><a href="#响应返回值类型-void" class="headerlink" title="响应返回值类型: void"></a>响应返回值类型: void</h3><ul><li><p>默认情况: 默认去跳转到以请求路径为名的文件</p><blockquote><p>当没有方法返回值的时候</p><p>方法是执行了的</p><p><img src="https://blog.chasingwind.top/1567131300331.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567131300331.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>跳转会报错 错误显示 没有testVoid.jsp(默认的是我们请求的路径的名字)资源</p><p>也就是说 当返回值为void的时候 </p><p><strong>视图控制器会去根据我们在springmvc.xml中的配置的响应的目录和后缀名去查找名称为我们配置的方法的path值的文件</strong></p><p>没有的话 就会报错</p><p><img src="https://blog.chasingwind.top/1567131382934.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567131382934.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567131270432.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567131270432.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用request和response请求转发到指定的页面</p><blockquote><p>使用<strong>请求转发</strong>来指定跳转的页面</p><p><img src="https://blog.chasingwind.top/1567131768018.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567131768018.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1567131801182.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567131801182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>还可以使用<strong>重定向</strong>的方式</p><blockquote><p>重定向不能访问WEB-INF目录下的文件</p><p><img src="https://blog.chasingwind.top/1567132160286.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567132160286.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里是在webapp目录下新建的success.jsp文件</p><p><img src="https://blog.chasingwind.top/1567132117998.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567132117998.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>还有一个作用就是  <strong>将数据直接响应到页面</strong>  这样<strong>还是跳转到配置路径为名的页面   但是不会再报错</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1567132389639.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567132389639.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1567132399158.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567132399158.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="响应返回值类型-ModelAndView"><a href="#响应返回值类型-ModelAndView" class="headerlink" title="响应返回值类型: ModelAndView"></a>响应返回值类型: ModelAndView</h3><ul><li><p><strong>ModelAndView对象</strong>是Spring提供的一个对象，可以用来调整具体的JSP视图</p></li><li><p>完成的功能: 既可以完成数据的封装, 还可以跳转到指定的页面</p><blockquote><p><img src="https://blog.chasingwind.top/1567132976008.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567132976008.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>同样的  在跳转到的页面可以获取域中的数据</p><p><img src="https://blog.chasingwind.top/1567133038750.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567133038750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>其实在返回String类型的时候 底层使用的也是ModelAndView</strong></p></blockquote></li></ul><h3 id="SpringMVC提供的转发和重定向"><a href="#SpringMVC提供的转发和重定向" class="headerlink" title="SpringMVC提供的转发和重定向"></a>SpringMVC提供的转发和重定向</h3><ul><li><p>控制器中的方法在<strong>提供了 String 类型的返回值之后，默认就是请求转发,就是上面的返回值是String类型的情况,使用的是视图解析器</strong>。我们也可以写成：</p><blockquote><p>请求转发</p><p><img src="https://blog.chasingwind.top/1567134233748.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567134233748.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>需要注意的是，如果用了 <strong>forward：</strong>则路径必须写成实际视图 url，不能写逻辑视图。也就是使用的不再是视图解析器  路径需要我们自己提供 </p><p>它相当于于“request.getRequestDispatcher(“<strong>url</strong>“).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器中的方法。</p></blockquote></li><li><p>重定向</p><blockquote><p><img src="https://blog.chasingwind.top/1567134372682.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567134372682.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>重定向需要注意的是  我们不需要再提供项目的名称  底层已经帮我们实现</p></blockquote></li></ul><h3 id="异步请求以及响应"><a href="#异步请求以及响应" class="headerlink" title="异步请求以及响应"></a>异步请求以及响应</h3><p>当客户端<strong>发送的是Ajax异步请求</strong>的时候，在后台我们需要把响应的信息转换成JSON的字符串进行响应。</p><ol><li><p>异步环境的搭建</p><blockquote><p>在webapp目录下创建js文件夹存储引入的jQuery.js文件</p><p><img src="https://blog.chasingwind.top/1567146897421.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567146897421.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在页面中引入jQuery</p><p>并添加按钮绑定单击事件<br><img src="https://blog.chasingwind.top/1567150609484.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567150609484.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果 页面不显示弹出内容  </p><p>原因是  在前端控制器中  配置的拦截所有的页面  这个静态文件jQuery.js也被拦截了</p><p><img src="https://blog.chasingwind.top/1567150668918.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567150668918.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>需要告诉前端控制器 在springmvc.xml中设置不拦截静态资源</p><p><img src="https://blog.chasingwind.top/1567153395081.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567153395081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>进行测试  可以将弹窗弹出</p></blockquote></li><li><p>发送Ajax请求</p><blockquote><p>单击按钮发送Ajax请求到服务器</p><p><img src="https://blog.chasingwind.top/1567156642247.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567156642247.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在方法中接收请求中的数据</p><p><img src="https://blog.chasingwind.top/1567156680450.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567156680450.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将上面拿到的JSON数据封装到JavaBean中，响应给客户端</p><blockquote><p>当请求中的JSON的data中的数据的key值等于要封装的JavaBean的属性值的时候  可以使用已经封装好的方法进行数据的封装</p><p>使用jackson来完成  在pom.xml导入依赖</p><p><img src="https://blog.chasingwind.top/1567156998121.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567156998121.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1567157538351.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567157538351.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>但是此时在客户端收到的数据是JSON格式的  所以返回对象是不行的 需要将对象转换为JSON格式</p><p>使用<code>@ResponseBody</code>注解</p><blockquote><p><code>@ResponseBody</code>  用于将方法的返回值以特定的格式写入到response的body区域，进而将数据返回给客户端。当方法上面没有写ResponseBody,底层会将方法的返回值封装为ModelAndView对象</p><p>假如是字符串则直接将字符串写到客户端,</p><p>假如是一个对象，此时会将对象转化为json串然后写到客户端</p><p>控制层方法的返回值是如何转化为json格式的字符串的呢？其实是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。如果是bean对象，会调用对象的getXXX（）方法获取属性值并且以键值对的形式进行封装，进而转化为json串。如果是map集合，采用get(key)方式获取value值，然后进行封装。</p></blockquote><p><img src="https://blog.chasingwind.top/1567157652578.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567157652578.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在客户端的Ajax请求中就可以使用回调函数来完成数据的操作</p><p><img src="https://blog.chasingwind.top/1567164080816.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567164080816.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试</p><p><img src="https://blog.chasingwind.top/1567164120323.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567164120323.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>客户端拿到了我们的数据   而且是Object类型的  也就是jackson帮我们完成了封装</p><p><img src="https://blog.chasingwind.top/1567164181849.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567164181849.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在以前 这样的处理还需要转换为流对象 …..</p><p>改正上面的两个错误</p><p>第一个就是json的MIME类型</p><p><img src="https://blog.chasingwind.top/1567163965833.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567163965833.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第二个就是jackson的版本过低会报错  改成2.9.8</p><p><img src="https://blog.chasingwind.top/1567164044302.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567164044302.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="SpringMVC实现文件上传"><a href="#SpringMVC实现文件上传" class="headerlink" title="SpringMVC实现文件上传"></a>SpringMVC实现文件上传</h2><ol><li><p>使用Web来实现文件的上传</p><blockquote><p>首先使用表单来完成文件的选择</p><p><img src="https://blog.chasingwind.top/1567173298984.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567173298984.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在后端的方法中来解析上传的文件</p><p>这里需要导入jar包</p><p><img src="https://blog.chasingwind.top/1567173454857.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567173454857.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>提交的表单 内容会被封装到Request对象中 我们可以在Request中获取</p><p><img src="https://blog.chasingwind.top/1567175037714.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567175037714.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>最终会将文件上传到target目录下的uploads目录下</p></blockquote></li><li><p>使用SpringMVC来完成文件的上传</p><blockquote><p>原理</p><p><img src="https://blog.chasingwind.top/1567175385836.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567175385836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们需要做的就是 </p><p>配置文件解析器 并且在控制器类的方法的参数中将上传的文件项作为参数</p><p><img src="https://blog.chasingwind.top/1567176466726.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567176466726.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567176540846.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567176540846.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>两点注意</p><p>第一点就是form表单中</p><p><img src="https://blog.chasingwind.top/1567175589714.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567175589714.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第二点就是 在配置文件解析器的时候的id 必须是<code>multipartResolver</code></p></blockquote></li><li><p>SpringMVC跨服务器的文件上传</p><blockquote><p>在实际开发中，我们会有很多处理不同功能的服务器。例如： </p><p>应用服务器：负责部署我们的应用 </p><p>数据库服务器：运行我们的数据库 </p><p>缓存和消息服务器：负责处理大并发访问的缓存和消息 </p><p>文件服务器：负责存储用户上传文件的服务器。 </p></blockquote><ol><li><p>准备两个tomcat服务器(一个是应用服务器,一个作为图片服务器)，并创建一个用于存放图片的web工程</p></li><li><p>在文件服务器的 tomcat 配置中加入，允许读写操作。文件位置:</p><blockquote><p>web.xml</p><p><img src="https://blog.chasingwind.top/1567179645029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567179645029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在图片服务器中添加依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1567179681074.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567179681074.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写代码</p><blockquote><p><img src="https://blog.chasingwind.top/1567179873474.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567179873474.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="SpringMVC异常处理以及拦截器"><a href="#SpringMVC异常处理以及拦截器" class="headerlink" title="SpringMVC异常处理以及拦截器"></a>SpringMVC异常处理以及拦截器</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当我们处理过程中出现异常的时候，如果我们不使用异常处理器的话，异常就会一直向上抛出，直到浏览器显示异常。这样的异常提示很不友好，所以，我们可以通过异常处理器来完成异常页面的显示</p><blockquote><p><img src="https://blog.chasingwind.top/1567217039093.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567217039093.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>如果我们程序中有错误的话，并且我们不进行处理 就会在浏览器显示错误信息</p><p><img src="https://blog.chasingwind.top/1567219669544.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567219669544.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567219648546.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567219648546.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用异常处理器进行错误处理</p><p>编写自定义异常类（做提示信息）</p><p><img src="https://blog.chasingwind.top/1567220887867.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567220887867.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>捕获异常</p><p><img src="https://blog.chasingwind.top/1567220918874.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567220918874.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>编写异常处理器</p><p><img src="https://blog.chasingwind.top/1567221014700.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567221014700.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>配置异常处理器（跳转到提示页面）</p><p>在springmvc.xml中进行配置</p><p><img src="https://blog.chasingwind.top/1567221122809.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567221122809.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>编写error.jsp  也就是将来需要跳转到的页面  获取异常的信息</p><p><img src="https://blog.chasingwind.top/1567221316359.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567221316359.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>进行测试</p><p><img src="https://blog.chasingwind.top/1567221354997.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567221354997.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>异常会在控制台输出  但是在页面上会跳转到我们的error.jsp  并且 提示我们自定义类的异常的信息</p></blockquote><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于<strong>对处理器(Controller控制器类)进行预处理和后处理(分别是拦截和放行)。</strong></p><ol><li><p>拦截器和Servlet中过滤器的区别</p><ol><li><strong>过滤器</strong>是 servlet 规范中的一部分，任何 java web 工程都可以使用。</li><li><strong>拦截器</strong>是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。</li><li><strong>过滤器</strong>在 url-pattern 中配置了*<em>/**</em>之后，可以对所有要访问的资源拦截。</li><li><strong>拦截器</strong>它是<strong>只会拦截访问的控制器方法</strong>，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。</li></ol></li><li><p>拦截器的使用</p><ol><li><p>编写拦截器类，实现接口</p><blockquote><p>这里先使用预处理方法</p><p><img src="https://blog.chasingwind.top/1567227816047.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567227816047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置拦截器</p><blockquote><p>在springmvc.xml中进行配置</p><p><img src="https://blog.chasingwind.top/1567233025618.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567233025618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>可见 在Controller控制器方法执行之前 先执行了拦截器中的方法</p><p><img src="https://blog.chasingwind.top/1567233066157.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567233066157.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>拦截器类中的方法</p><blockquote><p>上面我们使用了其中的预处理的方法<code>preHandle</code></p><p>当我们使用的返回值是false时候 是不会放行的 这个时候我们可以使用方法来进行请求转发或者重定向等等</p><p>比如 可以用在将用户未登录的时候 进行拦截 跳转到提示用户登录的页面</p><p><img src="https://blog.chasingwind.top/1567233490010.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567233490010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样就不会跳转到之前的成功页面了</p><p><img src="https://blog.chasingwind.top/1567233569455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567233569455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>注意各个方法执行的时机</p><p><img src="https://blog.chasingwind.top/1567233937527.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567233937527.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567233893111.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567233893111.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>拦截器链</p><ul><li>多个拦截器 在springmvc.xml文件中进行配置</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC概述以及入门</title>
      <link href="2019/08/27/SpringMVC%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/"/>
      <url>2019/08/27/SpringMVC%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>本节介绍了SpringMVC的基本概念以及SpringMVC的入门案例的编写，对请求参数中的数据进行绑定，自定义类型转换器还有一些常用的注解。</p><a id="more"></a><h2 id="SpringMVC的基本概念"><a href="#SpringMVC的基本概念" class="headerlink" title="SpringMVC的基本概念"></a>SpringMVC的基本概念</h2><ol><li><p>三层架构</p><ul><li><p>表现层(SpringMVC) : 接收客户端发送的请求 , 与后台进行交互 , 然后将结果进行封装,响应给客户端浏览器</p></li><li><p>业务层(Spring)</p></li><li><p>持久层(MyBatis)</p><blockquote><p><img src="https://blog.chasingwind.top/1566918800753.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566918800753.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>MVC模型</p><ul><li><p>表现层的框架一般都会使用MVC模型</p></li><li><p>MVC 设计模型</p><ul><li>M Model 模型—&gt;JavaBean</li><li>V View 视图—&gt;JSP</li><li>C Controller 控制器—&gt;Servlet</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1566919342088.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566919342088.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>SpringMVC框架</p><ul><li><p>SpringMVC 是一种<strong>基于 Java 的实现 MVC 设计模型</strong>的请求驱动类型的<strong>轻量级 Web 框架</strong>，属于 Spring FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。</p></li><li><p>Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而<strong>在使用 Spring 进行 WEB 开发时，可以选择使用 Spring的 Spring MVC 框架或集成其他 MVC 开发框架</strong>，如 Struts1(现在一般不用)，Struts2 等。 </p></li><li><p>SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成 为最优秀的 MVC 框架。 </p></li><li><p>它通过一套注解，让一个<strong>简单的 Java 类成为处理请求的控制器</strong>，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。</p><blockquote><p><img src="https://blog.chasingwind.top/1566919647604.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566919647604.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>SpringMVC的优势</p><ol><li><strong>模块化设计</strong>, 每个模块单独完成对应的功能</li><li>分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 </li><li>和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 </li><li>等等…..</li></ol></li><li><p>SpringMVC和Struts2框架的对比分析(<strong>面试</strong>)</p><ul><li><p>共同点</p><ol><li>都是表现层框架 , 都是基于MVC模型的</li><li>底层都离不开原始的ServletAPI(Request和Response)</li><li>处理请求的机制都是一个核心控制器</li></ol></li><li><p>区别</p><ol><li><p>SpringMVC的入口是Servlet , Struts2的入口是Filter</p></li><li><p>SpringMVC(单例) 是<strong>基于方法设计</strong>的，而 <strong>Struts2 是基于类</strong>(多例)，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。</p></li><li><p>SpringMVC 使用更加简洁,同时还支持 JSR303, 处理 Ajax 的请求更方便</p><p>(JSR303 是<strong>一套 JavaBean 参数校验的标准</strong>，它定义了很多常用的校验注解，我们可以直接<strong>将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了</strong>。)</p></li><li><p><strong>Struts2 的 OGNL 表达式使页面的开发效率相比 SpringMVC 更高些</strong>，但执行效率并没有比 JSTL 提升，尤其是 struts2 的表单标签，远没有 html 执行效率高。</p></li></ol></li></ul></li></ol><h2 id="SpringMVC的入门"><a href="#SpringMVC的入门" class="headerlink" title="SpringMVC的入门"></a>SpringMVC的入门</h2><h3 id="入门案例的分析以及编码"><a href="#入门案例的分析以及编码" class="headerlink" title="入门案例的分析以及编码"></a>入门案例的分析以及编码</h3><ol><li><p>入门案例的需求</p><blockquote><p><img src="https://blog.chasingwind.top/1566975358477.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566975358477.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>环境搭建</p><ol><li><p>创建maven-webapp项目</p></li><li><p>在项目的目录下创建java,resources目录  并且右键MakeAs…</p><blockquote><p><img src="https://blog.chasingwind.top/1566979721226.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566979721226.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>pom.xml中导入依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1566980173207.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566980173207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置前端控制器(就是一个Servlet)</p><blockquote><p>在web.xml中进行配置<code>DispatcherServlet</code></p><p><img src="https://blog.chasingwind.top/1566980649253.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566980649253.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在resources下创建配置文件springmvc.xml (不需要后缀名)</p><blockquote><p><img src="https://blog.chasingwind.top/1566980728751.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566980728751.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>部署到本地的Tomcat</p></li></ol></li><li><p>入门案例代码编写</p><ol><li><p>我们需要写一个index.jsp</p><blockquote><p>此jsp中有一个超链接 当我们点击的时候 会跳转到另一个jsp页面 这里通过超链接进行跳转使用的是GET的方式</p><p><img src="https://blog.chasingwind.top/1566990003774.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566990003774.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写Controller控制器类  用来接收超链接的请求</p><blockquote><p><img src="https://blog.chasingwind.top/1566990092259.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566990092259.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>点击超链接之后 要让Controller中的方法执行 就需要这个类的对象</p></blockquote></li><li><p>在springmvc.xml中控制反转的方式创建对象</p><ol><li><p>引入约束文件</p><blockquote><p><img src="https://blog.chasingwind.top/1566990647020.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566990647020.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>开启SpringMVC扫描的包</p><blockquote><p><img src="https://blog.chasingwind.top/1566990758557.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566990758557.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>在Controller类上面添加表现层的注解<code>@Controller</code> , 用于创建对象</p><blockquote><p><img src="https://blog.chasingwind.top/1566990836667.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566990836667.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>有了控制器对象之后 , 需要点击这个超链接发送请求,然后去执行这个方法</p><blockquote><p>在方法上面使用注解<code>@RequestMapping</code>  请求映射 , 将我们的请求映射到当前的方法  <strong>需要填写请求的路径path</strong></p><p><img src="https://blog.chasingwind.top/1566991035326.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566991035326.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在web.xml中配置加载SpringMVC的配置文件springmvc.xml</p><blockquote><p><img src="https://blog.chasingwind.top/1566991413405.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566991413405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>上面完成的功能 : 发送请求,通过控制器就能执行其中的方法sayHello</p><blockquote><p><strong>还需要在方法中完成页面的跳转</strong></p><p><img src="https://blog.chasingwind.top/1566991614808.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566991614808.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>SpringMVC的默认的规则</p><p><strong>返回的字符串表示的是跳转到的jsp文件的名字</strong></p></blockquote></li><li><p>在WEB-INF目录下创建success.jsp文件  是需要跳转到的页面</p><blockquote><p><img src="https://blog.chasingwind.top/1566991754577.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566991754577.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>指定控制器类中的方法执行完 , 去找到这个success.jsp页面</p><blockquote><p>在springmvc.xml中配置视图的解析器<code>InternalResourceViewResolver</code></p><p>这个类会帮助我们进行页面的跳转</p><p>需要配置的是跳转到的<strong>页面所在的目录</strong>以及<strong>页面的后缀名</strong></p><p><img src="https://blog.chasingwind.top/1566992161007.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566992161007.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>开启SpringMVC注解的支持</p><blockquote><p>在springmvc.xml配置文件中进行配置</p><p><img src="https://blog.chasingwind.top/1566992209526.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566992209526.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>在超链接中添加跳转的路径(相对路径)</p><blockquote><p><img src="https://blog.chasingwind.top/1566992669206.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566992669206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>href属性中不能写<code>/</code>  因为写这个的话 作用是在根目录下查找hello文件 </p><p>以“/”开头的，那就表示直接回到起点重新开始。网址如果有太多层目录,这时候我们简单粗暴地用“/”开头，就直接回到根目录，然后再顺着向下查找对应的资源文件。所以要记得，其它相对路径的规则前面是不加“/”的哟！</p></blockquote></li><li><p>这样就完成了需求 , 进行测试</p><blockquote><p>index.jsp</p><p><img src="https://blog.chasingwind.top/1566992393518.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566992393518.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>点击跳转  成功进行了跳转</p><p><img src="https://blog.chasingwind.top/1566992465729.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566992465729.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="入门程序的流程分析"><a href="#入门程序的流程分析" class="headerlink" title="入门程序的流程分析"></a>入门程序的流程分析</h3></li><li><p>启动服务器，加载相关的配置文件</p><ol><li><p>在web.xml中 配置的前端控制器(DispatcherServlet)在服务器启动的时候就会被创建出来</p></li><li><p>这个对象会去类路径下加载springmvc.xml配置文件</p></li><li><p>在springmvc.xml中 , 回去扫描注解所在的包 , 通过控制反转创建控制器类对象放入Ioc容器中(@Controller) , 创建视图解析器对象(完成页面的跳转) , 通过RequestMapping注解配置请求会执行的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1566993668896.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566993668896.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>发送请求，后台处理请求</p><ol><li><p>点击超链接发送请求</p></li><li><p>执行DispatcherServlet(前端控制器) , 因为在Servlet中匹配了所有的请求</p><blockquote><p><img src="https://blog.chasingwind.top/1566994117991.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566994117991.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>根据请求的URL（超链接中）对应到ResultMapping的值，找到执行的具体的方法</p></li><li><p>方法执行完返回success</p></li><li><p>控制器去找视图解析器对象</p><blockquote><p>在springmvc.xml中配置视图解析器</p><p><img src="https://blog.chasingwind.top/1566994247297.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566994247297.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>视图解析器会帮助我们跳转到success.jsp</p></li><li><p>控制器会将这个页面响应给客户端</p><blockquote><p><img src="https://blog.chasingwind.top/1566994469499.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566994469499.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h3 id="案例中的组件介绍"><a href="#案例中的组件介绍" class="headerlink" title="案例中的组件介绍"></a>案例中的组件介绍</h3><ul><li><p>SpringMVC框架<strong>基于组件方式</strong>执行流程 , 每个组件完成单独的功能</p></li><li><p>前端控制器（DispatcherServlet） : 控制整个流程的执行</p><blockquote><p>用户请求到达前端控制器，它就相当于 MVC模式中的 C(Controller控制器)，dispatcherServlet 是整个流程控制的中心，由它<strong>调用其它组件处理用户的请求</strong>, DispatcherServlet 的存在降低了组件之间的耦合性。</p></blockquote></li><li><p>处理器映射器（HandlerMapping） : 映射到某个类中的某个方法</p><blockquote><p>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p></blockquote></li><li><p>处理器适配器（HandlerAdapter） : 适配@Controller的bean对象, 去执行对象中的方法</p><blockquote><p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p></blockquote></li><li><p>处理器（Handler）:也叫作Controller</p><blockquote><p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</p></blockquote></li><li><p>视图解析器（View Resolver） : 跳转到具体的页面</p><blockquote><p>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p></blockquote><hr><blockquote><p><img src="https://blog.chasingwind.top/1566996307985.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566996307985.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a>RequestMapping注解</h3><ol><li><p>作用 : 用于建立<strong>请求 URL 和处理请求方法</strong>之间的<strong>对应关系</strong>。</p></li><li><p>出现位置</p><ol><li><p>类上</p><blockquote><p>请求 <strong>URL 的第一级访问目录</strong>。此处不写的话，就相当于应用的根目录。写的话需要以/开头。</p><p>它出现的目的是为了使我们的 URL 可以<strong>按照模块化管理</strong>:</p><hr><p>当在一个类中有多个方法的时候  在类上面配置访问的一级目录  在方法上配置访问的二级目录</p><p><img src="https://blog.chasingwind.top/1566996946309.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566996946309.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>请求的路径就可以编写两级的路径 才只能对应到具体的方法</p><p><img src="https://blog.chasingwind.top/1566996993093.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566996993093.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>方法上</p><blockquote><p>请求 URL 的第二级访问目录。</p></blockquote></li></ol></li><li><p>RequestMapping中的属性</p><ol><li><p>path : 指的是映射的路径(请求的URL) , 和value属性的作用相同</p></li><li><p>value : 和path的作用相同  </p></li><li><p>method : <strong>指定接收的请求的方式 , 只有对应的请求方式才会执行这个对应的方法</strong></p><blockquote><p>比如 我配置这里的/hello为POST  但是超链接访问的方式是GET</p><p>那么就会报405错  Method Not Allowed</p><p><img src="https://blog.chasingwind.top/1566997345127.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997345127.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>params : 用于限制请求参数的条件 , 支持简单的表达式. </p><blockquote><p>要求请求中的参数的key和value必须和params中的配置的一样</p><p><img src="https://blog.chasingwind.top/1566997641486.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997641486.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里的意思就是 请求的参数中必须包含username</p><p>不添加的时候 会报错</p><p><img src="https://blog.chasingwind.top/1566997694812.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997694812.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566997713154.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997713154.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>添加username</p><p><img src="https://blog.chasingwind.top/1566997771009.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997771009.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>还可以指定表达式 只有请求参数中符合表达式才可以完成方法的执行</p><p>比如 :</p><p><img src="https://blog.chasingwind.top/1566997853209.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997853209.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>而请求中未添加username的值zhangsan  或者添加的不是zhangsan 都会报错</p><p><img src="https://blog.chasingwind.top/1566997901391.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997901391.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>正确的请求</p><p><img src="https://blog.chasingwind.top/1566997976091.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566997976091.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>headers : 限制请求消息头的条件 , 也就是<strong>限制在发送请求中必须包含的请求头</strong></p></li></ol></li></ol><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><p>获取客户端请求中的参数 , 就是请求参数的绑定</p><ol><li><p>绑定机制</p><ol><li>表单提交的数据都是key=value格式的,比如: username=haha&amp;password=123</li><li> SpringMVC的参数绑定过程是<strong>把表单提交的请求参数，作为控制器中方法的参数进行绑定的, 这样就可以对用户请求的数据进行操作了</strong></li><li>要求：<strong>提交表单的key和方法的参数的名称是相同的</strong></li></ol></li><li><p>支持的数据类型</p><ol><li><p><strong>基本数据类型和字符串类型</strong></p><blockquote><p>请求的URL</p><p><img src="https://blog.chasingwind.top/1567002454528.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567002454528.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>参数绑定 并执行方法</p><p><img src="https://blog.chasingwind.top/1567002495538.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567002495538.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>params.jsp页面</p><p><img src="https://blog.chasingwind.top/1567002722697.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567002722697.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击超链接 就会跳转到success页面  并且超链接中绑定的有参数</p><p><img src="https://blog.chasingwind.top/1567002810973.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567002810973.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在控制台输出了对应的数据 说明已经获取到了请求的参数 </p><p><img src="https://blog.chasingwind.top/1567002843418.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567002843418.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>JavaBean类型</strong></p><ol><li><p>请求中的<strong>参数的name的值要等于JavaBean中的属性的值</strong>, 只有这样 , SpringMVC才会帮助我们正确地进行封装</p></li><li><p>在方法中填写需要封装的JavaBean就行</p><blockquote><p><img src="https://blog.chasingwind.top/1567004323717.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567004323717.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在控制器类中只需要告诉SpringMVC封装到的JavaBean</p><p><img src="https://blog.chasingwind.top/1567004380956.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567004380956.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>提交表单</p><p>这里先不要用中文 会乱码</p><p><img src="https://blog.chasingwind.top/1567005076570.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567005076570.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>控制台输出</p><p><img src="https://blog.chasingwind.top/1567005213731.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567005213731.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>当需要<strong>封装的JavaBean中有别的类的引用的时候</strong></p><p>在这里User类中有引用类型Account</p><p><img src="https://blog.chasingwind.top/1567005639610.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567005639610.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在Account类中的属性</p><p><img src="https://blog.chasingwind.top/1567005661030.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567005661030.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们是将account中的属性封装到account , 再将account作为属性封装到<strong>User</strong>对象中</p><p>所以在请求参数中这样填写name</p><p>映射的方法的参数还是User对象</p><p><img src="https://blog.chasingwind.top/1567005736166.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567005736166.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试</p><p><img src="https://blog.chasingwind.top/1567005774686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567005774686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/1567005810223.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567005810223.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>解决POST请求中文乱码问题</p><blockquote><p>在web.xml进行配置   使用的是过滤器</p><p><img src="https://blog.chasingwind.top/1567006275032.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567006275032.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试之前的中文数据  控制台正常输出</p><p><img src="https://blog.chasingwind.top/1567006397729.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567006397729.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p><strong>集合数据类型(List,Map集合等等)</strong></p><blockquote><p>在User里面封装List和Map</p><p><img src="https://blog.chasingwind.top/1567007024611.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567007024611.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在表单中填写</p><p><img src="https://blog.chasingwind.top/1567007109198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567007109198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试</p><p><img src="https://blog.chasingwind.top/1567006956766.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567006956766.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>List和Map都进行了封装</p><p><img src="https://blog.chasingwind.top/1567006976010.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567006976010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><ul><li><p>在我们的请求中，<strong>数据都是以String类型进行传输</strong>的，<strong>请求参数绑定的过程中，可以正确地转换为对应的类型，其实就是SpringMVC帮我们进行了数据类型的转换</strong></p></li><li><p>但是有些类型不支持转换，比如我们自定义的日期格式2019-08-29默认转换的话就会出现异常，所以需要我们进行自定义类型的转换</p><blockquote><p>表单数据封装到Account</p><p><img src="https://blog.chasingwind.top/1567042918210.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567042918210.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567042888704.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567042888704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567042940005.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567042940005.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们使用提供的格式填写日期的时候</p><p><img src="https://blog.chasingwind.top/1567042843333.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567042843333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>控制台正常输出 并且没有出现异常</p><p><img src="https://blog.chasingwind.top/1567042870978.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567042870978.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>但是当我们使用其他格式的日期时</p><p><img src="https://blog.chasingwind.top/1567043006589.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567043006589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>已经出现了客户端4XX错误  也就是在数据封装的时候类型转换出现了错误</p><p><img src="https://blog.chasingwind.top/1567043021003.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567043021003.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用自定义数据类型转换器</p><ol><li><p>定义一个类，实现Converter接口，该接口有两个泛型<code>&lt;S,T&gt;</code>，S表示传入的字符串，T表示需要转换成的类型</p></li><li><p>实现接口中的convert方法</p><blockquote><p><img src="https://blog.chasingwind.top/1567044362780.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567044362780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在springmvc.xml中<strong>配置自定义类型转换器</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1567044734260.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567044734260.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将我们自定义的类型转换器设置生效</p><blockquote><p>在标签<code>&lt;mvc:annotation-driven&gt;</code>中配置自定义的来类型转换器</p><p><img src="https://blog.chasingwind.top/1567044865866.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567044865866.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>输入的日期格式</p><p><img src="https://blog.chasingwind.top/1567044929312.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567044929312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>转换的结果   成功转换 并未报错</p><p><img src="https://blog.chasingwind.top/1567044944357.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567044944357.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h2 id="获取原生的Servlet的API"><a href="#获取原生的Servlet的API" class="headerlink" title="获取原生的Servlet的API"></a>获取原生的Servlet的API</h2><blockquote><p>直接在需要的方法中添加参数</p><p><img src="https://blog.chasingwind.top/1567045420586.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567045420586.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>获取成功</p><p><img src="https://blog.chasingwind.top/1567045433345.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567045433345.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h2 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h2><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><ul><li><p>作用：<strong>将请求中指定名称的参数赋值给控制器中的形参</strong>。</p></li><li><p>属性</p><ul><li>value：请求参数中的名称。</li><li>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</li></ul><blockquote><p>可以用来<strong>解决当请求中的参数与你要封装到的参数的名称不同的时候</strong></p><p>请求中的参数是name</p><p><img src="https://blog.chasingwind.top/1567046463910.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046463910.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567046446031.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046446031.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>而需要在方法中绑定的参数是username  而非请求参数中的name</p><p><img src="https://blog.chasingwind.top/1567046495951.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046495951.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在控制台的输出显示 并没有成功地进行封装</p><p><img src="https://blog.chasingwind.top/1567046520851.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046520851.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>此时就可以使用注解<code>@RequestParam</code>来进行匹配 </p><p>其中的<strong>value属性就是指定请求参数中的参数</strong></p><p><img src="https://blog.chasingwind.top/1567046783415.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046783415.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>再次进行请求 就封装上了</p><p><img src="https://blog.chasingwind.top/1567046671602.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046671602.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567046720979.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046720979.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>至于required属性的话 默认值就是true  可以不进行配置</p><p>这个属性为true的作用就是 <strong>请求参数中必须有含有指定的属性的名字</strong></p><p>比如 当你的请求中的参数是uname而不是name  机会报错</p><p><img src="https://blog.chasingwind.top/1567046994704.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567046994704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>甚至是username的时候  也会出现错误</p><p><img src="https://blog.chasingwind.top/1567047058813.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567047058813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><ul><li><p>作用：<strong>获取请求体中的内容</strong>，直接使用得到是 key=value&amp;key=value…结构的数据。 <strong>GET 请求方式不适用，因为GET请求方式中没有请求体。</strong> </p></li><li><p>属性</p><blockquote><p>POST方式</p><p><img src="https://blog.chasingwind.top/1567047729016.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567047729016.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在方法的参数上使用注解  <strong>参数的名字不能和请求中的属性名相同</strong></p><p><img src="https://blog.chasingwind.top/1567047754700.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567047754700.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1567047659324.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567047659324.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>成功获取到请求体  因为在http协议中传输的时候会进行URL编码  这里是进行了URL编码的结果</p><p><img src="https://blog.chasingwind.top/1567047690105.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567047690105.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="@PathVaribale"></a>@PathVaribale</h3><ol><li><p>RESTful风格的URL路径</p><blockquote><p>请求的<strong>路径相同</strong>，但是在请求的时候(请求的超链接)使用<strong>不同的请求方式</strong>（GET，POST，PUT，DELETE等等）来区别不同的方法来执行。</p><p>当<strong>请求的路径和请求的方式都相同</strong>的时候，就可以<strong>使用占位符</strong>来区别不同的执行方法</p><p>Restful风格结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p></blockquote></li><li><p>注解<code>@PathVariable</code></p><ul><li><p>作用: 用于<strong>绑定 URL 中的占位符</strong>。例如：请求 url 中 /delete/<strong>{id}**，这个</strong>{id}**就是 url 占位符。</p><blockquote><p>在请求路径中添加占位符来区别不同执行方法</p><p><img src="https://blog.chasingwind.top/1567062858285.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567062858285.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用注解获取URL中的占位符</p><p><img src="https://blog.chasingwind.top/1567062904618.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567062904618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><ul><li><p>作用 : 用于<strong>获取请求的消息头</strong></p><blockquote><p>不能这样获取消息头 需要指定消息头的键的名称</p><p><img src="https://blog.chasingwind.top/1567063430985.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567063430985.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的结果就是报错</p><p><img src="https://blog.chasingwind.top/1567063457685.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567063457685.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>需要指定你要获取的对应的消息头</strong></p><p><img src="https://blog.chasingwind.top/1567063565690.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567063565690.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><ul><li><p>作用 : 用于把指定 Cookie 名称的值传入控制器方法参数。获取Cookie的值</p><blockquote><p><img src="https://blog.chasingwind.top/1567064290670.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567064290670.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同样也需要指定获取的Cookie的键的名称</p><p><img src="https://blog.chasingwind.top/1567064321945.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567064321945.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567064332040.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567064332040.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><ul><li><p>作用</p><blockquote><p>它可以用于<strong>修饰方法和参数</strong>。 </p><p>出现在<strong>方法</strong>上，表示<strong>当前方法会在控制器的方法执行之前，先执行</strong>。它可以修饰没有返回值的方法，也可 以修饰有具体返回值的方法。 </p><p>出现在<strong>参数</strong>上，获取指定的数据给参数赋值。</p></blockquote></li><li><p>演示作用在方法上</p><blockquote><p>作用在<strong>方法</strong>上</p><p><img src="https://blog.chasingwind.top/1567065065649.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567065065649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567065088556.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567065088556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在请求的连接中请求的是testModelAttribute  但是在结果中 先执行的是添加注解的方法</p><p><img src="https://blog.chasingwind.top/1567065132295.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567065132295.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用场景</p><blockquote><p>当表单提交数据不是完整的实体类数据时，<strong>保证没有提交数据的字段使用数据库对象原来的数据。</strong></p><p>比如 我们表单中提交的不完整的时候</p><p><img src="https://blog.chasingwind.top/1567069556097.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567069556097.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可见  封装的对象中的date就是null </p><p><img src="https://blog.chasingwind.top/1567069664890.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567069664890.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们可以借助这个注解 在控制器方法执行前 把这个date的值从数据库中查询获取并封装 然后将这个封装的完整的对象返回给控制器方法  </p><p>这样的话 控制器方法中的封装的对象属性既不会是null了</p><p>提交的表单数据</p><p><img src="https://blog.chasingwind.top/1567070038484.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567070038484.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>通过<code>@ModelAttribute</code>在控制器方法之前将未提供的表单数据进行封装</p><p><img src="https://blog.chasingwind.top/1567070120823.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567070120823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果  date被封装上数据</p><p><img src="https://blog.chasingwind.top/1567070146680.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567070146680.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>演示作用在参数上</p><blockquote><p>还是上面的案例  这里是当注解修饰的方法没有返回值的时候 </p><p>采取的做法就是 <strong>将封装的对象存到map集合中</strong></p><p>在控制器方法中的参数上 通过注解来取出集合中的这个对象</p><p><img src="https://blog.chasingwind.top/1567070495540.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567070495540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样同样可以将数据封装进去</p><p><img src="https://blog.chasingwind.top/1567070515246.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567070515246.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h3><ul><li><p>作用: 用于<strong>多次执行控制器方法间的参数共享</strong>, 作用在类上</p></li><li><p>属性:</p><ul><li>value：用于指定存入的属性名称</li><li>type：用于指定存入的数据类型。</li></ul><blockquote><p>多次请求之间的Session共享  可以使用原生的Request</p><p>也可以<strong>使用Model来将数据存储到Request域中</strong></p><p><img src="https://blog.chasingwind.top/1567071825517.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567071825517.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567071871839.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567071871839.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可以看到  数据已经存储在request域中</p><p><img src="https://blog.chasingwind.top/1567071800645.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567071800645.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>SessionAttributes的使用</p><blockquote><p>在类上添加注解 使用注解可以将数据添加到Session域中</p><p><img src="https://blog.chasingwind.top/1567072339104.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567072339104.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Session域中已经存储了数据</p><p><img src="https://blog.chasingwind.top/1567075433603.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567075433603.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>那么在Session域中就可以对这些数据进行操作</p><p>比如 取Session</p><p><img src="https://blog.chasingwind.top/1567075462297.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567075462297.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1567075490652.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567075490652.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>删除Session</p><p><img src="https://blog.chasingwind.top/1567075919369.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1567075919369.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的JdbcTemplate以及事务控制</title>
      <link href="2019/08/25/Spring%E4%B8%AD%E7%9A%84JdbcTemplate%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
      <url>2019/08/25/Spring%E4%B8%AD%E7%9A%84JdbcTemplate%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>本节介绍了我们之前一直使用的Spring中的JdbcTemplate中的一些常用点的介绍，另外介绍了声明式的事务控制的实现的方式，分别使用XML，注解和纯注解的方式实现事务控制。</p><a id="more"></a><h2 id="Spring中的JdbcTemplate"><a href="#Spring中的JdbcTemplate" class="headerlink" title="Spring中的JdbcTemplate"></a>Spring中的JdbcTemplate</h2><ul><li>Spring中的<code>new BeanPropertyRowMapper&lt;&gt;()</code>是<strong>将结果封装成对象,再装进集合</strong>中</li></ul><p>Spring已经为我们提供好了方法 我们只需要指定<code>new BeanPropertyRowMapper&lt;封装的实体类&gt;(实体类的字节码文件)</code></p><ul><li>JedcDaoSupport的使用 : 用于抽取多个Dao中的重复代码，通过继承JdbcDaoImpl来实现</li></ul><h2 id="Spring中基于声明式事务控制"><a href="#Spring中基于声明式事务控制" class="headerlink" title="Spring中基于声明式事务控制"></a>Spring中基于声明式事务控制</h2><p>通过Spring的AOP的方式添加事务控制 , 类比我们自己之前使用动态代理实现的事务管理器</p><h3 id="Spring中的事务控制的API"><a href="#Spring中的事务控制的API" class="headerlink" title="Spring中的事务控制的API"></a>Spring中的事务控制的API</h3><ul><li><p>JavaEE 体系进行分层开发，<strong>事务处理位于业务层</strong>，Spring 提供了分层设计业务层的事务处理解决方案。 </p></li><li><p>Spring 框架为我们提供了一组事务控制的接口。</p></li><li><p><strong>Spring 的事务控制都是基于 AOP</strong> 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。</p></li><li><p><code>PlatformTransactionManager</code>接口</p><blockquote><p>接口中<strong>有commit和rollback</strong> 可以作为通知bean</p><p>他的实现类有  二者的区别就是一个使用数据源(数据库的连接信息等等)一个没有使用</p><p><img src="https://blog.chasingwind.top/1566889504806.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566889504806.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>TransactionDefinition</code>接口</p><blockquote><p>事务的定义信息</p><p><img src="https://blog.chasingwind.top/1566889627682.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566889627682.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>事务的隔离级别：Spring默认使用的是数据库的隔离级别</p><p>事物的传播行为：什么情况下必须有事务（增删改，Required），什么情况下事务可有可无（查询，Supports）</p><p>事务是否只读：<strong>查询</strong>的时候设置为只读</p></blockquote></li><li><p><code>TransactionStatus</code>接口</p><blockquote><p>事务状态</p><p><img src="https://blog.chasingwind.top/1566889548423.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566889548423.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>存储点 : 事务是按步提交 , 一旦设置存储点 ,  每个存储点就是事务的一步, 执行成功就提交这一步,所有步骤都成功,提交事务.  失败的话 , 回滚到存储点之前</p></blockquote></li><li><p>使用步骤</p><ol><li>配置事务管理器</li><li>配置事务信息</li><li>配置切入点表达式</li></ol></li></ul><h3 id="基于XML配置"><a href="#基于XML配置" class="headerlink" title="基于XML配置"></a>基于XML配置</h3><ol><li><p>添加约束</p><blockquote><p>DataAccess中的</p><p><img src="https://blog.chasingwind.top/1566892408188.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566892408188.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置事务管理器</p><blockquote><p><img src="https://blog.chasingwind.top/1566892445294.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566892445294.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>并注入数据源</p><p><img src="https://blog.chasingwind.top/1566892491689.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566892491689.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置事务的通知</p><blockquote><p>使用<code>tx:advice</code>配置事务的通知</p><p>属性id : 事务通知的唯一标识</p><p>属性transaction-manager  :  给事务通知提供一个事务管理器引用</p><p><img src="https://blog.chasingwind.top/1566892731858.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566892731858.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置AOP中的切入点表达式</p><blockquote><p><img src="https://blog.chasingwind.top/1566894534851.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566894534851.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>建立事务通知和切入点表达式的对应关系</p><blockquote><p>需要将这个接口中的提交和回滚的方法对应到需要增强的Service中</p><p><img src="https://blog.chasingwind.top/1566894664768.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566894664768.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>建立切入点表达式和事务通知的关系</p><p><code>&lt;aop:advisor&gt;</code>定义通知器  (通知器跟切面一样，也包括通知和切点)</p><p><code>&lt; aop:advisor&gt;</code>和<code>&lt; aop:aspect&gt;</code>其实都是将通知和切面进行了封装，原理基本上是一样的，只是使用的方式不同而已。</p><p><img src="https://blog.chasingwind.top/1566894825912.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566894825912.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置事务的属性</p><blockquote><p>在事务通知的内部(<code>&lt;tx:advice&gt;</code>)进行配置</p><p><code>name</code> : 需要进行事务管理的方法</p><p><code>isolation</code> : 用于<strong>指定事务的隔离级别</strong> , 默认是DEFAULT , 表示使用数据库的默认的隔离级别</p><p><code>propagation</code> : 用于指定事务的传播行为 ,表示一定会有事务进行管理 .默认值是<strong>REQUIRED</strong> , <strong>增删改</strong>的选择 ;<strong>查询</strong>使用<strong>SUPPORTS</strong></p><p><code>read-only</code> : 指定事务是否只读  默认值是false , <strong>用于查询的情况才能为true</strong></p><p><code>timeout</code> : 用于指定执行事务的超时时间 , 默认值是-1 , 以秒为单位</p><p><code>rollback-for</code> : <strong>用于指定一个异常</strong> , </p><ul><li>当产生该异常的时候 , 事务回滚. </li><li>产生其他的异常的时候 , 事务不回滚 . </li><li>没有默认值. </li><li>表示任何异常都回滚</li></ul><p><code>no-rollback-for</code> : <strong>用于指定一个异常</strong> , </p><ul><li>当产生该异常的时候 , 事务不回滚. </li><li>产生其他的异常的时候 , 事务回滚  </li><li>没有默认值. </li><li>表示任何异常都回滚</li></ul><p>如果以上<strong>两个都不指定的话</strong>  是<strong>默认回滚</strong>的</p><hr><p>一般我们只需要进行配置的话</p><p><img src="https://blog.chasingwind.top/1566896134291.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566896134291.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>还可以使用通配符的方式</p><p><img src="https://blog.chasingwind.top/1566896228119.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566896228119.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>下面的优先级较上面的高  但是<strong>匹配的是以findXxx类型的查询方法</strong> </p></blockquote></li><li><p>总配置图</p><blockquote><p><img src="https://blog.chasingwind.top/1566896955122.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566896955122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>表示的是 对于<code>edu.ahnu.service.impl</code>包下的所有的方法进行增强</p><p>增强的方法是txAdvice(事务管理)  </p></blockquote></li><li><p>测试</p><blockquote><p><img src="https://blog.chasingwind.top/1566896985084.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566896985084.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在无异常的情况下转账成功</p><p>在有异常的情况下进行了回滚的操作</p></blockquote></li></ol><h3 id="基于注解配置"><a href="#基于注解配置" class="headerlink" title="基于注解配置"></a>基于注解配置</h3><ol><li><p>添加约束</p><blockquote><p><img src="https://blog.chasingwind.top/1566898717920.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566898717920.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置Spring创建容器的时候需要扫描的包</p><blockquote><p><img src="https://blog.chasingwind.top/1566899071468.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566899071468.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置Service和Dao</p><blockquote><p>Service</p><p><img src="https://blog.chasingwind.top/1566899113155.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566899113155.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Dao</p><p><img src="https://blog.chasingwind.top/1566899154689.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566899154689.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Dao需要注入JdbcTemplate  配置JdbcTemplate 注入数据源</p><p><img src="https://blog.chasingwind.top/1566899193031.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566899193031.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Spring中基于注解的配置</p><ol><li><p>配置事务管理器</p><blockquote><p><img src="https://blog.chasingwind.top/1566912532130.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566912532130.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>开启Spring对注解事务的支持</p><blockquote><p><img src="https://blog.chasingwind.top/1566906482484.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566906482484.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在需要事务支持的地方使用<code>@Transactional</code>注解</p><blockquote><p><img src="https://blog.chasingwind.top/1566906512647.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566906512647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对于不使用默认的  需要单独在方法生进行配置</p><p><img src="https://blog.chasingwind.top/1566906717970.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566906717970.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>测试通过</p></li></ol><h3 id="Spring基于纯注解的事务控制"><a href="#Spring基于纯注解的事务控制" class="headerlink" title="Spring基于纯注解的事务控制"></a>Spring基于纯注解的事务控制</h3><p>在基于注解的配置的基础上进行配置</p><ol><li><p>首先 配置Spring扫描的包</p><blockquote><p><img src="https://blog.chasingwind.top/1566913932517.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566913932517.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对应的操作</p><p><img src="https://blog.chasingwind.top/1566913979378.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566913979378.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置Jdbc以及数据库的连接的信息</p><blockquote><p><img src="https://blog.chasingwind.top/1566914019461.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566914019461.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在JdbcConfiguration类中进行配置上面的两个信息</p><p><img src="https://blog.chasingwind.top/1566914952554.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566914952554.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>并且在<strong>主配置文件中 进行指定对应的配置文件的路径</strong></p><p><img src="https://blog.chasingwind.top/1566915072657.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566915072657.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>然后就是 开启注解支持</p><blockquote><p><img src="https://blog.chasingwind.top/1566915107281.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566915107281.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在主配置中添加注解支持的配置</p><p><img src="https://blog.chasingwind.top/1566915155609.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566915155609.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>事务管理器的配置</p><blockquote><p><img src="https://blog.chasingwind.top/1566915213992.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566915213992.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>创建TransactionConfig类进行配置</p><p><img src="https://blog.chasingwind.top/1566915478713.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566915478713.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在主配置文件中配置</p><p><img src="https://blog.chasingwind.top/1566915522721.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566915522721.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在测试类中指定主配置文件</p><blockquote><p><img src="https://blog.chasingwind.top/1566915613924.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566915613924.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行测试  发现成功 甚是欣喜!</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的AOP及其配置</title>
      <link href="2019/08/24/Spring%E4%B8%AD%E7%9A%84AOP%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE/"/>
      <url>2019/08/24/Spring%E4%B8%AD%E7%9A%84AOP%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</p><a id="more"></a><h2 id="完善Account案例以及问题分析"><a href="#完善Account案例以及问题分析" class="headerlink" title="完善Account案例以及问题分析"></a>完善Account案例以及问题分析</h2><ol><li><p>在Service中添加转账的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1566718202894.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566718202894.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>上面的问题就是  在两次updateAccount之间  出现了 异常  这样导致的就是</p><p>在A账户减了钱  B账户的钱没有增加</p></blockquote></li><li><p>问题分析</p><blockquote><p>上面出现的问题是什么导致的呢 ?</p><p>首先<strong>不是没有事务</strong> , </p><p>因为在增删改中 我们也没有进行事务的提交 但是却可以执行成功  这<strong>说明增删改是有事务管理的</strong></p><p>那么分析  这里可以看到<strong>每次执行都是一个新的连接</strong></p><p>而<strong>每个连接都是由一个事务进行管理</strong> 那么也就是说 这个转账由4个事务进行管理</p><p>每个操作执行完成 就会提交 </p><p>就导致了 异常之前的事务都提交了</p><p>异常之后的 无法执行  也就不能提交</p><p><img src="https://blog.chasingwind.top/1566718619756.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566718619756.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将转账使用一个Connection来控制 也就是一个事务进行控制</p><blockquote><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。</p><p>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><p><strong>使用ThreadLocal对象把Connection和当前线程绑定</strong>,从而在一个线程中只有一个控制事务的对象</p><p>编写ConnectionUtil工具类</p><p><img src="https://blog.chasingwind.top/1566719013643.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566719013643.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>事务管理相关的工具类</p><blockquote><p>要进行事务控制 首先需要把Connection设置为<strong>手动提交事务</strong></p><p>通过我们自己的commit进行事务的提交</p><p>然后提供相应的方法</p><p><img src="https://blog.chasingwind.top/1566719438776.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566719438776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将Service中的方法添加事务控制</p><blockquote><p><img src="https://blog.chasingwind.top/1566719571009.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566719571009.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这样就有了事务控制</p></blockquote></li><li><p>在Dao中使用我们自己提供的Connection对象 </p><blockquote><p>这里进行了修改 使用的是QueryRunner</p><p><img src="https://blog.chasingwind.top/1566721718144.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566721718144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>修改方法  使得每个方法使用的是我们自己提供的事务管理</p><p><img src="https://blog.chasingwind.top/1566721858137.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566721858137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在beans.xml进行配置</p><blockquote><p>首先 不能让这个连接从数据库连接池中获取</p><p><img src="https://blog.chasingwind.top/1566721961216.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566721961216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>进行其他的依赖注入</p><p><img src="https://blog.chasingwind.top/1566727323811.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566727323811.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行测试</p><blockquote><p>当出现异常的时候</p><p><img src="https://blog.chasingwind.top/1566728380124.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566728380124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>数据库中的两个数据都未发生改变</p><p><img src="https://blog.chasingwind.top/1566728406490.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566728406490.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>正常执行的时候</p><p><img src="https://blog.chasingwind.top/1566728447964.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566728447964.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>说明已经完成了事务管理  并且使用的是一个Connection对一个操作进行的管理</p></blockquote></li><li><p>进行优化</p><blockquote><p>配置文件中实在是太乱了….</p><p>在Service中使用事务控制 虽然达到了效果  </p><p>但是<strong>代码重复太多</strong></p><p>而且<strong>方法之间有较强的依赖</strong></p><p>比如 在每个操作中都需要开启事务(TransactionManager中的方法),关闭事务等等…</p><p>那么怎么实现在下图中 <strong>既可以实现事务管理 又可以避免方法之间的依赖</strong>呢</p><p><img src="https://blog.chasingwind.top/1566724072070.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566724072070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li><p>特点 : 字节码随用随创建</p></li><li><p>作用 : 不修改源码的基础上对方法进行增强</p></li><li><p>分类:</p><ol><li>基于接口的动态代理</li><li>基于子类的动态代理</li></ol></li><li><p>动态代理的体现</p><ol><li>在数据库连接池中的close方法  不是将连接关闭 而是将连接放回到连接池 其中就是对close方法进行了增强</li></ol></li></ul><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><ol><li><p>涉及的类 : <strong>Proxy</strong></p></li><li><p>提供者 : JDK官方</p></li><li><p>如何<strong>创建代理对象</strong></p><ul><li>使用Proxy类中的newProxyInstance方法</li></ul></li><li><p>创建代理对象的要求</p><ul><li><strong>被代理的类最少实现一个接口</strong> , 如果没有则不能使用</li></ul></li><li><p>newProxyInstance方法的参数</p><blockquote><p><img src="https://blog.chasingwind.top/1566741260138.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566741260138.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>ClassLoader</strong> : 用于加载<strong>被代理的对象字节码</strong> , 写的是<strong>要去代理的对象的类加载器</strong></p><p><strong>Class[ ]</strong>  :  字节码数组, 用于<strong>让代理对象和被代理对象有相同的方法</strong> , 通过<strong>实现同一个接口来实现</strong> , 这样代理商和厂家就有了相同的功能 , 而代理商可以在此基础上进行增强方法 ,  这就是上面的要求的原因. 写的是<strong>代理商和厂家之间实现的”约定”(接口)</strong></p><p><strong>InvocationHandler</strong> : 用于<strong>提供增强的代码</strong> 。在此我们要写如何进行代理 , 一般都是写一个该接口的实现类 , 通常情况下使用的是匿名内部类 , 谁要使用代理商 , 谁写这个代码(我们现在是消费者 , 要去联系代理商 , 所以这个增强的方法  是我们(消费者)自己写)</p></blockquote></li><li><p>实现</p><blockquote><p>被代理对象(厂家)</p><p><img src="https://blog.chasingwind.top/1566743193531.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566743193531.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>代理对象(代理商)和被代理对象(厂家)之间的约定(接口)</p><p><img src="https://blog.chasingwind.top/1566743272265.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566743272265.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>作为消费者 通过代理商买电脑 然后代理商去执行厂家中的方法 在此过程中进行方法的增强</p><p>图中的  method.invoke(被代理对象,被代理对象的方法的参数);</p><p><img src="https://blog.chasingwind.top/1566743580566.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566743580566.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><ol><li><p>涉及的类 : Enhancer</p></li><li><p>提供者 : 第三方cglib库</p></li><li><p>如何创建代理对象</p><ul><li>使用Enhancer类中的create方法</li></ul></li><li><p>创建代理对象的要求</p><ul><li>被代理的类不能是最终类(final修饰),最终类不能创建子类, 也就无从谈起代理</li></ul></li><li><p>create方法的参数</p><blockquote><p><img src="https://blog.chasingwind.top/1566744260679.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566744260679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Class : 用于指定<strong>被代理对象的字节码</strong></p><p>Callback : 用于<strong>提供增强的代码</strong> , 一般写的都是该接口的子接口的实现类 MethodInterceptor(方法拦截)</p></blockquote></li><li><p>实现</p><blockquote><p>添加依赖</p><p><img src="https://blog.chasingwind.top/1566743771152.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566743771152.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566744856530.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566744856530.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="解决案例中的问题"><a href="#解决案例中的问题" class="headerlink" title="解决案例中的问题"></a>解决案例中的问题</h2><p>我们希望的是 使用的Service既可以使用事务管理 而且这个Service中的对于事务管理的方法的依赖不在里面</p><blockquote><p><img src="https://blog.chasingwind.top/1566724072070.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566724072070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>用于创建Service的代理对象的工厂</p><p><img src="https://blog.chasingwind.top/1566747218158.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566747218158.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>修改配置文件中的依赖  </p><p>在测试中指定就是说 在依赖注入的时候需要按照名字注入</p><p><img src="https://blog.chasingwind.top/1566747345348.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566747345348.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>测试</p><p><img src="https://blog.chasingwind.top/1566747389097.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566747389097.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>异常与不异常 都已经经过了事务管理  这里就不进行展示了</p></blockquote><h2 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h2><ol><li>什么是AOP?<ul><li>在软件业，AOP为<strong>Aspect Oriented Programming</strong>的缩写，意为：<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/6016335">面向切面编程</a>，通过<strong>预编译方式</strong>和<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术。AOP是<a href="https://baike.baidu.com/item/OOP">OOP</a>的延续，是软件开发中的一个热点，也是<a href="https://baike.baidu.com/item/Spring">Spring</a>框架中的一个重要内容，是<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/4035031">函数式编程</a>的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。</li><li>简单地说，就是把程序中的重复的代码抽取出来，在要执行的时候,，使用动态代理技术， 在不修改源码的基础上，对已有的方法进行增强。</li></ul></li><li>AOP的作用以及优势<ul><li>作用：在程序运行期间，不修改源码对已有的方法进行增强</li><li>优势 ：减少重复代码，提高开发效率，维护方便</li></ul></li><li>AOP的实现方式：动态代理技术</li><li>Spring中的AOP<ul><li>通过配置的方式（XML或者注解）实现动态代理</li></ul></li></ol><h2 id="Spring中AOP相关术语"><a href="#Spring中AOP相关术语" class="headerlink" title="Spring中AOP相关术语"></a>Spring中AOP相关术语</h2><ul><li><p>JoinPoint（<strong>连接点</strong>）：可以理解为<strong>代理对象与被代理对象之间的接口或者子类中的所有的方法</strong>，可以将这些方法作为增强方法，在不改变源代码的基础上对方法起到增强的作用。</p></li><li><p>Pointcut（<strong>切入点</strong>）：可以理解为<strong>代理对象与被代理对象之间的接口或者子类中的所有的被增强的方法</strong>，因为所有的连接点并不都需要进行代理。</p></li><li><p>Advice（通知/增强）：通知就是指拦截（使用接口实现动态代理中的<strong>invoke</strong>方法/使用子类实现动态代理的<strong>intercept</strong>方法）到连接点之后要做的事情</p><blockquote><p><img src="https://blog.chasingwind.top/1566792175114.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566792175114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Introduction（引介）：引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field（字段）。</p></li><li><p>Target（目标对象）：被代理的对象</p></li><li><p>Weaving（织入）：把增强应用到目标对象来创建新的代理对象的过程，比如：上面的案例中，原有的Service不支持事务控制，而我们通过动态代理创建了一个新的代理对象，在返回代理对象的过程中添加了事务的支持，那么<strong>加入事务支持的整个过程叫做织入</strong></p></li><li><p>Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类（代理对象）</p></li><li><p>Aspect（切面）：是指切入点（需要增强的方法）和通知（哪些方法方法什么时候执行）的结合</p></li></ul><h2 id="Spring中我们需要完成的"><a href="#Spring中我们需要完成的" class="headerlink" title="Spring中我们需要完成的"></a>Spring中我们需要完成的</h2><ul><li><p>开发阶段（我们做的）</p><p>编写核心业务代码（开发主线）</p><p>把公用代码抽取出来，制作成通知。（开发阶段最后再做）</p><p>在配置文件中，声明切入点与通知间的关系，即切面。</p></li><li><p>运行阶段（Spring框架完成的）</p><p><strong>Spring 框架监控切入点方法的执行</strong>。一旦监控到切入点方法被运行，使用代理机制，动态创建目象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p></li></ul><h2 id="Spring的AOP配置的环境搭建"><a href="#Spring的AOP配置的环境搭建" class="headerlink" title="Spring的AOP配置的环境搭建"></a>Spring的AOP配置的环境搭建</h2><ol><li><p>添加相应的依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1566806010866.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566806010866.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>AccountService接口</p><blockquote><p><img src="https://blog.chasingwind.top/1566805544693.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566805544693.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现接口中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1566805569576.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566805569576.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>PrintLog来模拟通知</p><blockquote><p><img src="https://blog.chasingwind.top/1566805668276.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566805668276.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>我们使用自己编写动态代理的方法来实现</p><blockquote><p><img src="https://blog.chasingwind.top/1566805749467.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566805749467.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>beans.xml的配置</p><p><img src="https://blog.chasingwind.top/1566805807377.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566805807377.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试 </p><blockquote><p>通过动态代理我们就实现了在不修改源码的基础上对方法进行了增强</p><p><img src="https://blog.chasingwind.top/1566805862573.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566805862573.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Spring中基于XML的AOP配置"><a href="#Spring中基于XML的AOP配置" class="headerlink" title="Spring中基于XML的AOP配置"></a>Spring中基于XML的AOP配置</h2><ul><li>上面通过自己编写动态代理和配置beans.xml还是有点麻烦</li><li>其实Spring为我们提供了通过XML配置的方式实现AOP</li></ul><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ol><li><p>添加相应的依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1566805446639.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566805446639.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在配置文件中添加AOP的约束</p><blockquote><p><img src="https://blog.chasingwind.top/1566806077072.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566806077072.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在配置文件置中配置AOP</p><ol><li><p>将<strong>通知</strong>Bean也进行配置(交给Spring管理)</p></li><li><p>使用<code>&lt;aop:config&gt;</code> 标签 表示开始AOP的配置</p></li><li><p>使用<code>&lt;aop:aspect&gt;</code> 标签 表示<strong>开始配置切面</strong></p><blockquote><p>标签中的属性</p><p>id : 给<strong>切面唯一的标识</strong></p><p>ref : 指定<strong>通知类Bean的id</strong></p></blockquote></li><li><p>在<code>&lt;aop:aspect&gt;</code>标签内部 使用对应的标签来<strong>配置通知的类型</strong></p><blockquote><p>我们在这里是在让printLog方法在切入点之前执行  所以是<strong>前置通知</strong></p><p><code>&lt;aop:before&gt;</code> 表示<strong>前置通知</strong></p><p>其中的属性   </p><p><strong>method</strong>  :  表示通知Logger类中哪一个方法是前置通知   </p><p><strong>pointcut</strong> : 用于<strong>指定切入点表达式</strong>, 该表达式的含义指的是<strong>对连接点中哪些方法进行增强</strong>  pointcut属性值的写法 : <strong>execution(切入点表达式)</strong>   </p><p><strong>切入点表达式</strong>的写法 : <strong>访问修饰符 返回值类型 包名.包名….类名.方法名(参数列表)</strong>      </p><p> exp:  public void edu.ahnu.service.impl.AccountServiceImpl.saveAccount()</p></blockquote></li><li><p>总配置图</p><blockquote><p>首先  我们有一个需要增强的类 accountService ———&gt; 配置accountService对象</p><p>我们增强的是 在accountService 切入点方法执行之前 执行printLog方法 ——–&gt;配置Log通知类</p><p>然后我们配置了切面 引用通知Log</p><p>在这个切面中有一个方法printLog  在切入点执行之前执行</p><p>这个切入点 就是配置的切入点表达式 </p></blockquote><blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog.chasingwind.top/1566807920134.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566807920134.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></h2><p>这里的<code>&lt;aop:before method=&quot;&quot; pointcut=&quot;&quot;&gt;</code> 表示的是 对pointcut切入点方法进行增强 , 增强的方法是method方法 而且是前置通知</p></blockquote></li><li><p>测试</p><blockquote><p>一样可以执行成功 并且进行了方法的增强</p><p><img src="https://blog.chasingwind.top/1566808303227.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566808303227.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h3 id="切入点表达式的写法"><a href="#切入点表达式的写法" class="headerlink" title="切入点表达式的写法"></a>切入点表达式的写法</h3><blockquote><p>这个表达式可以被aspectjweaver解析</p><p><img src="https://blog.chasingwind.top/1566817142230.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566817142230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566811399427.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566811399427.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的配置 只能对切入点中的一个方法进行配置</p><p><strong>全通配写法</strong>  :  <code>* *..*.*(..)</code>   这样就实现了对<strong>所有的切入点都进行增强的功能</strong></p><p><img src="https://blog.chasingwind.top/1566812248627.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566812248627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>全通配写法的由来 : </p><p>访问修饰符可省略</p><p>返回值可以使用通配符,表示任意返回值</p><p>包名可以使用通配符, 表示任意包。但是有几级包，就要写几个<code>*.</code> , <code>*..</code>表示当前包及其子包</p><p><strong>类名</strong>和<strong>方法名</strong>都可以使用<code>*</code>实现通配</p><p>参数列表 : </p><ul><li>可以直接写数据类型 , 基本类型直接写名称(比如: int) , 引用类型写包名.类名的方式(比如 : java.lang.String)</li><li>有参数的时候, 可以使用通配符<code>*</code></li><li>使用<code>..</code>表示有无参数均可 , 有参数的话可以是任意类型</li></ul><hr><p>上面的写法存在的问题就是  这样匹配的是<strong>全部的类</strong></p><p>开发中, 我们只需要在<strong>需要实现的类</strong>中进行方法的增强</p><p>比如 这里 我们应该写成AccountServiceImpl中的类需要增强  </p><p><img src="https://blog.chasingwind.top/1566812750427.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566812750427.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="通知的类型配置"><a href="#通知的类型配置" class="headerlink" title="通知的类型配置"></a>通知的类型配置</h3><blockquote><p>在printLog中添加需要通知</p><p><img src="https://blog.chasingwind.top/1566817828065.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566817828065.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在beans.xml中进行配置</p><p><img src="https://blog.chasingwind.top/1566818156019.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566818156019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试</p><p><img src="https://blog.chasingwind.top/1566818188904.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566818188904.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>因为程序没有异常 所以并没有执行到异常通知</p><p>通过理解之前通过动态代理配置事务管理也可以知道</p><p>异常是在catch中的 而正确返回执行的是try  那自然就不会执行catch了</p></blockquote><h3 id="切入点表达式的配置"><a href="#切入点表达式的配置" class="headerlink" title="切入点表达式的配置"></a>切入点表达式的配置</h3><blockquote><p>在上面的配置中 配置的切入点都一样 我们可以 将它提取出来</p><p>使用标签<code>&lt;aop:pointcut&gt;</code> 配置 </p><p>属性id : 指定表达式的唯一标识</p><p>属性express : 指定表达式的内容</p><hr><p>在配置通知的时候 使用<code>pointcut-ref</code>属性来配置表达式的内容</p><p>这里的<code>&lt;aop:pointcut&gt;</code>是<strong>在<code>&lt;aop:aspect&gt;</code>内部进行配置</strong>的，</p><p>所以只能在<strong>此切面内部使用</strong></p><p><img src="https://blog.chasingwind.top/1566818601728.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566818601728.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>还有一种就是<strong>配置在切面之外</strong>  但是需要在<code>&lt;aop:config&gt;</code>标签内 这样的话  <strong>所有的切面都可以使用</strong>了</p><p><img src="https://blog.chasingwind.top/1566818838470.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566818838470.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="配置环绕通知"><a href="#配置环绕通知" class="headerlink" title="配置环绕通知"></a>配置环绕通知</h3><ol><li><p>当我们仅仅配置环绕通知的时候</p><blockquote><p>使用<code>&lt;aop:arounnd&gt;</code>进行配置</p><p><img src="https://blog.chasingwind.top/1566819812768.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566819812768.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>环绕通知的方法</p><p><img src="https://blog.chasingwind.top/1566819834617.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566819834617.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试中的调用</p><p>我们调用的是saveAccount方法 </p><p><img src="https://blog.chasingwind.top/1566819890387.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566819890387.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>但是输出的却是环绕通知方法arroundPrintLog的内容</p><p><img src="https://blog.chasingwind.top/1566819941192.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566819941192.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>问题分析</p><blockquote><p>在上面的情况中  也就是当我们配置环绕通知后 , <strong>切入点方法没有执行</strong> , 反而<strong>执行的是环绕通知的方法</strong></p><hr><p>对比我们在动态代理中的代码</p><p><img src="https://blog.chasingwind.top/1566820276257.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566820276257.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在<strong>环绕通知中添加切入点方法</strong></p><blockquote><p>使用Spring框架中的 <code>ProceedingJoinPoint</code>接口中的<code>proceed()</code>方法, 此方法的作用就是<strong>明确调用切入点方法</strong></p><p><strong>该接口可以作为环绕通知的方法参数</strong> , 在程序执行的时候 , Spring框架会为我们提供该接口的实现类供我们使用</p><hr><p>进行环绕通知的编写  </p><p>这里可以感觉到 这就是Spring的动态代理啊</p><p>在<code>proceedingJoinPoint.proceed(args);</code>执行之前的通知就是前置通知</p><p>在<code>proceedingJoinPoint.proceed(args);</code>之后执行的通知就是后置通知</p><p>其他跟动态代理都一样的….</p><p><img src="https://blog.chasingwind.top/1566821120308.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566821120308.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可以理解为他是Spring为我们提供<strong>通过代码的方式手动控制增强方法何时执行的方式</strong></p><hr><p>测试</p><p><img src="https://blog.chasingwind.top/1566821271476.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566821271476.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以发现增强了方法 </p></blockquote></li></ol><h2 id="Spring中基于注解的AOP配置"><a href="#Spring中基于注解的AOP配置" class="headerlink" title="Spring中基于注解的AOP配置"></a>Spring中基于注解的AOP配置</h2><p>在注解的配置中可以按照之前的XML的配置的过程将它改为注解的方式配置</p><ol><li><p>在beans.xml文件中添加约束并且配置要扫描的包</p><blockquote><p><img src="https://blog.chasingwind.top/1566827122571.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566827122571.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566827169931.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566827169931.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在AccountService和PrintLog上面添加注解</p><blockquote><p><img src="https://blog.chasingwind.top/1566827242825.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566827242825.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>并且在切面类上加注解<code>@Aspect</code></p><p><img src="https://blog.chasingwind.top/1566827308451.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566827308451.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在切入点方法上添加注解</p><blockquote><p>注意这里的切入点的配置  是一个方法  并且使用注解</p><p><img src="https://blog.chasingwind.top/1566827433497.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566827433497.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>当我们把环绕通知注释之后 以防止影响结果</p><p><img src="https://blog.chasingwind.top/1566827512096.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566827512096.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>出现了执行顺序的问题  这是Spring的一个问题   所以谨慎选择Spring中AOP的此种注解方式的配置</p></blockquote><blockquote><p>测试环绕通知</p><p>执行的顺序是正常的</p><p><img src="https://blog.chasingwind.top/1566827614667.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566827614667.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基于注解的IOC</title>
      <link href="2019/08/23/Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC/"/>
      <url>2019/08/23/Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC/</url>
      
        <content type="html"><![CDATA[<p>本节讲述了在IOC中的常用的注解，以及通过案例实现单表查询的功能的XML的实现和注解方式的实现。再次基础上，完全使用注解来实现相同的功能。</p><a id="more"></a> <h2 id="Spring中IOC的常用注解"><a href="#Spring中IOC的常用注解" class="headerlink" title="Spring中IOC的常用注解"></a>Spring中IOC的常用注解</h2><ul><li><p>无论是基于XML还是注解的方式实现的配置，它们要实现的功能是相同的，都是为了降低程序间的耦合</p></li><li><p>注解按照功能分类</p><blockquote><p>之前的xml配置</p><p><img src="https://blog.chasingwind.top/1566536314466.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566536314466.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在使用注解的配置之前 需要在beans.xml中添加约束</p><blockquote><p><img src="https://blog.chasingwind.top/1566541248230.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566541248230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>并且告诉Spring我们使用注解在哪一个包下面 以便Spring进行扫描</p><p><img src="https://blog.chasingwind.top/1566541288567.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566541288567.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="用于创建对象的注解"><a href="#用于创建对象的注解" class="headerlink" title="用于创建对象的注解"></a>用于创建对象的注解</h3><p>作用和xml配置中的<code>&lt;bean&gt;</code>标签的作用相同</p><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><ul><li><p><code>@Component</code></p><ul><li>作用 : 用于把创建的<strong>当前类对象</strong>存入Spring容器中</li><li>属性 : <ul><li>value : 用于指定bean的id , 可以不写 , 不写的话id默认为当前类名的首字母小写</li></ul></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1566541327534.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566541327534.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>运行结果</p><p><img src="https://blog.chasingwind.top/1566541370932.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566541370932.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>@Controller</code> : 一般用于<strong>表现层</strong></p></li><li><p><code>@Service</code> : 一般用于<strong>业务层</strong></p></li><li><p><code>@Repository</code> : 一般用在<strong>持久层</strong></p><p>这三个的作用和<code>@Component</code>的作用一模一样 , 这样做只是Spring框架为我们提供明确的三层模型的注解 , 使得三层对象更清晰</p></li></ul><h3 id="用于注入数据的注解"><a href="#用于注入数据的注解" class="headerlink" title="用于注入数据的注解"></a>用于注入数据的注解</h3><p>作用和xml配置中的<code>&lt;bean&gt;</code>标签下的<code>&lt;property&gt;</code>作用相同</p><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul><li><p><code>@Autowired</code></p><ul><li><p>作用 : <strong>自动按照类型注入</strong></p></li><li><p>出现的位置 : 变量或者方法上等等</p></li><li><p>备注 : 在使用注解注入时 , <strong>set方法不是必须的</strong></p><blockquote><p>未注入之前  由于accountDao变量为空  会报错</p><p><img src="https://blog.chasingwind.top/1566542350871.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566542350871.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>当容器中含有<strong>唯一的</strong>一个bean对象的类型和要注入的变量的类型匹配 , 就可以注入成功 ; </p><blockquote><p><img src="https://blog.chasingwind.top/1566543665128.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566543665128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>将accountDao变量注入  可以正常测试</p><p><img src="https://blog.chasingwind.top/1566542403730.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566542403730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>当容器中<strong>没有</strong>可以与注入的变量类型相匹配的类型的时候 , 注入失败</p></li><li><p>当容器中含有<strong>多个</strong>bean对象的类型和要注入的变量的类型匹配 的时候 , 在这多个bean对象中<strong>根据变量名进行匹配</strong> , 如果有变量名匹配 , 就注入 ; 否则 , 报错</p><blockquote><p>此图中就没有对应的变量名  所以注入失败</p><p><img src="https://blog.chasingwind.top/1566545631085.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566545631085.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>accountDao1</p><p><img src="https://blog.chasingwind.top/1566545901917.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566545901917.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>accountDao2</p><p><img src="https://blog.chasingwind.top/1566545923758.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566545923758.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当有多个accountDao类型的时候  <strong>但是没有匹配的变量名</strong></p><p>注入的变量名为<strong>accountDao</strong>的时候</p><p>报错</p><p><img src="https://blog.chasingwind.top/1566546027799.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566546027799.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>注入的变量名为<strong>accountDao1</strong></p><p>执行的方法时Dao1中的方法</p><p><img src="https://blog.chasingwind.top/1566546183063.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566546183063.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>注入的变量名为<strong>accountDao2</strong>的时候</p><p>执行的方法时Dao2中的方法</p><p><img src="https://blog.chasingwind.top/1566546240398.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566546240398.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul></li></ul><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul><li><p><code>@Qualifier</code></p><ul><li>作用: 在<strong>按照类注入的基础上再按照名称注入</strong>，这样就解决了在变量名不需要修改的情况下，实现按照对应的名称注入。</li><li>属性 : <ul><li>value : 用于指定注入的bean的id</li></ul></li><li>备注 : 在<strong>给类成员注入的时候不能单独使用,需要配合<code>@Autowired</code>使用</strong> , 在给方法参数注入的时候可以(后面讲解)</li></ul><blockquote><p>可以看到  在变量名还是accountDao的情况下  配置的value的值是容器中的对应的bean对象的accountDao1  执行的也是对应的方法</p><p><img src="https://blog.chasingwind.top/1566546694508.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566546694508.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注入accountDao2</p><p><img src="https://blog.chasingwind.top/1566546828520.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566546828520.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul><li><p><code>@Resource</code></p><ul><li>作用 : <strong>直接按照bean的id注入</strong></li><li>属性 : <ul><li>name : 用于指定注入的bean的id(已经在beans.xml中进行配置)</li></ul></li></ul><blockquote><p>指定 name属性的值为 accountDao1</p><p><img src="https://blog.chasingwind.top/1566547039347.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566547039347.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>指定 name属性的值为 accountDao2</p><p><img src="https://blog.chasingwind.top/1566547070381.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566547070381.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><hr><p>以上3个注解  都<strong>只能注入其他已经存在于Ioc容器中的bean类型的数据</strong>(accountDao1 , accountDao2)</p><p>而基本类型和String类型无法通过上面的注解实现</p><p><strong>集合类型只能通过XML配置文件注入</strong></p><h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><ul><li><code>@Value</code><ul><li>作用 : 用于<strong>注入基本数据类型和String类型</strong></li><li>属性<ul><li>value : 用于指定数据的值 , 可以使用Spring中的SpEL(Sprig中的EL表达式 , 形式为<code>$&#123;表达式&#125;</code>)  </li></ul></li></ul></li></ul><h3 id="用于改变作用范围的注解"><a href="#用于改变作用范围的注解" class="headerlink" title="用于改变作用范围的注解"></a>用于改变作用范围的注解</h3><p>作用和<code>&lt;bean&gt;</code>标签中使用<code>scope</code>属性的作用相同</p><h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><ul><li><p><code>@Scope</code></p><ul><li>作用: 用于指定<strong>bean的作用范围</strong>,也就是对象的作用范围, 所以作用在类上</li><li>属性<ul><li>value : 指定范围的取值 , 常用的有: singleton(单例) , prototype(多例)</li></ul></li></ul><blockquote><p>配置bean的作用范围为prototype</p><p><img src="https://blog.chasingwind.top/1566547942478.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566547942478.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566547988837.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566547988837.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="用于和生命周期相关的"><a href="#用于和生命周期相关的" class="headerlink" title="用于和生命周期相关的"></a>用于和生命周期相关的</h3><ol><li><p>和生命周期相关的 : 作用和<code>&lt;bean&gt;</code>标签中的<code>init-method</code>和<code>destory-method</code>的作用相同</p><ul><li><code>@PostConstruct</code> : 用于指定<strong>初始化方法</strong></li><li><code>@PreDestory</code> : 用于指定<strong>销毁方法</strong></li></ul></li></ol><h2 id="使用XML方式实现案例"><a href="#使用XML方式实现案例" class="headerlink" title="使用XML方式实现案例"></a>使用XML方式实现案例</h2><ol><li><p>Service层</p><blockquote><p><img src="https://blog.chasingwind.top/1566571008503.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566571008503.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Dao层</p><blockquote><p><img src="https://blog.chasingwind.top/1566572264674.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566572264674.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置文件 beans.xml</p><blockquote><p><img src="https://blog.chasingwind.top/1566571367915.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566571367915.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>其实这里注入数据库连接信息dataSource使用set方法不太合适  最好使用构造方法的方式注入</p><p>同时注意到template  的  scope是<strong>prototype</strong>  否则的话 会出现线程安全问题</p><hr><p>修改的地方  因为在druid连接池中  使用的数据库配置的名字是 <code>driverClassName</code></p><p><img src="https://blog.chasingwind.top/1566572370078.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566572370078.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566572393804.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566572393804.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p><img src="https://blog.chasingwind.top/1566572416998.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566572416998.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>其他的测试都一样的  在这里不测试</p></blockquote></li></ol><h2 id="使用注解方式实现案例"><a href="#使用注解方式实现案例" class="headerlink" title="使用注解方式实现案例"></a>使用注解方式实现案例</h2><ol><li><p>在上面的使用xml方式的基础上进行修改</p></li><li><p>修改配置文件</p><blockquote><p><img src="https://blog.chasingwind.top/1566573561210.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566573561210.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用注解的方式实现IoC和DI</p><blockquote><p>Service   @Autowired自动按照类型注入  此时已经不需要set方法了</p><p><img src="https://blog.chasingwind.top/1566573609140.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566573609140.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Dao</p><p><img src="https://blog.chasingwind.top/1566573644242.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566573644242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="纯注解方式实现案例"><a href="#纯注解方式实现案例" class="headerlink" title="纯注解方式实现案例"></a>纯注解方式实现案例</h2><h3 id="Configuration和-ComponentScan"><a href="#Configuration和-ComponentScan" class="headerlink" title="@Configuration和@ComponentScan"></a>@Configuration和@ComponentScan</h3><ul><li><p>在上面的两种方式的配置中，都需要使用配置文件beans.xml。</p><blockquote><p>为了完全消除配置文件  需要解决下面的两个问题  就需要新的注解</p><p>第一个就是告诉Spring需要扫描的包</p><p>第二个就是通过配置文件注入信息</p><p><img src="https://blog.chasingwind.top/1566573831035.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566573831035.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><hr><ul><li><p><code>@Configuration</code>  :  指定当前类是一个配置类 </p></li><li><p><code>@ComponentScan</code>  : 可以用于指定Spring在创建容器时要扫描的包</p><ul><li><p>属性 : </p><ul><li>value  : 与base-package作用相同 , 都是用于指定创建容器时扫描的包</li><li>basePackages</li></ul></li><li><p>使用此注解等同于在配置文件中的</p><blockquote><p><img src="https://blog.chasingwind.top/1566574385306.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566574385306.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><blockquote><p>使用上面的两个注解实现</p><p>首先 需要一个配置类  在配置类上进行注解的配置</p><p>然后  在一个配置类中配置要扫描的包</p><p><img src="https://blog.chasingwind.top/1566574562099.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566574562099.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><ul><li><p><code>@Bean</code>   :  用于<strong>把当前方法的返回值作为bean对象存入Spring容器中</strong></p><ul><li>属性 : <ul><li><strong>name</strong> : 用于指定bean的id，当不写时，默认值是当前方法的名字</li></ul></li><li>备注 :<ul><li>当使用<strong>注解配置的方法有形式参数</strong>的时候，Spring会去请其中查找有没有匹配的bean对象, 匹配的方式以及结果都跟注解<code>@Autowired</code>相同</li></ul></li></ul><blockquote><p>下面这段配置实现的功能 </p><p><strong>创建JdbcTemplate对象</strong> </p><p><strong>再把这个对象存入容器中</strong></p><p><img src="https://blog.chasingwind.top/1566574931941.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566574931941.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>通过注解实现相同的功能</p><p>在template中需要注入DataSource</p><p><img src="https://blog.chasingwind.top/1566576214604.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566576214604.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>这个时候就可以将配置文件删除了</p><p>进行测试  </p><p>注意 此时获取容器需要使用的是<strong>注解的形式的配置</strong></p><p>所以使用的是类<code>AnnotationConfigApplicationContext</code></p><p><img src="https://blog.chasingwind.top/1566576336991.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566576336991.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>还存在的一个问题就是  </p><p>我们之前使用的template是多例的</p><p>上面没有进行配置  可以使用<code>@Scope</code>进行配置</p><p><img src="https://blog.chasingwind.top/1566576551213.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566576551213.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="Configuration的细节"><a href="#Configuration的细节" class="headerlink" title="@Configuration的细节"></a>@Configuration的细节</h3><ul><li><p>当配置类作为<code>AnnotationConfigApplicationContext</code>对象创建的参数时，该注解可以不写</p><blockquote><p>此时类 已经没有了<code>@Configuration</code>配置</p><p><img src="https://blog.chasingwind.top/1566577032119.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577032119.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用<code>AnnotationConfigApplicationContext</code>获取容器  </p><p>因为参数就是<code>SpringConfiguration</code>类</p><p><img src="https://blog.chasingwind.top/1566577058147.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577058147.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>但是如果 </p><p>我们需要将SpringConfiguration作为一个配置类 放公共的配置</p><p>在JdbcConfiguration中放置数据库相关的配置的时候  </p><p>该怎样实现呢</p><hr><p>首先 将config包添加到需要扫描的包中</p><p><img src="https://blog.chasingwind.top/1566577374162.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577374162.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在JdbcConfiguration上配置<code>@Configuration</code></p><p><img src="https://blog.chasingwind.top/1566577416436.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577416436.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>因为  此时Test类中  获取容器中传入的参数是<code>SpringConfiguration.class</code></p><p>所以在这个配置类的上面没有配置<code>@Configuration</code></p><p><img src="https://blog.chasingwind.top/1566577486709.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577486709.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>还有一种方式实现上述的功能 </p><p>将JdbcConfiguration也作为参数传入<code>AnnotationConfigApplicationContext</code></p><p><img src="https://blog.chasingwind.top/1566577639758.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577639758.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>此时两个类都不需要<code>@Configuration</code>注解</p><p><img src="https://blog.chasingwind.top/1566577665630.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577665630.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566577678006.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577678006.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><ul><li><p><code>@import</code>  :  用于导入其他的配置类</p><ul><li>属性 : <ul><li>value : 用于指定其他配置类的字节码 , 当我们使用<code>@Import</code>注解的时候 , 那么这个配置类是<strong>主配置类</strong> , 而导入的是子配置类</li></ul></li></ul><blockquote><p>使用Import注解实现上面的效果</p><p>在Test中  <strong>只需要指定这个主配置类的字节码文件</strong></p><p><img src="https://blog.chasingwind.top/1566577965337.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566577965337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在主配置SpringConfiguration中  不再需要指定扫描的包config</p><p>使用Import注解 导入子配置JdbcConfiguration</p><p><img src="https://blog.chasingwind.top/1566578054598.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566578054598.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>子配置  可以不写<code>@Configuration</code></p><p><img src="https://blog.chasingwind.top/1566578069615.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566578069615.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><ul><li><p><code>@PropertySource</code>  :  用于<strong>指定properties文件的位置</strong></p><ul><li>属性 : <ul><li>value  :  用于指定<strong>文件的名称和文件的位置</strong> , 其中有一个关键字 : classpath,用于表示这个文件是在类路径下</li></ul></li></ul><blockquote><p>当前配置类存在的问题  :  应该从配置文件中来读取数据库连接的信息 而不是写死</p><p>配置类</p><p><img src="https://blog.chasingwind.top/1566579462215.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566579462215.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置文件</p><p><img src="https://blog.chasingwind.top/1566579590938.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566579590938.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>此时要想这个配置文件被读取 就需要配置注解<code>@PropertySource</code></p><p>因为resources目录下的文件在发布在服务器上之后</p><p>resources目录下的文件放在target的classes目录下  </p><p>所以可以使用classpath执行后面的路径是类路径</p><p><img src="https://blog.chasingwind.top/1566579746270.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566579746270.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><hr><p>在现实开发中，</p><p>当我们使用的类是jar包（JdbcTemplate）中的，多数<strong>使用XML来配置</strong></p><p>当我们使用的类是我们自己写的，多数使用<strong>注解配置</strong></p><ul><li><p><code>@Qualifier</code>  : 当有多个匹配的参数的时候 ,指定其中的一个作为参数 </p><ul><li>此处讲解的是作用在方法的参数上</li></ul><blockquote><p>比如有两个连接数据库的信息时   需要使用第二个的时候 就可以在参数上进行配置</p><p>他的匹配方式和<code>@Autowired</code>一样</p><p><img src="https://blog.chasingwind.top/1566580657529.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566580657529.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="Spring和Junit的整合"><a href="#Spring和Junit的整合" class="headerlink" title="Spring和Junit的整合"></a>Spring和Junit的整合</h2><ol><li><p>在测试类中存在的问题</p><blockquote><p>在每个测试方法中的重复代码</p><p><img src="https://blog.chasingwind.top/1566581195965.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566581195965.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>试想通过自动注入的方式 </p><p>但是却不能实现  因为在Test中不会创建容器存储</p><p><img src="https://blog.chasingwind.top/1566581282344.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566581282344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>解决方法</p><ol><li><p>导入Spring整合的Junit的依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1566581373008.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566581373008.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用Junit提供的一个注解<code>@Runwith</code>把原有的main方法替换成Spring提供的（称之为运行器）</p><blockquote><p><img src="https://blog.chasingwind.top/1566581508549.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566581508549.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>告诉Spring的运行器<code>@ContextConfiguration</code>，Spring的Ioc容器创建基于xml还是注解的形式，以及位置</p><blockquote><p>ContextConfiguration的属性</p><ol><li><p>locations  :  指定<strong>xml文件</strong>的位置，加上classpath关键字，表示在类路径下</p><p><img src="https://blog.chasingwind.top/1566582259516.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566582259516.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>classes：指定<strong>注解类</strong>所在的位置</p><p><img src="https://blog.chasingwind.top/1566582016029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566582016029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring概述以及基于XML的IOC配置</title>
      <link href="2019/08/22/Spring%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%9F%BA%E4%BA%8EXML%E7%9A%84IOC%E9%85%8D%E7%BD%AE/"/>
      <url>2019/08/22/Spring%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%9F%BA%E4%BA%8EXML%E7%9A%84IOC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>本节讲解了Spring框架的基础知识以及程序之间耦合的概念,使用Ioc(控制反转)来降低耦合,使用依赖注入的方式来管理依赖,也就是将类之间的依赖交给Spring来管理.</p><a id="more"></a><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><h3 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h3><p>Spring 是分层的 Java SE/EE 应用 full-stack （全栈）轻量级开源框架，以 <strong>IoC（Inverse Of Control： 控制反转）和 AOP（Aspect Oriented Programming：面向切面编程）为内核</strong>，提供了展现层 Spring  MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，<strong>还能整合开源世界众多著名的第三方框架和类库</strong>，逐渐成为使用最多的 Java EE 企业应用开源框架。</p><h3 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h3><ol><li><p><strong>方便解耦，简化开发</strong></p><blockquote><p>通过 Spring 提供的 IoC 容器，可以<strong>将对象间的依赖关系交由 Spring 进行控制</strong>，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p></blockquote></li><li><p><strong>AOP</strong> <strong>编程的支持</strong></p><blockquote><p>通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付。</p></blockquote></li><li><p><strong>声明式事务的支持</strong></p><blockquote><p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。</p></blockquote></li><li><p><strong>方便程序的测试</strong></p><blockquote><p>可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</p></blockquote></li><li><p><strong>方便集成各种优秀框架</strong></p><blockquote><p>Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持</p></blockquote></li><li><p><strong>降低</strong> <strong>JavaEE API</strong> <strong>的使用难度</strong></p><blockquote><p>Spring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的 使用难度大为降低。</p></blockquote></li><li><p><strong>Spring</strong> <strong>源码是经典学习范例</strong></p><blockquote><p>Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。</p></blockquote></li></ol><h3 id="Spring的体系结构"><a href="#Spring的体系结构" class="headerlink" title="Spring的体系结构"></a>Spring的体系结构</h3><blockquote><p><img src="https://blog.chasingwind.top/1566440452710.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566440452710.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h2 id="程序的耦合以及解耦"><a href="#程序的耦合以及解耦" class="headerlink" title="程序的耦合以及解耦"></a>程序的耦合以及解耦</h2><ol><li><p>耦合：程序之间的依赖关系</p><ul><li><p>类之间的依赖</p></li><li><p>方法之间的依赖</p></li></ul></li><li><p>解耦：<strong>降低</strong>程序之间的依赖关系</p><ul><li><p>我们在开发中，应该做到：<strong>编译期不依赖</strong>，运行时才依赖</p><blockquote><p>当我们取消mysql依赖的时候</p><p><img src="https://blog.chasingwind.top/1566442319353.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566442319353.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>去运行JdbcDemo</p><p>由于jdbc包已经不存在了  就会报错  而且是<strong>编译期的错误</strong></p><p><img src="https://blog.chasingwind.top/1566442363183.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566442363183.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当我们使用反射的方法来操作这个类的时候(同样没有依赖jdbc包的情况下)</p><p>这个时候不再是编译期错误  而是<strong>运行期异常</strong></p><p><img src="https://blog.chasingwind.top/1566442464272.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566442464272.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们把依赖添加上之后  就可以运行啦</p></blockquote><hr><p>解决<strong>类之间依赖</strong>思路:</p><ol><li><p>在创建对象的时候，<strong>使用反射来创建对象</strong>，避免使用new关键字</p><blockquote><p>比如上面的  </p><p>通过依赖的方式创建对象的时候：依赖的只是这个类名的字符串</p><p>而通过new的方式创建对象的时候：依赖的确是整个类</p></blockquote></li><li><p>通过读取<strong>配置文件</strong>来获取创建的对象的全限定类名</p><blockquote><p>上面通过反射的方式存在的问题</p><p>因为这个字符串写死了  后期如果需要修改 就需要修改代码</p><p>所以应该写在配置文件中</p></blockquote></li></ol></li></ul></li><li><p>模拟实际开发中的耦合问题</p><blockquote><p>我们来<strong>模拟</strong>三层架构的实现</p><p>首先,测试类创建Servlet对象 调用其中的方法</p><p><img src="https://blog.chasingwind.top/1566456631270.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566456631270.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Servlet创建Service对象  调用Service中的方法<br><img src="https://blog.chasingwind.top/1566456678039.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566456678039.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Service创建Dao的对象  调用其中的方法</p><p><img src="https://blog.chasingwind.top/1566456718029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566456718029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Dao中的方法</p><p><img src="https://blog.chasingwind.top/1566456740769.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566456740769.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试类执行</p><p><img src="https://blog.chasingwind.top/1566458943246.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566458943246.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这是我们之前经常写的代码</p><p>这里的依赖其实是很严重的   只要缺少任何一个类  都会出现错误</p></blockquote></li><li><p>降低依赖的方法 : <strong>工厂模式</strong></p><ul><li><p>创建Bean对象的工厂</p><blockquote><p>Bean : 可重用组件</p><p>Bean &gt; JavaBean</p><p>JavaBean : 用Java语言编写的可重用组件</p></blockquote><blockquote><p>对于上面的实例</p><p>使用Bean对象工厂创建Service和Dao对象</p><ul><li><p>首先 需要一个配置文件来配置我们的service和dao</p><ul><li>配置的内容 : 唯一标志=全限定类名 (key=value)</li><li>配置文件可以是properties或者xml</li></ul><blockquote><p>这里使用的是properties配置文件</p><p><img src="https://blog.chasingwind.top/1566458721321.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566458721321.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>通过读取配置文件中的内容,通过反射创建对象</p><blockquote><p>创建BeanFactory工厂类  提供通过反射创建对象的方法getBean</p><p><img src="https://blog.chasingwind.top/1566458798044.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566458798044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></blockquote><blockquote><p>修改后的代码  </p><p>Test调用Servlet</p><p><img src="https://blog.chasingwind.top/1566458842178.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566458842178.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Servlet调用Service</p><p><img src="https://blog.chasingwind.top/1566458876273.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566458876273.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Service调用Dao</p><p><img src="https://blog.chasingwind.top/1566458906050.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566458906050.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>最终实现了同样的效果</p><p><img src="https://blog.chasingwind.top/1566458929388.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566458929388.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>存在的问题</p><blockquote><p><strong>上面的创建对象是多例的</strong>  也就是说 每次执行都会重新创建对象</p><p> 因为每次执行的话 都会调用getBean   其中的newInstance()就会创建对象</p><p><img src="https://blog.chasingwind.top/1566460065092.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566460065092.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>而<strong>我们并不需要每次调用方法都去创建对象  可以使用单例模式</strong></p><p>可以通过 <strong>只使用一次newInstance创建一个对象  并将这个对象存起来</strong></p><p>可以将这个<strong>newInstance</strong>放在static代码块中(这样就只会执行一次 创建一次对象)  </p><p>并且<strong>将创建的对象存在Map中</strong>  以防止垃圾回收</p><p>将来<strong>getObject</strong>根据名称创建对象的时候  从Map中取</p><hr><p><img src="https://blog.chasingwind.top/1566461015692.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566461015692.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="IOC概念和Spring中的IOC"><a href="#IOC概念和Spring中的IOC" class="headerlink" title="IOC概念和Spring中的IOC"></a>IOC概念和Spring中的IOC</h2><h3 id="IOC的概念"><a href="#IOC的概念" class="headerlink" title="IOC的概念"></a>IOC的概念</h3><ul><li><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a>中的一种设计原则，可以<strong>用来降低计算机代码之间的耦合度</strong>。其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）。</li><li>通过控制反转，<strong>对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它</strong>。也可以说，依赖被注入到对象中。</li><li>控制反转（Inversion of Control）是说<strong>创建对象的控制权发生转移</strong>，以前创建对象的主动权和创建时机由应用程序把控，而现在这种权利转交给 IoC 容器<strong>，它就是一个专门用来创建对象的工厂</strong>，你需要什么对象，它就给你什么对象</li></ul><h3 id="Spring中的IOC"><a href="#Spring中的IOC" class="headerlink" title="Spring中的IOC"></a>Spring中的IOC</h3><ol><li><p>Spring的简单使用</p><ol><li><p>创建新项目 , 在pom.xml中导入Spring依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1566463090733.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566463090733.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在maven中可以看到依赖的结构</p><p><img src="https://blog.chasingwind.top/1566463136929.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566463136929.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>resources文件夹下新建配置文件</p><blockquote><p>这段配置可以在Spring的官方文档的Core中查找</p><p><img src="https://blog.chasingwind.top/1566463337212.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566463337212.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566463298842.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566463298842.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将创建对象交给Spring的IoC管理</p><blockquote><p>在resources目录下 创建beans.xml配置文件  这就是IoC的核心容器的配置文件</p><p><img src="https://blog.chasingwind.top/1566463610978.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566463610978.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>获取Spring的IoC核心容器 , 并根据id获取对象</p><blockquote><p><img src="https://blog.chasingwind.top/1566464340449.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566464340449.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>运行结果  可见 我们使用IoC创建出了对应的对象</p><p><img src="https://blog.chasingwind.top/1566464388579.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566464388579.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>ApplicationContext的三个常用的实现类</p><p><img src="https://blog.chasingwind.top/1566464629800.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566464629800.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>ClassPathXmlApplicationContext  : 可以加载<strong>类路径下的配置文件</strong> , 如果配置文件不在类路径下 , 那么就无法加载 ,也就无法通过IoC创建对象</p><p>FileSystemXmlApplicationContext  :  可以加载<strong>任意磁盘位置(具有访问权限)的配置文件</strong></p><p>AnnotationConfigApplicationContext  :  通过<strong>读取注解来创建容器</strong></p></blockquote></li></ol><hr><blockquote><p>核心容器的两个接口  一个是ApplicationContext 而ApplicationContext实现了BeanFactory接口</p><p><img src="https://blog.chasingwind.top/1566465831843.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566465831843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>ApplicationContext</strong>  :  在构建核心容器的时候，创建对象采取的策略是<strong>立即加载的方式</strong>。也就是说 ， 只要一读取完配置文件就会立即根据配置文件中的<code>&lt;bean&gt;</code>通过反射来创建对象</p><p>适用于 ： 单例模式  只需要创建一次对象 ，在读取配置文件之后就进行创建</p><hr><p><strong>BeanFactory</strong>  :  在构建核心容器时，创建对象采用<strong>延迟加载</strong>的策略。也就是说，什么时候<strong>根据id获取对象（执行getBean方法）</strong>，就什么时候创建对象。</p><p>适用于：<strong>多例模式  用的时候再创建</strong> </p></blockquote><ol start="5"><li><p><strong>创建Bean对象</strong>的三种方式</p><ol><li><p>使用<strong>默认构造函数</strong>创建</p><blockquote><p>在Spring的配置文件中使用<code>&lt;bean&gt;</code>标签，<strong>配置id和class属性</strong>之后，并且<strong>没有其他的属性和标签的时候</strong>。采用的就是默认构造函数创建Bean对象</p><p>当配置的全类名对应的类中<strong>没有默认构造函数的时候，则对象无法创建</strong></p><blockquote><p>修改构造函数  这样就没有了默认构造函数</p><p><img src="https://blog.chasingwind.top/1566476775612.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566476775612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>此时已经在配置文件中出现了错误</p><p><img src="https://blog.chasingwind.top/1566476812242.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566476812242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>运行的时候出现的错误</p><p><img src="https://blog.chasingwind.top/1566476841265.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566476841265.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></blockquote></li><li><p>使用工厂中的<strong>普通方法</strong>创建对象</p><blockquote><p>当我们需要使用jar包中的方法来创建对象</p><p>或者</p><p>当某个类中有一个方法，这个<strong>方法的返回值是一个对象</strong>，我们想要通过这个方法创建对应的对象的时候，并将它存入Spring容器</p><hr><p><img src="https://blog.chasingwind.top/1566477767161.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566477767161.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置</p><p><img src="https://blog.chasingwind.top/1566478013105.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566478013105.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用工厂中的<strong>静态方</strong>法创建对象</p><blockquote><p>类中的静态方法</p><p><img src="https://blog.chasingwind.top/1566478354566.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566478354566.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置</p><p><img src="https://blog.chasingwind.top/1566478328317.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566478328317.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p><strong>Bean对象的作用范围</strong></p><blockquote><p>默认情况下  可见  创建的是同一个对象</p><p>使用<code>ApplicationContext</code>  立即加载  创建的是<strong>单例对象</strong></p><p>使用<code>BeanFactory </code>  使用的时候才进行对象的创建  可以用来创建<strong>多例对象</strong></p><p>单例对象或者多例对象是可以<strong>在创建Bean对象的时候进行设置的</strong></p><p><img src="https://blog.chasingwind.top/1566478847368.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566478847368.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>通过<code>&lt;bean&gt;</code>标签的<strong>scope属性</strong>可以进行设置bean的作用范围</p><p>取值：</p><p>singleton：单例(默认情况)</p><p>prototype：多例</p><p>request：作用于web应用的request请求范围</p><p>session：作用于web应用的会话范围</p><p>global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境的时候，等同于session</p></blockquote><blockquote><p>单例</p><p><img src="https://blog.chasingwind.top/1566479131164.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566479131164.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>跟默认情况是相同的</p><p><img src="https://blog.chasingwind.top/1566479146388.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566479146388.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>多例</p><p><img src="https://blog.chasingwind.top/1566479182944.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566479182944.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566479191869.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566479191869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>Bean对象的生命周期</strong></p><ol><li><p>单例对象</p><blockquote><p>出生: 当<strong>容器创建时，对象出生</strong></p><p>活着: 当容器还在, 对象就在存活</p><p>死亡: 当<strong>容器销毁, 对象死亡</strong></p><hr><p>配置</p><p><img src="https://blog.chasingwind.top/1566480077131.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566480077131.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>类中的方法</p><p><img src="https://blog.chasingwind.top/1566480105981.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566480105981.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试</p><p><img src="https://blog.chasingwind.top/1566480226285.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566480226285.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>多例对象</p><blockquote><p>出生 : <strong>使用对象的时候才创建</strong></p><p>活着 : 只要在使用过程中中就一直活着</p><p>死亡 : <strong>当对象长时间不用, 并且没有别的对象引用的时候 , 只能由Java的垃圾回收机制来回收</strong></p><hr><p><img src="https://blog.chasingwind.top/1566480492094.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566480492094.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试代码不变</p><p><img src="https://blog.chasingwind.top/1566480513562.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566480513562.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果   虽然容器关闭了 但是对象并没有执行销毁  只能等待垃圾回收机制来销毁对象</p><p><img src="https://blog.chasingwind.top/1566480532924.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566480532924.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><ol><li><p>概念</p><ul><li>IOC实现的是降低类之间的耦合，但是并不是消除。所以，必然还会存在依赖关系。</li><li>将依赖关系的管理交给Spring来管理，<strong>在当前类需要使用到其他类对象的时候，由Spring来为我们提供，我们只需要在配置文件中说明</strong>，这就是依赖注入。</li><li>依赖注入<strong>主要用于类中对象成员变量的赋值</strong></li></ul></li><li><p>依赖注入的数据分类</p><ol><li>基本类型和String</li><li>其他Bean类型（在配置文件或者注解中配置过的bean）</li><li>复杂类型（集合类型）</li></ol></li><li><p>依赖注入的方式</p><ol><li><p>使用构造函数提供（<strong>一般不用</strong>）</p><ol><li><p>使用方式</p><blockquote><p>使用的标签：<code>constructor-arg</code></p><p>标签出现的位置：<code>&lt;bean&gt;</code>标签内</p><p>标签的属性：</p><blockquote><p>type：用于指定<strong>要注入的数据的数据类型</strong>，该数据类型也是构造函数中的参数的类型</p><p>index：用于将要注入的数据给<strong>构造函数中指定索引位置的参数赋值</strong>，索引从0开始</p><p>name：根据构造函数中的参数名来赋值<br>这三种都是用来给构造函数中的参数赋值的，<strong>直接用name就能达到效果</strong></p><hr><p>value：用于给参数赋值，用于基本类型和String类型的数据</p><p>ref：用于指定其他的bean类型，也就是在配置文件中配置过的bean</p></blockquote><p>构造函数</p><p>这里<strong>只要关注数据类型</strong>就可以了  不要关心变量名 </p><p><img src="https://blog.chasingwind.top/1566485473509.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566485473509.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置文件</p><p><img src="https://blog.chasingwind.top/1566485605358.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566485605358.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用通过依赖注入的方式获取的对象执行方法  并且可以发现这个对象已经通过构造函数赋值了</p><p><img src="https://blog.chasingwind.top/1566485687916.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566485687916.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>特点</p><ol><li>优点 : 在<strong>获取bean对象的时候注入数据是必须的</strong>，否则创建对象会失败，因为已经没有默认构造函数（未提供）了</li><li>缺点 : 改变了bean对象的实例化方式，使我们在创建对象的时候，如果用不到这些数据，你也必须提供（在没有其他构造函数的情况下）</li></ol></li></ol></li><li><p>使用set方法提供（更常用）</p><ol><li><p>使用</p><blockquote><p>使用的标签 : <code>&lt;property&gt;</code></p><p>标签出现的位置 : <code>&lt;bean&gt;</code>标签的内部</p><p>便签的属性</p><blockquote><p>name : 需要设置的<strong>参数的属性名</strong></p><p>value : 用于给参数赋值，用于基本类型和String类型的数据</p><p>ref : 用于指定其他的bean类型，也就是在配置文件中配置过的bean</p></blockquote><hr><p>使用set方法为参数赋值</p><p><img src="https://blog.chasingwind.top/1566487816840.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566487816840.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置文件</p><p><code>&lt;property&gt;</code>的中name标签的值是<strong>属性值</strong></p><p><img src="https://blog.chasingwind.top/1566487849788.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566487849788.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试类</p><p><img src="https://blog.chasingwind.top/1566487909759.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566487909759.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>特点</p><ol><li>优势 : 创建对象时,可以直接使用默认构造函数 , 对参数的设置也没有要求</li><li>缺点 : 如果某个参数必须要有值, 这是无法保证的 </li></ol></li></ol></li><li><p>对于复杂类型（集合类型的注入）：只能选择上面的两种方式的一种</p><ol><li><p>通过set的方式进行注入</p><blockquote><p>类</p><p><img src="https://blog.chasingwind.top/1566489204104.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566489204104.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置文件</p><p>对于List类型(只有值,而不是键值对类型的)的数据的配置  :  包括 Array,List,Set</p><p><img src="https://blog.chasingwind.top/1566489353674.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566489353674.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果   正确的封装进去</p><p><img src="https://blog.chasingwind.top/1566489386565.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566489386565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>对于Map类型(键值对)的数据的封装  :  包括Map,Properties</p><p><img src="https://blog.chasingwind.top/1566489648991.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566489648991.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果</p><p><img src="https://blog.chasingwind.top/1566489664647.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566489664647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>结构相同的,标签可以互换</p><blockquote><p>List结构的 : Array,List,Set</p><p>Map结构的: Map,Properties</p><p>标签可以互换</p><p><img src="https://blog.chasingwind.top/1566489918392.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566489918392.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以我们只需要使用两组标签(list,map)就行了</p></blockquote></li></ol></li><li><p>使用注解提供(后面讲解)</p></li></ol></li></ol><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><ul><li><p>IoC可以<strong>通过配置文件</strong>来创建一个类的对象</p></li><li><p>依赖注入(DI)的作用是  :  Spring帮助我们管理对象的创建,<strong>那么对象对应的类中的成员变量（包括对其他类的对象的引用）的赋值就是通过DI的方式来进行初始化。</strong></p><blockquote><p> 比如  下一节的内容中</p><p>在Service类中</p><p><img src="https://blog.chasingwind.top/1566572662578.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566572662578.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置文件</p><p><img src="https://blog.chasingwind.top/1566572638344.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566572638344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可以看到 通过IoC使用getBean的方法创建accountService对象, 存入容器</p><p>而在Service类中  需要依赖Dao对象  那么就需要使用依赖注入(DI)</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的缓存以及注解开发</title>
      <link href="2019/08/17/Mybatis%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>2019/08/17/Mybatis%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>MyBatis中的延迟加载可以分为对一和对多的两种形式，在MyBatis的缓存中，又可以分为一级缓存和二级缓存。另外，使用注解的方式进行持久层的开发也是很便捷的。</p><a id="more"></a><h2 id="MyBatis中的延迟加载"><a href="#MyBatis中的延迟加载" class="headerlink" title="MyBatis中的延迟加载"></a>MyBatis中的延迟加载</h2><blockquote><p>考虑如下情景</p><p>当一个用户 他有100个账户信息的时候</p><ul><li>在查询这个用户信息的时候，需要把他的所有的账户信息同时查询出来吗（一对多）</li><li>在查询这个用户账户信息的时候，需要把这个用户信息查询出来吗（一对一）</li></ul><hr><ul><li>在查询用户信息的时候，并<strong>不需要</strong>将用户的所有的账户信息查询出来，浪费内存空间</li><li>在查询用户的账户信息的时候，<strong>需要</strong>将用户的信息一并查出来，因为单单一个账户的信息，无法获取更多的信息</li></ul></blockquote><ol><li>什么是延迟加载？<ul><li>在真正使用数据的时候才发起查询，不用的时候不查询。按需加载（懒加载）</li></ul></li><li>什么是立即加载？<ul><li>不管用不用，只要一调用方法，就马上发起查询</li></ul></li><li>我们该怎么进行选择呢?<ol><li>一对<strong>多</strong>，多对<strong>多</strong><ul><li>通常情况下 ，延迟加载</li></ul></li><li>多对<strong>一</strong>，一对<strong>一</strong><ul><li>通常情况下，立即加载(<strong>默认情况下就是立即加载</strong>)</li></ul></li></ol></li></ol><h3 id="使用Association实现延迟加载"><a href="#使用Association实现延迟加载" class="headerlink" title="使用Association实现延迟加载"></a>使用Association实现延迟加载</h3><ol><li><p>一对一延迟加载</p><blockquote><p>实现在查询账户信息的同时 查询用户的信息  <strong>懒加载的方式</strong></p></blockquote><blockquote><p>AccountDao</p><p><img src="https://blog.chasingwind.top/1566374184488.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566374184488.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>AccountDao.xml</p><p>注意到下面的select已经不是<code>select * from account left join user on account.uid = user.id</code> </p><p><img src="https://blog.chasingwind.top/1566374324268.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566374324268.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试类</p><p>注意到这个SQL语句  </p><p><img src="https://blog.chasingwind.top/1566374365638.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566374365638.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样<strong>并未实现懒加载</strong>   这也是默认的情况   </p><hr><p>实现懒加载</p><p>在SQLMapperConfig.xml文件中进行配置<code>lazyLoadingEnabled</code></p><p><img src="https://blog.chasingwind.top/1566374789954.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566374789954.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>执行测试类</p><p>先查询的是所有的订单   </p><p>当需要查询用户的时候  再根据用户的信息进行查询</p><p><img src="https://blog.chasingwind.top/1566374851066.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566374851066.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>总结</p><blockquote><p>总结以上实现懒加载的步骤</p><ol><li>需要在对应的.xml文件中关联需要懒加载的对象(比如,这里的账户信息延迟加载用户信息,在Account.xml中配置association延迟加载为User)</li><li>并且在association中配置延迟加载的时候执行的方法(select)</li><li>在全局配置文件中进行懒加载的配置</li></ol></blockquote></li></ol><h3 id="使用Collection实现延迟加载"><a href="#使用Collection实现延迟加载" class="headerlink" title="使用Collection实现延迟加载"></a>使用Collection实现延迟加载</h3><ol><li><p>一对多延迟加载</p><blockquote><p>查询用户的同时  查询用户的所有的账户    懒加载的方式</p></blockquote><blockquote><p>UserDao</p><p><img src="https://blog.chasingwind.top/1566376593656.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566376593656.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>UserDao.xml</p><p><img src="https://blog.chasingwind.top/1566376620839.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566376620839.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试类</p><p><img src="https://blog.chasingwind.top/1566377276567.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566377276567.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="MyBatis中的缓存"><a href="#MyBatis中的缓存" class="headerlink" title="MyBatis中的缓存"></a>MyBatis中的缓存</h2><ol><li>什么是缓存<ul><li>内存中的临时数据，MyBatis中的缓存就是将查询的数据存储在缓存中，下次再需要查询的时候直接在缓存中取，而不需要去和数据库进行交互</li></ul></li><li>为什么使用缓存<ul><li>减少和数据库的交互次数，提高执行效率</li></ul></li><li>什么样的数据适合用缓存？<ul><li>经常需要查询并且不经常改变</li><li>对<strong>实时性数据</strong>要求不高</li></ul></li><li>什么样的数据不适合用缓存？<ul><li>经常改变的数据</li><li>对实时性数据要求高，比如：银行汇率，抢购库存等等</li></ul></li></ol><h3 id="MyBatis中的一级缓存（默认使用）"><a href="#MyBatis中的一级缓存（默认使用）" class="headerlink" title="MyBatis中的一级缓存（默认使用）"></a>MyBatis中的一级缓存（默认使用）</h3><ul><li><p>它指的是Mybatis中SqlSession对象的缓存。当SqlSession对象消失时，MyBatis的一级缓存也就消失了。</p></li><li><p>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，MyBatis会先去SqlSession中查询是否有，有的话直接拿出来用。</p></li><li><p>实例</p><blockquote><p>查询同一个用户</p><p><img src="https://blog.chasingwind.top/1566379142441.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379142441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>两次查询只执行了一次SQL查询语句</p><p><img src="https://blog.chasingwind.top/1566379172214.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379172214.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>并且 查询得到的对象是同一个对象</p><p><img src="https://blog.chasingwind.top/1566379196050.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379196050.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>也就是说 第一次查询是从数据库中进行查询  第二次查询是从缓存中进行的查询</p></blockquote></li><li><p>缓存的清除</p><blockquote><p>当SqlSession消失之后,缓存会被清空</p><p><img src="https://blog.chasingwind.top/1566379480665.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379480665.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可以看到这里执行了两次SQL</p><p><img src="https://blog.chasingwind.top/1566379518944.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379518944.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>并且不是同一个对象了</p><p><img src="https://blog.chasingwind.top/1566379547399.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379547399.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>可以使用SqlSession的方法来清空缓存</p><blockquote><p><img src="https://blog.chasingwind.top/1566379679535.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379679535.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>当缓存中的数据在数据库中发生改变之后并且提交时候,缓存中的数据就会发生改变</p><blockquote><p><img src="https://blog.chasingwind.top/1566379851120.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566379851120.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>保存,删除,更新并且提交之后,一级缓存会被自动清空.从而保证数据的同步</p><p>再次查询的话,会执行SQL语句</p></blockquote></li></ul><h3 id="MyBatis中的二级缓存（手动开启）"><a href="#MyBatis中的二级缓存（手动开启）" class="headerlink" title="MyBatis中的二级缓存（手动开启）"></a>MyBatis中的二级缓存（手动开启）</h3><ul><li><p>它指的是Mybatis中SqlSessionFactory对象的缓存。</p></li><li><p>由同一个SqlSessionFactory对象创建的<strong>SqlSession共享其缓存。</strong></p></li><li><p>原理</p><blockquote><p><img src="https://blog.chasingwind.top/1566380649469.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566380649469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>同一个SqlSessionFactory下的SqlSession共享二级缓存</strong></p></blockquote></li><li><p>二级缓存的使用步骤</p><blockquote><p>在SqlMaperConfig.xml中配置使MyBatis框架支持二级缓存<code>cacheEnabled</code></p><p><img src="https://blog.chasingwind.top/1566380961844.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566380961844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566381054622.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566381054622.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在当前的映射文件(XxxDao.xml)中进行配置</p><p><img src="https://blog.chasingwind.top/1566381166686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566381166686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在当前的操作中(select,insert…标签)支持二级缓存</p><p><img src="https://blog.chasingwind.top/1566381205702.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566381205702.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1566382205311.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566382205311.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/1566382246754.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566382246754.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可见 第二次查询并没有执行SQL语句,而是从二级缓存中查询的</p><hr><p>但是   查询的并不是同一个对象</p><p><img src="https://blog.chasingwind.top/1566382295247.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566382295247.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>原因是  二级缓存中<strong>存放的是数据,不是对象</strong></p><p><strong>当用户去使用缓存中的这些数据的时候, MyBatis会将这些缓存的数据封装成一个对象</strong>,从而就有了上面的现象 <strong>两个相同的数据不是同一个对象</strong>,每次查询都重新将数据进行封装,成为一个新的对象</p></blockquote></li></ul><h2 id="MyBatis中的注解开发"><a href="#MyBatis中的注解开发" class="headerlink" title="MyBatis中的注解开发"></a>MyBatis中的注解开发</h2><h3 id="四个基础的注解的使用"><a href="#四个基础的注解的使用" class="headerlink" title="四个基础的注解的使用"></a>四个基础的注解的使用</h3><ol><li><p>环境搭建</p><blockquote><p>目录</p><p><img src="https://blog.chasingwind.top/1566399178393.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566399178393.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这次我们使用了数据库的外部配置文件</p><p><img src="https://blog.chasingwind.top/1566399253510.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566399253510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>主配置文件中</p><p><img src="https://blog.chasingwind.top/1566399304404.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566399304404.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>User实体类</p><p><img src="https://blog.chasingwind.top/1566399200532.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566399200532.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>UserDao</p><p>这里使用的是注解的形式</p><p><img src="https://blog.chasingwind.top/1566399327734.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566399327734.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试类  可以调用这个使用注解的方法</p><p><img src="https://blog.chasingwind.top/1566399360059.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566399360059.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>两种方式的比较</p><blockquote><p>上面只使用了注解，而没有使用映射配置文件  那么这两个都能实现相同的功能</p><p>两者比较  </p><p><img src="https://blog.chasingwind.top/1566399763265.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566399763265.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当既有注解，又有配置文件的时候，不管你用不用<strong>都会报错</strong>的</p></blockquote></li><li><p>@Insert注解的使用</p><blockquote><p><img src="https://blog.chasingwind.top/1566400344153.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400344153.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566400380637.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400380637.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566400393925.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400393925.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>@Update的使用</p><blockquote><p><img src="https://blog.chasingwind.top/1566400660655.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400660655.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566400668904.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400668904.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566400682660.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400682660.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>@Delete的使用</p><blockquote><p><img src="https://blog.chasingwind.top/1566400828822.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400828822.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566400840685.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400840685.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566400848696.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400848696.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>@Select的使用</p><blockquote><p><img src="https://blog.chasingwind.top/1566400875156.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400875156.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566400887262.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566400887262.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>复杂功能的实现</p><blockquote><p>模糊查询</p><p><img src="https://blog.chasingwind.top/1566401281585.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566401281585.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566401290044.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566401290044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>聚合函数</p><p><img src="https://blog.chasingwind.top/1566401411590.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566401411590.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566401425587.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566401425587.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="属性名和数据库列名对应"><a href="#属性名和数据库列名对应" class="headerlink" title="属性名和数据库列名对应"></a>属性名和数据库列名对应</h3><ul><li><p>当需要封装到的实体类的类名和数据库的列名不相同的时候</p><blockquote><p>使用<code>@Results</code>注解配置</p><p><img src="https://blog.chasingwind.top/1566401956903.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566401956903.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的写法只适用于一个方法上</p><hr><p>要想将这个配置作用在多注解上的话  需要使用id属性</p><p><img src="https://blog.chasingwind.top/1566402141128.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566402141128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在需要用的注解上配置<code>@ResultMap</code>  值就是刚才的id的值</p><p><img src="https://blog.chasingwind.top/1566402205469.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566402205469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="注解实现一对一查询"><a href="#注解实现一对一查询" class="headerlink" title="注解实现一对一查询"></a>注解实现一对一查询</h3><blockquote><p>一个账户对应一个用户</p></blockquote><blockquote><p>首先在主表Account中添加User的引用</p><p><img src="https://blog.chasingwind.top/1566406132211.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566406132211.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>从表User中的根据用户的Id查询用户的信息  将来需被调用的</p><p><img src="https://blog.chasingwind.top/1566405958343.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566405958343.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在从表中使用<strong>one</strong></p><p>这里从表中的column的值是作为从表中的那个查询方法的参数的 , </p><p>比如这里是根据 用户的id查询用户的信息  , 他的值是主表Account中的用户的id  也就是uid</p><p><img src="https://blog.chasingwind.top/1566405828535.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566405828535.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>实现了对用户的封装</p><p><img src="https://blog.chasingwind.top/1566405897569.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566405897569.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="注解实现一对多的查询"><a href="#注解实现一对多的查询" class="headerlink" title="注解实现一对多的查询"></a>注解实现一对多的查询</h3><blockquote><p>一个用户有多个账户</p></blockquote><blockquote><p>首先在主表User中添加从表Account的集合的引用</p><p><img src="https://blog.chasingwind.top/1566406310650.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566406310650.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Account中的FindAccountByUid的方法</p><p><img src="https://blog.chasingwind.top/1566406340093.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566406340093.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在从表中使用<strong>many</strong></p><p>还有一点就是这里使用的是延迟加载</p><p><img src="https://blog.chasingwind.top/1566407207718.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566407207718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1566407236024.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566407236024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="注解实现二级缓存"><a href="#注解实现二级缓存" class="headerlink" title="注解实现二级缓存"></a>注解实现二级缓存</h3><ul><li><p>一级缓存默认开启</p></li><li><p>二级缓存的开启</p><blockquote><p>在全局配置文件中SqlMapConfig.xml进行配置<code>cacheEnable</code> 为true  </p><p>其实不配置也可以 因为默认值就是true</p><p><img src="https://blog.chasingwind.top/1566407619857.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566407619857.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在XxxDao上开启二级缓存</p><p><img src="https://blog.chasingwind.top/1566407702048.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566407702048.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试</p><p><img src="https://blog.chasingwind.top/1566407999434.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566407999434.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以看到只执行了一次SQL语句</p><p><img src="https://blog.chasingwind.top/1566407964737.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566407964737.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis使用以及多表</title>
      <link href="2019/08/16/Mybatis%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%A4%9A%E8%A1%A8/"/>
      <url>2019/08/16/Mybatis%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%A4%9A%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>这里介绍了MyBatis中的连接池的种类以及事务,使用标签if,where,foreach实现动态SQL以及MyBatis中的多表查询的操作</p><a id="more"></a><h2 id="MyBatis中的连接池以及事务"><a href="#MyBatis中的连接池以及事务" class="headerlink" title="MyBatis中的连接池以及事务"></a>MyBatis中的连接池以及事务</h2><ol><li><p>MyBatis连接池的3种配置方式</p><blockquote><p><img src="https://blog.chasingwind.top/1566227662983.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566227662983.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>type属性值有3种</p><ol><li>POOLED     使用连接池，每次从连接池中获取连接。连接池其实就是一个集合，这个集合需要是<strong>线程安全</strong>的，以防不同的线程拿到同一个连接，而且还需要实现队列的<strong>先进先出</strong>的特性（底层代码）</li><li>UNPOOLED 不使用连接池，而是使用普通的连接，每次使用都需要重新创建连接，使用结束销毁连接</li><li>JNDI     采用<strong>服务器提供的JNDI技术实现</strong>，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。<pre><code>          注意：如果不是web或者maven的war工程，是不能使用的                我们课程中使用的是tomcat服务器，采用连接池就是dbcp连接池。</code></pre></li></ol><hr><p>查看源码可以知道</p><p>PooledDataSource和UnPooledDataSource都实现了DataSource接口</p></blockquote></li><li><p>MyBatis中的事务</p><ul><li><p>通过SqlSession对象的commit方法和rollback方法实现事务的提交和回滚</p><blockquote><p><img src="https://blog.chasingwind.top/1566229189718.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566229189718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>默认的是手动提交</strong> 我们可以设置为自动提交</p><blockquote><p>可见  未设置之前是false  也就是手动提交的方式</p><p><img src="https://blog.chasingwind.top/1566229265634.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566229265634.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在openSession参数中设置自动提交</p><p><img src="https://blog.chasingwind.top/1566229307051.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566229307051.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><ol><li><p>if标签的使用</p><ol><li><p>首先是创建方法</p><blockquote><p><img src="https://blog.chasingwind.top/1566231187262.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566231187262.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置这个方法</p><blockquote><p><img src="https://blog.chasingwind.top/1566231564579.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566231564579.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>如果if标签的条件成立的话   就会将条件拼接到SQL语句中</p></blockquote></li><li><p>测试类</p><blockquote><p>只有姓名的时候的查询</p><p><img src="https://blog.chasingwind.top/1566231646898.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566231646898.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当加上查询的条件性别的时候</p><p><img src="https://blog.chasingwind.top/1566231807459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566231807459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>从而实现了SQL语句的拼接</p></blockquote></li></ol></li><li><p>where标签的使用</p><blockquote><p>不适用恒成立的where 1 = 1</p><p>而是将if标签放在where标签中</p><p><img src="https://blog.chasingwind.top/1566232075630.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566232075630.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>foreach和sql标签</p><ol><li><p>foreach标签</p><blockquote><p>当我们有这样的需求的时候</p><p><img src="https://blog.chasingwind.top/1566266894786.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566266894786.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用MaBatis来实现</p><p>UserDao接口</p><p><img src="https://blog.chasingwind.top/1566267411298.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566267411298.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>封装的UserInfo类</p><p><img src="https://blog.chasingwind.top/1566267639166.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566267639166.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>UserDao.xml</p><p>这里的if标签中的test中的Ids就是传入的测试类中的Ids集合</p><p><img src="https://blog.chasingwind.top/1566267611686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566267611686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试类</p><p><img src="https://blog.chasingwind.top/1566267707446.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566267707446.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>sql标签</p><blockquote><p>用于抽取重复放入语句</p><p><img src="https://blog.chasingwind.top/1566267927945.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566267927945.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="MyBatis中的多表"><a href="#MyBatis中的多表" class="headerlink" title="MyBatis中的多表"></a>MyBatis中的多表</h2><ol><li><p>表之间的关系</p><ol><li>一对多</li><li>多对一</li><li>一对一</li><li>多对多</li></ol></li><li><p>MyBatis中的多表查询</p><p>需求: </p><blockquote><p>当我们查询用户时，可以同时得到用户下所包含的账户信息</p><p>当我们查询账户时，可以同时得到账户的所属用户信息</p></blockquote><ol><li><p>基础环境的准备</p><blockquote><p>建立用户表,账户表</p><p><img src="https://blog.chasingwind.top/1566285362784.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566285362784.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>建立用户实体类,账户实体类</p><p><img src="https://blog.chasingwind.top/1566285385104.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566285385104.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566285398559.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566285398559.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>建立两个配置文件UserDao.xml以及AccountDao.xml</p><p><img src="https://blog.chasingwind.top/1566285458385.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566285458385.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566285476724.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566285476724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>SqlMapperConfig.xml中进行了别名的配置</p><p><img src="https://blog.chasingwind.top/1566285531357.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566285531357.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>一对一</p><blockquote><p>一个账户只能对应一个用户</p><p>在获取用户账户信息的同时获取此账户的用户信息</p><p>SQL中查询语句是这样的</p><p><img src="https://blog.chasingwind.top/1566286292730.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566286292730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol><li><p>使用子类来封装信息(不常用)</p><blockquote><p>我们可以通过一个Account账户类的子类来封装账户信息以及我们需要的用户的信息</p><p>AccountUser类</p><p><img src="https://blog.chasingwind.top/1566287339750.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566287339750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>toString方法</p><p><img src="https://blog.chasingwind.top/1566287456390.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566287456390.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>AccountDao接口</p><p><img src="https://blog.chasingwind.top/1566287364302.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566287364302.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>配置</p><p><img src="https://blog.chasingwind.top/1566287388364.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566287388364.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>测试类</p><p><img src="https://blog.chasingwind.top/1566287407836.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566287407836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/1566287433469.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566287433469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>将User封装在Account中</p><blockquote><p>主表实体类中含有从表实体类的引用</p><p>Account类</p><p><img src="https://blog.chasingwind.top/1566295728083.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566295728083.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置AccountDao.xml</p><p><img src="https://blog.chasingwind.top/1566296158345.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566296158345.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试类</p><p><img src="https://blog.chasingwind.top/1566296181667.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566296181667.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>一对多</p><blockquote><p>主表实体类应该包含<strong>从表实体的集合引用</strong></p><p>一个用户有多个账户信息</p><p>在获取用户信息的时候获取用户的所有的账户信息</p></blockquote><ol><li><p>在主表中添加从表集合的引用</p><blockquote><p><img src="https://blog.chasingwind.top/1566304748620.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566304748620.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在主表的接口的配置文件中进行配置</p><blockquote><p><img src="https://blog.chasingwind.top/1566304893856.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566304893856.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这里的查询使用的是左外连接</p><p>因为有的用户没有账户信息  但是还是需要显示用户的信息的</p></blockquote></li><li><p>测试类</p><blockquote><p><img src="https://blog.chasingwind.top/1566304980716.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566304980716.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>多对多</p><blockquote><p>一个用户可以有多种角色, 比如,学生,顾客….</p><p>而每种角色可以有多个用户</p></blockquote><ol><li><p>基础环境的准备</p><blockquote><p>为了让用户表和角色表具有多对多的关系, 需要借助中间表来实现。</p><p>中间表中包含各自的主键<br><img src="https://blog.chasingwind.top/1566307256589.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566307256589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>建立对用的实体类User和Role(用户的角色)</p><p><img src="https://blog.chasingwind.top/1566308336389.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566308336389.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1566308397468.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566308397468.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>查询所有的角色</strong> ，同时获取角色对用的用户的信息</p><blockquote><p>SQL查询语句  需要两次左外连接</p><p>第一次</p><p><img src="https://blog.chasingwind.top/1566307635820.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566307635820.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第二次</p><p><img src="https://blog.chasingwind.top/1566307711650.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566307711650.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>去掉user_role表</p><p><img src="https://blog.chasingwind.top/1566307794090.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566307794090.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>进行配置</p><p>在Roledao.xml中添加引用</p><p><img src="https://blog.chasingwind.top/1566308473580.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566308473580.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>更正  上面 从表中的非主键 应该是result标签</p><hr><p>测试类</p><p><img src="https://blog.chasingwind.top/1566308520818.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566308520818.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查询所有的用户 , 同时获取用户的角色</p><blockquote><p>首先是SQL语句</p><p><img src="https://blog.chasingwind.top/1566309499121.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566309499121.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>进行UserDao.xml的配置</p><p><img src="https://blog.chasingwind.top/1566309612328.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566309612328.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>测试类</p><p><img src="https://blog.chasingwind.top/1566309644730.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566309644730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis基本使用</title>
      <link href="2019/08/15/Mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2019/08/15/Mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这里介绍了在MyBatis使用代理的情况下对于数据库的CRUD的操作以及常用的输入类型以及输出类型的结果集的介绍。</p><a id="more"></a><h2 id="MyBatis的CRUD"><a href="#MyBatis的CRUD" class="headerlink" title="MyBatis的CRUD"></a>MyBatis的CRUD</h2><ol><li><p>首先进行Test测试类的优化</p><blockquote><p>将初始化的代码以及销毁的代码提取出来成为一个方法</p><p><img src="https://blog.chasingwind.top/1566202093305.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566202093305.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>MyBatis的保存操作</p><ol><li><p>在UserDao接口中进行方法的定义</p><blockquote><p><img src="https://blog.chasingwind.top/1566203148186.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566203148186.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在UserDao.xml文件中进行配置</p><blockquote><p>使用的是insert标签</p><p>这里的参数类型指的是方法传入的参数类型</p><p>另外values中需要对应User类中的<strong>属性名</strong></p><p><img src="https://blog.chasingwind.top/1566203223216.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566203223216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>执行Test测试的方法   查看控制台日志</p><blockquote><p><img src="https://blog.chasingwind.top/1566203975109.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566203975109.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>控制台日志</p><p><img src="https://blog.chasingwind.top/1566204079181.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566204079181.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>也就是说 当前的事务是手动提交事务</p><p>去查询数据库  里面并没有进行用户数据的存储</p><p><img src="https://blog.chasingwind.top/1566204140994.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566204140994.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>设置事务的提交方式为自动提交</p><blockquote><p><img src="https://blog.chasingwind.top/1566204221140.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566204221140.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>控制台日志</p><p><img src="https://blog.chasingwind.top/1566204263862.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566204263862.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>查询数据库</p><p><img src="https://blog.chasingwind.top/1566204288640.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566204288640.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>MyBatis中的更新操作</p><ol><li><p>在UserDao中添加</p><blockquote><p><img src="https://blog.chasingwind.top/1566205025112.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205025112.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在UserDao.xml中进行配置</p><blockquote><p>使用update标签</p><p><img src="https://blog.chasingwind.top/1566205072378.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205072378.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试类</p><blockquote><p>这里已经将事务的提交放在了After中</p><p><img src="https://blog.chasingwind.top/1566205165306.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205165306.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>因为这里是根据用户的id进行查询   所以需要设置查询用户的id</p><p><img src="https://blog.chasingwind.top/1566205307957.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205307957.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查询数据库</p><blockquote><p><img src="https://blog.chasingwind.top/1566205323225.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205323225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>MyBatis中的删除操作</p><ol><li><p>UserDao接口中的方法</p><blockquote><p>根据用户的id进行删除</p><p><img src="https://blog.chasingwind.top/1566205674122.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205674122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置UserDao.xml文件</p><blockquote><p>在这里的parameterType  可以填写<strong>Integer/integer/INT/int/java.lang.integer任意一个都可以</strong></p><p>还有一点就是 因为deleteUser方法的参数只有一个 所以在SQL语句中**#{可以任意填写,只起占位的作用}**</p><p><img src="https://blog.chasingwind.top/1566205725060.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205725060.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>执行Test测试</p><blockquote><p><img src="https://blog.chasingwind.top/1566205915444.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205915444.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查询数据库</p><blockquote><p><img src="https://blog.chasingwind.top/1566205948280.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566205948280.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>MyBatis中的查询一个操作</p><ol><li><p>UserDao接口中的方法</p><blockquote><p>根据用户的id进行查询  返回一个User对象</p><p><img src="https://blog.chasingwind.top/1566206535469.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566206535469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在UserDao.xml中进行配置</p><blockquote><p>这里不仅需要参数的类型 , 还需要返回值类型</p><p><img src="https://blog.chasingwind.top/1566206598424.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566206598424.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行测试类</p><blockquote><p><img src="https://blog.chasingwind.top/1566206812206.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566206812206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/1566206840556.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566206840556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>MyBatis中的模糊查询操作</p><ol><li><p>UserDao接口中的方法</p><blockquote><p>根据用户名查询 姓名中含有王的用户</p><p><img src="https://blog.chasingwind.top/1566207150442.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566207150442.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在UserDao.xml中进行配置</p><blockquote><p>可见 在这里并没有实现模糊查询的%%</p><p><img src="https://blog.chasingwind.top/1566207193404.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566207193404.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行测试类</p><blockquote><p>正在测试类中需要完成参数的传递  需要加上%%完成模糊查询的功能</p><p><img src="https://blog.chasingwind.top/1566207257469.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566207257469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/1566207283883.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566207283883.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>模糊查询的另一种方式**(了解)**以及两者的区别</p><blockquote><p>在UserDao.xml中的配置</p><p><img src="https://blog.chasingwind.top/1566208142472.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566208142472.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>以及在测试类中的写法  这里不需要用%</p><p><img src="https://blog.chasingwind.top/1566208172848.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566208172848.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><hr><blockquote><p>区别就是</p><p>第一种查询语句</p><p><img src="https://blog.chasingwind.top/1566208301487.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566208301487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第二种的查询语句</p><p><img src="https://blog.chasingwind.top/1566208249212.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566208249212.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见  </p><p>第一种方式实现的查询语句是使用的PreparedStatement</p><p>第二种使用的是Statement的方式  会<strong>出现SQL注入的问题</strong></p></blockquote></li></ol></li><li><p>MyBatis中的聚合函数的查询</p><ol><li><p>UserDao接口中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1566207788998.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566207788998.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在UserDao.xml中进行配置</p><blockquote><p><img src="https://blog.chasingwind.top/1566207815754.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566207815754.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>运行测试类</p><blockquote><p><img src="https://blog.chasingwind.top/1566207833217.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566207833217.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="MyBatis中的参数以及结果集"><a href="#MyBatis中的参数以及结果集" class="headerlink" title="MyBatis中的参数以及结果集"></a>MyBatis中的参数以及结果集</h2><ol><li><p>输入类型(parameterType)</p><blockquote><p>基本类型 ,Int,String….</p><p>JavaBean类型, User…</p><p>JavaBean的包装类, …</p></blockquote><blockquote><p>OGNL表达式：</p><pre><code>Object Graphic Navigation Language对象    图    导航       语言它是通过对象的属性名来获取数据。在写法上把get给省略了。</code></pre><p>比如：我们获取用户的名称</p><pre><code>类中的写法：user.getUsername();OGNL表达式写法：user.username</code></pre><p>mybatis中为什么能直接写username,而不用user.呢：</p><pre><code>因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名</code></pre><p><img src="https://blog.chasingwind.top/1566289321237.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566289321237.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>输出类型(resultType)</p><blockquote><p>简单类型</p><p>JavaBean对象</p><p>JavaBean对象的集合</p></blockquote><blockquote><p>当数据库中的列名与实体类中的属性名不相同的时候</p><ol><li><p>可以在SQL语句中将查询的列名起别名</p></li><li><p>进行配置resultMap 使得数据库中的列名和实体类的属性名相对应</p><blockquote><p><img src="https://blog.chasingwind.top/1566290401387.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566290401387.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></blockquote></li><li><p>解决SQL语句中的类名与封装的类中的属性名不一致</p><ul><li>resultMap结果类型</li><li>在SQL语句中将查询的列起别名</li></ul></li></ol><h2 id="标签的使用"><a href="#标签的使用" class="headerlink" title="标签的使用"></a>标签的使用</h2><ol><li><p>typeAliases</p><blockquote><p><strong>这个标签要放在<code>&lt;environments&gt;</code>标签上方</strong></p><p>用于指定domain包下的类  用来起别名的  </p><p>package标签用来<strong>指定要配置别名的包</strong>,当指定之后,该包下的实体类都会注册别名,并且<strong>类名就是别名</strong>,不区分大小写</p><p><img src="https://blog.chasingwind.top/1566287912728.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566287912728.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>package</p><blockquote><p>除了上面的package , package还有一个常用的地方就是</p><p>用于指定<strong>Dao接口所在的包</strong>  指定之后 就不需要再写mapper,  resources以及class了</p><p><img src="https://blog.chasingwind.top/1566288172568.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566288172568.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>以前</p><p><img src="https://blog.chasingwind.top/1566288317589.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566288317589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>现在</p><p><img src="https://blog.chasingwind.top/1566288338560.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566288338560.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis入门</title>
      <link href="2019/08/14/Mybatis%E5%85%A5%E9%97%A8/"/>
      <url>2019/08/14/Mybatis%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录</p><a id="more"></a><h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><ol><li><p>什么是框架 ? </p><ul><li>框架（Framework）是<strong>整个或部分系统的可重用设计</strong>，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是<strong>可被应用开发者定制的应用骨架</strong>。前者是从应用方面而后者是从目的方面给出的定义。</li><li>它是我们软件开发中的一套解决方案，不同的框架解决不同的问题。框架中封装了很多的细节，使开发者可以使用极简的方式实现功能，大大提高开发效率</li><li>简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。</li></ul></li><li><p>三层架构</p><ol><li><p>表现层：用户展示数据</p></li><li><p>业务层：处理业务需求</p></li><li><p>持久层：和数据库交互</p><blockquote><p>各层对应的框架</p><p><img src="https://blog.chasingwind.top/1565841760330.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565841760330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>持久层技术解决方案</p><ol><li><p>JDBC技术</p><p>Connection</p><p>PreparedStatement</p><p>ResultSet</p></li><li><p>Spring的JdbcTemplate：Spring中对JDBC的简单封装</p></li><li><p>Apache的DBUtils：它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装</p></li></ol><hr><p>但是这些<strong>都不是框架</strong>，因为这些只是对一些使用的封装，并没有一整套完整的解决方案</p><ul><li><p>JDBC是规范</p></li><li><p>Spring的JdbcTemplate和Apache的DBUtils都只是工具类</p></li></ul></li><li><p>回顾之前我们的JDBC中的问题</p><ol><li>数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</li><li>SQL语句在代码中硬编码，造成代码不易维护，实际应用 SQL 变化的可能较大，SQL 变动需要改变 Java 代码。</li><li>使用 preparedStatement 向占有位符号传参数存在硬编码，因为 SQL 语句的 where 条件不一定，可能多也可能少，修改 SQL 还要修改代码，系统不易维护。</li><li>对结果集解析存在硬编码（查询列名），SQL 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 JavaBean对象解析比较方便。</li></ol></li><li><p>MyBatis是一个优秀的<strong>基于 Java 的持久层框架</strong></p><ul><li>它内部封装了 JDBC，使开发者<strong>只需要关注 SQL语句本身</strong>， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程，他使用ORM思想实现对结果集的封装</li><li>MyBatis <strong>通过 xml 或注解的方式将要执行的各种 statement 配置起来</strong>，并通过 Java 对象和 statement 中SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射为 Java 对象并返回。</li><li>采用 <strong>ORM 思想</strong>解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC API 底层访问细节，使我们不用与 JDBC API 打交道，就可以完成对数据库的持久化操作。</li></ul><hr><p>ORM ：Object Relational Mappging 对象关系映射</p><p>功能：把<strong>数据库中的表和实体类中的属性对应起来</strong>，让我们可以操作实体类就实现操作数据库表的功能</p></li></ol><h2 id="Mybatis框架快速入门"><a href="#Mybatis框架快速入门" class="headerlink" title="Mybatis框架快速入门"></a>Mybatis框架快速入门</h2><h3 id="MyBatis环境搭建"><a href="#MyBatis环境搭建" class="headerlink" title="MyBatis环境搭建"></a>MyBatis环境搭建</h3><ol><li><p>创建一个Java项目（非JavaWeb项目）</p></li><li><p>创建数据库环境</p></li><li><p>项目的pom.xml的配置</p><blockquote><p><img src="https://blog.chasingwind.top/1565844296492.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565844296492.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>新建实体类以及接口</p><blockquote><p>实体类User</p><p><img src="https://blog.chasingwind.top/1565846476556.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565846476556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>接口UserDao</p><p><img src="https://blog.chasingwind.top/1565846494270.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565846494270.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在resources目录下创建<code>.xml</code>文件，一般习惯命名为<code>SqlMapConfig.xml</code></p><blockquote><p>加入约束</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration          PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;          &quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</code></pre><hr><p>对Mybatis的约束</p><p><img src="https://blog.chasingwind.top/1565845979301.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565845979301.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在对每个Dao的配置中 需要指定每个Dao配置文件的路径</p></blockquote><blockquote><p>下面是对每个Dao的配置 首先在对应的路径下创建文件</p><p><img src="https://blog.chasingwind.top/1565846194779.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565846194779.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>首先  引入约束  </p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper          PUBLIC &quot;-//MyBatis.org//DTD Mapper 3.0//EN&quot;          &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; </code></pre><p><img src="https://blog.chasingwind.top/1565846630384.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565846630384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>环境搭建的注意事项</p><blockquote><p>创建UserDao.xml 和 UserDao.java时名称是为了和我们之前的知识保持一致。</p><pre><code>        在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper        所以：UserDao 和 UserMapper是一样的</code></pre></blockquote><blockquote><p>在idea中创建目录的时候，它和包是不一样的</p><pre><code>        包(Package)在创建时：com.itheima.dao它是三级结构        目录(Directory)在创建时：com.itheima.dao是一级目录</code></pre></blockquote><blockquote><p>MyBatis的映射配置文件位置必须和Dao接口的<strong>包结构相同</strong></p><p>也就是说</p><p><img src="https://blog.chasingwind.top/1565848220182.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565848220182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>映射配置文件的mapper标签namespace属性的取值必须是Dao接口的全限定类名</p><p><img src="https://blog.chasingwind.top/1565848318733.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565848318733.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>映射配置文件的操作配置（select,insert,update等等），id属性的取值必须是Dao接口的方法名</p><p><img src="https://blog.chasingwind.top/1565848373590.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565848373590.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><hr><p>当我们遵守后面3条的时候!!  我们在开发中就<strong>不需要写Dao的实现类</strong>了!!</p></li></ol><h3 id="MyBatis入门案例"><a href="#MyBatis入门案例" class="headerlink" title="MyBatis入门案例"></a>MyBatis入门案例</h3><p>MyBatis的入门案例</p><ol><li><p>导入log4j.properties配置文件到resources目录下 并且创建测试类</p><blockquote><p><img src="https://blog.chasingwind.top/1565848620666.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565848620666.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写测试类  因为遵循了上面的规则 就不需要写接口的实现类了</p><blockquote><p><img src="https://blog.chasingwind.top/1565932030509.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565932030509.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>这里还需要进行返回对象的设置</p><blockquote><p>返回类型表示 数据库查询完之后需要将结果封装的类型</p><p>需要在UserDao.xml文件中进行配置 <strong>封装的全类名</strong></p><p><img src="https://blog.chasingwind.top/1565932314029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565932314029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>结果</p><blockquote><p><img src="https://blog.chasingwind.top/1565932387934.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565932387934.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="MyBatis入门案例分析"><a href="#MyBatis入门案例分析" class="headerlink" title="MyBatis入门案例分析"></a>MyBatis入门案例分析</h3><ol><li><p>读取配置文件</p><blockquote><p>在上面我们使用的是相对路径 /src/java/main/cccc.xml</p><p>其实在开发中更常用的是</p><p>第一个 : 使用类加载器 , 但是只能读取类路径的配置文件</p><p>第二个 : 使用ServletContext对象的getRealPath()</p></blockquote></li><li><p>使用SqlSessionFactory创建工厂</p><blockquote><p>创建工厂MyBatis使用了<strong>构建者模式</strong></p><p>构建者模式: 把对象的创建细节隐藏 , 使用者直接调用方法获取对象</p></blockquote></li><li><p>使用工厂生产SqlSession对象</p><blockquote><p>生产SqlSession使用了工厂模式</p><p>优势 : 解耦</p></blockquote></li><li><p>使用SqlSession创建Dao接口的代理对象</p><blockquote><p>创建Dao接口实现类使用了代理</p><p>优势 :  不修改源码的基础上对已有方法进行增强</p></blockquote></li></ol><h3 id="MyBatis基于注解的方式"><a href="#MyBatis基于注解的方式" class="headerlink" title="MyBatis基于注解的方式"></a>MyBatis基于注解的方式</h3><ol><li><p>删除UserDao.xml文件 , 在Dao接口的方法上使用@Select()注解, 并且指定SQL语句</p><blockquote><p><img src="https://blog.chasingwind.top/1565934290167.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565934290167.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在SQLMapConfig.xml文件中进行mapper配置的时候，使用class属性指定Dao接口的<strong>全限定类名</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1565934370642.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565934370642.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><hr><p>在MyBatis中也是可以通过实现接口来达到这样的结果的  但是比较繁琐</p><p>其实在MyBatis中是通过代理方式来找到Dao的方法的 是<strong>通过namespace和id来唯一确定这个SQL语句的</strong></p><p><img src="https://blog.chasingwind.top/1565934533020.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565934533020.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><h2 id="自定义MyBatis框架"><a href="#自定义MyBatis框架" class="headerlink" title="自定义MyBatis框架"></a>自定义MyBatis框架</h2><p>经过分析，MyBatis在使用代理Dao的方式实现findAll方法的时候做了什么事？</p><blockquote><p>第一：创建代理对象</p><p>第二：在代理对象中调用selectList方法</p></blockquote><ol><li><p>MyBatis框架执行过程的分析</p><blockquote><p><img src="https://blog.chasingwind.top/1566183477761.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566183477761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><strong>读取配置文件</strong></p><p>SQLMapConfig.xml文件  有了这些配置 可以<strong>创建Connection对象</strong></p><p><img src="https://blog.chasingwind.top/1565937201282.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565937201282.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>SqlMapConfig.xml中的 <code>&lt;mappers&gt;</code>    有了这个就可以<strong>映射配置信息</strong></p><p><img src="https://blog.chasingwind.top/1565937309644.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565937309644.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>UserDao.xml   (XML的方式)有了这个就可以执行SQL语句, 就可以获取PreparedStatement  而且还封装了返回值封装的类型的全限定类名</p><p><img src="https://blog.chasingwind.top/1565937370063.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565937370063.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><strong>FindAll()方法的执行过程</strong></p><p><img src="https://blog.chasingwind.top/1565938274231.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565938274231.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上图中的Mapper中封装的是<strong>键</strong>是全限定类名以及对应的<strong>执行的SQL语句</strong>以及<strong>执行的结果封装的类名</strong></p><p>这样在以后还需要添加其他的SQL语句以及对应的类名的时候就比较方便通用</p><hr><p><strong>selectList代理方法的增强</strong>  需要我们自己实现</p><p><img src="https://blog.chasingwind.top/1565938777565.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565938777565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行自定义方法的实现(XML的方式)</p><ul><li><p>在实现的过程中，我们需要关注的就是</p><ol><li>如何创建代理对象，使用这些设计模式带来的优点</li><li>调用之间的组合关系</li></ol></li><li><p>首先，分析在入门案例中的代码设计的类与接口</p><blockquote><ol><li>class Resources</li><li>class SqlSessionFactoryBuilder</li><li>interface SqlSessionFactory</li><li>interface SqlSession</li></ol></blockquote></li><li><p>进行自定义的实现</p><ol><li><p>首先进行项目的创建, 并删除pom.xml文件中的MyBatis依赖</p><blockquote><p>此时的Test中由于缺少对应的类以及接口 会报错  </p><p><img src="https://blog.chasingwind.top/1566112444098.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566112444098.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建相应的类以及接口</p><ol><li><p>类Resources以及其中的方法</p><blockquote><p><img src="https://blog.chasingwind.top/1566112736742.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566112736742.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建类SqlSessionFactoryBuilder以及其中的方法build</p><blockquote><p><img src="https://blog.chasingwind.top/1566112966631.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566112966631.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建接口SqlSessionFactory</p><blockquote><p><img src="https://blog.chasingwind.top/1566113139927.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566113139927.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建接口SqlSession以及接口中的方法getMapper和close</p><blockquote><p><img src="https://blog.chasingwind.top/1566113452712.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566113452712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>到此为止 ,  Test中已经不会报错了</p><blockquote><p>引入对应的创建的类以及接口</p><p><img src="https://blog.chasingwind.top/1566113549208.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566113549208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>实现创建的类以及接口中的具体实现</p><ol><li><p>准备工作  读取配置文件以及修改工具类</p><blockquote><p>此时需要读取XML文件</p><p>此时已经不需要对应的 MyBatis中的约束文件了</p><p>需要将对应的约束删除</p><p>UserDao.xml</p><p><img src="https://blog.chasingwind.top/1566113888672.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566113888672.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>SqlMapConfig.xml</p><p><img src="https://blog.chasingwind.top/1566113923367.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566113923367.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>要对XML文件进行解析  需要使用工具类XMLConfigBuilder</p><p>导入并进行修改    根据其中的错误进行修改</p><ol><li><p>导入dom4j的坐标依赖以及jaxen坐标</p></li><li><p>创建Configuration配置类</p><blockquote><p><img src="https://blog.chasingwind.top/1566119878170.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566119878170.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Mapper类</p><blockquote><p><img src="https://blog.chasingwind.top/1566117053976.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566117053976.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>这个时候  再将工具类中的导包进行注释以及将注解的方式进行注释  就不再报错了</p></li></ol></blockquote></li><li><p>实现SqlSessionFactoryBuilder的build方法</p><blockquote><p>构建者 需要返回一个工厂  就需要实现创建工厂的实现类</p><p><img src="https://blog.chasingwind.top/1566118483974.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566118483974.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建SqlSessionFactory工厂的实现类</p><blockquote><p>工厂的实现类中的openSession方法  需要返回一个工厂生产的对象</p><p><img src="https://blog.chasingwind.top/1566118502171.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566118502171.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建SqlSession对象的实现类</p><blockquote><p>在SqlSessionImpl中实现对应的方法</p><p><img src="https://blog.chasingwind.top/1566118583649.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566118583649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><hr><p>以上 就将我们的各种类联系起来了</p><p>首先 , 我们读取配置文件使用到了Resources类</p><p>然后 , 将配置文件的信息交给构建者SqlSessionFactoryBuilder </p><p>然后 , 构建者根据信息使用工具类XMLConfigBuilder创建SqlSessionFactory工厂对象</p><p>然后 , 工厂对象SqlSessionFactory中的openSession方法给我们提供了创建SqlSession对象方法</p><p>最后 , 我们需要做的就是在SqlSession对象session中实现创建代理对象以及执行SQL语句的方法并且实现close方法</p></li><li><p>实现具体的SqlSession中的方法</p><blockquote><p>在实现类中  实现接口中的方法</p><p><img src="https://blog.chasingwind.top/1566138122575.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566138122575.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>在MapperProxy类中对方法进行增强</p><p>这里invoke方法中主要是  获取mappers中存储的方法名以此作为键来获取对应的值 值中存储有SQL语句以及需要封装到的对应的类名</p><p><img src="https://blog.chasingwind.top/1566138169811.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566138169811.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>使用已经提供好的工具  来实现selectList方法</p><p><img src="https://blog.chasingwind.top/1566138468984.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566138468984.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>DataSourceUtil工具类  用来获取连接</p><p><img src="https://blog.chasingwind.top/1566138514431.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566138514431.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><hr><ol><li><p>我们需要的是查询所有findAll()的方法, 而这个功能在Exeuctor工具类中实现</p></li><li><p>在创建MapperProxy工具类调用这个Exeuctor工具类中的selectList方法</p></li><li><p>创建代理对象的时候实现MapperProxy工具类对方法进行增强(这里是指调用selectList方法)</p></li><li><p>在MapperProxy类中存储的有执行的SQL语句以及封装的结果, 这些内容都在配置文件中</p></li><li><p>然后就是读取配置文件, 工具类XMLConfigureBuilder将读取到的结果存储封装成Configuration类对象 , Configuration中存储的有连接数据库的信息以及执行的SQL的信息封装成的map</p><hr><p>总的来说就是</p><ol><li>创建代理对象</li><li>执行查询所有</li></ol></li></ol></li></ol></li></ul></li><li><p>自定义实现(注解的方式)</p><ol><li><p>配置mapper中的属性为class</p><blockquote><p><img src="https://blog.chasingwind.top/1566143180768.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566143180768.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在UserDao上进行注解的设置</p><blockquote><p><img src="https://blog.chasingwind.top/1566143218674.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566143218674.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建@interface</p><blockquote><p><img src="https://blog.chasingwind.top/1566143256250.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566143256250.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>结束</p></li></ol></li><li><p>总的来说, 过程是这样的</p><blockquote><p><img src="https://blog.chasingwind.top/1566144850665.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566144850665.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>这里向看一下这个解析XML的类  虽然不是掌握的重点 但是却可以清晰的直到是如何获取通过配置文件获取SQL语句以封装的实体类的</p><blockquote><p><img src="https://blog.chasingwind.top/1566143624014.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1566143624014.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境部署以及Nginx</title>
      <link href="2019/08/12/Linux%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8ANginx/"/>
      <url>2019/08/12/Linux%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8ANginx/</url>
      
        <content type="html"><![CDATA[<p>本篇讲述了在Linux上部署JDK,MySQL，Tomcat以及Nginx，并在服务器上发布Web项目。此外，还会对于Ngix有一个基本的介绍以及如何使用等等。</p><a id="more"></a><h2 id="Linux上的项目环境搭建"><a href="#Linux上的项目环境搭建" class="headerlink" title="Linux上的项目环境搭建"></a>Linux上的项目环境搭建</h2><ul><li>为了让项目在服务器上运行，就需要在服务器上安装项目运行的环境，包括JDK，Tomcat，MySQL等等</li></ul><h2 id="Linux上安装JDK"><a href="#Linux上安装JDK" class="headerlink" title="Linux上安装JDK"></a>Linux上安装JDK</h2><ol><li><p>在我们安装CentOS的时候，已经帮我们安装好了开源的JDK，OpenJDK，但是并不是我们想要的版本</p><blockquote><p><img src="https://blog.chasingwind.top/1565617647616.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565617647616.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>卸载OpenJDK</p><ol><li><p>执行<code>rpm -qa | grep java</code>  :  查询到系统中与Java有关的安装包</p><blockquote><p>Linux rpm 命令用于<strong>管理套件。</strong></p><p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序</p><p>rpm 命令有点类似于Windows中的控制面板 ,  对安装的软件进行管理</p><ul><li>-q 　使用询问模式，当遇到任何问题时，rpm指令会先询问用户。</li><li>-a 　查询所有套件。</li><li>-e      &lt;套件档&gt;或–erase&lt;套件档&gt; 　删除指定的套件。</li><li>–nodeps 　不验证套件档的相互关联性。</li></ul><hr><p><img src="https://blog.chasingwind.top/1565618079560.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565618079560.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>执行<code>rpm -e --nodeps xxxxx</code>  :  卸载xxxx</p><blockquote><p><img src="https://blog.chasingwind.top/1565618423662.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565618423662.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建JDK安装路径</p><ol><li><p>创建JDK安装的目录  :  usr/local/src目录下创建java目录</p></li><li><p>下载JDK的压缩文件(.tar.gz)到java目录下 并解压</p></li><li><p>配置环境变量  </p><blockquote><p><code>vim /etc/profile</code>  :  直接打开etc下的profile文件在此文件中进行配置</p><pre><code class="properties">export JAVA_HOME=/usr/local/src/java/jdk1.8.0_181  #此处为jdk解压的路径export JAVA_BIN=$JAVA_HOME/binexport JAVA_LIB=$JAVA_HOME/libexport CLASSPATH=.:$JAVA_LIB/tools.jar:$JAVA_LIB/dt.jarexport PATH=$JAVA_BIN:$PATH</code></pre></blockquote></li><li><p>使JDK环境变量生效 , 并查看安装的Java版本</p><blockquote><p><code>source /etc/profile</code></p><p><img src="https://blog.chasingwind.top/1565621094445.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565621094445.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h2 id="Linux上安装MySQL"><a href="#Linux上安装MySQL" class="headerlink" title="Linux上安装MySQL"></a>Linux上安装MySQL</h2><ol><li><p>创建MySQL目录 :  usr/local/src目录下创建MySQL目录</p></li><li><p>检测是否已经安装了MySQL, <code>rpm -qa | grep mysql</code>  , 安装与否视情况而定, 我的系统没有自带MySQL</p></li><li><p>下载rpm文件</p><blockquote><p><img src="https://blog.chasingwind.top/1565623282338.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565623282338.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>因为CentOS属于Redhat  , 所以下载Redhat的就行了</p></blockquote></li><li><p>安装</p><blockquote><p><code>rpm -ivh mysql的rpm文件</code></p><p><code>yum install mysql-server</code></p><p>然后就是下载安装了</p><p>下载页面在这里 一定不要选错<code>https://dev.mysql.com/downloads/repo/yum/</code></p><p><img src="https://blog.chasingwind.top/1565623553620.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565623553620.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>启动并查看MySQL状态</p><blockquote><p>启动 :  <code>systemctl start mysqld</code></p><p>查看MySQL状态 :  <code>systemctl status mysqld</code></p><p><img src="https://blog.chasingwind.top/1565624468986.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565624468986.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>登录MySQL</p><ol><li><p>在第一次启动MySQL服务器的时候 , 系统吧会给root用户创建一个临时的密码,我们需要进行修改</p></li><li><p>首先,查看这个临时密码, 并使用他来登录</p><blockquote><p>查看临时密码 : <code>grep &#39;temporary password&#39; /var/log/mysqld.log</code></p><p><img src="https://blog.chasingwind.top/1565624770185.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565624770185.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>登录MySQL</p><p><img src="https://blog.chasingwind.top/1565624932187.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565624932187.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行密码的修改</p><blockquote><p><code>alter user &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;你的新密码&#39;;</code></p><p>这里8.0以后的MySQL密码设置都比较严格 ,需要有大写字母数字和符号</p></blockquote></li></ol></li><li><p>设置开机自启动(root用户下)</p><ol><li><p><code>vim /etc/rc.local</code>  打开文件 进行修改 (管理员命令下)</p></li><li><p>在文件中添加<code>systemctl status mysqld</code></p><blockquote><p><img src="https://blog.chasingwind.top/1565626805250.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565626805250.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>保存退出</p></li></ol></li><li><p>开启远程服务(为某个用户)</p><ol><li><p>使用root用户登录MySQL</p></li><li><p>设置权限</p><ol><li><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;root用户的密码&#39;;</code>  主机名为%表示任意主机都可以访问  , 这句话是可以不执行的 因为系统默认有root用户</li><li><code>GRANT ALL PRIVILEGES ON *.* TO &#39;用户名&#39;@&#39;%&#39; WITH GRANT OPTION;</code></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1565627570956.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565627570956.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>防火墙设置(不是在MySQL中进行设置)</p><ol><li><p>开启3306端口 : <code>firewall-cmd --zone=public --add-port=3306/tcp --permanent</code></p></li><li><p>重启防火墙 : <code>firewall-cmd --reload</code></p><blockquote><p><img src="https://blog.chasingwind.top/1565627911244.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565627911244.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>进行连接</p><blockquote><p>如果实在阿里云服务器中的话  还需要开启安全组策略</p><p><img src="https://blog.chasingwind.top/1565767465711.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565767465711.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>因为我刚刚创建了一个叫client的用户</p><p><img src="https://blog.chasingwind.top/1565629283347.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565629283347.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Linux上安装Tomcat"><a href="#Linux上安装Tomcat" class="headerlink" title="Linux上安装Tomcat"></a>Linux上安装Tomcat</h2><ol><li><p>创建Tomcat目录 :  usr/local/src目录下创建Tomcat目录</p></li><li><p>解压文件  <code>tar -xvf Tomcat文件名</code></p><blockquote><p>查看目录  有时我们熟悉的画面</p><p><img src="https://blog.chasingwind.top/1565629896389.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565629896389.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>启动和关闭</p><blockquote><p>在Windows下使用的是start.bat和shutdown.bat</p><p>在Linux中使用的是start.sh和shutdown.sh</p><p>sh == shell</p><p><img src="https://blog.chasingwind.top/1565630020286.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565630020286.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>执行命令</p><p><img src="https://blog.chasingwind.top/1565630169076.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565630169076.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>设置防火墙</p><ol><li>开启8080端口  : <code>firewall-cmd --zone=public --add-port=8080/tcp --permanent</code></li><li>重启防火墙 : <code>firewall-cmd --reload</code></li></ol></li><li><p>当我们重新启动的时候 , 就可以通过浏览器进行访问了</p><blockquote><p><img src="https://blog.chasingwind.top/1565630368272.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565630368272.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>如果是阿里云的话 设置完需要重启服务器</p></li></ol><h2 id="Linux上发布项目"><a href="#Linux上发布项目" class="headerlink" title="Linux上发布项目"></a>Linux上发布项目</h2><ol><li><p>将数据库还原到Linux上</p><ol><li><p>备份Windows上的数据库</p><blockquote><p><img src="https://blog.chasingwind.top/1565630747070.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565630747070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在Linux上还原数据库</p><blockquote><p><img src="https://blog.chasingwind.top/1565630979814.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565630979814.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>将程序的代码发布到Linux上</p><ol><li><p>将项目打包成war包</p><blockquote><p>使用IDEA中的Maven的package</p><p><img src="https://blog.chasingwind.top/1565631512705.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565631512705.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565631540942.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565631540942.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将打包的<code>.war</code>文件上传到Tomcat的webapps目录下</p><ul><li>使用FileZilla软件可以轻松将文件上传</li><li>将上传的<code>.war</code>文件放到Tomcat的<code>webapps</code>目录下</li></ul></li><li><p>修改数据库的配置文件以及文件中的内容等等</p></li><li><p>通过路径进行访问  比如:<code>https://IP地址:8080/项目打包的名字</code></p></li></ol></li></ol><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h3><ol><li><p>概念 : </p><ul><li><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1/100571">服务</a>。</li><li>其将<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而<a href="https://baike.baidu.com/item/%E9%97%BB%E5%90%8D/2303308">闻名</a>。2011年6月1日，nginx 1.0.4发布。</li><li>Nginx是一款<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835">轻量级</a>的<a href="https://baike.baidu.com/item/Web/150564">Web</a> 服务器/<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>服务器及<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106">电子邮件</a>（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806">并发</a>能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、<a href="https://baike.baidu.com/item/%E4%BA%AC%E4%B8%9C/210931">京东</a>、<a href="https://baike.baidu.com/item/%E6%96%B0%E6%B5%AA/125692">新浪</a>、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%98%93/185754">网易</a>、<a href="https://baike.baidu.com/item/%E8%85%BE%E8%AE%AF/112204">腾讯</a>、<a href="https://baike.baidu.com/item/%E6%B7%98%E5%AE%9D/145661">淘宝</a>等。</li></ul></li><li><p>为什么使用Nginx ? </p><blockquote><p><strong>大用户量高并发</strong>已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢?</p><p>用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的</p><hr><p>为了解决这个问题引入了负载均衡方法,</p><p>而Nginx则是一款免费开源的负载均衡的服务器</p></blockquote></li></ol><h3 id="Nginx-Tomcat的集群配置-Windows"><a href="#Nginx-Tomcat的集群配置-Windows" class="headerlink" title="Nginx+Tomcat的集群配置(Windows)"></a>Nginx+Tomcat的集群配置(Windows)</h3><blockquote><p>完成Nginx负载均衡,那么需要先来介绍Tomcat的安装和配置,我们首先要来配置Tomcat完成集群的配置.</p><p>因为我们没有多台服务器运行Tomcat.那么我们可以模拟在一台服务器上运行多个Tomcat程序.</p></blockquote><ol><li><p>在一台电脑上安装两个Tomcat  复制Tomcat的目录就行</p><blockquote><p><img src="https://blog.chasingwind.top/1565689224117.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565689224117.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改Tomcat配置文件 , 修改端口  在conf目录下的server.xml文件中</p><blockquote><p><img src="https://blog.chasingwind.top/1565689099992.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565689099992.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565689119911.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565689119911.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565689134909.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565689134909.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我是在原本的端口上都加了1  只要不跟另一个Tomcat的端口冲突就行了</p></blockquote></li><li><p>将项目分别发布到两个服务器中</p><blockquote><p>将项目分别放在两个Tomcat的webapps目录下就行</p><p>分别启动Tomcat  进行访问</p><p><img src="https://blog.chasingwind.top/1565690579877.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565690579877.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>但是这样有一个问题  就是  <strong>这个时候我们去访问网站  用户需要使用不同的ip地址去访问同一个网站?</strong></p><p>所以就<strong>需要一个网址在有多台服务器的情况下有一个统一的的入口 ,  那就是Nginx</strong>    </p></blockquote></li><li><p>安装Nginx (端口号是80)</p><blockquote><ol><li><p>下载Nginx 解压就行了</p><blockquote><p><img src="https://blog.chasingwind.top/1565690936465.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565690936465.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>双击开启</p></li><li><p>Nginx是有默认路径的   端口号是80</p><blockquote><p>去访问localhost:80</p><p><img src="https://blog.chasingwind.top/1565691356872.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565691356872.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></blockquote></li><li><p>进行配置  conf目录下的nginx.conf</p><ul><li><p>将两个服务器映射到同一个Nginx , 那么就需要进行配置</p><blockquote><p> 这里是默认的配置<img src="https://blog.chasingwind.top/1565691782665.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565691782665.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p> <img src="https://blog.chasingwind.top/1565691856541.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565691856541.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p> 进行修改</p><p> 这里是正常的修改</p><p> <img src="https://blog.chasingwind.top/1565692295309.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565692295309.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p> 由于我的出现了致命的配置错误 ,  这个问题搞了我大半天</p><p> 除了上面的配置之外  还需要在<code>location</code>中配置</p><pre><code class="xml">#修改发送到后端的header的hostproxy_set_header Host $host;  #设置真实IPproxy_set_header X-Real-Ip $remote_addr;proxy_set_header X-Forwarded-For $remote_addr;</code></pre><p> <img src="https://blog.chasingwind.top/1565704968115.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565704968115.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p> 在Nginx目录下 , 使用Cmder重新加载Nginx的配置文件 :  <code>nginx -s reload</code></p><p> <img src="https://blog.chasingwind.top/1565692373873.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565692373873.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote><blockquote><p>这样我们就可以通过同一个地址访问这两个服务器了 也就实现了负载均衡</p><p><img src="https://blog.chasingwind.top/1565705637739.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565705637739.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这里还有一个问题  那就是当我们刷新同一个<code>local/test</code>的时候, Session会发生改变  也就是不再是同一个会话  显然这并不是我们想要的</p><p>可见,Session的ID已经发生改变</p><p><img src="https://blog.chasingwind.top/1565705861028.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565705861028.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>Tomcat集群中的Session共享</p><ol><li><p>让<strong>每一个用户只能访问同一台服务器</strong> , 这样就不存在Session丢失的问题</p><blockquote><p>可以在配置文件中进行配置</p><p><img src="https://blog.chasingwind.top/1565706108826.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565706108826.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>还可以设置权重 来让用户优先访问哪一个服务器 权重越大,那么就越优先被使用</p><p><img src="https://blog.chasingwind.top/1565706219350.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565706219350.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用Tomcat广播机制完成Session的共享(不推荐)</p><blockquote><p>因为当集群中的服务器较多的时候,每一个服务器都需要广播自己的Session , 显然对资源的耗费比较大</p></blockquote><ol><li><p>修改Tomcat中的server.xml</p><blockquote><p>将注释打开就行了</p><p><img src="https://blog.chasingwind.top/1565706917619.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565706917619.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当有多个集群的时候  就需要再进行详细的配置</p></blockquote></li><li><p>修改项目中的<code>web.xml</code>文件 , 加入节点<code>&lt;distributable/&gt;</code></p><blockquote><p><img src="https://blog.chasingwind.top/1565707100573.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565707100573.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>重启服务器</p></li></ol></li><li><p>Tomcat集群+Redis缓存的Session共享配置方法</p><blockquote><p>将所有的Session保存在Redis缓存中 , 并且取的时候也从Redis中取</p></blockquote><blockquote><p>参考</p><p>[配置参考]: <a href="https://blog.csdn.net/hua1586981/article/details/78132710">https://blog.csdn.net/hua1586981/article/details/78132710</a></p></blockquote><ol><li><p>下载相关的jar包 , 导入到服务器下的lib目录中</p></li><li><p>在conf下的context.xml中配置</p><blockquote><p><img src="https://blog.chasingwind.top/1565709172780.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565709172780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我的Redis没有密码  需哦一将password这一项去掉</p><p><img src="https://blog.chasingwind.top/1565709626081.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565709626081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>重启Tomcat查看效果</p></li></ol></li></ol></li></ol><h3 id="Nginx-Tomcat的集群配置-Linux"><a href="#Nginx-Tomcat的集群配置-Linux" class="headerlink" title="Nginx+Tomcat的集群配置(Linux)"></a>Nginx+Tomcat的集群配置(Linux)</h3><ol><li><p>在Linux上安装多个Tomcat(root用户下)</p><blockquote><p>解压tar.gz文件就行了</p><p><img src="https://blog.chasingwind.top/1565712245030.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565712245030.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改Tomcat2的conf/server.xml文件  进行端口的修改</p><blockquote><p><img src="https://blog.chasingwind.top/1565712789487.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565712789487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565712853718.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565712853718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565712867024.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565712867024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>将项目的war包上传到对应的webapps目录下</p><blockquote><p><img src="https://blog.chasingwind.top/1565713180481.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565713180481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>启动两个Tomcat</p><blockquote><p>你会发现只能访问一个</p><p>这里还记得之前需要配置防火墙吗 ? 因为我们没有对新的端口(8081)进行防火墙的配置并重启防火墙</p><p><code>firewall-cmd --zone=public --add-port=8081/tcp --permanent</code></p><p><code>firewall-cmd --reload</code></p><p><img src="https://blog.chasingwind.top/1565714009476.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565714009476.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>进行访问</p><p><img src="https://blog.chasingwind.top/1565714187677.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565714187677.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Linux上安装Nginx</p><ol><li><p>安装依赖包</p><blockquote><p><code>yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</code>  一键安装所需要的依赖包</p></blockquote></li><li><p>下载Nginx的安装包并解压</p><blockquote><p><img src="https://blog.chasingwind.top/1565715307480.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565715307480.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>执行安装命令</p><blockquote><p>在Nginx目录下执行命令  这个是默认路径</p><p><code>./configure &amp;&amp; make &amp;&amp; make install</code></p><p>可以进行配置的修改</p><p><code>./configure --prefix=安装路径</code></p><p>然后再执行<code>make &amp;&amp; make install</code></p><p>比如我在我的Nginx目录下直接执行</p><pre><code>./configure \--prefix=/usr/local/src/Nginx/nginx-1.16.0 \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi</code></pre><p>注意 :  第一行中的就是安装的路径  </p><hr><p>然后执行  <code> make &amp;&amp; make install</code>命令</p><hr><p>总之 你需要找到sbin目录  因为后面启动要使用</p><p><img src="https://blog.chasingwind.top/1565717935198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565717935198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>启动Nginx</p><blockquote><p>在/sbin目录下执行<code>./config</code></p><p><img src="https://blog.chasingwind.top/1565773988300.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565773988300.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我的报错了  原因是没有对应的文件夹  创建就行了</p><p><img src="https://blog.chasingwind.top/1565774056851.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565774056851.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行访问</p><blockquote><p><img src="https://blog.chasingwind.top/1565774083132.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565774083132.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h3 id="负载均衡相关知识"><a href="#负载均衡相关知识" class="headerlink" title="负载均衡相关知识"></a>负载均衡相关知识</h3><ol><li><p>负载均衡</p><ul><li><p>概念</p><blockquote><p>负载均衡就是<strong>一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。</strong>当然, 请求的分配是有很多种算法的</p></blockquote></li></ul></li><li><p>负载均衡服务器</p><ol><li><p>分类</p><ul><li>硬负载  : 通过硬件实现的负载均衡服务器，简称<strong>硬负载</strong> , 例如：f5。</li><li>软负载  : 通过软件来实现的负载均衡，简称<strong>软负载</strong>:例如apache和Nginx</li></ul></li><li><p>区别</p><ol><li><p>作用的网络层次</p><blockquote><p>硬负载作用的网络层次比较多，可以作用到socket接口的数据链路层对发出的请求进行分组转发</p><hr><p>软负载作用的层次在http协议层之上可以对http请求进行分组转发</p></blockquote></li><li><p>成本</p><blockquote><p>硬负载成本比较高</p><hr><p>软负载因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。</p></blockquote></li></ol></li></ol></li></ol><h3 id="代理相关知识"><a href="#代理相关知识" class="headerlink" title="代理相关知识"></a>代理相关知识</h3><ol><li><p>正向代理</p><ul><li><p>概念 : 一般情况下，如果没有特别说明，<strong>代理技术默认说的是正向代理技术</strong>。关于正向代理的概念如下： 正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代 理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><blockquote><p><img src="https://blog.chasingwind.top/1565681799008.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565681799008.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>作用 :</p><ol><li><p>访问本无法访问的服务器B</p><blockquote><p>当用户与服务器之间的路由出现故障的时候  用户可以通过代理服务器进行服务器的访问，生活中常见的翻墙就是使用代理技术和其他技术一起实现的</p><p><img src="https://blog.chasingwind.top/1565681952156.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565681952156.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>加速访问服务器B</p><blockquote><p>在早期带宽较小的时候, 使用正向代理来提速。做法就是在客户端到代理服务器和服务器的路径使用高速链路。这样就比通过路由访问速度快</p></blockquote></li><li><p>Cache作用</p><blockquote><p>如果在用户A访问服务器B中的某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。</p><p>这一技术在Cache中术语就叫<strong>Cache命中</strong>。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。</p></blockquote></li><li><p>客户端访问授权</p><blockquote><p><img src="https://blog.chasingwind.top/1565682486432.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565682486432.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>隐藏访问者的行踪</p><blockquote><p><img src="https://blog.chasingwind.top/1565682522790.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565682522790.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内 容返回给客户端。<strong>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</strong></p></li></ul></li><li><p>反向代理</p><ul><li><p>概念 : 反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。<strong>客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端</strong>。</p><blockquote><p><img src="https://blog.chasingwind.top/1565683649446.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565683649446.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>作用 : </p><ol><li><p>保护和隐藏原始资源服务器</p><blockquote><p><img src="https://blog.chasingwind.top/1565683218426.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565683218426.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实际上<strong>反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。</strong></p><p><strong>由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。</strong>尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情</p></blockquote></li><li><p><strong>负载均衡</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1565683327259.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565683327259.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当反向代理服务器不止一个的时候，我们甚至可以把它们做成<strong>集群</strong>，</p><p>当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。</p></blockquote></li><li><p>Cache作用</p><blockquote><p><img src="https://blog.chasingwind.top/1565683879787.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565683879787.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它<strong>可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据</strong>，特别是一些静态的数据，比如图片和文件，</p><p>如果这些<strong>反向代理服务器能够做到和用户X来自同一个网络</strong>，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心</p><hr><p>CDN技术 : </p><p>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术</p></blockquote></li></ol></li></ul></li><li><p>透明代理</p><ul><li><p>概念 : 透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。 透明代理实践的例子就是时下很多公司使用的行为管理软件。</p><blockquote><p><img src="https://blog.chasingwind.top/1565684141025.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565684141025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>用户A和用户B并不知道行为管理设备充当透明代理行为，</p><p>当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并<strong>作为实际的请求方</strong>，向服务器A或B发送请求，</p><p>当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，</p><p>如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。</p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="2019/08/11/Linux%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/11/Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>本篇主要讲述了Linux的基础知识,Linux在虚拟机上安装以及命令行的操作, 其中包括平常经常会使用的Linux的命令, 以及一些权限管理,包括对用户以及文件等等.</p><a id="more"></a><h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><ol><li><p>为什么需要学习Linux?</p><ul><li>一般服务器都安装在Linux操作系统上, 我们需要将项目发布到Linux上</li></ul></li><li><p>什么是<strong>Linux</strong>?</p><ul><li><p>Linux是一套<strong>免费</strong>使用和自由传播的<a href="https://baike.baidu.com/item/%E7%B1%BBUnix">类Unix</a><a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>，是一个基于<a href="https://baike.baidu.com/item/POSIX">POSIX</a>和Unix的多用户、<a href="https://baike.baidu.com/item/%E5%A4%9A%E4%BB%BB%E5%8A%A1/1011764">多任务</a>、支持<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404">多线程</a>和多<a href="https://baike.baidu.com/item/CPU">CPU</a>的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持<a href="https://baike.baidu.com/item/32%E4%BD%8D/5812218">32位</a>和<a href="https://baike.baidu.com/item/64%E4%BD%8D">64位</a>硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><blockquote><p>Linux是基于Unix的</p><p>Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但<strong>它们都使用了Linux内核</strong>。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机</p><p> <img src="https://blog.chasingwind.top/1565607511216.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565607511216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>什么是<strong>Unix</strong>?</p><ul><li>UNIX操作系统（尤尼斯），是一个强大的多用户、多任务<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>，支持多种<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/8535061">处理器架构</a>，按照操作系统的分类，属于<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3067636">分时操作系统</a></li><li>UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。</li></ul></li><li><p>Linux系统的应用</p><ul><li><strong>服务器系统</strong>：Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 主要是<strong>免费</strong>的系统</li><li>嵌入式系统：路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，</li><li>高性能运算、计算密集型应用：Linux有强大的运算能力。</li><li>桌面应用系统</li><li>移动手持系统</li></ul></li><li><p>Linux的版本</p><ol><li>内核版本<ul><li>内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；</li></ul></li><li>发行版本<ul><li>发行版本是一些组织和公司根据自己发行版的不同而自定的 ；</li></ul></li></ol></li><li><p>Linux的主流版本</p><blockquote><p><img src="https://blog.chasingwind.top/1565607492119.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565607492119.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="Linux的安装"><a href="#Linux的安装" class="headerlink" title="Linux的安装"></a>Linux的安装</h2><ol><li>虚拟机：VMWare（收费），VirtualBox（免费）</li><li>在虚拟机中安装CentOS</li></ol><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><blockquote><p><img src="https://blog.chasingwind.top/1565607442759.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565607442759.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>root管理员的home目录root</p><p>其他用户的home目录home目录中</p></blockquote><h2 id="Linux的远程管理工具"><a href="#Linux的远程管理工具" class="headerlink" title="Linux的远程管理工具"></a>Linux的远程管理工具</h2><ol><li><p>远程管理工具的作用</p><ul><li>Linux一般作为服务器使用，而服务器一般放在机房，你不可能在机房操作你的Linux服务器。这时我们就需要远程登录到Linux服务器来管理维护系统。</li></ul></li><li><p>远程管理工具 SecureCRT</p><ol><li><p>安装注册</p></li><li><p>配置Linux的ip</p><blockquote><p><img src="https://blog.chasingwind.top/1565585511110.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565585511110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用</p><blockquote><p><img src="https://blog.chasingwind.top/1565586100036.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565586100036.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可以看到跟在虚拟机上使用有一样的效果</p></blockquote></li></ol></li></ol><h2 id="Linux的常用命令"><a href="#Linux的常用命令" class="headerlink" title="Linux的常用命令"></a>Linux的常用命令</h2><h3 id="切换目录的命令-cd"><a href="#切换目录的命令-cd" class="headerlink" title="切换目录的命令 cd"></a>切换目录的命令 cd</h3><ol><li><p><code>cd /</code>和<code>cd ~</code></p><blockquote><p><img src="https://blog.chasingwind.top/1565535316989.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565535316989.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>cd /</code>和<code>cd ~</code>的区别就是 : </p><p>前者是系统根目录,就是我们看到的<strong>Linux的目录结构</strong></p><p>后者是root用户的目录,就是这个样子的</p><p><img src="https://blog.chasingwind.top/1570152539725.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1570152539725.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>cd xxx/</code>,<code>cd ..</code>,<code>cd -</code></p><blockquote><p><img src="https://blog.chasingwind.top/1565535886496.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565535886496.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><code>cd -</code>：回到上一次所在的目录</p><p><img src="https://blog.chasingwind.top/1565535980962.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565535980962.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><code>cd .</code>进入的还是当前的目录,<code>cd..</code>进入的是当前目录的上一级目录</p><p><img src="https://blog.chasingwind.top/1565537243458.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565537243458.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="列出文件列表-ls-ll"><a href="#列出文件列表-ls-ll" class="headerlink" title="列出文件列表 ls ll"></a>列出文件列表 ls ll</h3><ul><li><p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。</p></li><li><p>格式 : ls[参数] [路径或文件名]</p><blockquote><p><code>ls</code> 和 <code>ls -a</code>  ：</p><p>ls显示当前目录下的文件</p><p>ls -a 显示当前目录下的所有的文件  包括隐藏文件</p><p><img src="https://blog.chasingwind.top/1565536620296.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565536620296.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Linux中的隐藏文件以<code>.</code>开头</p></blockquote></li><li><p><code>ls -l</code> == <code>ll</code>  :   以一种格式显示查询到的文件</p><blockquote><p><img src="https://blog.chasingwind.top/1565536989990.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565536989990.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565537048462.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565537048462.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>ll -a</code> : 将命令进行组合使用 , 以某种格式显示目录下的所有的文件</p><blockquote><p><img src="https://blog.chasingwind.top/1565537093972.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565537093972.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可以看到其实每个目录下都会有隐藏文件<code>.</code>和<code>..</code>,这就是我们<code>cd..</code>使用的</p></blockquote></li><li><p>当我们不知道命令的参数的时候, 我们可以使用<code>man xxx</code>来查询xxx中的对应的命令 的参数,q退出查询</p></li></ul><h3 id="创建目录和移除目录-mkdir-rmdir"><a href="#创建目录和移除目录-mkdir-rmdir" class="headerlink" title="创建目录和移除目录 mkdir rmdir"></a>创建目录和移除目录 mkdir rmdir</h3><ul><li><p><code>mkdir xxx</code>和<code>mkdir -p xxx/xxx/xxx/....</code></p><blockquote><p>mkdir(make directory)命令可用来创建子目录。</p><p>mkdir xxx  在当前目录下创建app目录</p><p>mkdir –p xxxx/xxxx  建立多层级目录</p><p><img src="https://blog.chasingwind.top/1565575371544.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565575371544.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>rmdir</code></p><blockquote><p>remove directory  命令可用来<strong>删除“空”的子目录</strong>：</p><p><img src="https://blog.chasingwind.top/1565575638890.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565575638890.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当目录中为空的的时候  可以使用此命令进行删除空的目录</p><p>当目录中不为空的时候,无法使用这个命令进行删除</p></blockquote></li></ul><h3 id="浏览文件-cat-more-less"><a href="#浏览文件-cat-more-less" class="headerlink" title="浏览文件 cat more less"></a>浏览文件 cat more less</h3><ul><li><p>cat</p><blockquote><p><code>cat xxxx</code>  :  用来查看xxxx文件中的内容</p><p><img src="https://blog.chasingwind.top/1565575903088.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565575903088.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>more</p><blockquote><p><code>more xxx</code></p><p>当文件较多的时候(对于没有滚动条的终端),more用于要显示的内容会超过一个画面长度的情况</p><p>按空格键显示下一个画面。</p><p>回车显示下一行内容。</p><p>按 q 键退出查看。</p></blockquote></li><li><p>less</p><blockquote><p><code>less xxx</code></p><p>用法和more类似，不同的是less可以通过PgUp、PgDn键来控制上下翻页</p></blockquote></li><li><p>tail</p><blockquote><p>tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：<strong>用于显示文件后几行的内容。</strong></p><p><code>tail -num xxxx</code> : 查看文件xxxx的后num行内容</p><p><img src="https://blog.chasingwind.top/1565576454430.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565576454430.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><code>tail -f xxxx</code>  : 动态查看xxxx中的内容 ,动态的意思就是对文件中的内容进行实时更新, 一般用于加载日志信息</p><p><code>Ctrl + c</code>  :  结束查看</p><p><img src="https://blog.chasingwind.top/1565576670001.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565576670001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="文件操作的命令"><a href="#文件操作的命令" class="headerlink" title="文件操作的命令"></a>文件操作的命令</h3><ul><li><p><code>rm</code> : 删除文件</p><blockquote><p><code>rm xxxx</code>  : 删除xxxx文件</p><p><img src="https://blog.chasingwind.top/1565582219249.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565582219249.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><code>rm -f xxxx</code>  :  删除xxxx文件不询问</p><p><img src="https://blog.chasingwind.top/1565582500710.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565582500710.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565582449890.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565582449890.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>rm -r xxxx</code> : 删除目录,递归删除</p><blockquote><p><img src="https://blog.chasingwind.top/1565582610737.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565582610737.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>a/b/c是一个多层级目录  可以使用此命令一下删除a以及其子目录</p><p><img src="https://blog.chasingwind.top/1565582686396.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565582686396.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>rm -rf xxxx</code>  :  不询问删除xxxx中的所有文件</p><blockquote><p><code>rm -rf  xxxx </code>  不询问递归删除xxxx</p><p><code>rm -rf * </code>     删除所有文件</p><p><code>rm -rf /*</code>    自杀</p></blockquote></li><li><p><code>cp</code>  :  copy,复制文件 </p><ol><li><p><code>cp a.txt b.txt</code> : 将a.txt文件复制为b.txt , 到当前目录</p><blockquote><p><img src="https://blog.chasingwind.top/1565587509555.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565587509555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>cp xxxx 目录/</code>  :  将xxxx文件复制到某个目录下</p><blockquote><p><img src="https://blog.chasingwind.top/1565587617376.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565587617376.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p><code>mv</code>  :  move,移动文件(相当于剪切+粘贴)</p><ol><li><p><code>mv xxxx 目录/</code> : 将xxxx文件移动到某个指定的目录下</p><blockquote><p><img src="https://blog.chasingwind.top/1565587754161.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565587754161.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>mv 文件a 文件b</code>  :  就相当于在当前目录下 , 将文件a重命名为文件b</p><blockquote><p> <img src="https://blog.chasingwind.top/1565587849804.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565587849804.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><h3 id="打包-解压-tar"><a href="#打包-解压-tar" class="headerlink" title="打包/解压 tar"></a>打包/解压 tar</h3><ul><li><p><strong>tar命令位于/bin目录下</strong>，它能够将用户所指定的文件或目录打包成一个文件，但<strong>不做压缩</strong>。</p></li><li><p>一般<strong>Linux上常用的压缩方式是选用tar将许多文件打包成一个文件</strong>，此时未经过压缩处理，后缀名为<code>.tar</code>，再以gzip压缩命令**压缩成xxx.tar.gz(或称为xxx.tgz)**的文件，此时就是压缩文件了。</p></li><li><p><code>.tar</code>是一个打包过的文件，<code>.tar.gz</code>是一个压缩文件</p></li><li><p>tar常用的参数</p><blockquote><p>-c：创建一个新tar文件</p><p>-v：显示运行过程的信息</p><p>-f：指定文件名</p><p>-z：调用gzip压缩命令进行压缩</p><p>-t：查看压缩文件的内容</p><p>-x：解开tar文件</p></blockquote></li><li><p><code>tar -cvf 文件名.tar 需要打包的文件</code>  : 将文件<strong>打包</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1565588577205.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565588577205.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><code>./*</code>   :   代表当前目录下的所有的文件</p></blockquote></li><li><p><code>tar -cvzf 文件名.tar.gz 需要压缩的文件</code>  : 将文件<strong>打包并且压缩</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1565588919685.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565588919685.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>tar -xvf  压缩文件名</code>  :  将压缩文件解压缩到当前目录</p><blockquote><p><img src="https://blog.chasingwind.top/1565589276813.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565589276813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>tar -xvf  压缩文件名 -C 解压缩路径</code>  :  将压缩文件解压缩到…</p><blockquote><p><img src="https://blog.chasingwind.top/1565589659995.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565589659995.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意的是 : <code>-C</code>需要大写!</p></blockquote></li></ul><h3 id="查找-grep"><a href="#查找-grep" class="headerlink" title="查找 grep"></a>查找 grep</h3><ul><li><p>相当于<code>Ctrl + F</code>  ,  用于在文件中查找指定的字符串你</p><blockquote><p><code>grep xxxx 文件名</code>  :  在文件中查找xxxx</p><p><code>grep xxxx 文件名 --color </code>  :  将查找到的结果高亮显示</p><p><code>grep xxxx 文件名 -Bx</code>  :  显示查找到的结果处的**(Before)前x行**</p><p><code>grep xxxx 文件名 -Ax</code>  :  显示查找到的结果处的**(After)后x行**</p><p><img src="https://blog.chasingwind.top/1565590265257.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565590265257.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul><li><p><code>pwd</code>  :  显示当前所在的目录</p><blockquote><p><img src="https://blog.chasingwind.top/1565590688224.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565590688224.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>touch</code>  :  创建一个空的文件</p><blockquote><p><img src="https://blog.chasingwind.top/1565590783234.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565590783234.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>ll -h</code>  :  显示文件的大小 , 带单位的显示</p><blockquote><p><img src="https://blog.chasingwind.top/1565590862798.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565590862798.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>wget 地址</code>  :  下载文件</p></li></ul><h3 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h3><ul><li><p>在Linux中, 文件是没有扩展名之分的 , 所有的文件都可以使用编辑器打开</p></li><li><p>文件的格式</p><blockquote><p>文件是以<code>-</code>开头的</p><p>文件夹是以<code>d</code>开头的</p><p><img src="https://blog.chasingwind.top/1565591157053.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565591157053.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h3><ul><li><p>Vim可以当作Vi的升级版本，他可以用多种颜色的方式来显示一些特殊的信息</p></li><li><p>Vim的三种模式 : 命令行、插入、底行模式。</p><ol><li>切换到命令行模式：<strong>按Esc键</strong>,然后根据命令(i,o,a,:等等)来切换不同的模式；</li><li>切换到插入模式：按 i 、o、a键；</li><li>切换到底行模式：按 :（冒号）；</li></ol></li><li><p>Vim中的一些常用的<strong>命令</strong></p><ol><li><p>使用vim打开文件进行编辑   <code>vim 文件名</code></p></li><li><p>退出, 在命令行模式下</p><blockquote><p>退出：esc  +  <code>:q</code></p><p>修改文件：输入i进入插入模式</p><p>保存并退出：esc + <code>:wq</code></p><p> 不保存退出：esc + <code>:q!</code></p></blockquote></li><li><p>复制(<code>yy</code>) + 粘贴(<code>p</code>)</p></li><li><p><code>dd</code>删除当前行</p></li></ol></li></ul><h3 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h3><p>将输出信息不输出在控制台,而是输出到重定向的对应的文件中</p><ol><li><p><code>&gt;</code>  :  <strong>不可以对重定向之后的文件进行追加操作</strong>,  也就是说 当我们再次重定向这个文件之后, 之前的文件内容就不在了 </p><blockquote><p><img src="https://blog.chasingwind.top/1565597295000.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565597295000.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&gt;&gt;</code>  :  将输出信息重定向到文件中 , 并且<strong>这个文件是可追加</strong>的  , 新的重定向的数据会拼接在之前信息的后面</p><blockquote><p><img src="https://blog.chasingwind.top/1565597523059.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565597523059.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><ul><li><p>管道是Linux命令中重要的一个概念，其作用是<strong>将一个命令的输出用作另一个命令的输入。</strong></p></li><li><p>比如 , 在Linux中查询Java相关的进程</p><blockquote><p><code>ps -ef</code>  :  Linux中的进程</p><p>这里的意思就是在查询到的<code>ps -ef</code>的数据中, 进行<code>grep java</code>操作</p><p><img src="https://blog.chasingwind.top/1565597925141.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565597925141.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="命令控制执行-amp-amp"><a href="#命令控制执行-amp-amp" class="headerlink" title="命令控制执行 &amp;&amp;"></a>命令控制执行 &amp;&amp;</h3><ul><li><p>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。  </p></li><li><p>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。  </p></li><li><p>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p><blockquote><p><img src="https://blog.chasingwind.top/1565598170972.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565598170972.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="网络通信命令"><a href="#网络通信命令" class="headerlink" title="网络通信命令"></a>网络通信命令</h2><ol><li><code>ifconfig</code>  显示或设置网络设备。<ul><li><code>ifconfig</code>  显示网络设备</li><li><code>ifconfig xxx up</code> 启用xxx网卡</li><li><code>ifconfig xxx down</code>  停用xxx网卡</li></ul></li><li><code>ping</code>   探测网络是否通畅。<ul><li><code>ping ip地址</code> </li></ul></li><li><code>netstat -an</code>  查看网络端口的信息。<ul><li><code>netstat -an | grep 3306</code> 查询3306端口占用情况</li></ul></li></ol><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><ol><li><p><code>date</code> 显示或设置系统时间</p><ul><li><p><code>date</code>  显示当前系统时间</p></li><li><p><code>date -s “2014-01-01 10:10:10“</code>  设置系统时间</p><blockquote><p><img src="https://blog.chasingwind.top/1565601724763.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565601724763.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p><code>df</code> 显示磁盘信息</p><ul><li><p><code>df –h</code>  友好显示大小</p><blockquote><p><img src="https://blog.chasingwind.top/1565601762990.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565601762990.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p><code>free</code>  显示内存状态</p><blockquote><p><img src="https://blog.chasingwind.top/1565601829480.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565601829480.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>top</code> 显示，管理执行中的程序</p><ul><li><p>有点像windows中的任务管理器 , 可以动态显示当前进程的状态</p></li><li><p>右上角load average 是 负载</p><blockquote><p><img src="https://blog.chasingwind.top/1565601901496.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565601901496.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p><code>clear</code> 清屏幕 </p></li><li><p><code>ps</code> 正在运行的某个进程的状态</p><ul><li><code>ps –ef</code>  查看所有进程</li><li><code>ps –ef | grep xxxx</code> 查找xxxx进程</li></ul></li><li><p><code>kill</code> 杀掉某一进程</p><ul><li><code>kill xxxx </code> 杀掉xxxx编号的进程</li><li><code>kill -9 xxxx</code>   强制杀死进程xxxx</li></ul></li><li><p><code>du</code> 显示目录或文件的大小。</p><blockquote><p><img src="https://blog.chasingwind.top/1565602109321.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565602109321.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>who</code> 显示目前登入系统的用户信息</p><blockquote><p><img src="https://blog.chasingwind.top/1565602178203.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565602178203.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>hostname</code> 查看当前主机名</p><ul><li><p>vim /etc/sysconfig/network </p><blockquote><p><img src="https://blog.chasingwind.top/1565602190471.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565602190471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p><code>uname</code> 显示系统信息。</p><ul><li><p><code>uname -a</code> 显示详细信息</p><blockquote><p><img src="https://blog.chasingwind.top/1565602258467.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565602258467.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>uname -a 显示本机详细信息。依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p></blockquote></li></ul></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ol><li><p><code>useradd</code>  添加一个用户(root用户的状态下)</p></li><li><p><code>passwd xxxx</code>  为xxxx设置密码</p><blockquote><p><img src="https://blog.chasingwind.top/1565603073679.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565603073679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>su - 用户名</code>  : 切换用户 ,注意空格</p><blockquote><p><img src="https://blog.chasingwind.top/1565603183315.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565603183315.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>userdel </code>  :  删除一个用户(root用户状态下)</p><ul><li><p>userdel test 删除test用户(不会删除home目录)</p><blockquote><p><img src="https://blog.chasingwind.top/1565603566702.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565603566702.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见  用户的文件夹还是存在的</p></blockquote></li><li><p>userdel –r xxxx  删除xxxx用户以及home目录</p></li></ul></li></ol><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><ul><li>当在创建一个新用户user时，若<strong>没有指定他所属于的组，就建立一个和该用户同名的私有组</strong>, 创建用户时也可以指定所在组</li></ul><ol><li><code>groupadd 组名</code>  :  创建组<ul><li><code>useradd 用户名 –g 组名</code>  :   创建用户并且指定组</li></ul></li><li><code>groupdel xxxx </code>   :  删除组xxxx<ul><li>如果该组有用户成员，必须先删除用户才能删除组。</li></ul></li><li><code>id</code>  :  查看当前用户的id以及所在组的id</li></ol><h2 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h2><ol><li><p>文件权限</p><blockquote><p><img src="https://blog.chasingwind.top/1565605624010.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565605624010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565605331211.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565605331211.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可以发现 </p><p>每组权限都有3个取值  r代表可读,w代表可写,x表示可执行</p><p>其实Linux中的<strong>每一组权限</strong>都可以取0~7的值(权限的值可以进行相加,表示一组权限),一共8种状态不重复</p></blockquote></li><li><p>文件类型</p><ol><li>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </li><li>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。  </li><li>设备文件： Linux系统把每一个设备都看成是一个文件</li></ol></li><li><p>文件类型标识</p><ol><li>普通文件  :  <code>-</code></li><li>目录  :  <code>d</code></li><li>符号链接 (快捷方式)  :  <code>l</code></li><li>字符设备文件  :  <code>c</code></li></ol></li><li><p>文件权限管理</p><ol><li><p><code>chmod</code>  :  change modify , 变更文件或目录的权限。</p><ul><li><p><code>chmod 755 a.txt</code>   :  修改a.txt的文件权限为<code>rwxr-xr-x</code></p></li><li><p><code>chmod u=rwx,g=rx,o=rx a.txt</code>  修改a.txt的文件权限为<code>rwxr-xr-x</code></p><blockquote><p><img src="https://blog.chasingwind.top/1565606540804.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565606540804.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565606623966.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565606623966.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>即使你设置文件权限000, root用户还是可以对文件进行rwx的操作</p></li></ul></li><li><p><code>chown</code>  :   变更文件或目录改文件所属用户和组</p><ul><li><code>chown 用户名:组名 xxxx</code>    ：变更xxxx的所属用户和组</li><li><code>chown -R 用户名:组名 目录</code>    ：变更<strong>目录中的所有的子目录及文件</strong>的所属用户和组</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb项目</title>
      <link href="2019/08/08/JavaWeb%E9%A1%B9%E7%9B%AE/"/>
      <url>2019/08/08/JavaWeb%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>JavaWeb基础的知识学完了 , 做一个JavaWeb项目来复习巩固JavaWeb的知识.主要使用三层架构的思想来完成设计以及代码的编写 ,设计简单的前端,后端,客户端以及服务器之间的数据的传递等等</p><a id="more"></a><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="Web层"><a href="#Web层" class="headerlink" title="Web层"></a>Web层</h3><ul><li><p>Servlet：前端控制器</p></li><li><p>html：视图</p></li><li><p>Filter：过滤器</p></li><li><p>BeanUtils：数据封装</p></li><li><p>Jackson：json序列化工具</p></li></ul><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><ul><li><p>Javamail：java发送邮件工具</p></li><li><p>Redis：nosql内存数据库</p></li><li><p>Jedis：java的redis客户端</p></li></ul><h3 id="DAO层"><a href="#DAO层" class="headerlink" title="DAO层"></a>DAO层</h3><ul><li><p>Mysql：数据库</p></li><li><p>Druid：数据库连接池</p></li><li><p>JdbcTemplate：jdbc的工具</p></li></ul><h2 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h2><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h3><ol><li><p>页面效果</p><blockquote><p><img src="https://blog.chasingwind.top/1565329698204.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565329698204.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>功能分析</p><blockquote><p><img src="https://blog.chasingwind.top/1565329730805.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565329730805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>代码实现</p><ol><li><p>前台代码实现</p><blockquote><p>在用户输入信息之后对用户输入是否符合规定进行校验  使用JavaScript实现</p><p><img src="https://blog.chasingwind.top/1565329864254.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565329864254.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在此使用异步提交表单是为了获取服务器响应的数据。因为我们前<strong>台使用的是html作为视图层</strong>，不能够直接从servlet相关的域对象获取值，只能通过ajax获取响应数据</p></blockquote></li><li><p>后台代码实现</p><ol><li><p>RegisterSubmitServlet</p><blockquote><p>对用户填入的信息进行校验 是去查询数据库的校验 以完成注册的功能</p><p><img src="https://blog.chasingwind.top/1565330088349.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330088349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>UserService和UserServiceImpl</p><blockquote><p><img src="https://blog.chasingwind.top/1565330295530.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330295530.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>UserDao以及UserDaoImpl</p><blockquote><p><img src="https://blog.chasingwind.top/1565330438042.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330438042.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h3 id="邮件激活"><a href="#邮件激活" class="headerlink" title="邮件激活"></a>邮件激活</h3><ul><li><p>在用户注册之后需要点击邮箱中的激活连接进行激活</p><blockquote><p>这里需要使用MailUtil工具类来发送邮件</p><p>需要设置发信的邮箱的账号以及授权码 </p><p>修改put中的邮箱的类型</p><p><img src="https://blog.chasingwind.top/1565330567948.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330567948.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>这里是测试  使用sendMail的方法</p><p><img src="https://blog.chasingwind.top/1565330642777.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330642777.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>用户点击激活邮件进行激活</p><ul><li>用户激活其实就是修改用户表中的status为‘Y’</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1565330761700.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330761700.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>激活的分析图</p><p><img src="https://blog.chasingwind.top/1565330772738.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330772738.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>service中的方法</p><p><img src="https://blog.chasingwind.top/1565330908977.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330908977.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>dao中的方法</p><p><img src="https://blog.chasingwind.top/1565330969592.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565330969592.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>用户点击邮箱中的链接进行激活的操作</p><blockquote><p><img src="https://blog.chasingwind.top/1565331107792.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331107792.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Service中的active方法  通过用户请求的唯一code值来判断是否是本人激活</p><p><img src="https://blog.chasingwind.top/1565331163586.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331163586.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>UserDao中的查找code的方法  一次来判断用户请求中的code是否等于用户数据库中的code</p><p><img src="https://blog.chasingwind.top/1565331244271.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331244271.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ol><li><p>前台代码</p><blockquote><p><img src="https://blog.chasingwind.top/1565331383951.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331383951.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>后台代码</p><blockquote><p>LoginServlet</p><p><img src="https://blog.chasingwind.top/1565331443226.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331443226.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>通过用户名和密码来判断用户输入的信息正确与否从而进行登录</p><p><img src="https://blog.chasingwind.top/1565331508570.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331508570.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Dao中的方法</p><p><img src="https://blog.chasingwind.top/1565331577454.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331577454.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>什么叫做登录了？session中有user对象。</p><p>实现步骤：</p><ol><li><p>访问servlet，将session销毁</p></li><li><p>跳转到登录页面</p><blockquote><p>header.html</p><p><img src="https://blog.chasingwind.top/1565331669908.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331669908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Servlet</p><p><img src="https://blog.chasingwind.top/1565331697856.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565331697856.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="功能优化"><a href="#功能优化" class="headerlink" title="功能优化"></a>功能优化</h2><ul><li><p>BaseServlet的抽取</p><ul><li><p>我们有很多个Servlet都是对用户的操作，可以将这些Servlet抽取出来，像Service一样，放在一个Service里面</p></li><li><p>减少Servlet的数量，现在是一个功能一个Servlet，将其优化为一个模块一个Servlet，<strong>相当于在数据库中一张表对应一个Servlet</strong>，在Servlet中提供不同的方法，完成用户的请求。</p><blockquote><p><img src="https://blog.chasingwind.top/1565353820734.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565353820734.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>UserServlet中的find和add方法 </p><blockquote><p>UserServlet继承BaseServlet  因为继承HttpServlet的话 只能使用HttpServlet中的doPost,doGet等的方法 </p><p>所以我们就可以利用BaseServlet作为”中间人”来实现既能有Servlet功能,又可以自定义方法的功能</p><p><img src="https://blog.chasingwind.top/1565354715493.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565354715493.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>BaseServlet继承自HttpServlet,并实现service方法</p><blockquote><p><img src="https://blog.chasingwind.top/1565354885652.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565354885652.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>当我们访问的时候路径user/add的时候,控制台的输出</p><blockquote><p>BaseServlet中的service方法被执行了….</p><p><img src="https://blog.chasingwind.top/1565354980856.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565354980856.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以,我们可以利用类似的做法来实现将Servlet统一到一个里面,通过service方法中分发方法来实现</p></blockquote></li></ul></li><li><p>在service（）中完成方法的分发</p><ul><li><p>在上面的测试中，可以看到我们访问的是<code>/user/add</code>，这样就执行了service的方法</p></li><li><p>所以我们可以拿到<code>/user/add</code>中的<code>add</code>，获取方法对象通过反射，来执行这个方法</p><blockquote><p><img src="https://blog.chasingwind.top/1565356335843.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565356335843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>当我们进行访问的时候发生了异常</p><blockquote><p>这个异常是因为方法的权限是protected造成的  反射获取不到   当然可以通过暴力反射  但是这样不安全  因为这样的话私有的方法也可以获取了 </p><p><img src="https://blog.chasingwind.top/1565356420772.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565356420772.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>将方法的权限修改成public</p><p><img src="https://blog.chasingwind.top/1565356867190.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565356867190.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565356885242.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565356885242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>测试</p><blockquote><p>我们分别去访问不同的add和find方法的时候</p><p><img src="https://blog.chasingwind.top/1565356954096.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565356954096.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565356974963.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565356974963.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Category</p><p><img src="https://blog.chasingwind.top/1565357041802.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565357041802.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565357061227.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565357061227.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>可见,通过方法的分发 可以很好地调用不同的方法(继承了BaseServlet)</p></li></ul></li><li><p>Servlet的整合</p><blockquote><p>就是将之前的各个Servlet中的代码放到一个方法中</p><p>比如之前的注册的功能</p><p><img src="https://blog.chasingwind.top/1565357998843.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565357998843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>同时不要忘记前端代码的路径的修改</p><blockquote><p><img src="https://blog.chasingwind.top/1565358201117.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565358201117.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>修改为</p><p><img src="https://blog.chasingwind.top/1565358227699.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565358227699.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>等等 ….之前的路径都需要进行修改…省略..</p></blockquote></li></ul><h2 id="分类展示"><a href="#分类展示" class="headerlink" title="分类展示"></a>分类展示</h2><ol><li><p>效果</p><blockquote><p><img src="https://blog.chasingwind.top/1565358717807.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565358717807.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1565358724210.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565358724210.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>代码实现</p><ol><li><p>后台代码</p><blockquote><p>CategoryDaoImpl</p><p><img src="https://blog.chasingwind.top/1565360372586.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565360372586.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>CategoryServiceImpl</p><p><img src="https://blog.chasingwind.top/1565360398952.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565360398952.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>CategoryServlet</p><p><img src="https://blog.chasingwind.top/1565360455224.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565360455224.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>优化序列化为json的操作</p><p>我们在BaseServlet中重写Jackson的writeValue以及WriteValueAsString方法</p><p><img src="https://blog.chasingwind.top/1565360553256.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565360553256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>前台代码</p><blockquote><p>header.html中的静态的</p><p><img src="https://blog.chasingwind.top/1565363536498.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565363536498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>通过ajax请求来获取</p><p><img src="https://blog.chasingwind.top/1565363602349.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565363602349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在浏览器中可以看到请求的数据</p><blockquote><p>可以看到findAll请求响应回来的数据</p><p><img src="https://blog.chasingwind.top/1565364122491.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565364122491.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>优化分析：缓存优化</p><ul><li><p>分析发现，分类的数据在每一次页面加载后都会重新请求数据库来加载，对数据库的压力比较大，而且分类的数据不会经常产生变化，所有可以使用redis来缓存这个数据。</p><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1565364403617.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565364403617.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现</p><blockquote><p>CategoryServiceImpl</p><p><img src="https://blog.chasingwind.top/1565366541349.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565366541349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>因为返回的是一个List集合的形式 而是用缓存查询出来的是一个set集合 所以需要将缓存中的数据进行转换为list</p></blockquote></li></ul></li></ol><h2 id="旅游路线分页展示"><a href="#旅游路线分页展示" class="headerlink" title="旅游路线分页展示"></a>旅游路线分页展示</h2><ol><li><p>旅游分类和旅游线路的关系</p><blockquote><p>数据库中的两个表的关系  一对多</p><p><img src="https://blog.chasingwind.top/1565405048381.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565405048381.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>当我们点击不同的条目的时候,显示不同的商品信息</p><blockquote><p><img src="https://blog.chasingwind.top/1565405306498.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565405306498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>上面分析到  路线分类中的cid可以对应多个商品信息</p><p>所以在我们请求的时候  需要在请求的路径中添加cid</p><p><img src="https://blog.chasingwind.top/1565405504186.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565405504186.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565405592084.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565405592084.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>cid都是0?</p><p>因为我们在缓存中zrange的时候没有存储scores</p><p>可以使用zrangeWithScores  并且在封装的时候需要存储scores</p><p><img src="https://blog.chasingwind.top/1565406144551.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565406144551.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在Tuple类中  分别有对应的获取element和score的方法</p><p><img src="https://blog.chasingwind.top/1565406189506.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565406189506.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565406227448.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565406227448.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这样就取出来了对应的cid</p><p><img src="https://blog.chasingwind.top/1565406313655.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565406313655.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>如何在head.html中将cid取出来</p><blockquote><p>search 属性是一个可读可写的字符串，<strong>可设置或返回当前 URL 的查询部分（问号 ? 之后的部分）</strong>。</p><p><img src="https://blog.chasingwind.top/1565411689042.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565411689042.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这样就将请求中的cid取出来了</p></blockquote></li></ol><h3 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h3><ol><li><p>分页展示旅游线路的数据</p><ol><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1565411997668.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565411997668.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>PageBean对象</p><blockquote><p>将服务器端的数据封装成PageBean对象发送给浏览器</p><p><img src="https://blog.chasingwind.top/1565415686079.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565415686079.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>RouteServlet</p><blockquote><p>完成浏览器请求的数据的处理  以及将服务器中查询到的数据进行封装展示给浏览器</p><p><img src="https://blog.chasingwind.top/1565415774465.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565415774465.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>RouteService</p><blockquote><p>将在dao中查询的数据封装成PageBean返回给Servlet</p><p>因为客户端浏览器请求的URL中已经有cid,currentPage和PageSize的数据了 所以我们需要根据这些参数来计算出PageBean中未有的参数totalCount以及每页的数据list</p><p><img src="https://blog.chasingwind.top/1565415878960.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565415878960.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>RouteDao</p><blockquote><p>根据查询数据库的数据来返回给Service层需要的totalCount以及每页的数据的集合</p><p><img src="https://blog.chasingwind.top/1565415953192.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565415953192.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>我们通过给浏览器指定的URL的参数的形式来查看Servlet给浏览器返回的JSON数据</p><blockquote><p><img src="https://blog.chasingwind.top/1565416180870.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565416180870.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>JSON解析器查看</p><p><img src="https://blog.chasingwind.top/1565416241294.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565416241294.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h3 id="前台代码"><a href="#前台代码" class="headerlink" title="前台代码"></a>前台代码</h3><ol><li><p>首先完成页面内容以及页码的展示</p><blockquote><p>JavaScript</p><p><img src="https://blog.chasingwind.top/1565424196231.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565424196231.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>页面</p><p><img src="https://blog.chasingwind.top/1565424215805.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565424215805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>显示当前页的效果</p><blockquote><p><img src="https://blog.chasingwind.top/1565424542807.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565424542807.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565424551263.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565424551263.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>首页以及上一页的效果,下一页以及最后一页</p><blockquote><p>首页以及上一页</p><p><img src="https://blog.chasingwind.top/1565426341540.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565426341540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>下一页以及最后一页</p><p><img src="https://blog.chasingwind.top/1565426836872.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565426836872.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意字符串的拼接</p></blockquote></li><li><p>页码的优化</p><blockquote><p>需求</p><p><img src="https://blog.chasingwind.top/1565427176880.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565427176880.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>分页工具条的前5后4</p><p><img src="https://blog.chasingwind.top/1565428204834.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565428204834.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>效果</p><p><img src="https://blog.chasingwind.top/1565428314881.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565428314881.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565428327065.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565428327065.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565428335132.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565428335132.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>下一页跳转到页面顶部</p><blockquote><p>s在页面拼接完成后 </p><p><img src="https://blog.chasingwind.top/1565428279558.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565428279558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="旅游线路搜索"><a href="#旅游线路搜索" class="headerlink" title="旅游线路搜索"></a>旅游线路搜索</h2><ol><li><p>效果</p><blockquote><p><img src="https://blog.chasingwind.top/1565428453737.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565428453737.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查询参数的传递</p><blockquote><p>在header.html中完成输入数据的获取 以及 路径的跳转到route_list.html</p><p><img src="https://blog.chasingwind.top/1565429957376.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565429957376.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在route_list中获取请求路径中的数据</p><p><img src="https://blog.chasingwind.top/1565430409089.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565430409089.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>–</p><p>这样我们就拿到了搜索的数据</p><p>后面我们就可以使用这些数据发送到服务器中,去查询数据库获取我们需要的数据</p></blockquote></li><li><p>服务器端的代码的编写</p><blockquote><p>首先 大概的情况就是 </p><p>客户端请求的URL中可能会出现的情况\</p><p>1 只有cid</p><p>2 有cid和rname</p><p>所以我们需要将rname也放在查询的参数中</p></blockquote><blockquote><p>在RouteServlet中</p><p><img src="https://blog.chasingwind.top/1565431098070.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565431098070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565431123284.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565431123284.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>在service中</p><p><img src="https://blog.chasingwind.top/1565431162032.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565431162032.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565431180931.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565431180931.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>在dao中</p><p>我们需要根据请求参数的不同来查询不同的sql  </p><p>动态sql实现</p><p><img src="https://blog.chasingwind.top/1565431772256.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565431772256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565432315621.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565432315621.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>这样我们就查询到了数据</p><p><img src="https://blog.chasingwind.top/1565432648357.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565432648357.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>前台代码</p><blockquote><p>这里再进行参数的传递的时候  需要传递rname</p><p><img src="https://blog.chasingwind.top/1565446629486.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565446629486.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>并且需要完成分页的功能的话  需要对每个按钮中的load函数进行更新</p><p>特别注意这个拼接!!!!!</p><p><img src="https://blog.chasingwind.top/1565446708444.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565446708444.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565446738350.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565446738350.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1565446756880.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565446756880.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>这里还有一个问题  当我们在首页直接请求搜索的时候</p><blockquote><p>此时load函数中的第二个参数cid就是null</p><p><img src="https://blog.chasingwind.top/1565446849651.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565446849651.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在地址栏中的cid就是null</p><p><img src="https://blog.chasingwind.top/1565446835133.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565446835133.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>当传的参数为null的时候,那么进行类型转换的话 也会出现异常</p><p><img src="https://blog.chasingwind.top/1565446930537.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565446930537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>修改   让他不进行类型的转换</p><p><img src="https://blog.chasingwind.top/1565447012614.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565447012614.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="旅游线路详情页面"><a href="#旅游线路详情页面" class="headerlink" title="旅游线路详情页面"></a>旅游线路详情页面</h2><ol><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1565448027847.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565448027847.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565448040642.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565448040642.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Route类中的routeImgList存放的是详情页的图片</p><p><img src="https://blog.chasingwind.top/1565448665114.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565448665114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>数据库中表之间的关系</p><p><img src="https://blog.chasingwind.top/1565448756134.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565448756134.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>页面的跳转</p><blockquote><p>首先完成点击 查看详情 转到对应的页面</p><p><img src="https://blog.chasingwind.top/1565448428830.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565448428830.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>后台代码的编写</p><blockquote><p>我们需要的是Route的所有的数据(虽然可能并不会用到全部的数据)</p><p>首先,这是Route的数据</p><p><img src="https://blog.chasingwind.top/1565448665114.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565448665114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Servlet</p><p><img src="https://blog.chasingwind.top/1565453637034.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565453637034.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Service方法</p><p>route中存储的是Route对象中的所有的数据</p><p>但是后面的RouteImg以及Seller需要进行新的查询数据库的设置</p><p><img src="https://blog.chasingwind.top/1565453693831.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565453693831.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>RouteDaoImpl</p><p><img src="https://blog.chasingwind.top/1565453805023.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565453805023.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>RouteImgdaoImpl</p><p><img src="https://blog.chasingwind.top/1565453832456.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565453832456.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>SellerDaoImpl</p><p><img src="https://blog.chasingwind.top/1565453876046.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565453876046.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>然后将这些查询到的数据封装到route对象中  转换为json格式的数据</p><p>通过路径查询  可以得到数据</p><p><img src="https://blog.chasingwind.top/1565454019381.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565454019381.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>格式化后的json</p><p><img src="https://blog.chasingwind.top/1565454115330.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565454115330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>前台代码的编写</p><blockquote><p>route_detail.html页面加载完成后 </p><ol><li>获取rid(route_list.html页面跳转过来的)</li><li>发送Ajax请求</li><li>解析route对象的数据填充到html</li></ol></blockquote><blockquote><p>首先完成页面中数据部分的展示</p><p><img src="https://blog.chasingwind.top/1565455501638.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565455501638.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>图片部分的拼接</p><p>首先,页面是这样的</p><p><img src="https://blog.chasingwind.top/1565455685952.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565455685952.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>对应的html</p><p><img src="https://blog.chasingwind.top/1565455830225.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565455830225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>changeImg在toute_detail的上面</p><p><img src="https://blog.chasingwind.top/1565457231540.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565457231540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>效果</p><p><img src="https://blog.chasingwind.top/1565457287118.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565457287118.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="旅游线路收藏页面"><a href="#旅游线路收藏页面" class="headerlink" title="旅游线路收藏页面"></a>旅游线路收藏页面</h2><ol><li><p>分析</p><blockquote><p>表之间的关系  </p><p><img src="https://blog.chasingwind.top/1565497782660.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565497782660.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1565497797258.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565497797258.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>后台代码</p><blockquote><p>RouteServlet</p><p><img src="https://blog.chasingwind.top/1565499731297.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565499731297.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Service</p><p><img src="https://blog.chasingwind.top/1565499770553.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565499770553.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Dao</p><p><img src="https://blog.chasingwind.top/1565499796865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565499796865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>前台代码</p><blockquote><p>route_detail.html</p><p>改变收藏按钮的状态</p><p><img src="https://blog.chasingwind.top/1565502043585.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565502043585.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>收藏次数的动态展示</p><p>在RouteService中添加</p><p><img src="https://blog.chasingwind.top/1565502933203.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565502933203.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>dao</p><p><img src="https://blog.chasingwind.top/1565502963563.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565502963563.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>页面展示</p><p><img src="https://blog.chasingwind.top/1565502993820.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565502993820.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>点击按钮收藏线路</p><blockquote><p>分析</p><p><img src="https://blog.chasingwind.top/1565503165526.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565503165526.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>RouteServlet<br><img src="https://blog.chasingwind.top/1565504068761.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565504068761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>favouriteService</p><p><img src="https://blog.chasingwind.top/1565504112287.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565504112287.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>favouriteDao</p><p><img src="https://blog.chasingwind.top/1565504140530.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565504140530.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>前台代码</p><p><img src="https://blog.chasingwind.top/1565507352884.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565507352884.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>小优化</p><p><img src="https://blog.chasingwind.top/1565507392709.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565507392709.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven基础</title>
      <link href="2019/08/06/Maven%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/06/Maven%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><p>什么是Maven?</p><ul><li>Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。</li></ul></li><li><p>Maven能解决的问题</p><ul><li>能帮你构建工程，管理 jar 包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站 点</li></ul></li><li><p>Maven的两个核心特性</p><ol><li><strong>依赖管理</strong>：Maven对jar包的管理过程<ul><li>传统的项目jar包需要放在工程中，而在Maven项目中的jar包，是放在jar包仓库中，Maven工程通过pom.xml中的jar包的坐标，从而在Maven工程中使用jar包</li></ul></li><li><strong>一键构建</strong>：项目的整个构建过程，Maven可以一键完成<ul><li>项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven 进行管理，这个过程称为构建，一键构建是指Maven项目通过命令,可以一键完成上面的构建过程。</li></ul></li></ol></li><li><p>Maven安装</p><ol><li><p>解压即可</p><blockquote><p>目录结构</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098035638.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098035638.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>bin:存放了 maven 的命令，比如我们前面用到的mvn tomcat:run </p><p>boot:存放了一些 maven 本身的引导程序，如类加载器等 </p><p>conf:存放了 maven 的一些配置文件，如 setting.xml 文件 </p><p>lib:存放了 maven 本身运行所需的一些 jar 包 至此我们的 maven 软件就可以使用了，前提是你的电脑上之前已经安装并配置好了 JDK。 </p></blockquote></li><li><p>进行环境变量的配置</p><blockquote><p>新建系统环境变量</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098213561.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098213561.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在Path中新建环境变量</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098314120.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098314120.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在cmd中输入<code>mvn -v</code>查看版本信息,有的话就表明成功了</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098416274.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565098416274.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Maven仓库的种类以及仓库之间的关系</p><ul><li><p>当我们启动Maven项目的时候,会优先去本地仓库中寻找jar包，如果本地仓库没有jar包的话,会去联网中央仓库下载jar包，如果本地仓库没有需要的jar包,并且没有联网的话,就会报错</p></li><li><p>本地仓库：系统用户/.m2/repository</p><blockquote><p>C:\Users\WUXINHHUA.m2\repository</p></blockquote></li><li><p>中央仓库</p><blockquote><p>里面放置了几乎所有的开源的jar包</p></blockquote></li><li><p>远程仓库(私服)</p><blockquote><p>公司用的jar包的仓库,没有的话也会去中央仓库下载，当然也可以从本地仓库上传</p></blockquote></li></ul></li><li><p>本地仓库的配置</p><ul><li><p>因为maven默认的本地仓库是在C盘的，可以通过配置把他放在其他的盘</p><blockquote><p>在settings.xml中进行本地仓库的配置并把需要的jar包放进去</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565099296537.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565099296537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>Maven标准目录结构</p><blockquote><p>src/main/java —— 存放项目的.java 文件 </p><p>src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件 src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类 src/test/resources —— 测试资源文件 </p><p>target —— 项目输出位置，编译后的class 文件会输出到此目录</p><p>pom.xml——maven 项目核心配置文件 </p><p>注意：如果是普通的 java 项目，那么就没有webapp 目录。 </p></blockquote></li><li><p>Maven中常用的命令</p><ol><li>mvn clean : 清理已经编译过的信息,会删除target目录</li><li>mvn compile :  将src/main/java 下的文件编译为 class 文件输出到 target 目录下。 </li><li>mvn test : test 是 maven 工程的测试命令  mvn test，会执行src/test/java下的单元测试类。 同时编译java目录下的代码以及tset目录下的代码</li><li>mvn package : 将项目打包</li><li>mvn install : install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。 </li></ol><blockquote><p>上面的顺序中,当后面的命令执行时，前面的操作过程也都会自动执行， </p></blockquote></li><li><p>Maven生命周期</p><ol><li>清理生命周期 : mvn clean,清理项目编译信息</li><li>默认生命周期 : mvn compile ，编译；mvn test，测试；mvn package，打包；mvn install，安装；mvn deploy，发布。</li><li>站点生命周期</li></ol></li><li><p>Maven项目模型</p><blockquote><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565101064395.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565101064395.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在IDEA中集成Maven</p><blockquote><p>一定要在这个里面进行设置</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565104221471.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565104221471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>设置Maven以及Maven仓库</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565101332865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565101332865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置本地仓库优先</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565104287996.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565104287996.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>新建Servlet的时候,需要在pom.xml中添加依赖</p><blockquote><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565144849592.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565144849592.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>关于scope</p><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565144973344.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565144973344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>tomcat7默认使用的是tomcat6  需要在pom.xml中进行配置tomcat7 运行的时候使用tomcat7:run</p><blockquote><p><img src="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565144875199.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Maven%E5%9F%BA%E7%A1%80/1565144875199.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>并且在运行的时候使用<code>tomcat7:run</code></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="2019/08/04/Redis/"/>
      <url>2019/08/04/Redis/</url>
      
        <content type="html"><![CDATA[<p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，同时是一款NOSQL(Not Only SQL)系列的非关系型数据库。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><p>概念: Redis是一款高性能的<strong>NOSQL(Not Only SQL)系列的非关系型数据库</strong></p><blockquote><p>关系型数据库和非关系型数据库(NOSQL)</p><p><img src="https://blog.chasingwind.top/1564925605019.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564925605019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>当我们查询一些不是经常改变的数据的时候 ,去请求数据库的查询是比较耗时的,</p><p>所以可以用缓存的思想来解决这个问题</p><p><img src="https://blog.chasingwind.top/1564925682387.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564925682387.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>缓存的选择有很多</p><p>比如说 ,可以在内存中开辟空间 存储map集合(JVM中) , 但是这个问题就是他<strong>只能用在当前的项目中</strong></p><p>分布式缓存,<strong>NOSQL数据存储在内存中,而且可以部署在独立的机器上</strong>,刚好符合上面的要求 ,Redis用来做缓存就很合适</p></blockquote></li><li><p>一些相关的概念</p><ol><li><p>什么是NOSQL</p><blockquote><p>NOSQL(NOSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，<strong>泛指非关系型的数据库</strong>。</p><hr><p>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p></blockquote></li><li><p>NOSQL非关系型数据库和关系型数据库比较</p><blockquote><p>优点: </p><ol><li>成本：NOSQL数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li><li>查询速度：<strong>NOSQL数据库将数据存储于缓存之中</strong>，<strong>关系型数据库将数据存储在硬盘中</strong>，自然查询速度远不及NOSQL数据库。</li><li>存储数据的格式：NOSQL的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li><li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</li></ol><hr><p>缺点 : </p><ol><li>维护的工具和资料有限，因为NOSQL是属于新的技术，不能和关系型数据库10几年的技术同日而语。</li><li>不提供对SQL的支持，如果不支持SQL这样的工业标准，将产生一定用户的学习和使用成本。</li></ol></blockquote></li><li><p>关系型数据库和非关系型数据库的关系</p><blockquote><p>关系型数据库与NOSQL数据库并非对立而是<strong>互补的关系</strong>，即通常情况下使用关系型数据库，在适合使用NOSQL的时候使用NOSQL数据库，让NOSQL数据库对关系型数据库的不足进行弥补。</p><hr><p>一般会将<strong>数据存储在关系型数据库中</strong>，在<strong>NOSQL数据库中备份存储关系型数据库的数据</strong></p></blockquote></li></ol></li><li><p>主流的NOSQL产品</p><ul><li>键值(Key-Value)存储数据库<ul><li>相关产品 : Tokyo Cabinet/Tyrant、<strong>Redis</strong>、Voldemort、Berkeley DB</li><li>典型应用 : 内容缓存，主要用于处理大量数据的高访问负载。 </li><li>数据模型： 一系列键值对</li><li>优势： 快速查询</li><li>劣势： 存储的数据缺少结构化</li></ul></li><li>列存储数据库<ul><li>相关产品：Cassandra, HBase, Riak</li><li>典型应用：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li><li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li><li>劣势：功能相对局限</li></ul></li><li>文档型数据库<ul><li>相关产品：CouchDB、MongoDB</li><li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li><li>数据模型： 一系列键值对</li><li>优势：数据结构要求不严格</li><li>劣势： 查询性能不高，而且缺乏统一的查询语法</li></ul></li><li>图形(Graph)数据库<ul><li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li><li>典型应用：社交网络</li><li>数据模型：图结构</li><li>优势：利用图结构相关算法。</li><li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</li></ul></li></ul></li><li><p>什么是Redis?</p><ul><li>Redis是用C语言开发的一个<strong>开源的高性能键值对（key-value）数据库</strong>，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止<strong>Redis支持的键值数据类型</strong>如下：<ul><li>字符串类型 string</li><li>哈希类型 hash</li><li>列表类型 list</li><li>集合类型 set</li><li>有序集合类型 sortedset</li></ul></li><li><strong>Redis的应用场景</strong><ul><li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li><li>聊天室的在线好友列表</li><li>任务队列。（秒杀、抢购、12306等等）</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理（可以精确到毫秒）</li><li>分布式集群架构中的session分离</li></ul></li></ul></li></ol><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ol><li><p>官网 ：<a href="https://redis.io/">Redis官网</a></p></li><li><p>中文网：<a href="https://www.redis.net.cn/">Redis中文网</a></p></li><li><p>解压即可使用</p><ul><li>redis.windows.conf：配置文件</li><li>redis-cli.exe：redis的客户端</li><li>redis-server.exe：redis服务器端</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564927291743.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564927291743.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用</p><ol><li><p>双击redis-server.exe 启动Redis服务器端</p><blockquote><p>可以看到Redis的端口号是6379</p><p>进程ID为2960</p><p><img src="https://blog.chasingwind.top/1564927436692.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564927436692.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>双击redis-cli.exe 打开本地的客户端  这样客户端就连接上了服务器端</p><blockquote><p><img src="https://blog.chasingwind.top/1564928112898.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564928112898.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h2><ol><li><p>Redis的数据结构 : key,value格式的数据 , 其中key都是字符串，value有5种不同的数据结构</p><ul><li><p>value的数据结构：</p><ol><li>字符串类型 string</li><li>哈希类型 hash ： 相当于map格式 (key,value) </li><li>列表类型 list ： 相当于LinkedList格式。支持重复元素</li><li>集合类型 set  ： 不允许重复元素</li><li>有序集合类型 sortedset：不允许重复元素，且元素有顺序</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564928450204.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564928450204.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>命令行的操作</p><ol><li><p>字符串类型 string</p><ol><li>存储 : <code>set key value</code></li><li>获取 : <code>get key</code></li><li>删除 : <code>del key</code></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564931065287.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564931065287.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>哈希类型</p><ol><li>存储 : <code>hset key field(字段) value</code></li><li>获取 : <ol><li><code>hget key field</code>: 获取指定的field对应的值</li><li><code>hgetall key</code>：获取所有的field和value</li></ol></li><li>删除 : <code>hdel key field</code></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564931631733.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564931631733.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>列表类型 list : <strong>允许重复元素</strong>, 可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><ol><li>添加<ol><li><code>lpush key value</code>: 将元素加入列表左表</li><li><code>rpush key value</code>：将元素加入列表右边</li></ol></li><li>获取<ul><li><code>lrange key start end</code> ：范围获取</li><li><code>lrange key 0 -1</code> : 获取列表中的所有元素</li></ul></li><li>删除<ul><li><code>lpop key</code>： 删除列表<strong>最左边</strong>的元素，并将元素返回</li><li><code>rpop key</code>： 删除列表<strong>最右边</strong>的元素，并将元素返回</li></ul></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564932236612.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564932236612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>重复元素</p><p><img src="https://blog.chasingwind.top/1564932410731.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564932410731.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>集合类型 set : <strong>不允许存储重复元素</strong> <strong>不保证顺序</strong>,也就是存入和取出的顺序不一致</p><ol><li>存储 : <code>sadd key value</code></li><li>获取 : <code>smembers key</code> : 获取set集合中的所有的元素</li><li>删除 : <code>srem key value</code> : 删除set集合中的某个元素</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564932883029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564932883029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>有序集合类型 sortedset : <strong>不允许存储重复元素，且元素有顺序。</strong></p><ul><li>保证有序 ：<strong>每个元素都会关联一个double类型的分数</strong>。redis正是通过score的值来为集合中的成员进行从小到大的排序。</li></ul><ol><li>存储 : <code>zadd key score value </code>, 根据score的大小来进行排序</li><li>获取 : <code>zrange key start end [withscores]</code></li><li>删除 : <code>zrem key value</code></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564933497623.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564933497623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>通用命令</p><ol><li><code>keys *</code> : 查询所有的键  ,这个*可以替换为需要的正则表达式</li><li><code>type  key</code> : 获取键对应的value的类型</li><li><code>del key</code> : 删除指定的key value</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564933762946.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564933762946.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="持久化操作"><a href="#持久化操作" class="headerlink" title="持久化操作"></a>持久化操作</h2><ol><li><p>Redis是一个<strong>内存数据库</strong>，当Redis服务器重启，或者电脑重启了，那么数据就没有了。我们可以将Redis中的数据持久化保存到硬盘的文件中。这样当我们重启Redis后，会自动加载文件中的数据，进行恢复。</p></li><li><p>Redis持久化机制</p><ol><li><p>RDB：默认方式，不需要进行配置，默认使用这种机制（<strong>开销较小</strong>）</p><ul><li>在一定的间隔时间中，检测key的变化情况,然后持久化</li></ul><blockquote><p>在redis.windwos.conf文件中可以进行配置 , (图中的是默认的)</p><p><img src="https://blog.chasingwind.top/1564934531208.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564934531208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>比如说<code> save 300 10</code>的意思就是</p><p>在<strong>接下来的300秒key发生了10次变化</strong>,那么<strong>就在300s后进行一次持久化存储</strong></p><hr><p>如果将配置文件修改了  就需要在启动的时候指定配置文件的名称</p><p><code>redis-server.exe redis.windows.conf    </code></p><p><img src="https://blog.chasingwind.top/1564934849007.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564934849007.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564934912838.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564934912838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当达到持久化的条件的时候  会在目录中生成<code>.rpb</code>的文件</p><p><img src="https://blog.chasingwind.top/1564935020325.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564935020325.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>关闭服务器 重启就会加载之前的rpb文件进行恢复的操作</p></blockquote></li><li><p>AOF：日志记录的方式（<strong>开销较大</strong>）</p><ul><li>可以记录每一条命令的操作,可以每一次命令操作后,持久化数据</li></ul><blockquote><ol><li><p>编辑redis.windwos.conf文件</p><p>appendonly no（关闭AOF） –&gt; appendonly yes （开启AOF）</p><p><code># appendfsync always </code>： 每一次操作都进行持久化</p><p><code>appendfsync everysec ： 每隔一秒进行一次持久化</code></p><p><code># appendfsync no     ： 不进行持久化</code></p></li></ol></blockquote></li></ol></li></ol><h2 id="使用Java客户端操作Redis-Jedis"><a href="#使用Java客户端操作Redis-Jedis" class="headerlink" title="使用Java客户端操作Redis(Jedis)"></a>使用Java客户端操作Redis(Jedis)</h2><ol><li><p>Jedis : 一款Java操作Redis数据库的工具，作用可以类比MySQL中的JDBC</p></li><li><p>使用步骤：</p><ol><li>下载Jedis的相关的jar包<ol><li>commons-pool2-2.3.jar</li><li>jedis-2.7.0.jar</li></ol></li><li>使用</li></ol><blockquote><p>首先,需要确保你的数据库服务器是开着的</p><p><img src="https://blog.chasingwind.top/1564936863326.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564936863326.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>刚开始是没有数据的,执行过后的结果</p><p><img src="https://blog.chasingwind.top/1564936944384.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564936944384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用Jedis来操作Redis中的各种数据结构</p><ol><li><p>字符串类型 string</p><ul><li>set</li><li>get</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564984526243.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564984526243.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>setex()方法一般我们可以用在验证码</p></blockquote></li><li><p>哈希类型 hash ： map格式  </p><ul><li>hset</li><li>hget</li><li>hgetAll</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564985079358.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564985079358.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564985092043.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564985092043.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>列表类型 list ： linkedlist格式。支持重复元素</p><ul><li>lpush/rpush</li><li>lpop/rpop</li><li>lrange start end : 范围获取</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564985826098.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564985826098.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564985838206.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564985838206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>集合类型 set  ： 不允许重复元素</p><ul><li>sadd</li><li>smembers : 获取所有元素</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564987504084.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564987504084.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564987011093.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564987011093.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>有序集合类型 sortedset：不允许重复元素，且元素有顺序</p><ul><li>zadd</li><li>zrange</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564987431069.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564987431069.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564987450592.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564987450592.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Jedis的连接池(自带的) : JedisPool  <strong>对Jedis的连接有更好的复用和管理</strong></p><ol><li><p>使用</p><ol><li>创建JedisPool连接池对象</li><li>调用方法 getResource()方法获取连接</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564987944207.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564987944207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意,这里的close()不是关流 ,而是将连接归还到连接池中</p><hr><p>当然 我们可以进行连接池的一些参数的配置 在创建连接池的时候,将配置对象传入构造函数中</p><p><img src="https://blog.chasingwind.top/1564988276101.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564988276101.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置的参数参考</p><pre><code class="properties">#最大活动对象数     redis.pool.maxTotal=1000    #最大能够保持idel状态的对象数      redis.pool.maxIdle=100  #最小能够保持idel状态的对象数   redis.pool.minIdle=50    #当池内没有返回对象时，最大等待时间    redis.pool.maxWaitMillis=10000    #当调用borrow Object方法时，是否进行有效性检查    redis.pool.testOnBorrow=true    #当调用return Object方法时，是否进行有效性检查    redis.pool.testOnReturn=true  #“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1.  redis.pool.timeBetweenEvictionRunsMillis=30000  #向调用者输出“链接”对象时，是否检测它的空闲超时；  redis.pool.testWhileIdle=true  # 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3.  redis.pool.numTestsPerEvictionRun=50  #redis服务器的IP    redis.ip=xxxxxx  #redis服务器的Port    redis1.port=6379  </code></pre></blockquote></li></ol></li><li><p>Jedis连接池的工具类</p><blockquote><p>JedisPoolUtils</p><p>配置文件</p><p><img src="https://blog.chasingwind.top/1564989899374.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564989899374.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>工具类</p><p><img src="https://blog.chasingwind.top/1564990234978.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564990234978.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用工具类来获取连接池中的连接  这样我们就不需要进行配置了 </p><p>直接使用工具类中的方法来获取连接就行了</p><p><img src="https://blog.chasingwind.top/1564990274902.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564990274902.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li><p>需求</p><ol><li>提供index.html页面，页面中有一个省份 下拉列表</li><li>当 页面加载完成后 发送ajax请求，加载所有省份</li></ol></li><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1565016525407.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565016525407.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现</p><ol><li><p>数据库环境搭建</p><blockquote><p><img src="https://blog.chasingwind.top/1564993501327.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564993501327.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>导入相关的jar包以及配置文件</p><blockquote><p>这个问题碰到好几次了 ,就是druid.properties的问题</p><p>需要删除重新建立  别去复制内容  具体原因我也不知道为啥(找了我好久的)</p><hr><p>Servlet</p><p><img src="https://blog.chasingwind.top/1565016227044.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565016227044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Service层调用dao层</p><p><img src="https://blog.chasingwind.top/1565016264223.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565016264223.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>dao层</p><p><img src="https://blog.chasingwind.top/1565016292363.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565016292363.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>index.html</p><p><img src="https://blog.chasingwind.top/1565016364911.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565016364911.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意内容的拼接</p></blockquote></li><li><p>案例存在的问题 : 这里的数据是不经常发生变化的, 每一次去请求数据库耗时比较长 , 可以使用缓存解决</p><ul><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1565016555228.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565016555228.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><blockquote><p>使用缓存的方法</p><p><img src="https://blog.chasingwind.top/1565019987923.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565019987923.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>servlet中调用该方法</p><p><img src="https://blog.chasingwind.top/1565020031792.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1565020031792.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在这里给自己挖了个坑</p><p>就是之前代码出错把province中存储了”province_json”字符串 ,所以redis中是有数据的  , 一直获取不到正确的格式….  删除数据库中的内容就好了 </p><p>所以 一定要注意存储的时候province_json本来就是字符串了  别加引号</p></blockquote></li></ol></li><li><p>注意</p><ul><li>使用redis缓存一些不经常发生变化的数据。<ul><li>数据库的表执行 增删改的相关操作，需要将redis缓存数据删除，再次存入</li><li>在service对应的增删改方法中，将redis数据删除。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax和JSON</title>
      <link href="2019/08/04/Ajax%E5%92%8CJSON/"/>
      <url>2019/08/04/Ajax%E5%92%8CJSON/</url>
      
        <content type="html"><![CDATA[<p>Ajax是指一种创建交互式网页应用的网页开发技术，在无需重新加载整个网页的情况下，能够更新部分网页的技术。JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。</p><a id="more"></a><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><ol><li><p>概念：Ajax 即“<strong>Asynchronous</strong> Javascript And XML”（<strong>异步的</strong> JavaScript 和 XML），是指一种创建交互式应用的网页开发技术。</p><ul><li><p>同步和异步：建立在客户端和服务器端相互通信的基础上</p><ol><li>同步：客户端必须等待服务器端的响应。在<strong>等待的期间客户端不能做其他操作。</strong></li><li>异步：客户端不需要等待服务器端的响应。在<strong>服务器处理请求的过程中，客户端可以进行其他的操作。</strong></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564849883914.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564849883914.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>Ajax的特点</p><ol><li><p>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p></li><li><p><strong>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新</strong>。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p></li><li><p>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p><blockquote><p>实现上面的特点就是<strong>使用异步的方式</strong>进行客户端与服务器之间的请求的</p></blockquote></li></ol></li><li><p>实现方式</p><ol><li><p>原生JS实现方式(了解)</p><blockquote><p>通过JS的方式实现异步  这里主要参考W3School   </p><p><img src="https://blog.chasingwind.top/1564852375686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564852375686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>为了体现同步和异步的差别 我们让线程sleep 5秒来<strong>模拟服务器处理请求的时间</strong></p><p><img src="https://blog.chasingwind.top/1564852480894.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564852480894.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>异步</strong>的情况下  当我们<strong>点击按钮之后,立即点击输入框是可以获取焦点的</strong></p><p><img src="https://blog.chasingwind.top/1564852529761.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564852529761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><strong>同步</strong>的方式下, <strong>当我们点击按钮之后,线程睡眠的5秒内</strong>,<strong>点击输入框无法获取焦点</strong></p><p><img src="https://blog.chasingwind.top/1564852682144.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564852682144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>jQeury实现方式</p><ol><li><p><code>$.ajax(&#123;键值对,键值对...&#125;)</code></p><blockquote><p>jQuery文档</p><p><img src="https://blog.chasingwind.top/1564887058004.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564887058004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564887159283.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564887159283.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564887204435.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564887204435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564887409427.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564887409427.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>回调方法中的参数data是服务器返回的数据</p><p>常用的键值对</p><p>注意,每个键值对之间需要用<code>,</code>隔开,最后一个不用写逗号</p><p><img src="https://blog.chasingwind.top/1564889610152.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564889610152.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>$.get()</code> : 用来发送get请求</p><ul><li><p>语法: <code>$.get(url, [data], [callback], [type])</code> : 后面3个参数是可选的</p></li><li><p>参数</p><ul><li>url：请求路径</li><li>data：请求参数</li><li>callback：回调函数</li><li>type：服务器响应结果的类型</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564922809002.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564922809002.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564890168934.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564890168934.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol start="3"><li><p><code>$.post()</code>: 用来发送post请求</p><ul><li>语法 : <code>$.post(url, [data], [callback], [type])</code></li></ul></li></ol><ul><li><p>参数与get的相同</p><blockquote><p><img src="https://blog.chasingwind.top/1564890260869.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564890260869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>请求的参数data绑定在请求体中</p></blockquote></li></ul></li></ol></li></ol></li></ol><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ol><li><p>概念 : JSON (JavaScript Object Notation, <strong>JavaScript对象表示法</strong>) 是一种轻量级的数据交换格式</p><blockquote><p>在Java中,我们表示一个对象</p><pre><code class="java">Person p = new Person();p.setName(&quot;zhangsan&quot;);p.setAge(23);p.setGender(&quot;男&quot;);</code></pre><p>而在JavaScript中,我们可以用JSON来表示对象</p><pre><code class="javascript">var p = &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;;</code></pre></blockquote></li><li><p>JSON的作用</p><ol><li>可以用来表示JS对象</li><li>JSON现在多用于存储和交换文本信息,进行数据的传输</li><li>JSON 比 XML 更小、更快，更易解析。</li></ol></li><li><p>JSON语法</p><ol><li><p>基本规则</p><blockquote><ol><li>JSON数据由键值对构成<ul><li><strong>键</strong>用引号(单双都可以),也可以不使用引号</li><li><strong>值</strong>的取值类型<ol><li>数字</li><li>字符串(双引号中)</li><li>逻辑值: true/false</li><li>数组(<code>[]</code>中) : <ul><li>比如 : {“persons” : [{“name”:”zhangsan”,”age”:23},{“name”:”lisi”,”age”:23}]} </li></ul></li><li>JSON对象(<code>&#123;&#125;</code>中)</li><li>null</li></ol></li></ul></li><li>多对键值对之间用<code>,</code>分割</li><li><code>&#123;&#125;</code>保存对象</li><li><code>[]</code>保存数组</li></ol><p><img src="https://blog.chasingwind.top/1564892501222.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564892501222.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>获取JSON中的数据</p><ol><li><p>JSON对象.键名</p></li><li><p>JSON对象[“键名”]</p><blockquote><p><img src="https://blog.chasingwind.top/1564892772419.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564892772419.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>数组对象[索引]</p><blockquote><p><img src="https://blog.chasingwind.top/1564892866713.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564892866713.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564893010546.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564893010546.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>遍历</p><ul><li><p>语法: <code>for(... in ...)</code></p><blockquote><p>对基本格式中的键值对进行遍历</p><p><img src="https://blog.chasingwind.top/1564893533764.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564893533764.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>对数组进行遍历  双层for循环</p><p><img src="https://blog.chasingwind.top/1564893770573.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564893770573.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol></li></ol></li><li><p>JSON数据和Java对象的相互转换</p><ul><li><p>为什么要将数据进行转换?</p><ul><li>因为JSON数据经常在客户端与服务器端作为数据的载体,服务器端需要将JSON中的数据取出来在程序中转换为Java对象进行使用,并且还可以将Java对象转换为JSON给客户端使用</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564901395312.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564901395312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>JSON解析器 : jackson</p></li><li><p>JSON数据转换为Java对象(了解)</p><ol><li><p>导入jackson的jar包</p></li><li><p>创建jackson的核心对象 ObjectMapper</p></li><li><p>调用ObjectMapper的相关方法进行转换</p><blockquote><p>相关的方法</p><p>readValue(json字符串数据,class)</p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1564904584810.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564904584810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Java对象转换为JSON数据</p><ol><li><p>使用步骤</p><ol><li><p>导入jackson的jar包</p></li><li><p>创建jackson的核心对象 ObjectMapper</p></li><li><p>调用ObjectMapper的相关方法进行转换</p><blockquote><p>相关的方法</p><p><img src="https://blog.chasingwind.top/1564902488698.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564902488698.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>writeValue(参数1 , obj) :</p><p>参数1:</p><p>​     File : 将obj对象转换为JSON字符串，并保存到指定的文件中</p><p>​     Writer：将obj对象转换为JSON字符串，<strong>并将json数据填充到字符输出流中</strong></p><p>​    OutputStream：将obj对象转换为JSON字符串，<strong>并将json数据填充到字节输出流中</strong></p><p>​    writeValueAsString(obj) : 将obj对象转换为JSON字符串</p><hr><p>writeValueAsString</p><p><img src="https://blog.chasingwind.top/1564902834990.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564902834990.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ul></li><li><p>注解(在对应的属性或者set方法上面添加注解)</p><pre><code> 1. @JsonIgnore：排除属性。   2. @JsonFormat：属性值的格式化      &gt; ![](https://blog.chasingwind.top/1564903464694.png)    &gt;    &gt; ----    &gt;    &gt; 注解的添加    &gt;    &gt; ![](https://blog.chasingwind.top/1564903502701.png)</code></pre><ol start="3"><li><p>复杂的Java对象的转换</p><ol><li><p>List数组</p><blockquote><p>结果就是Person的对象数组</p><p><img src="https://blog.chasingwind.top/1564904001007.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564904001007.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Map : 对象的格式一致</p><blockquote><p><img src="https://blog.chasingwind.top/1564904214834.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564904214834.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h2 id="案例-检验用户名是否存在"><a href="#案例-检验用户名是否存在" class="headerlink" title="案例 : 检验用户名是否存在"></a>案例 : 检验用户名是否存在</h2><p>当我们去注册账号的时候,往往会检查用户名是否已经存在</p><p>其实就是 当输入框离焦之后,浏览器会发送一个ajax请求给服务器去查询用户名是否已经存在,服务器会相应消息</p><blockquote><p>当用户名已经存在的时候 , 服务器响应的消息</p><p><img src="https://blog.chasingwind.top/1564905405340.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564905405340.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>用户名不存在的时候响应的消息</p><p><img src="https://blog.chasingwind.top/1564905485820.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564905485820.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>前端代码</p><p><img src="https://blog.chasingwind.top/1564922482858.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564922482858.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>后台的代码  这里向服务器进行查询的代码进行了简化</p><p><img src="https://blog.chasingwind.top/1564922544693.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564922544693.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>界面</p><p>界面上的问题.  抓包已经显示了获取到了服务器响应的数据  但是页面却没有进行显示</p><p><img src="https://blog.chasingwind.top/1564922659453.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564922659453.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>存在的问题</p><p>响应消息中文乱码问题</p><p><img src="https://blog.chasingwind.top/1564922415959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564922415959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在doPost中设置响应的数据的方式</p><p><img src="https://blog.chasingwind.top/1564923173805.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564923173805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>问题2 : <strong>响应回来的数据是一个字符串  而并不是当作json文件进行处理的</strong></p><p>要想把文件作为json文件使用的话</p><p>处理方式1 : 在get方式中的type属性中设置为json</p><p><img src="https://blog.chasingwind.top/1564922887964.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564922887964.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>处理方式2: <strong>设置服务器的数据的响应格式</strong>为<code>response.setContentType(&quot;application/json;charset=utf-8&quot;);</code></p><p>json的MIME类型是<code>application/json</code></p></blockquote><blockquote><p>最后可用了</p><p>用户名可用的提示</p><p><img src="https://blog.chasingwind.top/1564923389565.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564923389565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>用户名已存在  不可用的提示</p><p><img src="https://blog.chasingwind.top/1564923507452.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564923507452.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery进阶</title>
      <link href="2019/08/03/jQuery%E8%BF%9B%E9%98%B6/"/>
      <url>2019/08/03/jQuery%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>jQuery是一个快速、简洁的JavaScript框架，jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。本节介绍了jQuery动画和遍历，事件绑定与切换以及一些案例。</p><a id="more"></a><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ol><li><p>默认显示和隐藏方式</p><ol><li><p><strong>show</strong>([speed,[easing],[fn]]) : 显示</p><ul><li>下面的所有方法的参数都是相同的</li><li>speed：<strong>动画的速度</strong>。<strong>三个预定义的值(“slow”,”normal”, “fast”</strong>)或<strong>表示动画时长的毫秒数值(如：1000)</strong></li><li>easing：用来<strong>指定切换效果</strong>，**默认是”swing”**，可用参数”linear”<ul><li>swing：动画执行时效果是 先慢，中间快，最后又慢</li><li>linear：动画执行时速度是匀速的</li></ul></li><li>fn：在动画完成时执行的函数，每个元素执行一次。（可不写）</li></ul></li><li><p><strong>hide</strong>([speed,[easing],[fn]]) : 隐藏</p></li><li><p><strong>toggle</strong>([speed],[easing],[fn]) : 切换显示和隐藏</p><blockquote><p><img src="https://blog.chasingwind.top/1564819781043.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564819781043.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p><strong>滑动</strong>显示和隐藏方式</p><ol><li><strong>slideDown</strong>([speed],[easing],[fn])</li><li><strong>slideUp</strong>([speed,[easing],[fn]])</li><li><strong>slideToggle</strong>([speed],[easing],[fn])</li></ol></li><li><p><strong>淡入淡出</strong>显示和隐藏方式</p><ol><li><strong>fadeIn</strong>([speed],[easing],[fn])</li><li><strong>fadeOut</strong>([speed],[easing],[fn])</li><li><strong>fadeToggle</strong>([speed,[easing],[fn]])</li></ol></li></ol><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol><li><p>js遍历</p><ul><li><p><code>for(初始化值; 循环结束条件;步长)</code></p><blockquote><p><img src="https://blog.chasingwind.top/1564820514957.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564820514957.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>jQuery遍历方式</p><ol><li><p><code>jQuery对象.each(callback)</code></p><ul><li><p><code>callback</code>就是一个回调函数,其实就是一个function()</p><blockquote><p><img src="https://blog.chasingwind.top/1564840492379.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564840492379.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><blockquote><p>获取citys中的li的方式</p><p>this的方式的弊端就是无法获取索引</p><p><img src="https://blog.chasingwind.top/1564840328948.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564840328948.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第二种方式 给回调函数传参  参数的名字随便 不一定是图中给的名字</p><ul><li>index: 就是元素在集合中的索引</li><li>element: 就是集合中的每一个元素对象</li></ul><p><img src="https://blog.chasingwind.top/1564840729487.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564840729487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>在此方法中,</p><p>function函数的返回值如果是<strong>false</strong>,那么结束循环(相当于break)</p><p>function函数的返回值如果是<strong>true</strong>,那么结束循环继续下一次循环(相当于continue)</p><p><img src="https://blog.chasingwind.top/1564841190487.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564841190487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这里相当于continue的效果</p></blockquote></li><li><p><code>$.each(object, [callback])</code></p><ul><li><p>这种方式与第一种方式的一个区别就是 第一种方式只能用jQuery对象进行调用  而这种方式,参数object既可以是jQuery对象也可以是js的数组对象 也称为全局遍历方式</p><blockquote><p>this的方式获取值</p><p><img src="https://blog.chasingwind.top/1564841489225.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564841489225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>方式2</p><p><img src="https://blog.chasingwind.top/1564841561960.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564841561960.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p><code>for(..of..)</code> : jQuery 3.0 版本之后提供的方式</p><blockquote><p>对citys下的li元素进行遍历</p><p><img src="https://blog.chasingwind.top/1564841734833.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564841734833.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ol><li><p>jQuery标准的绑定方式</p><ul><li><p>jQuery.事件方法(回调函数);</p><blockquote><p><img src="https://blog.chasingwind.top/1564842531268.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564842531268.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>focus事件</p><p><img src="https://blog.chasingwind.top/1564842829646.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564842829646.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>on绑定事件 , off解除绑定</p><ul><li><p>on绑定事件 : jQuery对象.on(“事件名称”,回调函数);</p></li><li><p>off解绑事件 : jQuery对象.off(“事件名称);</p><blockquote><p><img src="https://blog.chasingwind.top/1564843367880.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564843367880.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当off中没有function的时候, 是<strong>将组件上的所有事件全部解绑</strong></p><p><img src="https://blog.chasingwind.top/1564843481414.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564843481414.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>事件切换 : toggle</p><ul><li><p>jQuery对象.toggle(事件1,事件2,….);</p><ul><li>当单击jQuery对象对应的组件后,会依次执行事件1,事件2….直到最后一个,然后,再点击的话,又回到第一个,继续进行循环</li><li>注意：1.9版本之后, .toggle() 方法进行<strong>事件切换的功能删除</strong>,只能用于动画切换 , jQuery Migrate（迁移）插件可以恢复此功能。</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564844125991.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564844125991.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li><p>广告的自动显示与隐藏</p><ul><li><p>需求</p><ol><li>当页面加载完，3秒后。自动显示广告</li><li>广告显示5秒后，自动消失。</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564845123980.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564845123980.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>隐藏的时候</p><p><img src="https://blog.chasingwind.top/1564845177517.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564845177517.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>显示的时候<br><img src="https://blog.chasingwind.top/1564845207517.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564845207517.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>抽奖</p><blockquote><p>界面</p><p><img src="https://blog.chasingwind.top/1564845333527.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564845333527.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>实现</p><p><img src="https://blog.chasingwind.top/1564846713739.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564846713739.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>效果图</p><p><img src="https://blog.chasingwind.top/1564846655314.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564846655314.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><p>增强jQuery的功能</p></li><li><p>实现方式</p><ol><li><p><code>$.fn.extend(object) </code> : <strong>对象级别的插件</strong></p><ul><li>增强通过jQuery获取的对象的功能  $(“#id”)</li></ul><blockquote><p>使用插件实现复选框的选中与取消选中</p><p><img src="https://blog.chasingwind.top/1564847980579.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564847980579.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564847887707.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564847887707.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>$.extend(object)</code> : <strong>全局级别的插件</strong></p><ul><li>增强JQeury对象自身的功能  ,调用 : $</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564848301185.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564848301185.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery基础</title>
      <link href="2019/08/02/jQuery%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/02/jQuery%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>jQuery是一个快速、简洁的JavaScript框架，jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。本节介绍了jQuery基础,选择器以及一些案例。</p><a id="more"></a><h2 id="jQuery基础"><a href="#jQuery基础" class="headerlink" title="jQuery基础"></a>jQuery基础</h2><ol><li><p>概念：</p><ul><li>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</li><li>JavaScript框架：本质上就是一些js文件,封装了js的原生代码而已</li></ul></li><li><p>快速入门</p><ol><li><p>下载jQuery</p><blockquote><p>版本</p><p><img src="https://blog.chasingwind.top/1564730573838.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564730573838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>版本说明</p><p><img src="https://blog.chasingwind.top/1564730564796.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564730564796.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>jquery-xxx.js和jquery-xxx.min.js的区别<ul><li>jquery-xxx.js：开发版本。便于我们阅读，有良好的注释以及缩进</li><li>jquery-xxx.min.js：生产版本。程序中使用的，没有缩进，体积较小，加载速度更快</li></ul></li></ul></li><li><p>导入jQuery的文件  导入的是jquery-xxx.min.js</p></li><li><p>使用</p><blockquote><p><img src="https://blog.chasingwind.top/1564731272859.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564731272859.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>jQuery对象和JS对象区别与转换</p><blockquote><p><img src="https://blog.chasingwind.top/1564752019593.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564752019593.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>二者都可以作为数组使用,但是jQuery的使用比较方便</p><p><img src="https://blog.chasingwind.top/1564752374225.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564752374225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>jQuery对象在操作的时候，更加的方便</p><p>jQuery对象和js<strong>对象方法不通用</strong></p><blockquote><p>jQuery对象和js对象的方法不通用</p><p><img src="https://blog.chasingwind.top/1564752515058.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564752515058.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>所以如果我们需要使用js中的方法,就需要进行转换</p><ul><li><p><strong>jQuery对象转换为js对象</strong>：<code>jQuery对象[索引]</code>或者<code>jQuery对象.get(索引)</code>  因为虽然是一个对象 ，但是本质上是一个数组</p><blockquote><p>转换为js对象,从而使用js中的方法</p><p><img src="https://blog.chasingwind.top/1564753032845.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564753032845.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>js对象转换为jQuery对象</strong>：<code>$（js对象）</code></p><blockquote><p>转换为jQuery对象 使用jQuery中的方法html</p><p><img src="https://blog.chasingwind.top/1564752799923.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564752799923.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul></li></ol><h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><p>选择器：筛选具有相似特征的元素(标签)</p><ol><li><p>基本语法学习</p><ol><li><p>事件绑定</p><blockquote><p><img src="https://blog.chasingwind.top/1564753835722.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564753835722.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>入口函数</p><blockquote><p>DOM文档加载完成之后才执行该函数中的代码 相当于js中的window.onload</p><p><img src="https://blog.chasingwind.top/1564754107542.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564754107542.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>$(function())入口函数与window.onload的区别</p><ol><li><p>window.onload<strong>只能定义一次</strong>,定义多次的话,后面的会将前面的覆盖</p><blockquote><p><img src="https://blog.chasingwind.top/1564754416828.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564754416828.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意区别定义与调用</p></blockquote></li><li><p>$(function())可以定义多次,而且不会被覆盖</p><blockquote><p><img src="https://blog.chasingwind.top/1564754524362.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564754524362.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li><li><p>样式控制</p><blockquote><p>可以使用css属性来设置对象的css样式的键值对</p><p>推荐使用下面的那种,可进行检查</p><p><img src="https://blog.chasingwind.top/1564754781027.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564754781027.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>选择器分类</p><ol><li><p>基本选择器</p><ol><li>标签选择器（元素选择器）<ul><li>语法： <code>$(&quot;html标签名&quot;) </code>获得所有匹配标签名称的元素</li></ul></li><li>id选择器 <ul><li>语法： <code>$(&quot;#id的属性值&quot;)</code> 获得与指定id属性值匹配的元素</li></ul></li><li>类选择器<ul><li>语法： <code>$(&quot;.class的属性值&quot;)</code> 获得与指定的class属性值匹配的元素</li></ul></li><li>并集选择器<ul><li>语法： <code>$(&quot;选择器1,选择器2....&quot;) </code>获取多个选择器选中的所有元素</li></ul></li></ol><blockquote><p>需要注意的点: 并集选择器中的选择的元素需要用<strong>逗号隔开</strong></p><p><img src="https://blog.chasingwind.top/1564758539459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564758539459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>层级选择器</p><ol><li>后代选择器<ul><li>语法： <code>$(&quot;A B &quot;) </code>选择A元素内部的<strong>所有B元素</strong></li></ul></li><li>子选择器<ul><li>语法： <code>$(&quot;A &gt; B&quot;)</code> 选择A元素内部的<strong>所有B子元素</strong></li></ul></li></ol><blockquote><p>两者的差别</p><p><img src="https://blog.chasingwind.top/1564758886712.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564758886712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564759157016.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564759157016.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>属性选择器(这里的A表示的是<strong>标签</strong>)</p><ol><li>属性名称选择器<ul><li>语法：<code>$(&quot;A[属性名]&quot;)</code>包含指定属性的选择器</li></ul></li><li>属性选择器<ul><li>语法： <code>$(&quot;A[属性名=&#39;值&#39;]&quot;)</code> 包含指定属性等于指定值的选择器</li><li>语法： <code>$(&quot;A[属性名!=&#39;值&#39;]&quot;)</code> 匹配所有不含有指定的属性,或者属性不等于特定值的元素</li><li>语法： <code>$(&quot;A[属性名^=&#39;值&#39;]&quot;)</code> 匹配给定的属性以某些值开始</li><li>语法： <code>$(&quot;A[属性名$=&#39;值&#39;]&quot;)</code> 匹配给定的属性以某些值结束</li><li>语法： <code>$(&quot;A[属性名*=&#39;值&#39;]&quot;)</code> 匹配给定的属性包含某些值</li></ul></li><li>复合属性选择器<ul><li>语法： <code>$(&quot;A[属性名=&#39;值&#39;][]...&quot;) </code>包含多个属性条件的选择器</li></ul></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564760578001.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564760578001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>复合属性选择器中的条件都成立的时候才会被选出来</p></blockquote></li><li><p>过滤选择器</p><ol><li>首元素选择器<ul><li>语法： <code>元素:first</code> 获得选择的元素中的第一个元素</li></ul></li><li>尾元素选择器<ul><li> 语法： <code>元素:last</code> 获得选择的元素中的最后一个元素</li></ul></li><li>非元素选择器<ul><li>语法： <code>元素:not(selector) </code>不包括指定内容的元素</li></ul></li><li>偶数选择器<ul><li>语法： <code>元素:even</code> 偶数，从 0 开始计数</li></ul></li><li>奇数选择器<ul><li>语法： <code>元素:odd</code> 奇数，从 0 开始计数</li></ul></li><li>等于索引选择器<ul><li>语法： <code>元素:eq(index)</code> 指定索引元素</li></ul></li><li>大于索引选择器<ul><li>语法：<code>元素 :gt(index)</code> 大于指定索引元素</li></ul></li><li>小于索引选择器<ul><li>语法： <code>元素:lt(index)</code> 小于指定索引元素</li></ul></li><li>标题选择器<ul><li>语法： <code>:header</code> 获得标题（h1~h6）元素，固定写法</li></ul></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564762105520.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762105520.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>表单过滤选择器</p><ol><li><p>可用元素选择器 </p><ul><li>语法：<code>元素 :enabled</code> 获得可用元素</li></ul></li><li><p>不可用元素选择器 </p><ul><li>语法： <code>元素:disabled</code> 获得不可用元素</li></ul><blockquote><p>可用与不可用</p><p><img src="https://blog.chasingwind.top/1564762506965.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762506965.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可用选择器</p><p><img src="https://blog.chasingwind.top/1564762649031.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762649031.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>初始页面</p><p><img src="https://blog.chasingwind.top/1564762710965.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762710965.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>执行后</p><p>修改了其中的value值  而被标注的disabled的就不会被选中修改</p><p><img src="https://blog.chasingwind.top/1564762744339.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762744339.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>不可用选择器</p><p><img src="https://blog.chasingwind.top/1564762849100.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762849100.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>页面初始情况</p><p><img src="https://blog.chasingwind.top/1564762868180.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762868180.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>执行后</p><p><img src="https://blog.chasingwind.top/1564762885969.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564762885969.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>选中选择器(单选/复选框)</p><ul><li>语法： <code>元素:checked</code> 获得<strong>单选/复选框</strong>选中的元素</li></ul></li><li><p>选中选择器(下拉选择框)</p><ul><li>语法： <code>元素:selected</code> 获得<strong>下拉列表</strong>选中的元素，注意选取的是下拉列表中的option选项</li></ul></li></ol><blockquote><p>复选框</p><p>length属性表示复选框中选中的个数</p><p><img src="https://blog.chasingwind.top/1564763113551.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564763113551.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564763085983.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564763085983.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote><blockquote><p>多选下拉列表</p><p><img src="https://blog.chasingwind.top/1564763251146.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564763251146.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意的一点是: 选<strong>中的是下拉列表下的option标签</strong>被选中的个数!!</p><p>当然这个前面的属性选择器写的可以更简单</p><p><img src="https://blog.chasingwind.top/1564763457384.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564763457384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564763430775.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564763430775.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>jQuery的DOM操作</p><ol><li><p>内容相关的操作</p><ol><li>html()：获取/设置元素的<strong>标签体内容</strong> 比如,获取   <code>&lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;</code>  –&gt; <code>&lt;font&gt;内容&lt;/font&gt;</code></li><li>text()：获取/设置元素的<strong>标签体纯文本内容</strong>  比如，获取 <code>&lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;</code>  –&gt; <code>内容</code></li><li>val()：获取/设置元素的value属性值</li></ol><blockquote><p>页面</p><p><img src="https://blog.chasingwind.top/1564799814716.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564799814716.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564799486457.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564799486457.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意的一点就是</p><p>当设置text的时候</p><p><img src="https://blog.chasingwind.top/1564799841792.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564799841792.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>设置的可不仅仅是#mydiv的纯文本内容 而是#mydiv中的标签体的所有内容</p><p><img src="https://blog.chasingwind.top/1564799885726.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564799885726.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>删除属性</p><p><img src="https://blog.chasingwind.top/1564801183037.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564801183037.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564801226221.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564801226221.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>属性操作</p><ol><li><p>通用属性操作(操作标签的所有属性)</p><ol><li>attr(): 获取/设置元素的属性</li><li>removeAttr():删除属性</li><li>prop():获取/设置元素的属性</li><li>removeProp():删除属性</li></ol><ul><li>attr和prop区别？<ol><li>如果操作的是<strong>元素的固有属性</strong>，则建议使用prop</li><li>如果操作的是<strong>元素自定义的属性</strong>，则建议使用attr</li></ol></li></ul><blockquote><p>固有属性 就是在html中标签拥有的属性</p><p>比如: <code>&lt;li&gt;</code>标签的固有属性只有这两个</p><p><img src="https://blog.chasingwind.top/1564800909362.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564800909362.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>html内容</p><p><img src="https://blog.chasingwind.top/1564801006937.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564801006937.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>获取,设置,新增属性的值</p><p><img src="https://blog.chasingwind.top/1564801052885.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564801052885.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>浏览器中元素审查</p><p><img src="https://blog.chasingwind.top/1564801106671.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564801106671.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote><blockquote><p>checked是input标签的固有属性  所以使用prop</p><p><img src="https://blog.chasingwind.top/1564801412405.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564801412405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564801633295.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564801633295.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>对class属性操作</p><ol><li><p>addClass():添加class属性值</p></li><li><p>removeClass():删除class属性值</p></li><li><p>toggleClass():切换class属性</p><ul><li>比如: 判断如果元素对象上<strong>存在</strong>class=”one”，则<strong>将属性值one删除掉</strong>。  如果元素对象上<strong>不存在</strong>class=”one”，则<strong>添加</strong></li></ul><blockquote><p>second是一个class  这里是.second  类选择器</p><p><img src="https://blog.chasingwind.top/1564806511321.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564806511321.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564806618215.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564806618215.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>css() : 获取/设置css的属性</p><blockquote><p><img src="https://blog.chasingwind.top/1564806921917.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564806921917.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>CRUD操作</p><ol><li><p>append():父元素将子元素追加到末尾</p><ul><li>对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</li></ul></li><li><p>prepend():父元素将子元素追加到开头</p><ul><li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li></ul></li><li><p>appendTo():</p><ul><li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li></ul></li><li><p>prependTo()：</p><ul><li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li></ul><blockquote><p>初始页面</p><p><img src="https://blog.chasingwind.top/1564808107554.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564808107554.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>append和appendTo</p><p><img src="https://blog.chasingwind.top/1564808953351.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564808953351.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564808832191.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564808832191.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>prepend和prependTo</p><p><img src="https://blog.chasingwind.top/1564809134715.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809134715.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564809102824.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809102824.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>after():添加元素到元素后边</p><ul><li>对象1.after(对象2)： 将对象2添加到对象1后边。<strong>对象1和对象2是兄弟关系</strong></li></ul></li><li><p>before():添加元素到元素前边</p><ul><li>对象1.before(对象2)： 将对象2添加到对象1前边。<strong>对象1和对象2是兄弟关系</strong></li></ul></li><li><p>insertAfter()</p><ul><li>对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系</li></ul></li><li><p>insertBefore()</p><ul><li>对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li></ul><blockquote><p>after()和insertAfter()</p><p><img src="https://blog.chasingwind.top/1564809428039.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809428039.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564809352171.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809352171.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>before和insertBefore</p><p><img src="https://blog.chasingwind.top/1564809580261.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809580261.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564809523777.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809523777.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>remove():移除元素</p><ul><li>对象.remove():将对象删除掉</li></ul></li><li><p>empty():清空元素的所有后代元素。</p><ul><li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点</li></ul><blockquote><p>remove</p><p><img src="https://blog.chasingwind.top/1564809847245.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809847245.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564809873139.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809873139.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564809892455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809892455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>empty</p><p>初始</p><p><img src="https://blog.chasingwind.top/1564809991099.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564809991099.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564810015084.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564810015084.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果</p><p><img src="https://blog.chasingwind.top/1564810046268.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564810046268.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h2 id="jQuery基础案例"><a href="#jQuery基础案例" class="headerlink" title="jQuery基础案例"></a>jQuery基础案例</h2><ol><li><p>隔行换色</p><ul><li><p>需求 : 将<strong>数据行</strong>的奇数行背景色设置为 pink，偶数行背景色设置为 yellow</p><blockquote><p><img src="https://blog.chasingwind.top/1564815509509.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564815509509.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564815525332.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564815525332.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>全选全不选</p><blockquote><p><img src="https://blog.chasingwind.top/1564816031036.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564816031036.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>需要注意的一点就是 <strong>checked是属性</strong>!!</p></blockquote></li><li><p>QQ表情选择</p><blockquote><p>这里我们需要用到jQuery中的clone()</p><p><img src="https://blog.chasingwind.top/1564816687840.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564816687840.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564816611783.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564816611783.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564816633555.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564816633555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>多选下拉列表左右移动</p><blockquote><p><img src="https://blog.chasingwind.top/1564817401363.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564817401363.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564817414726.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564817414726.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter和Listener</title>
      <link href="2019/08/01/Filter%E5%92%8CListener/"/>
      <url>2019/08/01/Filter%E5%92%8CListener/</url>
      
        <content type="html"><![CDATA[<p>Fliter和Listener分别是Java Web中的过滤器和监听器, 在开发的过程中,结合Servlet在一起,他们三个被称为Java Web的三大组件。</p><a id="more"></a><h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter(过滤器)"></a>Filter(过滤器)</h2><ol><li><p>Web中的过滤器 ：当访问服务器的资源的时候，过滤器可以将请求拦截下来，完成一些特殊的功能</p></li><li><p>过滤器的作用：</p><ul><li>一般用于完成一些通用的操作。<ul><li>比如说登录验证，去访问多个资源，但这些资源只有在你登陆的情况下你才能去访问，如果没有过滤器的话，每个页面都需要进行判断用户是否已经登录了，所以我们可以使用过滤器，将登录的要求放在里面</li><li>设置编码</li><li>敏感字符的过滤，好熟悉的操作，那年我还是个王者，直到被禁了言……</li></ul></li></ul></li><li><p>快速入门</p><ol><li><p>步骤</p><ol><li><p>定义一个类,实现接口Filter(javax.servlet包中的)</p></li><li><p>重写方法</p></li><li><p>配置拦截路径，就是我们访问什么样的资源才会被过滤器拦截</p><ul><li>配置<ol><li>web.xml</li><li>注解</li></ol></li></ul><blockquote><p>这里的注解配置的路径是所有的资源路径</p><p><img src="https://blog.chasingwind.top/1564648645019.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564648645019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>jsp页面内容</p><p><img src="https://blog.chasingwind.top/1564648700535.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564648700535.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在浏览器中并没有显示index.jsp的内容 , 在控制台输出了doFilter()中的内容 说明当我们去访问index.jsp资源的时候,被过滤器拦截了</p><p><img src="https://blog.chasingwind.top/1564648768588.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564648768588.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>放行 </p><blockquote><p>过滤器的重要的操作  :  符合条件的就放行</p><p><img src="https://blog.chasingwind.top/1564649012393.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564649012393.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果  页面显示了index.jsp的内容 说明我们访问成功了  也就是说被放行了</p><p><img src="https://blog.chasingwind.top/1564649098771.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564649098771.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>过滤器的细节</p><ol><li><p>web.xml配置过滤器</p><blockquote><p><img src="https://blog.chasingwind.top/1564649531394.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564649531394.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>过滤器执行过程</p><p>放行之前的代码→通过放行之后访问到的资源→放行之后的代码</p><blockquote><p>一般我们是在放行之前对request对象的请求数据进行增强</p><p>在放行之后对response对象的响应消息进行增强</p><p><img src="https://blog.chasingwind.top/1564650609853.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564650609853.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>过滤器生命周期方法</p><ol><li>init：<strong>服务器启动之后</strong>,会创建Filter对象,执行init方法  ，只执行一次。我们一般用于<strong>加载资源</strong></li><li>doFilter：每一次请求被拦截的时候都会执行  ，可执行多次</li><li>destory：在服务器关闭之后,Filter对象被销毁，<strong>服务器正常关闭,就会执行destory方法</strong>  只执行一次。我们一般用于<strong>释放资源</strong></li></ol></li><li><p>过滤器配置详解</p><ol><li><p><strong>拦截路径</strong>的配置</p><ol><li>具体资源路径：<code>/index.jsp</code>  只有访问index.jsp资源的时候,才会执行过滤器</li><li>目录拦截：<code>/user/</code>   访问<strong>路径</strong>为/user下的所有资源的时候,都会执行过滤器</li><li>后缀名拦截：<code>*.jsp</code>    访问所有的后缀名为.jsp的资源的时候，过滤器都会被执行</li><li>拦截所有的资源：<code>/*</code>  访问所有的资源的时候,过滤器都会被执行</li></ol></li><li><p><strong>请求方式拦截</strong>的配置：资源被访问的方式，比如对直接进行资源访问的请求进行过滤，而不对因转发访问到的资源进行过滤</p><ol><li><p>注解配置</p><ul><li><p>设置注解中的<code>dispatcherTypes</code>属性</p><ol><li><p>REQUEST：默认值，浏览器直接请求资源</p><blockquote><p>配置注解中的dispatcherTypes为REQUEST属性的时候,</p><p>我们<strong>直接请求index.jsp的时候,过滤器被执行了</strong></p><p><img src="https://blog.chasingwind.top/1564655145803.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564655145803.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>而通过<strong>转发的方式访问的index.jsp并没有被拦截</strong></p><p>控制台没有输出”执行了过滤器”</p><p><img src="https://blog.chasingwind.top/1564655397730.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564655397730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>FORWARD：转发访问资源</p><blockquote><p>配置注解中的dispatcherTypes为FORWARD属性的时候</p><p>我们直接访问index.jsp,可见控制台输出并没有显示执行了过滤器</p><p><img src="https://blog.chasingwind.top/1564655619802.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564655619802.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>而我们通过<strong>转发的方式访问index.jsp的时候</strong></p><p><strong>执行了过滤器</strong></p><p><img src="https://blog.chasingwind.top/1564655759187.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564655759187.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>因为存放dispatcherTypes的属性值是一个数组的形式,所以可以配置多种属性值</p><p><img src="https://blog.chasingwind.top/1564656288971.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564656288971.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>INCLUDE：包含访问资源</p></li><li><p>ERROR：错误跳转资源</p></li><li><p>ASYNC：异步访问资源</p></li></ol></li></ul></li><li><p>web.xml配置</p><blockquote><p>在web.xml中进行dispatcher属性值的设置</p><p><img src="https://blog.chasingwind.top/1564656480984.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564656480984.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>过滤器链（配置多个过滤器）</p><ul><li><p>过滤器的执行顺序：如果有多个过滤器的话  执行顺序如图所示</p><blockquote><p><img src="https://blog.chasingwind.top/1564657068571.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564657068571.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564657567476.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564657567476.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>过滤器的先后</p><blockquote><p>上面过滤器的执行顺序有一个疑问就是?</p><p>为什么我们没有设置过滤器的先后,执行的是5在前,6在后;而不是6在前,5在后?</p></blockquote><ol><li>注解配置：按照<strong>类名的字符串比较</strong>规则比较，<strong>值小的先执行</strong><ul><li>AFilter和BFilter相比 ，AFilter先执行</li></ul></li><li>web.xml配置：<code>&lt;filter-mapping&gt;</code>谁定义在前面谁先执行</li></ol></li></ul></li></ol></li><li><p>案例1：登录验证</p><ol><li><p>需求</p><ol><li>访问之前的用户信息的资源。验证其是否登录</li><li>如果登录了，则直接放行。</li><li>如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”。</li></ol></li><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1564670841119.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564670841119.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现</p><blockquote><p>当我们过滤的与登陆相关的资源仅仅有图片中的资源的时候</p><p><img src="https://blog.chasingwind.top/1564670068982.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564670068982.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>页面显示是这样的</p><p><img src="https://blog.chasingwind.top/1564670123095.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564670123095.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>所以 ,需要将各种css,js,fonts还有验证码等等与登录相关的资源全部都进行过滤</p><p><img src="https://blog.chasingwind.top/1564670465997.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564670465997.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>那么这个时候的界面是这样的</p><p>并且你在未登录的情况下去访问其他页面   会被拦截回到登录界面  </p><p>这里因为是转发forward的形式,所以地址栏中的url并没有改变</p><p><img src="https://blog.chasingwind.top/1564670528216.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564670528216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>案例2：敏感词过滤</p><ol><li><p>需求</p><ol><li>对之前的案例录入的数据进行敏感词汇过滤</li><li>如果是敏感词汇，替换为 *** </li></ol></li><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1564671374570.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564671374570.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>因为过滤之前的request对象和过滤之后的request对象是同一个对象，但是request中只有getParameter方法来获取请求消息中的值，并<strong>没有setParameter方法来设置值</strong>，所以我们需要一个新的request对象</p></blockquote></li><li><p>增强对象的功能</p><ul><li><p>设计模式中的<strong>装饰模式</strong>和<strong>代理模式</strong>都可以用来增强对象的功能</p></li><li><p>代理模式</p><ol><li><p>概念：代理对象代理真实对象，达到增强真实对象的目的</p><blockquote><p><img src="https://blog.chasingwind.top/1564672414087.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564672414087.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现方式：两种实现方式的区别就在于代理对象的生成方式</p><ul><li>静态代理：在一个.java文件中描述代理模式</li><li>动态代理：在内存中形成代理类</li></ul></li><li><p>动态代理的实现步骤</p><ol><li>代理对象和真实对象实现相同的接口</li><li>代理对象 = Proxy.newProxyInstance();</li><li>使用代理对象调用方法</li><li>增强方法</li></ol></li><li><p>动态代理的基本实现</p><blockquote><p>以上面的卖电脑为例</p><p>接口</p><p><img src="https://blog.chasingwind.top/1564674363570.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564674363570.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>真实类实现接口重写方法</p><p><img src="https://blog.chasingwind.top/1564674386941.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564674386941.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这是普通的方法调用</p><p><img src="https://blog.chasingwind.top/1564674425927.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564674425927.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们用动态代理来增强对象  这里是基本的用法</p><p><img src="https://blog.chasingwind.top/1564675232709.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564675232709.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>实际的增强的操作是在invoke方法中来实现的</p></blockquote></li><li><p>invoke方法来进行方法增强的增强方式</p><ul><li><p>代理对象其实没有真实对象的功能,他只是调用接口中的方法,然后通过invoke方法中,去调用真实对象中的方法,并且可以在此同时来增强方法</p><blockquote><p><img src="https://blog.chasingwind.top/1564676421423.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564676421423.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>首先必须需要明确的一点的是：代理模式需要我们站在<strong>代理的角度</strong>来考虑问题</p><ol><li><p>增强参数列表</p><blockquote><p>在代理对象中是没有具体的方法的,他需要去调用真实对象的对应的方法</p><p>比如,上面的卖电脑</p><p>用户拿5000买电脑(通过代理proxy_lenove.saleComputer(5000)方法)买电脑),代理商拿4250去买联想公司的电脑(method.invoke(lenovo,money))</p><p><img src="https://blog.chasingwind.top/1564677186086.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564677186086.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>增强返回值</p><blockquote><p>在上面的卖电脑的方法中 返回值<code>return &quot;联想电脑&quot;</code></p><p>可以通过代理商 来增强返回值</p><p><img src="https://blog.chasingwind.top/1564677601986.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564677601986.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>增强方法体的执行逻辑</p><blockquote><p>可以在方法的执行前后进行操作逻辑的编写</p><p><img src="https://blog.chasingwind.top/1564677874557.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564677874557.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol></li></ul></li><li><p>实现</p><blockquote><p><img src="https://blog.chasingwind.top/1564680845937.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564680845937.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564680902020.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564680902020.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在这里需要注意的是</p><ol><li>放行的时候的参数是增强后的req</li><li>注意文件的编码  默认的是GBK编码</li></ol></blockquote></li></ol></li></ol><h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener(监听器)"></a>Listener(监听器)</h2><ol><li><p>概念：Web的三大组件之一</p><ul><li><p>事件监听机制：</p><ul><li><p>事件：一件事情</p></li><li><p>事件源：事件发生的地方</p></li><li><p>监听器：一个对象</p></li><li><p>注册监听：将事件，事件源，监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码,，也就是<strong>配置</strong></p><blockquote><p>比如,一个按钮（事件源）注册一个单击事件（事件）来执行一个function函数（监听器）</p></blockquote></li></ul></li></ul></li><li><p>ServletContextListener：监听ServletContext对象的创建和销毁</p><ul><li><p>方法：</p><ol><li>void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被<strong>销毁之前</strong>会调用该方法</li><li>void contextInitialized(ServletContextEvent sce) ：ServletContext<strong>对象创建后</strong>会调用该方法</li></ol></li><li><p>步骤：</p><ol><li><p>定义一个类，实现ServletContext接口</p></li><li><p>重写其中的方法</p></li><li><p>配置</p><ol><li>web.xml</li><li>注解</li></ol><blockquote><p>创建类实现接口，重写方法</p><p><img src="https://blog.chasingwind.top/1564727974344.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564727974344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>配置</p><p><img src="https://blog.chasingwind.top/1564728006122.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564728006122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><strong>一般我们可以用来加载资源文</strong>件  在服务器一启动就进行加载 这样的文件一般是全局文件</p><p>比如  我们加载src目录下的fileContext.xml文件</p><p><img src="https://blog.chasingwind.top/1564728625525.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564728625525.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>getInitParameter的参数需要在web.xml文件中进行配置</p><p><img src="https://blog.chasingwind.top/1564728722915.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564728722915.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的话 以后需要添加其他的新的文件的话  就可以在这里进行文件的添加</p></blockquote><blockquote><p>注解的形式进行配置的话</p><p>在类的上面直接添加注解就行了</p><p><img src="https://blog.chasingwind.top/1564728851044.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564728851044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fliter </tag>
            
            <tag> Listener </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP,EL,JSTL,三层架构(重点)</title>
      <link href="2019/07/28/JSP-EL%E5%92%8CJSTL/"/>
      <url>2019/07/28/JSP-EL%E5%92%8CJSTL/</url>
      
        <content type="html"><![CDATA[<p>这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</p><a id="more"></a><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ol><li><p>作用：用于配置JSP页面，导入资源文件</p></li><li><p>格式：<code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;</code></p><blockquote><p><img src="https://blog.chasingwind.top/1564294013897.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564294013897.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>分类</p><ol><li><p>page：配置JSP页面的</p><ul><li><p>contentType：等同于response.setContentType()</p><ol><li>设置响应体的MIME类型以及字符集</li><li>设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）</li></ol></li><li><p>import：导包，写java代码的时候,导包的内容</p><blockquote><p><img src="https://blog.chasingwind.top/1564294651989.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564294651989.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</p><blockquote><p><img src="https://blog.chasingwind.top/1564294806998.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564294806998.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>isErrorPage：标识当前也是是否是错误页面。</p><ul><li>true：是，可以使用内置对象exception</li><li>false：否。默认值。不可以使用内置对象exception</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564294948224.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564294948224.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>include：导入其他的页面，用于当一些页面的部分内容相同的的时候，直接将这些相同的内容写到一个jsp中，其他页面直接包含这个jsp。</p></li><li><p>taglib：导入资源，一般用来导入标签库</p><blockquote><p><img src="https://blog.chasingwind.top/1564295459933.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564295459933.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>prefix表示的是标签库的前缀  jstl一般用c表示</p></blockquote></li></ol></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>html注释<ul><li><code>&lt;!-- --!&gt;</code>：只能注释html代码片段</li></ul></li><li>jsp特有注释（推荐使用）<ul><li><code>&lt;%-- --%&gt;</code>：可以注释所有的jsp的内容</li></ul></li><li>使用html注释的内容，服务器还是会将注释过的内容发送给浏览器，只不过浏览器不解析，而jsp注释的内容，服务器就不会发送给浏览器</li></ol><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul><li><p>在jsp页面中不需要创建，直接使用的对象</p></li><li><p>jsp中的内置对象一共有9个：</p></li></ul><table><thead><tr><th align="center">变量名</th><th align="center">真实类型</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">pageContext</td><td align="center">PageContext</td><td align="center"><strong>当前页面共享数据</strong>，还可以获取其他八个内置对象</td></tr><tr><td align="center">request</td><td align="center">HttpServletRequest</td><td align="center"><strong>一次请求访问的多个资源之间</strong>(转发)</td></tr><tr><td align="center">response</td><td align="center">HttpServletResponse</td><td align="center">响应对象</td></tr><tr><td align="center">session</td><td align="center">HttpSession</td><td align="center"><strong>一次会话的多个请求间</strong></td></tr><tr><td align="center">application</td><td align="center">ServletContext</td><td align="center"><strong>所有用户间共享数据（最大的域对象）</strong></td></tr><tr><td align="center">page</td><td align="center">Object</td><td align="center">当前页面(Servlet)的对象  this</td></tr><tr><td align="center">out</td><td align="center">JspWriter</td><td align="center">输出对象，数据输出到页面上</td></tr><tr><td align="center">config</td><td align="center">ServletConfig</td><td align="center">Servlet的配置对象</td></tr><tr><td align="center">exception</td><td align="center">Throwable</td><td align="center">异常对象</td></tr></tbody></table><h2 id="MVC：开发模式"><a href="#MVC：开发模式" class="headerlink" title="MVC：开发模式"></a>MVC：开发模式</h2><ol><li><p>JSP演变历史</p><ol><li>早期只有Servlet,只能使用response输出标签数据,非常麻烦</li><li>后来有了JSP,简化了Servlet的开发,如果过度使用jsp，在jsp中既写大量的java代码，又写html表，难于维护，难于分工协作的弊端</li><li>再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性</li></ol></li><li><p>MVC开发模式</p><ol><li><p>M：Model,模型（JavaBean）: 完成具体的业务操作，如：查询数据库，封装对象</p></li><li><p>V：View,视图（JSP） : 展示数据</p></li><li><p>C：Controller,控制器（Servlet）: 获取用户的输入,调用模型,将数据交给视图进行展示</p><blockquote><p><img src="https://blog.chasingwind.top/1564297685623.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564297685623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>优缺点</p><ol><li>优点：耦合性低，方便维护，可以利于分工协作，重用性高</li><li>缺点：使得项目架构变得复杂，对开发人员要求高</li></ol></li></ol></li></ol><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ol><li><p>概念：Expression Language 表达式语言</p></li><li><p>作用：<strong>替换和简化JSP页面中Java代码的编写</strong></p></li><li><p>语法：<code>$&#123;表达式&#125;</code></p></li><li><p>注意：JSP默认是支持EL表达式的</p><blockquote><p>JSP会直接将结果展示</p><p><code>\</code>可以告诉浏览器不解析,从而让他原样展示</p><p><img src="https://blog.chasingwind.top/1564298354489.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564298354489.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当在page里面配置isELIgnored为true的时候,全局不解析EL表达式,原样展示</p><p><img src="https://blog.chasingwind.top/1564298499826.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564298499826.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用</p><ol><li><p>运算</p><ul><li>运算符<ol><li>算术运算符：+ - * /(div) %(mod)</li><li>比较运算符：&gt; &lt; &gt;= &lt;= == !=</li><li>逻辑运算符：&amp;&amp;(and) ||(or) !(not)</li><li>空运算符：empty<ul><li>功能：用于判断字符串，集合，数组对象<strong>是否是null或者长度是0</strong></li><li>比如 : <code>$&#123;empty list&#125;</code>,<br>取反 <code>$&#123;not empty list&#125;</code></li></ul></li></ol></li></ul></li><li><p>获取值</p><ol><li><p><strong>EL表达式只能从域对象中获取值</strong></p></li><li><p>语法：</p><ol><li><p><code>$&#123;域名称.键名称&#125;</code>：从指定域中获取指定键的值</p><ul><li><p>域名称</p><blockquote><p><img src="https://blog.chasingwind.top/1564387745217.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564387745217.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>比如：在request域中存储了username=zhangsan</p></li><li><p>获取：${requestScope.username}</p><blockquote><p><img src="https://blog.chasingwind.top/1564300910372.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564300910372.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意最后一个,当键名称不存在的时候,会用空字符串来代替</p></blockquote></li></ul></li><li><p><code>$&#123;键名&#125;</code>:表示依次从最小的域中查找是否有该键对应的值,直到找到为止</p><blockquote><p><img src="https://blog.chasingwind.top/1564301195059.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564301195059.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>获取对象,List集合,Map集合的值</p><ol><li><p>对象: <code>$&#123;域名称.键名.属性名&#125;</code>,实质上会去调用对象的对应属性的get方法</p><blockquote><p>获取对象中的<strong>属性值</strong>,只要有对应的Get方法,就有对应的属性值,如果填写的属性值不存在的话,页面会报错的</p><p><img src="https://blog.chasingwind.top/1564301999740.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564301999740.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>使用时间</p><p><img src="https://blog.chasingwind.top/1564302566504.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564302566504.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如果要实现时间的格式化?</p><p>在User中写getBir()</p><p><img src="https://blog.chasingwind.top/1564303107870.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564303107870.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在jsp中调用,一定要注意属性名第一个字母要小写</p><p><img src="https://blog.chasingwind.top/1564303170464.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564303170464.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>List集合:<code>$&#123;域名城.键名[索引]&#125;</code></p><blockquote><p>下标越界则会显示的是空字符串</p><p>list[2]表示的就是list集合中下标为2的数据, 这里就是user对象  然后化成获取对象的操作</p><p><img src="https://blog.chasingwind.top/1564303779053.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564303779053.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Map集合:<code>$&#123;域名称.键名.key&#125;</code> 或<code>$&#123;域名称.键名[&quot;key名&quot;]&#125;</code>: 获取map集合中键对应的值</p><blockquote><p><img src="https://blog.chasingwind.top/1564304378949.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564304378949.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>隐式对象: EL表达式中不用创建就可以直接使用</p><ul><li><p>EL隐式对象中有11个隐式对象</p></li><li><p>pageContext: 获取其他8个内置对象</p><blockquote><p><img src="https://blog.chasingwind.top/1564305003518.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564305003518.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><ol><li><p>概念 : JavaServer Pages Tag Library , JSP标准标签库</p><ul><li>Apache组织提供的开源的免费的JSP标签</li></ul></li><li><p>作用: 用于简化和替换JSP页面上的Java代码</p></li><li><p>使用步骤</p><ol><li>导入JSTL相关的jar包</li><li>引入标签库 : taglib属性,  <code>&lt;%@taglib %&gt;</code></li><li>使用标签</li></ol></li><li><p>常用的JSTL标签</p><ol><li><p>if    :相当于java中的<strong>if</strong>语句,他没有else</p><ul><li><p>if标签必须有的属性是test,其中用来存放条件表达式</p></li><li><p>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</p><blockquote><p><img src="https://blog.chasingwind.top/1564307011644.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564307011644.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>choose : 相当于java中的<strong>switch</strong>语句</p><blockquote><p>choose标签相当于switch</p><p>when标签相当于case</p><p>otherwise标签相当于ddefault</p><p><img src="https://blog.chasingwind.top/1564307469810.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564307469810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>foreach : 相当于java中的<strong>for</strong>语句</p><ol><li><p>完成重复操作</p><ul><li><p>属性</p><ul><li>begin : 开始值（包含）</li><li>end : 结束值（包含）</li><li>var ：临时变量</li><li>step：步长</li><li>varStatus: 循环状态对象<ul><li>index:容器中元素的索引</li><li>count: 循环次数,从1开始</li></ul></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564317294393.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564317294393.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>遍历容器</p><blockquote><p><img src="https://blog.chasingwind.top/1564317907538.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564317907538.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h2 id="三层架构-软件设计架构"><a href="#三层架构-软件设计架构" class="headerlink" title="三层架构:软件设计架构"></a>三层架构:软件设计架构</h2><ol><li><p>界面层(表示层): 用户看到的界面, 用户可以通过界面上的组件和服务器进行交互</p></li><li><p>业务逻辑层(控制层): 处理业务逻辑. </p></li><li><p>数据访问层(持久层) : 操作数据存储文件</p><blockquote><p>※※※※※※※※※※※※※※※※  超  级  重  点  ※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※</p><p><img src="https://blog.chasingwind.top/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.bmp" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.bmp" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="三层架构"></p></blockquote></li><li><p>用户信息的列表展示</p><ol><li><p>需求 : 用户信息的增删改查操作</p></li><li><p>设计: </p><ol><li>技术选型 : Servlet + JSP + MySQL + Tomcat</li><li>数据库的设计</li><li>开发<ol><li>环境搭建<ol><li>创建数据库环境</li><li>创建项目,导入jar包</li></ol></li><li>编码</li></ol></li><li>测试</li><li>部署运维</li></ol></li><li><p>环境搭建</p><ol><li><p>创建数据库环境</p><blockquote><p><img src="https://blog.chasingwind.top/1564364327051.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564364327051.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建项目,导入jar包</p><blockquote><p><img src="https://blog.chasingwind.top/1564365181862.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564365181862.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>导入页面内容</p><p><img src="https://blog.chasingwind.top/1564365283143.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564365283143.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编码</p><blockquote><p>列表查询功能的实现</p><p><img src="https://blog.chasingwind.top/1564365812785.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564365812785.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>创建包</p><p><img src="https://blog.chasingwind.top/1564366064946.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564366064946.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>JavaBean</p><p><img src="https://blog.chasingwind.top/1564366403364.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564366403364.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>首页改造,将index.html内容复制到index.jsp中</p><p><img src="https://blog.chasingwind.top/1564366506869.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564366506869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>修改跳转的路径到UserListServlet</p><p><img src="https://blog.chasingwind.top/1564366661065.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564366661065.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>创建UserListServlet</p><p><img src="https://blog.chasingwind.top/1564366776879.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564366776879.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>根据分析,第一步需要调用service层的findAll()</p><p>所以,创建UserService接口 以及他的实现类</p><p>UserService接口</p><p><img src="https://blog.chasingwind.top/1564367162915.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564367162915.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>UserServiceImpl实现类</p><p><img src="https://blog.chasingwind.top/1564367226513.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564367226513.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>UserService需要调用dao完成查询</p><p>所以,创建UserDao接口以及他的实现类</p><p><img src="https://blog.chasingwind.top/1564367362519.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564367362519.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>UserDaoImpl实现类  在这里编写使用JDBC操作数据库</p><p><img src="https://blog.chasingwind.top/1564367451426.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564367451426.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>以上代码先不写,先完成UserListServlet中的逻辑</p><p>首先,将dao的结果返回给UserServiceImpl,将结果返回给Servlet</p><p><img src="https://blog.chasingwind.top/1564367721427.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564367721427.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>然后,根据分析,在Servlet中完成对应的逻辑</p><p>将结果转发到jsp页面(<code>request.getRequestDispatcher(&quot;跳转到的jsp页面&quot;)</code>)  在后面的jsp页面中获取数据并进行数据的填写</p><p><img src="https://blog.chasingwind.top/1564368086675.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564368086675.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>完成DAO层的操作</p><p>将druid的配置文件放在src目录下</p><p><img src="https://blog.chasingwind.top/1564368522939.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564368522939.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>导入JDBCUtils工具类</p><p><img src="https://blog.chasingwind.top/1564368982623.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564368982623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>编写代码</p><p><img src="https://blog.chasingwind.top/1564369311823.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564369311823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>接下来就是在list.jsp页面进行数据的展示</p><p>首先,创建list.jsp</p><p>之后便是用EL和JSTL遍历查询到的List集合中的数据展示在页面上</p><p><img src="https://blog.chasingwind.top/1564369982721.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564369982721.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这个时候已经完成了查询的功能</p><p>检查跳转的页面是否正确,</p><p>删除无用的html文件</p></blockquote></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
            <tag> EL </tag>
            
            <tag> JSTL </tag>
            
            <tag> MVC </tag>
            
            <tag> 三层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session</title>
      <link href="2019/07/25/Cookie%E5%92%8CSession/"/>
      <url>2019/07/25/Cookie%E5%92%8CSession/</url>
      
        <content type="html"><![CDATA[<p>Cookie和Session分别是客户端会话技术和服务端会话技术，Cookie是将请求的会话数据存储到客户端，而Session则是将数据存储到服务器端。</p><a id="more"></a><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><ol><li>概念：在一次会话中，包含多次请求和响应。<ul><li>一次会话：浏览器第一次给服务器资源发送请求，<strong>会话建立</strong>，直到有一方断开，<strong>会话结束</strong>。</li></ul></li><li>功能：在一次会话的范围内（多次请求与响应之间）的多次请求间，共享数据（区别Http的请求与响应，是在域中共享数据,比如request域,servletContext域，是在某一次的请求与响应之中）</li><li>方式：<ol><li>客户端会话技术：Cookie，把数据存储到客户端</li><li>服务器端会话技术：Session，把数据存储到服务器端</li></ol></li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ol><li><p>概念：客户端会话技术，将数据保存到客户端</p></li><li><p>快速入门</p><ul><li><p>使用步骤</p><ol><li>创建Cookie对象，绑定数据<ul><li>Cookie类中：<code>new Cookie(String name, String value) </code></li></ul></li><li>通过<strong>服务器端的响应response</strong>，将Cookie对象发送到客户端<ul><li>HttpServletResponse接口中：<code>response.addCookie(Cookie cookie) </code></li></ul></li><li><strong>浏览器获取Cookie，通过request拿到数据：如果浏览器继续访问其他资源的话，浏览器的请求会自动将Cookie携带给服务器</strong><ul><li>HttpServletRequest接口中：<code>Cookie[]  request.getCookies()  </code></li></ul></li></ol><blockquote><p>CookieServletDemo1</p><p><img src="https://blog.chasingwind.top/1564051779699.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564051779699.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>CookieServletDemo2</p><p><img src="https://blog.chasingwind.top/1564051802647.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564051802647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>先访问Demo1打开会话 这样Cookie携带的信息就传递到了客户端存储起来了,再访问Demo2 就可以获取到之前存储在客户端的Cookie信息 ,在浏览器显示的结果是</p><p><img src="https://blog.chasingwind.top/1564051856228.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564051856228.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>就是我们发送的数据   </p><p>但是注意的一点就是  我们没有请求转发(forward)也没有重定向(redirect),两个Servlet之间并没有直接的联系  但是也是可以进行数据的传递的</p></blockquote></li><li><p>但是你在新的浏览器中直接访问Demo2 是不会有数据的 因为他们不在同一个会话中</p></li></ul></li><li><p>实现原理</p><ul><li><strong>基于响应头set-cookie和请求头cookie实现</strong></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564052241986.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564052241986.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>访问Demo1 服务器端会通过Set-Cookie: message=helloCookie 将Cookie发送到浏览器端</p><p><img src="https://blog.chasingwind.top/1564052306558.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564052306558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>访问Demo2 浏览器会携带Cookie: message=helloCookie 去请求服务器端</p><p><img src="https://blog.chasingwind.top/1564052346250.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564052346250.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>cookie的细节</p><ol><li><p>一次可不可以发送多个cookie?</p><ul><li>可以</li><li>创建多个cookie对象，使用response调用多次addCookie方法发送cookie即可。</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564060843995.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564060843995.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>cookie在浏览器中保存多长时间？</p><ol><li><p>默认情况下，Cookie是存储在浏览器的内存中，当浏览器关闭后，Cookie数据被销毁</p></li><li><p>持久化存储：</p><ol><li><p>setMaxAge（int seconds）</p><ul><li>参数为正数 ：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</li><li>负数：默认值</li><li>零：删除cookie信息</li></ul><blockquote><p>当参数是正数的时候</p><p>比如这里的<code>setMaxAge(60)</code>表示的含义有:</p><p>1 . 将cookie持久化存储到内存中 </p><p>2 . cookie的存活时间是60s</p><p><img src="https://blog.chasingwind.top/1564061298474.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564061298474.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>关闭浏览器再重新打开浏览器访问Demo2的时候(60s内),控制台输出了cookie的数据</p><p><img src="https://blog.chasingwind.top/1564061425995.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564061425995.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>时间超过60s,再去访问Demo2的时候,控制台不会输出数据,说明cookie已经被删除了</p></blockquote></li></ol></li></ol></li><li><p>cookie能不能存中文？</p><ul><li>在Tomcat8<strong>之前不</strong>支持中文数据<ul><li>将中文进行转码–一般用的是URL编码</li></ul></li><li>Tomcat8<strong>之后支持中文数据</strong>，但是对于特殊字符还是不支持，建议使用URL编码和URL解码进行编解码</li></ul></li><li><p>cookie共享问题？</p><ol><li><p>假设在<strong>一个tomcat服务器中，部署了多个web项目</strong>，那么在这些web项目中cookie能不能共享？</p><ul><li><p>默认情况下<strong>cookie是不共享的</strong></p></li><li><p>Cookie类中的方法：</p><p><strong>setPath(String path):设置cookie的获取范围</strong>。默认情况下，设置当前的虚拟目录</p></li><li><p><strong>如果要共享，则可以将path设置为”/“</strong></p></li></ul></li><li><p>不同的tomcat服务器间cookie共享问题？</p><ul><li><strong>setDomain（String path）</strong>：如果<strong>设置一级域名相同</strong>，那么多个服务器之间cookie可以共享</li><li>比如：setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</li></ul></li></ol></li></ol></li><li><p>Cookie的特点和作用</p><ol><li>特点<ol><li>cookie存储数据在客户端浏览器， 这样相比在服务器中存储不安全</li><li>浏览器对于单个cookie的大小有限制，以及同一域名下的总cookie数量也有限制</li></ol></li><li>作用：<ol><li>cookie一般用于存储少量的不太敏感的数据</li><li><strong>在不登录的情况下，完成服务器对客户端的身份识别</strong><ul><li>比如：百度首页的个性化设置，不登录的情况下也是可以进行设置的，当你退出重新进浏览器的时候 ，这些设置还在生效，也就是说这些设置存储在cookie中，你去请求百度页面的时候，会将这些cookie携带过去,百度服务器会根据cookie的信息对你的页面进行个性化的展示</li></ul></li></ol></li></ol></li></ol><h2 id="Cookie案例-记住上一次的访问时间"><a href="#Cookie案例-记住上一次的访问时间" class="headerlink" title="Cookie案例:记住上一次的访问时间"></a>Cookie案例:记住上一次的访问时间</h2><ol><li><p>需求：</p><ol><li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li><li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li></ol></li><li><p>分析：</p><ol><li>可以采用Cookie来完成</li><li>在服务器端的Servlet判断是否有一个名为lastTime的cookie<ol><li>有：说明不是第一次访问<ol><li>响应数据：欢迎回来，你上次访问的时间是2019年7月25日22:05:27</li><li>写回cookie：lastTime=2019年7月25日22:05:32</li></ol></li><li>没有：是第一次访问<ol><li>响应数据：您好，欢迎访问本站</li><li>写回cookie：lastTime=2019年7月25日22:06:10</li></ol></li></ol></li></ol></li><li><p>实现</p><blockquote><p><img src="https://blog.chasingwind.top/1564068970010.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564068970010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1564068991829.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564068991829.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564069004309.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564069004309.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>注意的问题：时间格式中的特殊字符Tomcat还是不支持的，这里需要进行<strong>URL编解码</strong></p></li></ol><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ol><li><p>概念：服务器端会话技术，在<strong>一次会话的多次请求间</strong>共享数据，将<strong>数据保存在服务器端的对象中</strong>。HttpSession</p></li><li><p>快速入门</p><ol><li><p>获取HttpSession对象</p><ul><li><code>HttpSession session = request.getSession();</code></li></ul></li><li><p>使用HttpSession对象</p><ul><li><code>Object getAttribute(String name)</code></li><li><code>void setAttribute(String name, Object value)</code></li><li><code>void removeAttribute(String name)  </code></li></ul><blockquote><p>SessionServletDemo1  用来存储数据  这里是第一次获取Session  因为之前没有进行存储 也就是说在服务器端是没有Session的, 所以就会创建一个新的Session(服务器帮我们创建) 并存储数据  然后响应给客户端(通过set-cookie:JSESSIONID=xxxx)  客户端存储下这个Cookie</p><p><img src="https://blog.chasingwind.top/1564136347816.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564136347816.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>SessionServletDemo2 在访问的过程中会通过cookie头携带JESSIONID去请求服务器 这样的话 我们就可以通过request,getSession获取到Session对象了  通过对比JESSIONID就可以知道是同一个Session了</p><p><img src="https://blog.chasingwind.top/1564136418659.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564136418659.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>先通过SessionServletDemo1 请求,再通过SessionServletDemo2请求</p><p>在控制台输出了共享的数据</p><p><img src="https://blog.chasingwind.top/1564136464949.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564136464949.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>将浏览器断开再去访问SessionServletDemo2,控制台没有输出,说明共享数据是在一次会话间的多次请求数据中</p><blockquote><p>控制台的输出为null , 说明并没有获取到数据</p><p><img src="https://blog.chasingwind.top/1564136592553.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564136592553.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Session原理</p><ul><li><p><strong>Session的实现是依赖于Cookie的</strong></p></li><li><p>在两个服务中都创建了Session对象，其实他们是同一个对象。那么服务器是怎样来判断这两次的Session对象是同一个的呢？</p><blockquote><p><img src="https://blog.chasingwind.top/1564136966959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564136966959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>Session的细节</p><ol><li><p>当客户端关闭后，服务器不关闭，两次获取的是不是同一个Session？</p><ul><li><p><strong>默认情况下不是同一个</strong>，因为客户端关闭后，一次会话就结束了，那么Cookie默认下是会被清除的,也就是说响应中的Set-cookie中携带的JSESSIONID就被清除了，那么再去请求的时候，携带的JSESSIONID就不再是之前的那一个了，也就不再是同一个Session了。</p><blockquote><p>第一次请求之后,关闭浏览器,再重新打开浏览器请求,发现获取的Session并不是同一个</p><p><img src="https://blog.chasingwind.top/1564138542510.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564138542510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>通过理解Session的原理，我们将Session的ID封装在响应头中通过Cookie发送到客户端并设置一定的存活时间</p><blockquote><p>可见,这两次获取的是同一个Session<br><img src="https://blog.chasingwind.top/1564138868864.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564138868864.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>当客户端不关闭，服务器关闭后(或者不是在同一次会话中的情况,比如你在浏览购物车,之后杀后台,但是这个购物车的数据还在)，两次获取的是不是同一个Session对象？</p><ul><li><strong>不是同一个，但是要确保数据不丢失</strong>，Tomcat已经帮我们完成这个功能<ul><li>Session的钝化：在服务器正常关闭之前，<strong>将Session对象序列化到硬盘上</strong></li><li>Session的活化：在服务器启动后，<strong>将Session文件转化为内存中的Session对象即可</strong></li></ul></li><li>当<strong>服务器正常关闭</strong>的时候，<strong>本地的Tomcat</strong>会将Session对象序列化到硬盘上，当服务器正常启动之后，这个序列化文件会被Tomcat自动读取并将本地文件删除，并将之前的Session对象还原到内存中，虽然这两次的Session的地址值不同，也就是说这两个Session不是同一个对象，但是这两次的Session的ID是相同的，这样就确保了数据不会丢失</li><li>IDEA会完成Session的钝化，但是活化的时候，会将存放Session的Work目录先删除，再新建一个Work目录，这样就不能读取倒这个序列化文件了，也就不能确保数据一样了</li></ul></li><li><p>Session什么时候被销毁？</p><ol><li><p>服务器关闭</p></li><li><p>Session对象调用HttpSession中的<code>invalidate()</code>方法自杀</p></li><li><p>Session的默认失效时间是30分钟，可以在web.xml中配置</p><pre><code class="xml">&lt;session-config&gt;    &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;</code></pre></li></ol></li></ol></li><li><p>Session的特点</p><ol><li>Session用于存储一次会话的多次请求的数据,<strong>存储在服务器端</strong></li><li>Session可以存储任意类型,任意大小的数据</li></ol></li><li><p>Session与Cookie的区别</p><ol><li>Session存储数据在服务器端，Cookie在客户端</li><li>Session没有数据大小限制，Cookie有</li><li>Session数据安全，Cookie相对于不安全</li></ol></li></ol><h2 id="Session案例-验证码"><a href="#Session案例-验证码" class="headerlink" title="Session案例:验证码"></a>Session案例:验证码</h2><ol><li><p>需求</p><ol><li>访问带有验证码的登录页面login.jsp</li><li>用户输入用户名，密码以及验证码。<ul><li>如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误</li><li>如果验证码输入有误，跳转登录页面，提示：验证码错误</li><li>如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</li></ul></li></ol></li><li><p>分析</p><blockquote><p><img src="https://blog.chasingwind.top/1564275034166.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564275034166.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>实现</p></li></ol><h1 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h1><h2 id="JSP入门"><a href="#JSP入门" class="headerlink" title="JSP入门"></a>JSP入门</h2><ol><li><p>概念：<strong>JSP=Java Server Pages：Java服务器端页面</strong>，可以理解为一个特殊的页面，其中既可以定义html标签，又可以写Java代码</p></li><li><p>作用:简化书写，页面中有一部分是需要用Java代码从服务器中来获取动态生成（writer（）方法），有一部分是静态的HTML页面</p></li><li><p><strong>JSP原理：JSP本质上就是一个Servlet</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1564109322811.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564109322811.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>Tomcat下的work目录中存放的是运行时产生的一些文件,其中放的就是.jsp生成的.java和.class文件</p><p><img src="https://blog.chasingwind.top/1564109669043.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564109669043.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>.java文件中可以看到他继承自HttpJspBase</p><p><img src="https://blog.chasingwind.top/1564109761639.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564109761639.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在Tomcat的源码中,可以发现HttpJspBase继承自HttpServlet</p><p><img src="https://blog.chasingwind.top/1564109989021.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564109989021.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在他的service方法中,输出页面标签的工作JSP回来帮我们完成</p></blockquote></li><li><p>JSP的脚本：JSP定义Java代码的方式</p><ul><li><p><code>&lt;% Java代码%&gt;</code>：定义的Java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。</p><blockquote><p><img src="https://blog.chasingwind.top/1564110289268.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564110289268.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在jsp转换后的java文件中的位置是在_jspService方法中</p><p><img src="https://blog.chasingwind.top/1564110451344.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564110451344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;%! Java代码%&gt;</code>：定义的是成员变量或者成员方法，在转换后的jsp的类的成员位置</p><blockquote><p><img src="https://blog.chasingwind.top/1564110743277.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564110743277.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>转换后的jsp文件中的位置是在成员变量的位置</p><p><img src="https://blog.chasingwind.top/1564110765668.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564110765668.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;%= Java代码%&gt;</code>：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</p><blockquote><p><img src="https://blog.chasingwind.top/1564111039028.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564111039028.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>转换后的jsp</p><p><img src="https://blog.chasingwind.top/1564111065385.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564111065385.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>JSP的内置对象</p><ul><li><p>在jsp页面中不需要获取和创建,就可以直接使用的对象</p><blockquote><p>request和out这两个对象,没有创建就直接使用</p><p><img src="https://blog.chasingwind.top/1564111263896.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564111263896.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>对应在jsp.java中的位置</p><p><img src="https://blog.chasingwind.top/1564111349574.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564111349574.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>因为这两个对象在jsp的.java中的service中都有声明</p></li><li><p>JSP一共有9个内置对象</p></li><li><p>今天学习3个：</p><ol><li><p>request</p></li><li><p>response</p></li><li><p>out：<strong>字符输出流</strong>对象。可以<strong>将数据输出到页面上</strong>。和response.getWriter()类似</p><ul><li><p>response.getWriter()和out.write()的区别： </p><ul><li>在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</li><li><strong>response.getWriter()数据输出永远在out.write()之前</strong></li></ul></li><li><p>以后直接用out输出就行了,以免打乱页面的数据</p></li></ul></li></ol></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http响应协议和Response</title>
      <link href="2019/07/24/Http%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%92%8CResponse/"/>
      <url>2019/07/24/Http%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%92%8CResponse/</url>
      
        <content type="html"><![CDATA[<p>Response对象用于动态响应客户端请示，控制发送给用户的信息，并将动态生成响应。Response对象只提供了一个数据集合cookie，它用于在客户端写入cookie值。若指定的cookie不存在，则创建它。若存在，则将自动进行更新。结果返回给客户端浏览器</p><a id="more"></a><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ol><li><p><strong>请求消息：客户端发送给服务器端的数据</strong></p><ul><li>数据格式<ol><li>请求行</li><li>请求头</li><li>请求空行</li><li>请求体</li></ol></li></ul></li><li><p><strong>响应消息：服务器端发送给客户端的数据</strong></p><ul><li><p>数据格式</p><ol><li><p>响应行</p><ol><li>组成：协议/版本 响应状态码 状态码描述</li><li><strong>响应状态码</strong>：服务器告诉客户端浏览器本次请求和响应的一个状态。<ol><li> 状态码都是3位数字 </li><li>分类<ol><li>1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码</li><li>2xx：成功。代表：200</li><li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li><li>4xx：客户端错误。代表：404（请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法</li><li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li></ol></li></ol></li></ol></li><li><p>响应头</p><ol><li><p>格式：头名称： 值</p></li><li><p><strong>常见的响应头</strong>：</p><ol><li><p><strong>Content-Type</strong>：服务器告诉客户端本次响应体数据格式以及编码格式</p><blockquote><p><strong>response.setContentType(String MIME)的作用是使客户端浏览器，区分不同种类的数据，并根据不同的MIME调用浏览器内不同的程序嵌入模块来处理相应的数据。</strong><br>例如web浏览器就是通过MIME类型来判断文件是GIF图片。通过MIME类型来处理json字符串。</p></blockquote></li><li><p><strong>Content-disposition</strong>：服务器告诉客户端以什么格式打开响应体数据</p><ul><li>值:<ol><li>in-line:默认值,在当前页面内打开</li><li>attachment;filename=xxx：以附件形式打开响应体。文件下载</li></ol></li></ul></li></ol></li></ol></li><li><p>响应空行</p></li><li><p>响应体：传输的数据</p><blockquote><p><img src="https://blog.chasingwind.top/1564013228374.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564013228374.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564013270375.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564013270375.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><ol><li><p>功能：设置响应消息</p><ol><li>设置响应行<ol><li>格式：HTTP/1.1 200 ok</li><li>设置状态码：setStatus（int sc）</li></ol></li><li>设置响应头：setHeader（String name, String value）</li><li>设置响应体：<ul><li>使用步骤：<ol><li>获取输出流<ul><li>字符输出流：PrintWriter getWriter()</li><li>字节输出流：ServletOutputStream getOutputStream()</li></ul></li><li>使用输出流，将数据输出到客户端浏览器</li></ol></li></ul></li></ol></li><li><p>完成重定向</p><ol><li><p>重定向：资源跳转的方式</p><blockquote><p><img src="https://blog.chasingwind.top/1564015255865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564015255865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>ResponseDemo1</p><p><img src="https://blog.chasingwind.top/1564016052341.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564016052341.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>ResponseDemo2</p><p><img src="https://blog.chasingwind.top/1564016103292.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564016103292.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>跳转结果</p><p><img src="https://blog.chasingwind.top/1564016120733.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564016120733.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>简化的重定向：因为每次重定向的状态码以及响应头location是相同的</p><blockquote><p>使用sendRedirect</p><p><img src="https://blog.chasingwind.top/1564016424713.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564016424713.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>重定向的特点：redirect</p><ol><li><p><strong>地址栏发生变化</strong></p></li><li><p>重定向<strong>可以访问其他站点(服务器)的资源</strong></p></li><li><p>重定向是<strong>两次请求</strong>。不能使用request对象来共享数据</p><blockquote><p><img src="https://blog.chasingwind.top/1564016753587.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564016753587.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>转发的特点：forward</p><ol><li>转发<strong>地址栏路径不变</strong></li><li>转发<strong>只能访问当前服务器下的资源</strong></li><li>转发是<strong>一次请求</strong>，可以使用request对象来共享数据</li></ol></li><li><p>路径的写法</p><ol><li><p><strong>相对路径</strong>：通过相对路径<strong>不可以确定</strong>唯一资源</p><p>如：<code>./index.html</code></p><p>以<code>.</code>开头的路径</p><ul><li>规则：找到当前资源和目标资源之间的相对位置关系,<strong>比较他们的绝对路径</strong></li></ul><p><code>./</code>:当前目录</p><p><code>../</code>:后退一级目录</p></li><li><p><strong>绝对路径</strong>：通过绝对路径<strong>可以确定</strong>唯一资源</p><p>如：<code>https://localhost/day15/responseDemo2    </code>    简化形式<code>/day15/responseDemo2</code></p><p>以<code>/</code>开头的路径</p><ul><li><p>规则:判断定义的路径是给谁用的？就是判断请求将来从哪儿发出</p><ol><li><p>给<strong>客户端浏览器使用</strong>：<strong>需要加</strong>虚拟目录(项目的访问路径)</p><ul><li><p>比如 ： <strong>HTML中的标签的地址<code>&lt;a&gt;</code>,<code>&lt;form&gt;</code>,以及重定向</strong></p></li><li><p>建议虚拟目录动态获取：<strong>request.getContextPath()</strong></p></li></ul></li><li><p>给<strong>服务器使用</strong>：<strong>不需要</strong>加虚拟目录  </p><ul><li><strong>比如：转发的时候的资源跳转</strong></li></ul></li></ol></li></ul></li><li><p>动态获取虚拟目录</p><ul><li>request.getContextPath()</li></ul></li></ol></li></ol></li><li><p>服务器输出<strong>字符数据</strong>到浏览器</p><ol><li><p>步骤</p><ol><li>获取字符输出流</li><li>输出数据</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1564021844133.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564021844133.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564021882086.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564021882086.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>其实也可以写标签</p><p><img src="https://blog.chasingwind.top/1564021927773.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564021927773.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>中文乱码的问题</p><ol><li><p>原因：编码和解码使用的字符集不相同</p><ul><li>服务器编码：输出流是response创建的 ，Tomcat默认的是ISO-8859-1</li><li>浏览器解码：默认的字符集和使用的操作系统的字符集相同中文的操作系统默认的是GBK（GBK2312扩展码）或者GBK2312</li></ul></li><li><p>解决：在<strong>获取流对象之前</strong>设置流的默认编码与浏览器解码使用的一致</p><blockquote><p><img src="https://blog.chasingwind.top/1564022392461.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564022392461.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564022872823.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564022872823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>这里还存在问题的,当我们不知道流的默认编码的时候,怎么办呢?</p><ul><li><p>告诉浏览器,服务器发送的消息体数据的编码,建议浏览器使用该编码进行解码</p><blockquote><p><img src="https://blog.chasingwind.top/1564022793692.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564022793692.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564022808246.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564022808246.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>简化的形式</p><blockquote><p><img src="https://blog.chasingwind.top/1564023064047.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564023064047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>服务器输出<strong>字节数据</strong>到浏览器</p><ol><li><p>获取字节输出流</p></li><li><p>输出数据 转换为字节</p><blockquote><p><img src="https://blog.chasingwind.top/1564023789223.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564023789223.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564023807823.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564023807823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>验证码</p><ol><li><p>本质：就是一张图片</p></li><li><p>目的：防止恶意表单注册  </p></li><li><p>生成基本的图片</p><blockquote><p><img src="https://blog.chasingwind.top/1564027742750.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564027742750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>生成的默认图片是这样的</p><p><img src="https://blog.chasingwind.top/1564027937853.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564027937853.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>美化图片</p><blockquote><p><img src="https://blog.chasingwind.top/1564029749199.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564029749199.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>效果</p><p><img src="https://blog.chasingwind.top/1564029768910.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564029768910.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用javascript来实现验证码的切换</p><blockquote><p><img src="https://blog.chasingwind.top/1564030915782.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564030915782.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>巧妙利用时间戳来避免浏览器不刷新!!</p></blockquote></li></ol></li></ol><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><ol><li><p>概念：代表<strong>整个web应用</strong>，可以和程序的容器(服务器)来通信，进行数据的交互</p></li><li><p>获取</p><ol><li><p>通过request对象获取</p><ul><li>request.getServletContext();</li></ul></li><li><p>通过HttpServlet获取</p><ul><li>getServletContext()</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564036235602.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564036235602.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p>可见 获取的结果是同一个对象</p><p><img src="https://blog.chasingwind.top/1564036276234.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564036276234.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>功能</p><ol><li><p>获取MIME类型</p><ul><li>MIME类型：在互联网通信过程中定义的一种文件数据类型<ul><li>格式： 大类型/小类型  比如：text/html    image/jpeg</li></ul></li><li><strong>作用</strong>：就是告诉客户端，服务器发送的数据类型</li><li>获取MIME类型：String getMimeType（String file）  这个方法是通过文件名来获取的MIME类型</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1564036968446.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564036968446.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1564036983384.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564036983384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>域对象：共享数据</p><ol><li>方法：<ol><li>setAttribute（String name,Object value）</li><li>getAttribute（String name）</li><li>removeAttribute（String name）</li></ol></li><li>ServletContext对象范围：<strong>所有用户所有请求的数据</strong></li></ol></li><li><p>获取文件的真实（服务器端路径）路径</p><p>因为我们是在编译器中编写代码,此时资源对应的位置即使工作目录中的位置,而当我们把项目发布到服务器上面的时候,我们通过浏览器进行访问,就需要知道在工作目录中的资源对应到服务器上面的资源的路径,以便我们通过浏览器进行访问.</p><ol><li><p>方法 ：String getRealPath（String path）</p><blockquote><p>这个目录下就是将来发布到服务器上的</p><p><img src="https://blog.chasingwind.top/1564038490020.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564038490020.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>工作空间文件目录</p><p><img src="https://blog.chasingwind.top/1564038738470.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564038738470.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>通过工作空间中的文件和getRealPath()方法获取服务器目录</p><ol><li><p>文件在web目录下</p><p><img src="https://blog.chasingwind.top/1564038674165.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564038674165.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564038763024.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564038763024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></li><li><p>文件在web目录下的WEB-INF目录下</p><p><img src="https://blog.chasingwind.top/1564038853086.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564038853086.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564038869747.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564038869747.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></li><li><p>文件在src目录下,将来在服务器上会放在WEB-INF目录下的classes目录下</p><p><img src="https://blog.chasingwind.top/1564038956029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564038956029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564039013113.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564039013113.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1564039028374.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564039028374.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在<strong>src目录下的文件还可以通过类加载器来获取</strong>  但是他不能获取web目录下的文件 所以有局限性</p></li></ol></blockquote></li></ol></li></ol></li></ol><h2 id="文件下载案例"><a href="#文件下载案例" class="headerlink" title="文件下载案例"></a>文件下载案例</h2><ol><li><p>需求</p><ol><li>页面显示超链接</li><li>点击超链接后弹出下载提示框</li><li>完成图片文件下载</li></ol></li><li><p>分析</p><ol><li>超链接指向的<strong>资源如果能够被浏览器解析</strong>，则<strong>在浏览器中展示</strong>，<strong>如果不能解析，则弹出下载提示框</strong>。不满足需求</li><li>任何资源都必须弹出下载提示框</li><li>使用响应头设置资源的打开方式：content-disposition:attachment;filename=xxx</li></ol></li><li><p>步骤：</p><ol><li>定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename</li><li>定义Servlet<ol><li>获取文件名称</li><li>使用字节输入流加载文件进内存</li><li>指定response的响应头： content-disposition:attachment;filename=xxx</li><li>将数据写出到response输出流</li></ol></li></ol></li><li><p>实现</p><blockquote><p>html页面中href属性的填写</p><p><img src="https://blog.chasingwind.top/1564043408374.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564043408374.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Servlet的编写</p><p><img src="https://blog.chasingwind.top/1564043493018.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564043493018.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>结果</p><blockquote><p><img src="https://blog.chasingwind.top/1564043529152.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564043529152.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>存在的问题：中文文件名的问题</p><blockquote><p><img src="https://blog.chasingwind.top/1564043901256.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564043901256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>文件名变成了__.jpg</p></blockquote><ul><li><p>解决思路</p><ol><li>获取客户端使用的浏览器的版本信息</li><li>根据不同的版本信息,设置filename的编码方式的不同</li></ol><blockquote><p>DownLoadUtils包根据不同的浏览器的版本进行不同编码的设置</p><p><img src="https://blog.chasingwind.top/1564044229408.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564044229408.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>通过工具类修改文件名</p><p><img src="https://blog.chasingwind.top/1564044563519.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564044563519.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果</p><p><img src="https://blog.chasingwind.top/1564044653046.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1564044653046.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Response </tag>
            
            <tag> Http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Request练习:登录页面</title>
      <link href="2019/07/24/Request%E7%BB%83%E4%B9%A0-%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/"/>
      <url>2019/07/24/Request%E7%BB%83%E4%B9%A0-%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>看似简单的登录页面,其实背后的逻辑试试有点复杂的,要用到数据库中的Druid连接池,JDBCTemplate；还有Servlet中的请求转发,数据共享等等</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>用户登录案例需求：<br>    1.编写login.html登录页面<br>        username &amp; password 两个输入框<br>    2.使用Druid数据库连接池技术,操作mysql，loggin数据库中user表<br>    3.使用JdbcTemplate技术封装JDBC<br>    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您<br>    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p><img src="https://blog.chasingwind.top/1563958607803.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563958607803.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>创建项目，导入html页面，配置文件，jar包</p><blockquote><p>一般我们会在web下的<code>WEB-INF</code>创建lib包来存储导入的jar包,并Add as Library</p><p><img src="https://blog.chasingwind.top/1563959068960.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959068960.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建数据库以及表</p><blockquote><p><img src="https://blog.chasingwind.top/1563959143728.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959143728.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Package domain , 编写User用户类</p><blockquote><p>目录</p><p><img src="https://blog.chasingwind.top/1563959257676.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959257676.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563959210402.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959210402.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Package util , 编写工具类JDBCUtils</p><blockquote><p><img src="https://blog.chasingwind.top/1563959325298.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959325298.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563959451681.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959451681.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Package dao , 编写类UserDao , 其中提供login方法</p><blockquote><p><img src="https://blog.chasingwind.top/1563959527984.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959527984.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563959623634.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959623634.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Package test , 进行单元测试 , 查看数据库等是否正常</p><blockquote><p><img src="https://blog.chasingwind.top/1563959718946.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959718946.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Test1</p><p><img src="https://blog.chasingwind.top/1563959749195.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959749195.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>Test2</p><p><img src="https://blog.chasingwind.top/1563959848026.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959848026.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建Package web ,编写LoginServlet类 </p><blockquote><p><img src="https://blog.chasingwind.top/1563959977727.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563959977727.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>编写FailServlet和SuccessServlet类</p><blockquote><p>FailServlet</p><p><img src="https://blog.chasingwind.top/1563960029341.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563960029341.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>SuccessSevlet</p><p><img src="https://blog.chasingwind.top/1563960098119.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563960098119.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>填写login.html的form表单的action的属性为 ：虚拟目录 + Servlet资源路径</p><blockquote><p><img src="https://blog.chasingwind.top/1563960131441.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563960131441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>进行整体测试</p><blockquote><p>正确的用户名和密码</p><p><img src="https://blog.chasingwind.top/1563960325205.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563960325205.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>错误的用户名或密码</p><p><img src="https://blog.chasingwind.top/1563960386224.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563960386224.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>改进：使用BeanUtils工具类，简化数据封装</p><ul><li><p>在LoginServlet中,当获取的参数很多的时候 ,这样操作就很麻烦</p><blockquote><p><img src="https://blog.chasingwind.top/1563962629145.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563962629145.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>期望就是 一次把所有的参数都获取出来  并且将他们一次封装成对象</p></li><li><p>BeanUtils的使用</p><blockquote><p><img src="https://blog.chasingwind.top/1563963096720.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563963096720.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>BeanUtils工具类:用于封装JavaBean</p><ol><li><p>什么是JavaBean?</p><ul><li><p>JavaBean : 标准的Java类  一般放在domain包下</p><ol><li>要求：<ol><li>类必须被public修饰</li><li>必须提供空参的构造器</li><li>成员变量必须使用private修饰</li><li>提供公共setter和getter方法</li></ol></li><li>功能：封装数据</li></ol></li><li><p>一些概念</p><ol><li><p>成员变量</p><p>就是我们声明的变量</p><blockquote><p><img src="https://blog.chasingwind.top/1563963860215.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563963860215.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>属性：大多数情况下和成员变量是相同的</p><ul><li><p>getUsername() –&gt; Username–&gt; <strong>username</strong></p></li><li><p>但也难免出现这样的</p><blockquote><p><img src="https://blog.chasingwind.top/1563963980904.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563963980904.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>方法：</p><ol><li><p>setProperty() ：设置<strong>属性值</strong> ，而不是成员变量</p><blockquote><p>参数分别是Bean对象 , <strong>属性名,属性值</strong></p><p><img src="https://blog.chasingwind.top/1563964311027.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563964311027.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1563964490479.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563964490479.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>getProperty()：获取属性值</p></li><li><p><strong>populate（Object obj , Map map）</strong>：将map集合的键值对信息，<strong>封装到对应的JavaBean对象中</strong></p><ul><li>把键当作属性的名称 , 值当作JavaBean对应的属性的值进行封装，会自动解析并遍历map</li></ul></li></ol></li></ol></li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Request </tag>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http请求协议和Request</title>
      <link href="2019/07/22/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/"/>
      <url>2019/07/22/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/</url>
      
        <content type="html"><![CDATA[<p>Request用来取出请求信息，Request对象是服务器对浏览器请求的封装。本节介绍了Request的基本原理以及其中一些常用的方法，并且利用所学的知识进行登录案例的实现。</p><a id="more"></a><h2 id="HTTP请求协议"><a href="#HTTP请求协议" class="headerlink" title="HTTP请求协议"></a>HTTP请求协议</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HTTP : Hyper Text Transfer Protocol 超文本传输协议</p><ul><li><p>传输协议 : 定义了<strong>客户端和服务器端通信时，发送数据的格式</strong></p></li><li><p>HTTP 协议特点 : </p><ol><li><strong>基于TCP/IP的高级协议</strong></li><li><strong>默认端口号:80</strong></li><li>基于请求/响应模型 : 一次请求对应一次响应</li><li> 无状态的：每次请求之间相互独立，不能交互数据</li></ol></li><li><p>历史版本</p><ul><li>1.0：每一次请求响应都会建立新的连接</li><li>1.1：<strong>复用连接</strong> 每次请求响应之后不会立即将连接断开,而是等一会,如果有新的请求,就会复用刚才的连接;如果没有请求,就会释放连接</li></ul><h3 id="请求消息的数据格式"><a href="#请求消息的数据格式" class="headerlink" title="请求消息的数据格式"></a>请求消息的数据格式</h3><ol><li><p>请求行</p><ul><li><strong>格式 : 请求方式 请求url 请求协议/版本</strong></li><li><strong>请求方式</strong> : HTTP协议有7种请求方式，常用的有2种<ul><li><strong>GET</strong> :<ol><li>请求参数在<strong>请求行</strong>中，在URL后。</li><li>请求的URL长度有限制的</li><li>不太安全</li></ol></li><li><strong>POST</strong> : <ol><li>请求参数在<strong>请求体</strong>中</li><li>请求的url长度没有限制的</li><li>相对安全</li></ol></li></ul></li><li><strong>请求URL</strong><ul><li>GET后面可能会有请求的数据</li><li>POST后面不会有请求的数据</li></ul></li></ul></li><li><p>请求头 : 客户端浏览器告诉服务器一些信息</p><ul><li>格式 : 请求头名称: 请求头值</li><li>常见的请求头<ol><li>Host : localhost 表示请求的主机是localhost</li><li>User-Agent : ….  浏览器告诉服务器 , 我访问你使用的浏览器的版本信息<ul><li>作用就是在服务器端获取该头的信息 , <strong>解决浏览器的兼容问题</strong></li></ul></li><li>Accept : … 告诉服务器,我作为浏览器可以接受什么样的信息格式</li><li>Referer :<code> http://localhost:8080/hello.html</code><ul><li>告诉服务器,当前请求从哪里来<ul><li>作用 : 1.防止别人盗取连接 , 2.统计工作</li></ul></li></ul></li><li>Connection : keep-alive  表示连接可以被复用</li></ol></li></ul><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563801615588.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563801615588.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>请求空行</p><ul><li>空行 ,就是用于分隔POST请求的请求头，和请求体的。</li></ul></li><li><p>请求体（正文） <strong>&lt;POST方式有请求体 GET方式没有请求体&gt;</strong> </p><ul><li>封装POST请求消息的请求参数的</li></ul><blockquote><p>POST方式的<strong>请求体</strong></p><p>就是我们提交的表单数据</p><p>username=zhangsan</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563800974576.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563800974576.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>而 GET方式是没有请求体的  提交的数据会在<strong>请求行中</strong></p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563801199796.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563801199796.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注 :  这里有个大坑就是</p><p>注释掉doXxx()中的super.doXxx(),不然405错误</p></blockquote></li></ol></li></ul><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Request原理"><a href="#Request原理" class="headerlink" title="Request原理"></a>Request原理</h3><blockquote><p>Request对象和Reponse对象</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563807053243.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563807053243.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>request原理</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563807365987.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563807365987.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol><li><p>request对象和response对象的原理</p><ol><li>Request对象和Response对象是<strong>由服务器创建</strong>的。我们来使用它们</li><li>Request对象是来<strong>获取请求消息</strong>，Response对象是来<strong>设置响应消息</strong></li></ol></li></ol><h3 id="request对象继承体系结构"><a href="#request对象继承体系结构" class="headerlink" title="request对象继承体系结构"></a>request对象继承体系结构</h3><p>   ServletRequest        –    接口</p><p>  ———-↑   继承————-</p><p>   HttpServletRequest    – 接口</p><p>  ———-↑   继承————–</p><p>   org.apache.catalina.connector.RequestFacade 类   (tomcat实现 ,将来tomcat通过这个类创建request对象,并传递给service方法)</p><h3 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a>request功能</h3><h4 id="获取请求消息数据"><a href="#获取请求消息数据" class="headerlink" title="获取请求消息数据"></a>获取请求消息数据</h4><h5 id="获取请求行数据"><a href="#获取请求行数据" class="headerlink" title="获取请求行数据"></a>获取请求行数据</h5><p><code>GET /day14/demo1?name=zhangsan HTTP/1.1</code></p><ul><li><p>方法 :</p><ol><li>获取请求方式 ：GET<ul><li>String getMethod()</li></ul></li><li>获取虚拟目录 : /day14<strong>（重点）</strong><ul><li>String getContextPath()</li></ul></li><li>获取Servlet路径 : /demo1<ul><li>String getServletPath()</li></ul></li><li>获取<strong>get方式请求参数</strong>：name=zhangsan<ul><li>String getQueryString()</li></ul></li><li>获取请求URI：/day14/demo1  <strong>（重点）</strong><ul><li>String getRequestURI():        /day14/demo1</li><li>StringBuffer getRequestURL() : <code>https://localhost/day14/demo1</code></li></ul></li><li>获取协议及版本：HTTP/1.1<ul><li>String getProtocol()</li></ul></li><li>获取客户机的IP地址：<ul><li>String getRemoteAddr()</li></ul></li></ol><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563871968331.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563871968331.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>输入的URL</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872042678.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872042678.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872003336.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872003336.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>URL : 统一资源定位符   <code> https://localhost:8080/Servlet/servletDemo1</code></p></li><li><p>URI :  统一资源标识符  <code>/Servlet/servletDemo1</code></p></li><li><p>URI的范围比URL的范围大</p></li></ul><h5 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h5><ol><li><p>String getHeader(String name):通过请求头的名称获取请求头的值<strong>（重点）</strong></p></li><li><p>Enumeration<String> getHeaderNames():获取所有的请求头名称</p><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872689530.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872689530.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872705877.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563872705877.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563873057303.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563873057303.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563873082422.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563873082422.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h5 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据"></a>获取请求体数据</h5><ul><li><p>请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p></li><li><p>步骤 : </p><ol><li>获取流对象<ul><li>BufferedReader getReader()：获取<strong>字符输入流</strong>，只能操作字符数据</li><li>ServletInputStream getInputStream()：获取<strong>字节输入流</strong>，可以操作所有类型数据</li></ul></li><li>再从流对象中拿数据</li></ol><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874408634.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874408634.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874429689.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874429689.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>html页面</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874452578.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874452578.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874472021.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563874472021.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h4 id="其他的功能"><a href="#其他的功能" class="headerlink" title="其他的功能"></a>其他的功能</h4><h5 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h5><p>通用方式 : 不论get还是post请求方式都可以使用下列方法来获取请求参数&lt;ServletRequest类中的方法&gt;</p><ol><li><p><strong>String getParameter(String name)   :   根据请求消息中的请求参数名称获取请求参数值</strong>  </p><ul><li>比如 ： 对于username=zs&amp;password=123  参数为username 返回zs</li></ul><blockquote><p>代码</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563876008533.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563876008533.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>post方式的html</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563875555148.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563875555148.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563876084953.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563876084953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><hr><p>get方式</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563875675915.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563875675915.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563876044375.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563876044375.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>可见 ,doPost和doGet中的代码是一样的  所以我们可以进行简化</p><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1564100045955.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1564100045955.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>String[] getParameterValues(String name):根据参数名称<strong>获取参数值的数组</strong>  </p><ul><li>比如 : hobby=xx&amp;hobby=game , 参数为hobby，返回xx和game。多用于复选框</li></ul><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883424357.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883424357.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883479780.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883479780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>结果   复选框中勾选的都会显示</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883461121.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883461121.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Enumeration<String> getParameterNames():获取所有请求的参数名称</p><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883747850.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883747850.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883769355.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883769355.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的话 可以通过这个参数名获取值</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883972433.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883972433.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883998558.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563883998558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意一点的是: getparameter获取的结果是String,而不是数组,在复选框中只会显示一个结果</p></blockquote></li><li><p>Map&lt;String,String[]&gt; getParameterMap()  :  获取所有参数的map集合</p><ul><li>注意: 这里的键是String类型的,值是String[]</li></ul><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563884441530.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563884441530.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样就解决了上面的通过getParameter获取的结果只有一个的问题</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563884493919.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563884493919.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>中文乱码问题</p><ul><li><p>get方式下 : Tomcat 8 已经将get方式乱码问题解决了</p></li><li><p>post方式：会乱码</p><ul><li>解决 ： <strong>在获取参数前，设置request的编码</strong>。request.setCharacterEncoding(“页面的编码方式”);</li></ul><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563885127346.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563885127346.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563885201027.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563885201027.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h5 id="请求转发：一种在服务器内部的资源跳转方式"><a href="#请求转发：一种在服务器内部的资源跳转方式" class="headerlink" title="请求转发：一种在服务器内部的资源跳转方式"></a>请求转发：一种<strong>在服务器内部的资源跳转方式</strong></h5><ol><li><p>步骤</p><ol><li>通过request对象<strong>获取请求转发器对象</strong>：RequestDispatcher getRequestDispatcher(String path)  这里的参数<strong>path就是转发的目的地</strong></li><li>使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) </li></ol><blockquote><p>ServletDemo3</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890524599.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890524599.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>ServletDemo4</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890544455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890544455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果 ,我们在浏览器中访问的是/servletSDemo3</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890589405.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890589405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>控制台的结果 不仅有Demo3还有Demo4</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890627077.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563890627077.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>特点</p><ol><li>这里的转发可以发现,当资源跳转的时候,<strong>浏览器的地址栏路径并未发生改变</strong></li><li><strong>转发之后的路径只能是当前服务器的内部资源</strong> , 不能是外部资源（比如 ： <code>www.baidu.com</code>）</li><li>转发过程中,<strong>只对服务器有一次请求</strong>，尽管在资源之间进行跳转多次</li></ol></li></ol><h5 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h5><ul><li><p>域对象 ：一个有作用范围的对象，可以在范围内共享数据</p></li><li><p>request域 ：代表<strong>一次请求的范围（多个Servlet之间），一般用于请求转发的多个资源中共享数据</strong></p></li><li><p>方法 ：</p><ol><li>void setAttribute(String name,Object obj):存储数据</li><li>Object getAttitude(String name):通过键获取值</li><li>void removeAttribute(String name):通过键移除键值对</li></ol><blockquote><p>ServletDemo3中存储数据到resquest域</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891535720.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891535720.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>ServletDemo4通过键来获取值</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891602678.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891602678.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果  访问Demo3跳转到Demo4  其中Demo4也获取到Demo3的共享的数据</p><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891640549.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891640549.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>ServletContext域</p><ul><li>作用范围 : <strong>整个webApps内的一个应用程序范围。</strong>也就是说Request域只能由相应的Requset访问（别的request不能访问），<strong>而ServletContext可以由该应用程序下的所有Servlet和Request访问，所以它的作用是实现数据的共享</strong>。共享的数据一般为该应用程序共同使用的数据，例如数据库的url，密码，用户名等等。</li></ul></li><li><p>获取ServletContext</p><ul><li><p>ServletContext  getServletContext() : 返回Context对象</p><blockquote><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891896783.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891896783.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891919967.png" class="lazyload" data-srcset="https://blog.chasingwind.top/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/1563891919967.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Http协议 </tag>
            
            <tag> Request </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet及其相关配置</title>
      <link href="2019/07/22/Servlet%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>2019/07/22/Servlet%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Server Applet , 运行在服务器端的小程序，Servlet就是一个接口，定义了Java类被浏览器访问到（或者说是被Tomcat识别）的规则。</p><a id="more"></a><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p> Servlet : Server Applet , <strong>运行在服务器端</strong>的小程序</p></li><li><p>Servlet就是一个<strong>接口</strong>，定义了Java类被浏览器访问到（或者说是被Tomcat识别）的规则。</p></li><li><p>将来我们<strong>自定义一个类</strong>，实现Servlet接口，重写其中的方法, 从而被Tomcat识别,那么这个类就是Servlet</p><blockquote><p><img src="https://blog.chasingwind.top/1563768634233.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563768634233.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Java EE7文档</p><p><img src="https://blog.chasingwind.top/1563769190537.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563769190537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>创建Java EE项目</p><blockquote><p><img src="https://blog.chasingwind.top/1563770284837.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563770284837.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>定义一个类,并实现Servlet接口</p></li><li><p>实现接口中的抽象方法</p><blockquote><p><img src="https://blog.chasingwind.top/1563770262350.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563770262350.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>配置Servlet</p><ul><li>因为访问的时候是通过URL进行访问的,也就是需要将这个类映射到访问路径</li></ul><blockquote><p>在<code>web.xml</code>文件中进行配置</p><p><img src="https://blog.chasingwind.top/1563770390053.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563770390053.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>结果</p><blockquote><p>浏览器页面没有内容 每次刷新浏览器 都会在控制台显示 说明这个方法被调用了 </p><p><img src="https://blog.chasingwind.top/1563770493321.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563770493321.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="Servlet的执行原理"><a href="#Servlet的执行原理" class="headerlink" title="Servlet的执行原理"></a>Servlet的执行原理</h3><ol><li>当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li><li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li><li>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</li><li>Tomcat会将字节码文件加载进内存，并且创建其对象</li><li>调用其方法</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563770978914.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563770978914.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><h3 id="Servlet中的生命周期（方法）"><a href="#Servlet中的生命周期（方法）" class="headerlink" title="Servlet中的生命周期（方法）"></a>Servlet中的生命周期（方法）</h3><ol><li><p>被创建 : 执行init方法 , 只执行一次</p><ul><li><p>Servlet什么时候被创建?</p><ul><li><p>默认情况下，<strong>第一次被访问时，Servlet被创建</strong></p></li><li><p>可以配置执行Servlet的创建时机。</p><ul><li><p>在<code>&lt;servlet&gt;</code>标签下配置<code>&lt;load-on-startup&gt;</code></p><ol><li><p><strong>第一次被访问时，创建</strong></p><ul><li><code>&lt;load-on-startup&gt;</code>的值为负数,其实我们不写这个标签的话  默认值就是-1</li></ul><blockquote><p>第一次被访问才会执行<br><img src="https://blog.chasingwind.top/1563779224183.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563779224183.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><strong>在服务器启动时，创建</strong></p><ul><li><code>&lt;load-on-startup&gt;</code>的值为0或正整数</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563779145792.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563779145792.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ul></li><li><p>Servlet中的的<strong>init()方法，只执行一次</strong>，说明<strong>一个Servlet在内存中只存在一个对象</strong>，也就是说Servlet是单例的</p><ul><li><p>多个用户同时访问的时候, 可能存在线程安全问题</p><p>解决方案 : 尽量不要在Servlet中定义成员变量 , 即使定义了成员变量,也不要对其进行值的修改 , 这样就不会出现并发的问题</p></li></ul></li></ul></li><li><p>提供服务 : 执行service()方法 , 执行多次</p><ul><li><strong>每次访问Servlet时，Service方法都会被调用一次</strong></li></ul></li><li><p>被销毁 : <strong>执行destory方法,只执行一次</strong></p><ul><li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li><li>只有<strong>服务器正常关闭时，才会执行destroy方法</strong>。</li><li><strong>destroy方法在Servlet被销毁之前执行</strong>，一般用于释放资源</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563778113422.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563778113422.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当刷新浏览器的时候 一直执行的是service方法 , 而init还是只执行了一次</p><p><img src="https://blog.chasingwind.top/1563778175567.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563778175567.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>服务器正常关闭的时候执行destroy方法</p><p><img src="https://blog.chasingwind.top/1563778255054.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563778255054.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>getServletConfig : 获取ServletConfig对象</p><blockquote><p><img src="https://blog.chasingwind.top/1563778435444.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563778435444.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>getServletInfo : 获取Servlet的一些信息,比如版本,作者等</p><blockquote><p><img src="https://blog.chasingwind.top/1563778535434.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563778535434.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h3 id="Servlet-3-0-注解配置"><a href="#Servlet-3-0-注解配置" class="headerlink" title="Servlet 3.0 注解配置"></a>Servlet 3.0 注解配置</h3><p>好处 : </p><ul><li><p>支持注解配置 , 可以不需要web.xml了</p></li><li><p>步骤 :</p><ol><li><p>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</p><blockquote><p><img src="https://blog.chasingwind.top/1563780343813.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563780343813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>定义一个类，实现Servlet接口</p></li><li><p>重写其中的方法</p></li><li><p>在类上使用@WebServlet注解，进行配置</p><blockquote><p><img src="https://blog.chasingwind.top/1563780779701.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563780779701.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这里仅仅需要配置访问路径就行了,而全类名因为这个注解本来就在这个类里面,就不需要写了</p><hr><p>更简单的  直接写 <code>@WebServlet(&quot;资源路径&quot;)</code></p><p><img src="https://blog.chasingwind.top/1563780977029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563780977029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>注 : <strong>Java EE6之后才支持Servlet3.0</strong></p></li></ul><h3 id="IDEA与Tomcat的相关配置"><a href="#IDEA与Tomcat的相关配置" class="headerlink" title="IDEA与Tomcat的相关配置"></a>IDEA与Tomcat的相关配置</h3><ol><li>IDEA会为每一个Tomcat部署的项目单独建立一份配置文件<ul><li>查看控制台的log：Using CATALINA_BASE:  ….</li></ul></li><li>工作空间项目    和     Tomcat部署的web项目<ul><li>Tomcat真正访问的是“Tomcat部署的web项目”，”<strong>Tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源</strong></li><li>WEB-INF目录下的资源不能被浏览器直接访问。</li></ul></li><li>断点调试：使用”小虫子”启动 debug 启动</li></ol><h3 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h3><p>Servlet – 接口</p><p>​    ↓</p><p>GenericServlet – 抽象类</p><p>​    ↓</p><p>HttpServlet  – 抽象类</p><ol><li><p>GenericServlet：将Servlet接口中其他的方法做了默认空实现，<strong>只将service()方法作为抽象</strong></p><ul><li><p>将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可</p><blockquote><p><img src="https://blog.chasingwind.top/1563783185682.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563783185682.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>HttpServlet</p><ul><li><p>为什么会有HttpServlet类的出现 ?</p><ul><li>将来service方法需要从服务器中处理的事情 : 获取数据 , 但是在获取数据之前需要进行判断数据的请求方式是Post或者Get , 当我们使用GenericServlet方法的时候 , 这些判断是需要我们自己写的 , 这些我们自己写的话, 每次使用service都需要我们自己在service方法中进行编写 这样就很麻烦</li><li>HttpServlet帮我们进行了上述的判断的操作 , 并且在判断中实现了不同的doXxx()方法 所以我们只需要实现doXxx()方法就行了</li></ul></li><li><p>HttpServlet : <strong>对http协议的一种封装，简化操作</strong></p><blockquote><p>在HttpServlet类中的service方法中对Http的7种请求方式进行了判断  </p><p><img src="https://blog.chasingwind.top/1563784351589.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563784351589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用步骤</p><ol><li>定义类继承HttpServlet</li><li>重写doGet和doPost方法</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563784724149.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563784724149.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h3 id="Servlet的相关配置"><a href="#Servlet的相关配置" class="headerlink" title="Servlet的相关配置"></a>Servlet的相关配置</h3><ol><li><p>urlpartten:Servlet访问路径</p><ol><li><p>一个Servlet可以定义多个访问路径,这些访问路径访问的都是同一个资源文件 ： @WebServlet（{“/d4”,”/dd4”,”/ddd4”}）</p></li><li><p>路径定义规则：</p><ol><li>/xxx：路径匹配</li><li>/xxx/xxx :  多层路径，目录结构</li><li>*.扩展名：扩展名匹配  前面不能加<code>/</code>, </li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563786478297.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563786478297.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="2019/07/21/Tomcat/"/>
      <url>2019/07/21/Tomcat/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>复习 :</p><p>网络通信三要素</p><ul><li><p>IP：电子设备(计算机)在网络中的唯一标识。</p></li><li><p>端口：应用程序在计算机中的唯一标识。 0~65536</p></li><li><p>传输协议：规定了数据传输的规则</p><ul><li>基础协议：<ul><li>TCP:安全协议，三次握手。 速度稍慢</li><li>UDP：不安全协议。 速度快</li></ul></li></ul></li></ul><h2 id="Web服务器软件"><a href="#Web服务器软件" class="headerlink" title="Web服务器软件"></a>Web服务器软件</h2><ul><li>服务器：安装了服务器软件的计算机</li><li>服务器软件：接收用户的请求，处理请求，做出响应</li><li>Web服务器软件：接收用户的请求，处理请求，做出响应。<ul><li>在web服务器软件中，可以部署Web项目，让用户通过浏览器来访问这些项目</li><li>动态资源需要借助Web服务器软件才能运行 , 所以有时候Web服务器软件也称为Web容器</li></ul></li><li>常见的java相关的web服务器软件：<ol><li>webLogic：Oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</li></ol></li><li>Java EE : Java语言在企业级开发中使用的技术规范的总和，一共<strong>规定了13项大的规范</strong></li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><ol><li><p>下载</p></li><li><p>安装 : 解压即可 , 安装的目录建议不要有中文和空格</p></li><li><p>卸载 : 删除解压的文件夹就行</p><blockquote><p>Tomcat文件目录</p><p><img src="https://blog.chasingwind.top/1563714322596.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563714322596.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="目录"></p></blockquote></li><li><p>启动 </p><ol><li><p>bin/startup.bat ,双击运行该文件即可</p></li><li><p>访问 : 浏览器输入 :</p><ul><li><code>https://localhost:8080</code>   访问自己</li><li><code>https://别人的ip:8080</code>   访问别人</li></ul></li><li><p>可能遇到的问题</p><ol><li><p>黑窗口一闪而过</p><ul><li>原因 : 没有正确配置JAVA_HOME环境变量</li><li>因为Tomcat纯java编写,启动和运行需要依赖电脑上的jdk ,所以正确配置JAVA_HOME</li></ul></li><li><p>启动报错</p><ul><li><p>一般是因为8080端口被占用</p><p>解决方法1 :结束占用端口的进程</p><ul><li><code>netstat -ano</code> : Cmd查看进程的端口号和对应的PID(进程ID),根据PID去任务管理器结束进程</li></ul><p>解决方法2: 修改Tomcat的端口号</p><ul><li><p>conf文件夹下的server.xml文件的默认端口号</p><pre><code class="xml">&lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot;redirectPort=&quot;8445&quot; /&gt;</code></pre><p>一般会将tomcat的默认端口号修改为80。<strong>80端口号是http协议的默认端口</strong></p><p>号,这样的好处就是 : 在访问的时候 ,不需要输入端口号就可以直接进行访问</p></li></ul></li></ul></li></ol></li></ol></li><li><p>关闭</p><ol><li>正常关闭<ul><li>bin/shutdown.bat</li><li>Ctrl + C</li></ul></li><li>强制关闭<ul><li>点击启动窗口的退出按钮</li></ul></li></ol></li><li><p>配置</p><ul><li><p>部署项目的方式 :</p><ol><li><p>直接将Web项目文件夹放到webapps目录下</p><ul><li><p>项目的访问路径 : <code>localhost:8080/Web项目访问路径/资源名称</code> ,</p></li><li><p><code>/Web项目访问路径</code>:也称为<strong>虚拟目录</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563715965019.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563715965019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>简化部署 : 将项目打包成<code>war</code>包,再将war包放置到webapps目录下</p><ul><li>war包在webapps目录下会自动解压缩</li></ul></li></ul></li><li><p>方式1的问题就是Web项目只能存放在固定的位置,方式2解决的问题就是可以将Web项目放在电脑的任意位置</p><ul><li><p>配置conf/server.xml文件</p><blockquote><p>在<code>&lt;Host&gt;</code>标签体中配置</p><p><code>&lt;Context docBase=&quot;项目存放的路径&quot; path=&quot;虚拟目录&quot; /&gt;</code></p><ul><li>docBase:项目存放的路径</li><li>path：虚拟目录 ,也就是访问的时候的地址</li></ul><hr><p><img src="https://blog.chasingwind.top/1563760402331.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563760402331.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563760371806.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563760371806.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>方式2的配置方式很不安全 , 因为server.xml是Tomcat的整个配置文件</p><blockquote><ol><li>在conf\Catalina\localhost<strong>创建任意名称的xml文件</strong>。</li><li>在文件中编写<code>&lt;Context docBase=&quot;项目存放的路径&quot; /&gt;</code></li><li>这里没有虚拟目录,那么该怎样访问呢&gt;<ul><li>访问的时候的<strong>虚拟目录就是这个xml文件的名称</strong></li></ul></li></ol><p><img src="https://blog.chasingwind.top/1563761884581.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563761884581.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563761927388.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563761927388.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>方式3也成为了<strong>热部署方式</strong>, 他不需要重启服务器就可以进行修改后的访问</p></li></ol></li></ul></li></ol><ol start="7"><li><p>静态项目和动态项目</p><ul><li><p>目录结构的区别</p><ul><li><p>Java动态项目的目录结构 :</p><blockquote><p>– 项目的根目录</p><blockquote><p>– WEB-INF目录: </p><blockquote><p> – web.xml：web项目的核心配置文件</p><blockquote><p>– classes目录：放置字节码文件的目录</p><p>– lib目录：放置依赖的jar包</p></blockquote></blockquote></blockquote></blockquote></li></ul></li></ul></li><li><p>将Tomcat集成到IDEA中,并且创建JavaEE的项目 , 部署项目</p><ol><li><p>将Tomcat集成到IDEA中</p><blockquote><ol><li><p>Run –&gt; Edit Configures</p><p><img src="https://blog.chasingwind.top/1563762688745.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563762688745.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>Temlpates–&gt;Tomcat Server–local(配置本地的Tomcat)</p><p><img src="https://blog.chasingwind.top/1563762799181.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563762799181.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>选择Tomcat所在的目录</p></li></ol></blockquote></li><li><p>创建Java  EE项目</p><blockquote><ol><li><p>创建新项目</p><p><img src="https://blog.chasingwind.top/1563763090438.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563763090438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>项目目录 : </p><p><img src="https://blog.chasingwind.top/1563763227281.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563763227281.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li><li><p>部署项目</p><blockquote><ol><li><p>查看部署配置</p><p><img src="https://blog.chasingwind.top/1563763750546.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563763750546.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>启动项目</p><p>这里默认打开的就是<code>localhost:8080</code>,默认的首页就是index.jsp</p><p><img src="https://blog.chasingwind.top/1563764008612.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563764008612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>访问自己的html  在web目录下创建html文件  访问的时候带上文件名 这里需要重新启动Tomcat</p><p><img src="https://blog.chasingwind.top/1563764200801.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563764200801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>热部署</p><p><img src="https://blog.chasingwind.top/1563764341810.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563764341810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML</title>
      <link href="2019/07/21/XML/"/>
      <url>2019/07/21/XML/</url>
      
        <content type="html"><![CDATA[<p>可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。XML被设计用来传输和存储数据,HTML被设计用来显示数据。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>概念 : Extensible Markup Language 可扩展标记语言<ul><li>可扩展 : 标签<strong>都是自定义</strong>的。<code> &lt;user&gt;</code>  <code>&lt;student&gt;</code></li></ul></li><li>功能<ul><li>存储数据,<strong>作为配置文件使用</strong></li><li>把数据存起来 , <strong>在网络中传输</strong> , XML是纯文本的,可以跨平台</li></ul></li><li>XML与HTML的区别<ul><li>xml标签都是自定义的，html标签是预定义。</li><li>xml的<strong>语法严格</strong>，html语法松散</li><li><strong>xml是存储数据的，html是展示数据</strong></li></ul></li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li><p>基本语法</p><ul><li>xml文档的后缀名 .xml</li><li>xml<strong>第一行</strong>必须定义为文档声明</li><li>xml文档中<strong>有且仅有一个根标签</strong></li><li>标签中的属性值必须使用引号(单双都可)引起来</li><li>标签必须正确关闭  (围堵标签或者自闭合标签)</li><li>xml<strong>标签名称区分大小写</strong></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563673843439.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563673843439.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>浏览器解析</p><p><img src="https://blog.chasingwind.top/1563673888079.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563673888079.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>组成部分</p><ol><li><p>文档声明</p><ol><li><code>1&lt;?xml 属性列表?&gt;</code>  注意 : <code>&lt;</code>,<code>?</code>,<code>xml</code>之间不能有空格</li><li>属性列表<ul><li>version：版本号，<strong>必须的属性 , 使用1.0就行了</strong></li><li>encoding : 编码方式 , 告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li><li>standalone：是否独立     (这个一般不写)<ul><li>取值<ul><li>yes：不依赖其他文件</li><li>no：依赖其他文件</li></ul></li></ul></li></ul></li></ol></li><li><p>指令(了解) ：结合CSS的</p><ul><li><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;</code></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563674875826.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563674875826.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>标签 : 标签名称是自定义的</p><ul><li>规则 : <ul><li>名称可以包含字母、数字以及其他的字符 </li><li>名称不能以数字或者标点符号开始 </li><li>名称不能以字母 xml（或者 XML、Xml 等等）开始 </li><li>名称不能包含空格 </li></ul></li></ul></li><li><p>标签中的属性</p><ul><li><strong>id属性值需要唯一</strong></li></ul></li><li><p>文本</p><ul><li>CDATA区：在该区域中的数据会被原样展示<ul><li>格式 :<code> &lt;![CDATA[ 数据 ]]&gt;</code></li></ul></li></ul></li></ol></li><li><p>约束 : 规定xml文档的书写规则</p><ul><li><p>作为框架的使用者(程序员)：</p><ol><li>能够在xml中引入约束文档</li><li>能够简单的读懂约束文档</li></ol><blockquote><p><img src="https://blog.chasingwind.top/%E7%BA%A6%E6%9D%9F.bmp" class="lazyload" data-srcset="https://blog.chasingwind.top/%E7%BA%A6%E6%9D%9F.bmp" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="约束"></p></blockquote></li><li><p>约束的分类</p><ol><li><p>DTD:一种简单的约束技术</p><ul><li>引入dtd文档到xml文档中<ul><li>内部dtd：将约束规则定义在xml文档中 (不常用)</li><li>外部dtd：将约束的规则定义在外部的dtd文件中<ul><li>本地 : <code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></li><li>网络 : <code> &lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</code></li></ul></li></ul></li><li>DTD的缺陷 : 对文本内容没有限制,  即使是错误的数据 , 也是没有限制的</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563679999351.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563679999351.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>等价的xml文件</p><p><img src="https://blog.chasingwind.top/1563680189251.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563680189251.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Schema:一种复杂的约束技术  (文件后缀名 : <code>.xsd</code>)</p><blockquote><p>这是Schema文件</p><p><img src="https://blog.chasingwind.top/1563681827473.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563681827473.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>等价的XML文件</p><p><img src="https://blog.chasingwind.top/1563681951451.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563681951451.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在XML中引入schema文件</p><pre><code class="xml">1.填写xml文档的根元素 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;2.引入xsi前缀.  xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;https://www.itcast.cn/xml  student.xsd&quot;//第一个值是需要使用的命名空间。第二个值是供命名空间使用的 XML schema 的位置 就是将上面声明的命名空间和相应的.xsd文件相关联4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;https://www.itcast.cn/xml&quot; // xmlns : xml namespace</code></pre><blockquote><p><img src="https://blog.chasingwind.top/1563682604865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563682604865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>起前缀 : 当一个xml被多个文件约束的时候 , 并且两个约束中有同一个标签名是的时候 用作区分</p><hr><p>演示</p><p><img src="https://blog.chasingwind.top/1563682889028.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563682889028.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>像我们之前并没有起别名的话  就是默认使用的就是这个约束</p><p><img src="https://blog.chasingwind.top/1563683023382.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563683023382.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Spring的schema</p><blockquote><p><img src="https://blog.chasingwind.top/1563683401328.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563683401328.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li><p>解析 : 操作XML文档 , 将文档中的数据读取到内存中</p><ul><li>操作XML文档<ol><li>解析(读取)：将文档中的数据读取到内存中</li><li>写入：将内存中的数据保存到xml文档中。持久化的存储</li></ol></li></ul></li><li><p>解析XML的方式</p><ol><li>DOM : 将标记语言文档<strong>一次性加载进内存</strong>，在内存中形成一棵DOM树<ul><li>优点 : 操作方便，可以对文档进行CRUD的所有操作</li><li>缺点 : 当文档比较大的时候,形成的树形结构太大 ,占内存</li></ul></li><li>SAX  :  <strong>逐行读取 , 基于事件驱动的</strong><ul><li>优点 : 基本上不占内存</li><li>缺点 : 只能进行读取 , 不能增删改</li></ul></li></ol></li><li><p>XML常见的解析器 : 根据解析XML不同的方式开发出的工具包</p><ol><li>JAXP : SUN公司提供的解析器 , 支持DOM和SAX思想</li><li>DOM4J : 一款优秀的解析器 </li><li>Jsoup : Jsoup 是一款Java 的<strong>HTML解析器</strong>，但也<strong>用在XML解析</strong> , 可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li><li>PULL：Android操作系统内置的解析器，sax方式的。</li></ol></li><li><p>Jsoup解析器</p><ul><li><p>快速入门</p><ol><li>导入jar包</li><li>获取Document对象</li><li>获取对应的标签(Element对象)</li><li>获取数据</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563693901836.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563693901836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Jsoup中的对象中的使用</p><ol><li><p>Jsoup：工具类，可以解析html或xml文档，返回Document</p><ul><li><p>parse：解析html或xml文档，返回Document</p><ul><li><p>parse(File in, String charsetName)：解析xml或html文件的。</p><blockquote><p><img src="https://blog.chasingwind.top/1563694658530.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563694658530.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>parse(String html)：解析xml或html字符串</p><blockquote><p><img src="https://blog.chasingwind.top/1563694770873.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563694770873.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>parse(URL url, int timeoutMillis)：通过<strong>网络路径</strong>获取指定的html或xml的文档对象</p><blockquote><p><img src="https://blog.chasingwind.top/1563694971240.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563694971240.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><p>返回值document就是<strong>字符串形式的html或者xml文档内容</strong></p></li></ul></li><li><p>Document：文档对象。<strong>代表内存中的DOM树</strong></p><ul><li><p>获取Element对象,返回值是字符串</p><ul><li><p>getElementById(String id)：根据<strong>id属性值</strong>获取<strong>唯一的element对象</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563696312452.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563696312452.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>getElementsByTag(String tagName)：根据<strong>标签名称</strong>获取元素<strong>对象集合</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563695827123.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563695827123.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>getElementsByAttribute(String key)：根据<strong>属性名称</strong>获取元素<strong>对象集合</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563695976136.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563695976136.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>结果中还有number= “s002”的信息</p></blockquote></li><li><p>getElementsByAttributeValue(String key, String value)：根据<strong>对应的属性名和属性值</strong>获取元素<strong>对象集合</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563696050284.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563696050284.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul></li><li><p>Elements：<strong>元素Element对象</strong>的集合。可以当做 <code>ArrayList&lt;Element&gt;</code>来使用</p></li><li><p>Element：元素对象</p><ol><li><p>获取标签的子元素对象</p><ul><li>getElementById(String id)：根据id属性值获取唯一的element对象</li><li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li><li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563699137519.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563699137519.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1563699165299.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563699165299.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>通过Document对象获取的是所有的标签名为name的对象</p><p>而</p><p>Element对象是Document对象集合中的一个子对象  也就是说获取的是子对象中的标签名为name的对象</p></blockquote></li><li><p>获取属性值</p><ul><li>String attr(String key)：根据属性名称获取属性值 , 属性名不区分大小写</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563699382033.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563699382033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>获取文本内容</p><ul><li>String text():获取所有字标签的纯文本内容</li><li>String html():获取标签体的所有内容(包括子标签的标签和文本的字符串内容)</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563699757051.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563699757051.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563699782236.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563699782236.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Node：节点对象</p><ul><li>是Document和Element的父类</li></ul></li></ol></li></ul></li><li><p>快捷查询方式</p><ol><li><p>selector : 选择器  , 结合CSS里面的选择器进行比较使用</p><blockquote><p>参考文档</p><p><img src="https://blog.chasingwind.top/1563700647025.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563700647025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>使用的方法：Elements    select(String cssQuery)</p><blockquote><p>Jsoup中的Selector类中的方法</p><p><img src="https://blog.chasingwind.top/1563859645659.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563859645659.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>返回值是Elements类型的  但是Document继承自Element  所以可以用Document来调用</p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1563701880686.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563701880686.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>XPath : XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p><ul><li>使用Jsoup的Xpath需要额外导入jar包。</li><li>查询w3cshool参考手册，使用xpath完成查询 : <a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp">XPath语法</a></li></ul><p>注意 : XPath是对DOM树结构进行操作, 也就是说,使用Document 文档对象就可以;了</p><blockquote><p><img src="https://blog.chasingwind.top/1563710638964.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563710638964.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BootStrap</title>
      <link href="2019/07/20/BootStrap/"/>
      <url>2019/07/20/BootStrap/</url>
      
        <content type="html"><![CDATA[<p>BootStrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。</p><a id="more"></a><p><a href="https://v3.bootcss.com/">BootStrap中文文档</a></p><ol><li><p>概念 : 是一个<strong>前端开发的框架</strong> , BootStrap是美国<a href="https://baike.baidu.com/item/Twitter/2443267">Twitter</a>公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、<a href="https://baike.baidu.com/item/JavaScript/321142">JavaScript</a> 开发的简洁、直观、强悍的<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF/5956545">前端</a>开发框架，使得 Web 开发更加快捷。</p><ul><li>框架 :  一个半成品的软件 , 开发人员可以在框架的基础上 ,再进行开发 , 简化编码</li><li>好处: <ol><li>定义了很多CSS的样式和JS插件。开发人员可以直接使用这些样式和插件得到丰富的页面效果</li><li>响应式布局 : 同一套页面可以兼容不同分辨率的设备.</li></ol></li></ul></li><li><p>快速入门</p><ol><li><p>下载BootStrap</p></li><li><p>将css,fonts,js目录复制到项目中</p></li><li><p>创建HTML页面,引入必要的资源文件</p><blockquote><p>Module文件列表</p><p><img src="https://blog.chasingwind.top/1563614584262.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563614584262.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>这里是模板文件</p><blockquote><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Hello BootStrap&lt;/title&gt;    &lt;!-- BootStrap --&gt;    &lt;link href=&quot;css/BootStrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;!--这里是对IE浏览器的支持--&gt;    &lt;!--&lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;--&gt;    &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;!-- 引入jQury --&gt;&lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入BootStrap --&gt;&lt;script src=&quot;js/BootStrap.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></blockquote></li></ol></li></ol><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul><li><p>同一套页面可以兼容不同分辨率的设备.</p></li><li><p>实现 : 依赖于栅格系统</p><ul><li><p>栅格系统 : 在所有的尺寸的显示设备中,将一行平均分成12个格子，可以指定元素占几个格子</p></li><li><p>步骤 : </p><ol><li><p>定义容器 : 相当于之前的table</p><ul><li><p>容器分类 : </p><ol><li><code>container</code> : 两边有留白</li><li><code>container-fluid</code> : 每种屏幕100%的屏幕宽度</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563625800818.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563625800818.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1563625800818"></p></blockquote></li></ul></li><li><p>定义行 : 相当于之前的tr   <strong>样式 : row</strong></p></li><li><p>定义元素 : 指定该元素在不同的设备上,所占的格子数目(CSS实现)  </p><p><strong>样式 : col-设备代号-格子数目</strong></p><p>设备代号 : </p><ol><li>xs：超小屏幕 手机 (&lt;768px)：比如 : col-xs-12</li><li>sm：小屏幕 平板 (≥768px)</li><li>md：中等屏幕 桌面显示器 (≥992px)</li><li>lg：大屏幕 大桌面显示器 (≥1200px)</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563625515044.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563625515044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当屏幕尺寸在变化的时候,每行显示的div的个数也在动态的变化</p><p>但是,无论在多大的尺寸的屏幕上,栅格系统都是将一行分为12个 </p></blockquote></li><li><p>注意</p><ol><li><p>一行中如果格子的数目超过12的话,超出部分就会自动换行</p></li><li><p>栅格类属性可以<strong>向上兼容</strong>,也就是说如果你有3个<code>&lt;div class=&quot;col-xs-4&quot;&gt;</code>的话,</p><blockquote><p><img src="https://blog.chasingwind.top/1563626375097.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626375097.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在手机上是这样</p><p><img src="https://blog.chasingwind.top/1563626398289.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626398289.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在pad上是这样</p><p><img src="https://blog.chasingwind.top/1563626428842.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626428842.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在电脑上是这样</p><p><img src="https://blog.chasingwind.top/1563626461845.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626461845.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，<strong>会一个元素占满一整行</strong></p><blockquote><p>当时设置的是中等屏幕大小的时候</p><p><img src="https://blog.chasingwind.top/1563626608048.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626608048.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>屏幕尺寸大于992px是这样</p><p><img src="https://blog.chasingwind.top/1563626671889.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626671889.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>小于992px是这样  ,占 一行</p><p><img src="https://blog.chasingwind.top/1563626713228.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626713228.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1563626140060.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563626140060.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ul></li></ul><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><ol><li>全局CSS样式<ul><li>按钮 : class=”btn btn-自己设置”</li><li>图片 :<ul><li>class=”img-responsive”：图片在任意尺寸都占100%</li><li>图片形状<ul><li><code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;</code>：方形</li><li><code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt;</code> ： 圆形</li><li><code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt;</code> ：相框</li></ul></li></ul></li><li>表格<ul><li>table</li><li>table-bordered</li><li>table-hover</li></ul></li><li>表单<ul><li>表单项添加：class=”form-control” </li></ul></li></ul></li><li>组件<ul><li>导航条</li><li>分页条</li></ul></li><li>插件<ul><li>轮播图</li></ul></li></ol><h2 id="JS插件"><a href="#JS插件" class="headerlink" title="JS插件"></a>JS插件</h2>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> BootStrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="2019/07/17/JavaScript/"/>
      <url>2019/07/17/JavaScript/</url>
      
        <content type="html"><![CDATA[<p>JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎</p><a id="more"></a><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ol><li><p>概念 : 一门<strong>客户端脚本语言</strong></p><ul><li>运行在客户端浏览器中,每一个浏览器都有JavaScript的解析引擎</li><li>脚本语言 : 不需要编译,直接就可以被浏览器解析执行了</li></ul></li><li><p>功能 : </p><ul><li>可以来增强用户和html页面的交互过程,可以来控制HTML元素,让页面有一些动态的效果,增强用户的体验</li></ul></li><li><p>JavaScript发展史:</p><ul><li><p>为什么会出现客户端脚本语言 ?</p><ul><li>因为在以前我们在填写表单与服务器的交互过程中,在网络带宽的限制下体验非常差.所以发明了一种在客户端就可以进行表单校验的功能的语言</li></ul></li><li><p>1992年,Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C–    ，后来更名为：ScriptEase</p></li><li><p>1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript</p></li><li><p>1996年，微软抄袭JavaScript开发出<strong>JScript</strong>语言,搭载到IE浏览器上</p></li><li><p>1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。</p></li></ul></li><li><p>所以总的来说 : <strong>JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</strong></p></li></ol><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ol><li><p>基本语法</p><ol><li><p>与HTML的结合的方式</p><ol><li><p>内部JS : 在HTML内部定义一个<code>&lt;script&gt;</code>标签,<code>&lt;script&gt;</code>标签内部就是JavaScript的代码</p><ul><li>可以将将JavaScript代码放在HTML的任意位置,但是执行的顺序跟JavaScript的放置顺序有关</li></ul><blockquote><p>这里的alert是弹出一个框, 是阻塞式的 ,不点击确定的话,就不会加载下面的内容</p><hr><p>这里是将<code>&lt;script&gt;</code>放置在<code>input</code>的前面</p><p><img src="https://blog.chasingwind.top/1563357366605.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563357366605.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击 确定  之后</p><p><img src="https://blog.chasingwind.top/1563357524552.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563357524552.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote><blockquote><p>这里是将<code>input</code>放在<code>script</code>的前面</p><p>先显示这个输入框  然后出现的弹窗</p><p><img src="https://blog.chasingwind.top/1563357748787.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563357748787.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1563357824627.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563357824627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>外部JS : 定义<code>script</code>,使用它的<code>src</code>属性加载外部的JS文件</p><blockquote><p><img src="https://blog.chasingwind.top/1563358236004.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563358236004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563358255607.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563358255607.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>注意 : <code>script</code>标签可以定义多个,并且可以在HTML的任意位置</p></li></ol></li><li><p>注释</p><ol><li>单行注释  : <code>//注释内容</code></li><li>多行注释 : <code>/*注释内容*/</code></li></ol></li><li><p>数据类型</p><ol><li><p>原始数据类型(基本数据类型)</p><ol><li><p>number : 数字。 整数,小数,NaN(not a number 一个不是数字的数字类型)</p><blockquote><p><img src="https://blog.chasingwind.top/1563360067268.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563360067268.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>string : 字符串 。JavaScript没有字符的概念,  单引号,双引号都可以用来定义字符串,例如 : “a” , ‘aaaaa’,”aasddd”等等,都是字符串</p><blockquote><p><img src="https://blog.chasingwind.top/1563360096039.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563360096039.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>boolean : 布尔类型 , true和false</p></li><li><p>null : 表示一个对象为空</p></li><li><p>undefined : 未定义,  就是一变量没有给初始化值,则会被默认赋值为undefined</p><blockquote><p><img src="https://blog.chasingwind.top/1563360128198.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563360128198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>引用数据类型 : 对象</p></li></ol></li><li><p>变量</p><ul><li><p>变量 :  一小块存储数据的内存空间</p></li><li><p>Java语言是强类型语言，而<strong>JavaScript是弱类型语言</strong>。</p><ul><li>强类型 : 在开辟变量存储空间时，<strong>定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</strong></li><li>弱类型：在开辟变量存储空间时，<strong>不定义空间将来的存储数据类型，可以存放任意类型的数据。</strong></li></ul></li><li><p>语法 : <code>var 变量名 = 初始化值;</code>或者<code>var 变量名 ;</code>,用到的时候再赋值是一样的</p><blockquote><p><img src="https://blog.chasingwind.top/1563359487667.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563359487667.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见,JavaScript中的变量是弱类型的</p></blockquote></li><li><p><code>typeof(变量名)</code>: 可以用来查看变量的类型</p><blockquote><p><img src="https://blog.chasingwind.top/1563360481459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563360481459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563360524544.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563360524544.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1563363941330.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563363941330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>运算符</p><ol><li><p>一元运算符</p><ul><li><p>++ , – , +(正号), -(负号)</p><ol><li><p>++(–) : 自增(自减) : </p><ul><li>++(–) 在前，先自增(自减)，再运算</li><li>++(–) 在后，先运算，再自增(自减)</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563368040552.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563368040552.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563368079897.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563368079897.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>+(-)：正负号 只用来要求number类型</p><ul><li>注意：在JS中，<strong>如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</strong></li><li>string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）, NaN和任何数进行运算都是NaN</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563368513504.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563368513504.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>boolean转number：true转为1，false转为0</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563368789565.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563368789565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li><li><p>算术运算符</p><ul><li><p><code>+ - * / % ...</code></p><blockquote><p><img src="https://blog.chasingwind.top/1563368927924.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563368927924.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>因为number可以接收小数类型</p></blockquote></li></ul></li><li><p>赋值运算符</p><ul><li><code>= += -+....</code></li></ul></li><li><p>比较运算符</p><ul><li><p><code>&gt; &lt; &gt;= &lt;= == ===(全等于)</code></p></li><li><p>比较方式</p><ul><li><p>类型相同：直接比较</p><ul><li>字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563369395116.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563369395116.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>类型不同：先进行类型转换，再比较</p><blockquote><p><img src="https://blog.chasingwind.top/1563369489391.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563369489391.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li><p>===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</p><blockquote><p><img src="https://blog.chasingwind.top/1563369523006.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563369523006.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul></li></ul></li><li><p>逻辑运算符</p><ul><li><p><code>&amp;&amp; || !</code></p></li><li><p>&amp;&amp; (与),具有短路效果</p></li><li><p>||(或) ,具有短路效果</p></li><li><p>!(非)</p><ul><li><p>其他类型转boolean：</p><ol><li><p>number：0或NaN为假，其他为真</p><blockquote><p><img src="https://blog.chasingwind.top/1563369972589.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563369972589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>string：除了空字符串(“”)，其他都是true</p><blockquote><p><img src="https://blog.chasingwind.top/1563370128231.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563370128231.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>null&amp;undefined:都是false</p><blockquote><p><img src="https://blog.chasingwind.top/1563370297416.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563370297416.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>对象：所有对象都为true</p><blockquote><p><img src="https://blog.chasingwind.top/1563370362950.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563370362950.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>可以运用上面的<code>!</code>来作为条件进行判断</p><blockquote><p>这样的条件判断的效果是一样的  因为字符串只有<code>&quot;&quot;</code>为false</p><p><img src="https://blog.chasingwind.top/1563370717134.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563370717134.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul></li><li><p>三元运算符</p><ul><li><p><code>A ? B : C </code></p><blockquote><p><img src="https://blog.chasingwind.top/1563370900690.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563370900690.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol></li><li><p>流程控制语句</p><ol><li><p><code>if ...else</code> : </p></li><li><p><code>switch</code></p><ul><li>在<strong>java</strong>中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)</li><li>在<strong>JS</strong>中,switch语句可以<strong>接收任意的原始数据类型</strong></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563374884322.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563374884322.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>while</code></p></li><li><p><code>do...while</code></p></li><li><p><code>for</code></p></li></ol></li><li><p>JS特殊语法(了解)</p><ol><li>语句以 ;  结尾，如果一行只有一条语句则 ;可以省略 (不建议)</li><li>变量的定义使用var关键字，也可以不使用<ul><li>用： 定义的变量是局部变量</li><li>不用：定义的变量是全局变量(不建议)</li></ul></li></ol></li></ol></li><li><p>练习 : </p><blockquote><p><img src="https://blog.chasingwind.top/1563376026631.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563376026631.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这里使用<code>document.write(&quot;&quot;);</code>在<code>script</code>中使用HTML;</p></blockquote></li><li><p>基本对象</p><ol><li><p>Function ： 函数(方法)对象</p><ol><li><p>创建</p><p>方式1 :</p><pre><code class="javascript">function 方法名称(形式参数列表)&#123;    方法体&#125;</code></pre><blockquote><p><img src="https://blog.chasingwind.top/1563414655150.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563414655150.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>定义方法的时候,形式参数可以不写类型 ,因为写的话都是var类型的</p></blockquote><p>方式2 :</p><pre><code class="javascript">var 方法名 = function(形式参数类表)&#123;    方法体&#125;</code></pre><blockquote><p><img src="https://blog.chasingwind.top/1563414911588.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563414911588.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>方法</p></li><li><p>属性</p><p>length : 形参的个数</p><blockquote><p><img src="https://blog.chasingwind.top/1563415836446.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563415836446.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>特点</p><ol><li><p>定义方法的时候,形参类型不用写,返回值类型也不用写</p></li><li><p>方法是一个对象,<strong>如果定义名称相同的方法,后面的方法会覆盖前面的方法</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563415200863.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563415200863.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在JS中,<strong>方法的调用只与方法的名称有关,和参数列表无关</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563415629595.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563415629595.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>在方法声明中有一个隐藏的内置对象arguments(数组),<strong>封装了所有的实际参数</strong>,也就是说arguments数组中存储的是所有的实际参数</p><blockquote><p><img src="https://blog.chasingwind.top/1563416238568.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563416238568.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>调用</p><p><code>方法名称(实际参数列表)</code></p></li></ol></li><li><p>Array : 数组对象</p><ol><li><p>创建</p><p><code>var arr = new Array(元素列表);</code></p><p><code>var arr = new Array(数组长度);</code></p><p><code>var arr = [元素列表];</code></p><blockquote><p><img src="https://blog.chasingwind.top/1563416947831.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563416947831.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>方法</p><p>join() : 将数组中的元素<strong>按照指定的分隔符拼接成字符串</strong></p><p>push() : 向数组的尾部添加一个或更多元素,并<strong>返回新的长度</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563418365458.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563418365458.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>属性</p><p>length : 数组的长度</p></li><li><p>特点</p><ol><li><p>JS中,数组元素的<strong>类型是可变的</strong></p></li><li><p>JS中,数组的<strong>长度是可变的</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563417717513.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563417717513.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见,数组中可以存储任意类型的数据</p><p>当访问的数组的下标越界的时候 ,显示的数据是undefined </p><hr><p>当将越界的数组元素定义之后  显示数组的长度是扩展后的长度</p><p><img src="https://blog.chasingwind.top/1563417976010.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563417976010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li><li><p>Date : 日期对象</p><ol><li><p>创建  :  <code>var date = new Date()</code></p></li><li><p>方法 : </p><ul><li>toLocaleString()：返回当前date对象对应的时间本地字符串格式</li><li>getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563429963191.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563429963191.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Math : 数学对象</p><ol><li><p>创建</p><ul><li>特点：<strong>Math对象不用创建，直接使用</strong>。  Math.方法名();</li></ul></li><li><p>方法</p><ul><li>random():返回 0 ~ 1 之间的随机数。 <strong>含0不含1</strong></li><li>ceil(x)：对数进行上舍入。 上取整 ,比x大的最小整数</li><li>floor(x)：对数进行下舍入。下取整 , 比x小的最大整数</li><li>round(x)：把数四舍五入为最接近的整数。</li></ul></li><li><p>属性</p><p>PI : 圆周率</p><blockquote><p><img src="https://blog.chasingwind.top/1563430429766.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563430429766.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>练习</p><blockquote><p>产生1~100之间的随机整数</p><p><img src="https://blog.chasingwind.top/1563430951275.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563430951275.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>RegExp：正则表达式对象</p><ol><li><p>正则表达式：定义字符串的组成规则。</p><ol><li><p>单个字符:<code>[ ]</code></p><p>如： [a] [ab] [a-zA-Z0-9_]</p><p> 特殊符号代表特殊含义的单个字符:</p><p>\d:单个数字字符 [0-9]</p><p>\w:单个单词字符[a-zA-Z0-9_]</p></li><li><p>量词符号</p><p>?：表示出现0次或1次</p><p>*：表示出现0次或多次</p><p>+：出现1次或多次</p><p>{m,n}:表示 m&lt;= 数量 &lt;= n</p><ul><li>m如果缺省： {,n}:最多n次</li><li>n如果缺省：{m,} 最少m次</li></ul></li><li><p>开始结束符号</p><ul><li>开始 : ^</li><li>结束 : $</li></ul></li></ol></li><li><p>正则对象 :  </p><ol><li><p>创建</p><ol><li><code>var reg = new RegExp(&quot;正则表达式&quot;);</code></li><li><code>var reg = /正则表达式/;</code></li></ol></li><li><p>方法</p><p>test(参数):验证指定的字符串是否符合正则定义的规范    </p></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563432907841.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563432907841.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>在第一种创建的方式中,一点注意的是  \w转义了  所以不再表达正则表达式的含义</p><p><img src="https://blog.chasingwind.top/1563433073863.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563433073863.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>Global : </p><ol><li><p>特点 : 全局对象 ,  这个Global中封装的方法不需要对象就可以直接调用。使用方法: <code>  方法名();</code></p></li><li><p>方法 : </p><ol><li><p>encodeURI():url编码</p><p>decodeURI():url解码</p><blockquote><p>在浏览器中,索尼的编码是  %E7%B4%A2%E5%B0%BC   </p><p><img src="https://blog.chasingwind.top/1563434641111.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563434641111.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>encodeURIComponent():url编码,<strong>编码的字符更多</strong></p><p>decodeURIComponent():url解码</p><blockquote><p><img src="https://blog.chasingwind.top/1563434963634.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563434963634.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>URL编码 : 在浏览器的数据传输的过程中 , 需要借助协议进行传输 , 而这些协议是不支持中文字符传的,所以中文就需要先进行编码</p><blockquote><p><img src="https://blog.chasingwind.top/1563434247555.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563434247555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>parseInt()  :  将字符串转为数字</p><ul><li>逐一判断每一个字符是否是数字，直到不是数字为止，将<strong>前边数字部分转为number</strong></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563435312648.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563435312648.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>isNaN():判断一个值是否是NaN</p><ul><li>NaN六亲不认，连自己都不认。所以就<strong>不能用NaN跟自己进行比较</strong>看是否相等。 NaN参与的==比较全部为false</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563435537274.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563435537274.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>eval():将 JavaScript 字符串 转换为JavaScript代码 ，并把它作为脚本代码来执行</p><blockquote><p><img src="https://blog.chasingwind.top/1563435859042.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563435859042.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol></li></ol><hr><h2 id="DOM简单学习"><a href="#DOM简单学习" class="headerlink" title="DOM简单学习"></a>DOM简单学习</h2><ul><li><p>功能 : 控制(增删改查)html文档的内容</p></li><li><p>代码 : 获取页面标签(元素)对象：DOM中<strong>标签(元素)被封装成Element对象</strong></p><ul><li><code>document.getElementById(&quot;id值&quot;)</code> :通过标签(元素)的id获取元素对象</li></ul></li><li><p>操作Element对象</p><ul><li><p><strong>修改属性值</strong></p><ol><li><p>明确获取的对象是哪一个?</p></li><li><p>查看API文档 , 查看哪些属性可以设置</p><p>API:<a href="https://www.w3school.com.cn/jsref/index.asp">w3school</a></p><p>比如: </p><blockquote><p><code>&lt;img&gt;</code>有这么多属性可以设置</p><p><img src="https://blog.chasingwind.top/1563440574642.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563440574642.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><hr><p><img src="https://blog.chasingwind.top/1563441192796.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563441192796.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>修改标签体内容</p><ul><li><p>属性 : <strong>innerHTML , 设置标签体的内容</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563441580081.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563441580081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>注意区分 : 操作Element对象是<strong>修改标签的属性</strong> , 而innerHTML是<strong>修改标签体的内容</strong></p></li></ul></li></ul><h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2><ul><li><p>功能 : 某些组件<strong>被</strong>执行了某些操作后，触发某些代码的执行。</p></li><li><p>如何绑定事件?</p><ol><li><p>直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p><ul><li>事件：onclick— 单击事件</li></ul><p>这种写法的缺点就是html代码和事件写在一起了 , 耦合度比较高</p><blockquote><p><img src="https://blog.chasingwind.top/1563442414207.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563442414207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>点击灯泡之后就会弹出弹窗</p></blockquote></li><li><p>通过js获取元素对象，指定事件属性(操作)，设置一个函数 , 这个函数就是事件要执行的代码</p><blockquote><p><img src="https://blog.chasingwind.top/1563442999062.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563442999062.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意上面的事件绑定的过程中,方法只有方法名</p></blockquote></li></ol></li><li><p>练习</p><blockquote><p><img src="https://blog.chasingwind.top/1563443931794.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563443931794.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>BOM : Browser Object Model 浏览器对象模型 , 将浏览器的各个组成部分封装成对象。</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id="Window：窗口对象"><a href="#Window：窗口对象" class="headerlink" title="Window：窗口对象"></a>Window：窗口对象</h4><ol><li><p>创建 : Window对象不需要创建就可以直接使用, <code>window.方法名()</code>,且<code>window</code>可省略</p></li><li><p>方法</p><ol><li><p>与<strong>弹出有关的方法</strong></p><ul><li>alert()    显示带有一段消息和<strong>一个确认按钮</strong>的警告框。</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563453800832.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563453800832.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>confirm()    显示带有一段消息以及<strong>确认按钮和取消按钮</strong>的对话框。<ul><li>如果用户点击<strong>确定</strong>按钮，则方法返回true</li><li>如果用户点击<strong>取消</strong>按钮，则方法返回false</li></ul></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563454050059.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563454050059.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>prompt()    显示<strong>可提示用户输入的对话框</strong><ul><li>返回值是用户输入的值</li></ul></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563454280418.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563454280418.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>与<strong>打开关闭有关的方法</strong></p><ul><li><p>open : 打开一个<strong>新的浏览器窗口</strong></p><ul><li><strong>返回值是新的Window对象</strong></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563455045644.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563455045644.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>open(参数) : 参数是新窗口的URL</p></blockquote></li><li><p>close : 关闭浏览器窗口</p><ul><li>谁调用close,那么就关闭谁</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563455518881.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563455518881.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以发现 ,默认的close()其实是<code>window.close()</code></p><p>关闭的是当前窗口</p><hr><p><img src="https://blog.chasingwind.top/1563455704805.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563455704805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>利用<code>open()</code>的返回值是一个窗口来作为参数  ,调用<code>close()</code>方法</p></blockquote></li></ul></li><li><p>与<strong>定时器有关的方法</strong></p><ul><li><p>setTimeout(参数1 , 参数2)    在<strong>指定的毫秒数后调用函数或计算表达式</strong>。 <strong>只执行一次</strong></p><ul><li>参数1 : js代码或者方法对象</li><li>参数2 : 毫秒值</li><li>返回值 : <strong>唯一标识，用于取消定时器</strong></li></ul></li><li><p>clearTimeout()    取消由 setTimeout() 方法设置的 timeout。</p><blockquote><p><img src="https://blog.chasingwind.top/1563456471186.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563456471186.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>setInterval(参数1 , 参数2)    按照<strong>指定的周期（以毫秒计）来调用函数或计算表达式</strong>。 <strong>每隔</strong><code>参数2</code>毫秒之后,执行<code>参数1</code></p><ul><li>参数1 :  js代码或者方法对象</li><li>参数2 : 毫秒值</li></ul></li><li><p>clearInterval()    取消由 setInterval() 设置的 timeout。</p><blockquote><p><img src="https://blog.chasingwind.top/1563456644722.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563456644722.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol></li><li><p>属性</p><ol><li><p>获取其他BOM<strong>对象</strong>：</p><p>history</p><p>location</p><p>Navigator</p><p>Screen:</p></li><li><p>获取DOM对象</p><p>document</p><blockquote><p><img src="https://blog.chasingwind.top/1563458395998.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563458395998.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1563458570057.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563458570057.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>返回值是对应属性的对象</p></blockquote><blockquote><p>document</p><hr><p><img src="https://blog.chasingwind.top/1563458702836.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563458702836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>特点 : </p></li><li><p>Window对象不需要创建就可以直接使用, <code>window.方法名()</code></p></li><li><p>window可省略 , 直接写成 <code>方法名()</code></p></li><li><p>练习 : </p><blockquote><p> 轮播图练习  ,也就是定时更换图片</p><p><img src="https://blog.chasingwind.top/1563457408952.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563457408952.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意这里的下标的变换的拼接方法!!</p></blockquote></li></ol><h4 id="Navigator：浏览器对象"><a href="#Navigator：浏览器对象" class="headerlink" title="Navigator：浏览器对象"></a>Navigator：浏览器对象</h4><h4 id="Screen：显示器屏幕对象"><a href="#Screen：显示器屏幕对象" class="headerlink" title="Screen：显示器屏幕对象"></a>Screen：显示器屏幕对象</h4><h4 id="History：历史记录对象"><a href="#History：历史记录对象" class="headerlink" title="History：历史记录对象"></a>History：历史记录对象</h4><ul><li>仅仅表示当前窗口的历史记录</li></ul><ol><li><p>创建</p><ol><li><code>window.history</code></li><li><code>history</code></li></ol></li><li><p>方法</p><ul><li><p>back()    <strong>加载</strong> history 列表中的<strong>前一个 URL</strong>。</p><blockquote><p><img src="https://blog.chasingwind.top/1563462530679.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563462530679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>forward()    <strong>加载</strong> history 列表中的<strong>下一个 URL</strong>。</p><blockquote><p><img src="https://blog.chasingwind.top/1563462330457.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563462330457.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这两个功能相同</p><p><img src="https://blog.chasingwind.top/1563462389538.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563462389538.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>  ​    </p></li><li><p>go(参数)    加载 history 列表中的某个具体页面。</p><ul><li>参数<ul><li>正数：前进几个历史记录 <code>go(1)</code>=<code>forward</code></li><li>负数：后退几个历史记录 <code>go(-1)</code>=<code>back</code></li></ul></li></ul></li></ul></li><li><p>属性</p><ul><li>length    返回当前窗口历史列表中的 URL 数量。</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563462001129.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563462001129.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="Location：地址栏对象"><a href="#Location：地址栏对象" class="headerlink" title="Location：地址栏对象"></a>Location：地址栏对象</h4><ol><li><p>创建</p><ol><li><code>window.location</code></li><li><code>location</code></li></ol></li><li><p>方法</p><ul><li>reload() : 重新加载当前文档。<strong>刷新</strong></li></ul></li><li><p>属性</p><ul><li>href : 设置或返回完整的 URL。</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563459877782.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563459877782.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>一般我们获取href是对他进行修改</p></blockquote></li><li><p>练习</p><blockquote><p>自动跳转主页</p><hr><p><img src="https://blog.chasingwind.top/1563461307168.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563461307168.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p> Document Object Model 文档对象模型</p></li><li><p><strong>将标记语言文档的各个组成部分，封装为对象</strong>。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p><blockquote><p><img src="https://blog.chasingwind.top/1563499632945.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563499632945.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>DOM树</p><p><img src="https://blog.chasingwind.top/DOM%E6%A0%91.bmp" class="lazyload" data-srcset="https://blog.chasingwind.top/DOM%E6%A0%91.bmp" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="DOM树"></p><p>当HTML文档进入浏览器内存的时候, 浏览器将整个文档转换为DOM树</p></blockquote></li><li><p>W3C DOM 标准被分为 3 个不同的部分</p><ol><li>核心DOM<ol><li>Document：<strong>文档对象</strong></li><li>Element：元素对象</li><li>Attribute：<strong>属性对象</strong></li><li>Text：文本对象</li><li>Comment : <strong>注释对象</strong></li><li>Node：节点对象，其他5个的父对象</li></ol></li><li>XML DOM - 针对 XML 文档的标准模型</li><li>HTML DOM - 针对 HTML 文档的标准模型</li></ol><p>注: <strong>XML DOM 和 HTML DOM是对核心DOM的扩展和封装</strong></p></li></ul><h3 id="核心DOM模型"><a href="#核心DOM模型" class="headerlink" title="核心DOM模型"></a>核心DOM模型</h3><h4 id="Document：文档对象"><a href="#Document：文档对象" class="headerlink" title="Document：文档对象"></a>Document：文档对象</h4><ol><li><p>创建 : 在HTML DOM模型中可以使用window对象来获取</p><ol><li><code>window.document</code></li><li><code>document</code></li></ol></li><li><p>方法</p><ol><li><p>获取Element对象 : 获取的是标签的对象们</p><ol><li>getElementById()    ： 根据<strong>id属性值</strong>获取元素对象。<strong>id属性值一般唯一</strong></li><li>getElementsByTagName()：根据<strong>元素的标签名称</strong>获取元素对象们。<strong>返回值是一个数组</strong></li><li>getElementsByClassName():根据<strong>Class属性值</strong>获取元素对象们。返回值是一个数组</li><li>getElementsByName(): 根据<strong>name属性值</strong>获取元素对象们。返回值是一个数组</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563502187307.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563502187307.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>创建其他DOM对象</p><ol><li>createAttribute(name) : 创建属性节点对象</li><li>createComment() : 创建注释节点对象</li><li>createElement() : 创建元素节点对象(标签)</li><li>createTextNode() : 创建文本节点对象</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563502630255.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563502630255.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这里是<strong>创建<code>table</code>标签对象</strong> , 这些对象是在内存中,并且跟原来的HTML文档没有关系</p></blockquote></li></ol></li><li><p>属性</p></li></ol><h4 id="Element：元素对象"><a href="#Element：元素对象" class="headerlink" title="Element：元素对象"></a>Element：元素对象</h4><ol><li><p>获取/创建 : 通过document来获取和创建</p></li><li><p>方法 : </p><ol><li>setAttribute()：设置属性</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563504003679.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563504003679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见,一开始<code>&lt;a&gt;</code>是没有属性的,所以只显示为普通的文本 ,通过setAttribute()设置<code>&lt;a&gt;</code>d的href属性  这样<code>&lt;a&gt;</code>就变成了超链接</p></blockquote><ol start="2"><li>removeAttribute()：删除属性</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563504343640.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563504343640.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><h4 id="Node-节点对象"><a href="#Node-节点对象" class="headerlink" title="Node : 节点对象"></a>Node : 节点对象</h4><ol><li><p>特点 : 他是其他5个核心DOM中的对象的父对象 , 所有DOM对象都可以被认为是一个节点</p></li><li><p>方法 : </p><ul><li><p><strong>DOM树的CRUD操作</strong>:</p><ol><li><p>appendChild()：向节点的子节点列表的结尾添加新的子节点</p><blockquote><p><img src="https://blog.chasingwind.top/1563507473627.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563507473627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>removeChild()    ：删除（并返回）当前节点的指定子节点。</p><blockquote><p><img src="https://blog.chasingwind.top/1563506913573.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563506913573.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>当我们点击的时候 并没有删除  /</p><p>其实是删除了的  只不过因为设置的<code>href</code>属性为空 ,相当于在本页面内跳转  </p><p>也就是说 当删除过后,又刷新了当前的页面</p><hr><p>设置<code>href=&quot;javascript:void(0);&quot;</code>  ,当我们点击之后 不进行页面的跳转</p><p><img src="https://blog.chasingwind.top/1563506972540.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563506972540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>void 是阻止返回值的运算符</p></blockquote></li><li><p>replaceChild()：用新节点替换一个子节点。</p></li></ol></li></ul></li><li><p>属性 : </p><ul><li><p>parentNode  返回当前节点的父节点。</p><blockquote><p><img src="https://blog.chasingwind.top/1563507670906.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563507670906.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>Node里面封装的CRUD方法,对于DOM树中的所有的对象都可以使用</p></li><li><p>练习</p><blockquote><p>这里实现的是动态表格内容的添加</p><p><img src="https://blog.chasingwind.top/1563525680569.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563525680569.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1563525711421.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563525711421.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>动态表格的删除</p><pre><code>//动态表格的删除// 1. 首先要知道要删除的是哪一个超链接//给a标签添加onclick onclick=&quot;delTr(this)&quot;// 2. 怎么删除//removeChild()  : 通过父节点删除子节点</code></pre><ol><li><p>在每个<code>&lt;a&gt;</code>标签内设置属性 onclick  : <code>onclick onclick=&quot;delTr(this)&quot;</code></p><p>这里的this就是指当前的对象</p><p><img src="https://blog.chasingwind.top/1563542449885.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563542449885.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p><code>table--&gt;tr--&gt;td--&gt;a</code></p><p><img src="https://blog.chasingwind.top/1563542560305.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563542560305.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>以上只可以将原始的3条数据删除,要删除新添加的项 需要设置属性</p><p><img src="https://blog.chasingwind.top/1563542626208.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563542626208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li></ol><h4 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h4><ul><li>HTML DOM是关于如何获取,修改,添加或删除HTML元素的标准</li></ul><ol><li><p>标签体的设置和获取 : innerHTML</p><blockquote><p><img src="https://blog.chasingwind.top/1563543949064.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563543949064.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>利用<code>&lt;table&gt;</code>的innerHTML来进行动态表格项的添加</p><p><img src="https://blog.chasingwind.top/1563544393698.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563544393698.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用html元素对象的属性 : 使用的时候查看文档</p></li><li><p>控制元素样式 : </p><ol><li><p>使用元素的style属性来设置  <strong>每一个元素都有style属性</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563545945019.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563545945019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</p><blockquote><ol><li><p>提前设置好类选择器</p><p><img src="https://blog.chasingwind.top/1563546249683.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563546249683.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>通过className设置标签的class属性值</p><p><img src="https://blog.chasingwind.top/1563546297203.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563546297203.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1563546321157.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563546321157.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li></ol></li></ol><h3 id="事件监听机制-简称事件"><a href="#事件监听机制-简称事件" class="headerlink" title="事件监听机制(简称事件)"></a>事件监听机制(简称事件)</h3><ol><li><p>概念 : 某些组件被执行了某些操作后，触发某些代码的执行。    </p><ul><li>事件 : 某些操作 如 : 单击，双击，键盘按下了，鼠标移动了</li><li>事件源：组件。如： 按钮 文本输入框..</li><li>监听器：代码。</li><li>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li></ul></li><li><p>常见的事件</p><ol><li><p>点击事件</p><ul><li>onclick：单击事件</li><li>ondblclick：双击事件</li></ul></li><li><p>焦点事件 –&gt;光标</p><ul><li><p>onblur：失去焦点</p><ul><li><p>一般用于表单校验,当用户填写完成的时候,提示正确与否</p><blockquote><p>只有当获取焦点之后,才能失去焦点</p><p>当鼠标点击非编辑框的区域的时候,就失去焦点</p><p><img src="https://blog.chasingwind.top/1563603269468.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563603269468.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>onfocus:元素获得焦点。</p></li></ul></li><li><p>加载事件</p><ul><li><p>onload：一张页面或一幅图像完成加载。</p><ul><li>常用于<code>window</code>或者<code>&lt;body&gt;</code></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563603375360.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563603375360.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>正常情况下,<code>&lt;script&gt;</code>在<code>&lt;input&gt;</code>之前的话,会因为<code>getNameById</code>为null而报错</p><p>当我们用<code>onload</code>来包裹这片代码的时候,就会等页面加载完成才会执行后面的代码,这样就不会发生错误了</p></blockquote></li></ul></li><li><p>鼠标事件</p><ul><li><p>onmousedown    鼠标按钮被按下。</p><blockquote><p><img src="https://blog.chasingwind.top/1563603979637.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563603979637.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>onmouseup    鼠标按键被松开。</p></li><li><p>onmousemove    鼠标被移动。</p></li><li><p>onmouseover    鼠标移到某元素之上。</p></li><li><p>onmouseout    鼠标从某元素移开。</p></li></ul></li><li><p>键盘事件</p><ul><li><p>onkeydown    某个键盘按键被按下。    </p><blockquote><p>Enter键是13</p><p><img src="https://blog.chasingwind.top/1563604179408.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563604179408.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>onkeyup        某个键盘按键被松开。</p></li><li><p>onkeypress    某个键盘按键被按下并松开。</p></li></ul></li><li><p>选中和改变</p><ul><li> onchange    域的内容被改变。</li><li>onselect    文本被选中。</li></ul></li><li><p>表单事件</p><ul><li><p>onsubmit    确认按钮被点击。</p><ul><li>当表单校验失败,会阻止提交</li></ul><blockquote><p>当这个方法的返回值是false的时候,就不会提交表单</p><p><img src="https://blog.chasingwind.top/1563604695861.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563604695861.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>或者,这样写</p><p>因为浏览器会把onclick解析成</p><pre><code class="javascript">function fun()&#123;    //onclick中的内容    return checkForm();&#125;</code></pre><p><img src="https://blog.chasingwind.top/1563605201064.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563605201064.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>onreset    重置按钮被点击。</p></li></ul></li><li><p>事件练习</p><blockquote><p>这里是实现表格的全选,全不选以及反选的功能  主要是熟悉事件</p><p><img src="https://blog.chasingwind.top/1563607238457.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563607238457.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>这里是校验填写的表单是否正确</p><p><img src="https://blog.chasingwind.top/1563611049771.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563611049771.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 和 CSS</title>
      <link href="2019/07/15/HTML%E5%92%8CCSS/"/>
      <url>2019/07/15/HTML%E5%92%8CCSS/</url>
      
        <content type="html"><![CDATA[<p>HTML不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p><a id="more"></a><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><h3 id="Web概念"><a href="#Web概念" class="headerlink" title="Web概念"></a>Web概念</h3><ul><li><p>JavaWeb : </p><ul><li>使用Java语言开发基于互联网的项目</li></ul></li><li><p>软件架构 : </p><ol><li><strong>C / S : Client/Server  客户端/服务器端</strong><ul><li>在用户本地有一个客户端程序,在远程有一个服务器端程序</li><li>优点<ol><li>用户体验好,比如客户端游戏和网页端游戏</li><li>可以将一些大型的本地数据存储下来,不会每次都去服务器重新下载,体验更好</li></ol></li><li>缺点 : <ol><li>开发,安装,部署,维护麻烦</li><li>开发需要<strong>同时开发客户端和服务器端</strong></li></ol></li></ul></li><li><strong>B / S : Browser/Server  浏览器端/服务器端</strong><ul><li>只需要一个浏览器,用户可以通过不同的URL,客户访问不同的服务器端程序</li><li>优点 : 开发,安装,部署,维护简单   <strong>只需要开发服务器端</strong></li><li>缺点 : <ol><li>如果应用过大,用户的体验可能会受到影响</li><li>对硬件要求过高,比如服务器端存储大,带宽大,客户这边太占带宽</li></ol></li></ul></li></ol></li><li><p>B/S架构详解</p><ul><li><p>资源 : </p><ul><li><p>静态资源 : 使用静态网页开发技术发布的资源</p><ul><li>特点 :  <ol><li>所有用户访问的结果<strong>是一样的</strong> , 如 : 文本,图片,音频,视频</li><li>静态网页开发技术 : HTML,CSS,JavaScript</li><li>如果用户请求的是静态资源,那么服务器会<strong>直接将静态资源发送给浏览器</strong>。浏览器中内置了静态资源的解析引擎,可以展示静态资源</li></ol></li></ul></li><li><p>动态资源 : 使用动态网页开发技术发布的资源</p><ul><li>特点 : <ol><li>所有用户能访问的结果, <strong>可能不一样</strong></li><li>动态网页开发技术 : Jsp/Servlet</li><li>如果用户请求的是动态资源,那么服务器会执行<strong>动态资源,转换为静态资源,再发送给浏览器</strong></li></ol></li></ul></li><li><p>我们要学习动态资源,必须要先学习静态资源</p><blockquote><p><img src="https://blog.chasingwind.top/1563157441508.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563157441508.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>静态资源 :</p><p>HTML : 用于搭建基础网页 , 展示页面的内容</p><p>CSS : 用于美化页面 , 页面布局</p><p>JavaScript :  控制页面的元素,让页面有一些动态的效果</p></li></ul></li></ul></li></ul><h2 id="HTML概述"><a href="#HTML概述" class="headerlink" title="HTML概述"></a>HTML概述</h2><ol><li><p>概念 : </p><ul><li>Hyper Text Markup Language  超文本标记语言<ul><li>超文本 :  超文本是用<strong>超链接</strong>的方法，将各种不同空间的文字信息组织在一起的网状文本</li><li>标记语言 : <ul><li>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</li><li>标记语言不是编程语言,没有逻辑性</li></ul></li></ul></li></ul></li><li><p>HTML入门</p><ul><li><p>语法 : </p><ol><li>文档的后缀是  .html  或者  .htm</li><li>标签分为<ul><li>围堵标签：有开始标签和结束标签。如 : <code> &lt;html&gt; &lt;/html&gt;</code></li><li>自闭合标签：开始标签和结束标签在一起。如 : <code>&lt;br/&gt;</code></li></ul></li><li>标签可以嵌套：<ul><li>需要正确嵌套，不能你中有我，我中有你</li><li>错误：<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></li><li>正确: <code>&lt;a&gt;&lt;b&gt;  &lt;/b&gt;&lt;/a&gt;</code></li></ul></li><li>在开始标签中可以定义属性 , 属性是由键值对构成 , 值用单双引号都可以</li><li>html标签不区分大小写  ,但是建议使用小写</li></ol></li><li><p>展示</p><blockquote><p><img src="https://blog.chasingwind.top/1563158577280.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563158577280.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563158540229.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563158540229.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h3 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h3><ol><li><p>文件标签: 构成html最基本的标签</p><ol><li><p>html : html文档的根标签, 根标签:最顶层的标签</p></li><li><p>head : 头标签 ,用于指定html文档的一些属性 ,<strong>引入外部的资源</strong></p></li><li><p>title :  定义网页标题的标签</p></li><li><p>body : 体标签 </p></li><li><p>：<code>&lt;!DOCTYPE html&gt;</code> html5中定义该文档是html文档</p><blockquote><p><img src="https://blog.chasingwind.top/1563172783122.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563172783122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>文本标签: 和文本有关的标签</p><ol><li><p>html注释 : <code>&lt;!-- 注释 --&gt;</code></p></li><li><p><code>&lt;br /&gt;或者 &lt;br&gt;</code> :  换行标签</p><blockquote><p>不添加<code>&lt;br /&gt;</code>标签  而在html中手动换行是没有效果的 会将tab,无论多少个空格都解析成一个空字符</p><p><img src="https://blog.chasingwind.top/1563173611200.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563173611200.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563173518016.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563173518016.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>只有添加<code>&lt;br /&gt;</code>标签后,才能起到换行的效果</p><p><img src="https://blog.chasingwind.top/1563173691466.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563173691466.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1563173784073.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563173784073.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;h1&gt; to &lt;h6&gt;</code>: 标题标签  <strong>自带换行</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1563174436547.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563174436547.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563174195526.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563174195526.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;p&gt;</code> : 段落标签 </p><blockquote><p><img src="https://blog.chasingwind.top/1563174910642.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563174910642.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563174925612.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563174925612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;hr /&gt;</code> : 自闭合标签,显示一条水平线</p><blockquote><p><img src="https://blog.chasingwind.top/1563175288104.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563175288104.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563175218383.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563175218383.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;b&gt;</code> : 字体加粗 bold</p><blockquote><p><img src="https://blog.chasingwind.top/1563175640123.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563175640123.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563175654913.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563175654913.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;i&gt;</code> : 斜体  italic</p><blockquote><p><img src="https://blog.chasingwind.top/1563175708989.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563175708989.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563175730108.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563175730108.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;font&gt;</code> : 字体标签</p><blockquote><p><img src="https://blog.chasingwind.top/1563178611850.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563178611850.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>属性的定义</p><ul><li><strong>color</strong> : <ol><li>英文单词 : 比如 : red,green</li><li>RGB : rgb(值1,值2,值3) : 值的范围0~255 ,值1,值2,值3 分别表示的是红绿蓝三种颜色的占比  这种方式已经不怎么使用了</li><li><strong>#值1,值2,值3</strong> : 值的范围<strong>00~FF</strong>,使用16进制来表示红绿蓝三种颜色的占比   <strong>推荐</strong>使用这种方式</li></ol></li><li>width : <ol><li>数值 : 比如 :width = ‘20’ ,数值的单位,<strong>默认是px(像素)</strong></li><li>百分比 :比如 : width = ‘20%’ , 相对于父元素的占比</li></ol></li></ul></li><li><p>html中的特殊字符的显示</p><blockquote><p><img src="https://blog.chasingwind.top/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%A1%A8.png" class="lazyload" data-srcset="https://blog.chasingwind.top/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%A1%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="特殊字符表"></p><hr><p>其中,空格<code>&amp;nbsp;</code>最为常用</p></blockquote></li></ol></li><li><p>图片标签 </p><ul><li><p><code>&lt;img / &gt;</code>: 自闭合标签</p></li><li><p>属性</p><ol><li>src : 图片路径</li><li>align : 对齐方式</li><li>alt : 图片加载失败的时候,就会显示alt中文字的信息</li></ol></li><li><p>关于图片路径src的书写</p><blockquote><p><img src="https://blog.chasingwind.top/1563182630088.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563182630088.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>列表标签</p><ol><li><p>有序列表</p><p><code>&lt;ol&gt;</code> :  order list  </p><p><code>&lt;li&gt;</code>: 列表项</p><blockquote><p><img src="https://blog.chasingwind.top/1563183112294.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563183112294.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563183139536.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563183139536.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>属性 :</p><p><img src="https://blog.chasingwind.top/1563183218267.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563183218267.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>无序列表  并不是说他的顺序是乱的 而<strong>是他的列表项前面的标识是没有先后顺序之分的</strong></p><p><code>&lt;ul&gt;</code> : unorder list</p><p><code>&lt;li&gt;</code> : 列表项</p><blockquote><p><img src="https://blog.chasingwind.top/1563183633471.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563183633471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563183615532.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563183615532.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>属性:  type : 可以修改无序列表的标识形式</p><p><img src="https://blog.chasingwind.top/1563183686016.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563183686016.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>链接标签</p><ul><li><p><code>&lt;a&gt;</code> : 超链接标签</p></li><li><p><code>&lt;a&gt; </code>标签始终是超链接，但是如果未设置 <strong>href 属性</strong>，则只是超链接的占位符。也就是普通的文本</p></li><li><p>属性 :</p><ul><li>href : 指定访问资源到的URL (统一资源定位符)</li><li>target : 指定打开资源的方式 ,就是 在当前页面或者在新的页面打开<ul><li>_self : 默认值 ,在当前页面打开</li><li>_blank: 在新的空表页面打开</li></ul></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563239279994.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563239279994.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563239301997.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563239301997.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p><code>span</code>和<code>div</code></p><ul><li><p>span : 文本信息在一行展示，行内标签 内联标签</p></li><li><p>div : <strong>每一个div占满一整行</strong>。块级标签</p></li><li><p>他们本身没有对包裹的文字起到任何效果,以后会结合CSS进行文字样式的修改</p><blockquote><p><img src="https://blog.chasingwind.top/1563239766159.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563239766159.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563239777858.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563239777858.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>语义化标签 : HTML5中为了提高程序的可读性,提供的一些标签,</p><ul><li><p>这些标签跟上面的<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>一样,对文字没有任何的效果,将来会通过CSS来进行样式的控制</p></li><li><p><code>&lt;header&gt;</code></p></li><li><p><code>&lt;footer&gt;</code></p></li><li><p>等等</p></li></ul></li><li><p>表格标签 : 在HTML中,表格没有列的概念只有行,然后每一行中有不同个数的单元格</p><ul><li><p><code>&lt;table&gt;</code> : 定义表格</p><ul><li><p>属性: </p><p>width: 宽度</p><p>border : 边框</p><p>cellpadding : 定义内容和单元格的距离 ,就是<strong>单元格上下两条边的间距</strong></p><p>cellspacing：定义<strong>单元格之间的距离</strong>。如果指定为0，则单元格的线会合为一条</p><p>bgcolor : 表格背景色</p><p>align: 表格对齐方式</p></li></ul></li><li><p><code>tr</code> : 定义行</p><p>bgcolor : 行背景色</p><p>align: 行中内容的对齐方式</p></li><li><p><code>th</code> : 定义<strong>表头</strong>单元格</p></li><li><p><code>td</code> : 定义单元格</p><p><strong>rowspan : 合并行</strong></p><p><strong>colspan : 合并列</strong></p></li><li><p><code>&lt;caption&gt;</code> : 表名</p></li><li><p><code>&lt;thead&gt;</code> : 表格的头部分 没有效果 , 有点像语义标签</p></li><li><p><code>&lt;tbody&gt;</code> : 表格的体部分 没有效果 , 有点像语义标签</p></li><li><p><code>&lt;tfoot&gt;</code> : 表格的脚部分 没有效果 , 有点像语义标签</p><blockquote><p><img src="https://blog.chasingwind.top/1563241861629.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563241861629.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563241881906.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563241881906.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><ol><li><p>表单 :</p><ul><li><p>概念 : 用于<strong>采集用户输入的数据</strong>的。这些采集到的数据用于和服务器进行交互</p></li><li><p><code>&lt;form&gt;</code> : 用于<strong>定义表单</strong>的, 可以定义一个范围,范围代表采集用户数据的范围,也就是说在<code>&lt;form&gt;</code>标签内的数据才会被采集</p><ul><li><p>属性 :</p><p>action : 提交数据到指定的URL ,”#” 代表指向的是当前的html的URL</p><p>method : 指定提交方式 </p><ul><li><p>分类 : 一共7种,常用2种</p><p>get :  </p><ol><li>请求参数<strong>会在地址栏中显示</strong>,会封装到请求行中</li><li>请求参数的长度是<strong>有限制的</strong></li><li>不太安全</li></ol><p>post : </p><ol><li>请求参数<strong>不会在地址栏中显示</strong>。会<strong>封装在请求体</strong>中(HTTP协议中讲解)</li><li>请求参数的长度是<strong>没有限制的</strong></li><li>比较安全</li></ol></li></ul></li><li><p>表单中的<strong>数据要想被提交,必须指定其name属性</strong></p></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563263032188.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563263032188.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当连接中拼接有提交的值的时候就说明数据采集成功了</p><p><img src="https://blog.chasingwind.top/1563263095263.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563263095263.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>必须注意的是 : 数据要想被提交,需要满足</p><ol><li>数据必须在<code>&lt;form&gt;</code>标签内</li><li>数据必须有name 属性</li></ol></blockquote></li><li><p>表单项标签</p><ul><li><p><code>&lt;input&gt;</code> : 可以通过type属性值  ,改变元素展示的样式  不写默认为**”text”**</p><ul><li>type : 样式属性 <ol><li><strong>text : 文本</strong> <ul><li>placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息</li><li>value : 输入框中的信息 ,但需要手动清空</li></ul></li><li><strong>password : 密码框</strong> 输入密码的时候会隐藏<ul><li>placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息</li></ul></li><li><strong>radio : 单选框</strong><ul><li>要想让多个单选框实现单选的效果，则<strong>多个单选框的name属性值</strong>必须一样 ,只有<strong>name</strong>属性值相同的单选框 ,才能作为<strong>同一组</strong>进行选择。</li><li>一般会给每一个单选框提供<strong>value属性，指定其被选中后提交的值 .</strong> 不给的话,  提交的时候默认值是<strong>on</strong></li><li>checked属性，可以指定默认值 </li></ul></li><li><strong>checkbox : 复选框</strong><ul><li>一般会给每一个单选框提供value属性，指定其被选中后提交的值 . 不给的话,  提交的时候默认值是<strong>on</strong></li><li>checked属性，可以指定默认值 </li></ul></li></ol></li></ul></li><li><p><code>&lt;label&gt;</code> : 指定输入项的文字描述信息</p><ul><li>for属性 : <strong>一般会和 input 的 id属性值对应</strong>。如果对应了，则点击label区域，会让input输入框获取焦点,就是光标自动跳到对应的输入框</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563266223730.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563266223730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>一定要注意 : 数据要想被采集,必须有name 属性 ,因为在提交的时候我们可以在地址栏中看到name的值是作为键的</p><hr><p><img src="https://blog.chasingwind.top/1563266140088.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563266140088.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=" "></p></blockquote><ul><li><code>&lt;file&gt;</code> : 文件选择框</li><li><code>&lt;hidden&gt;</code> :  隐藏域，用于提交一些信息。  在页面中并不会显示,但是提交的时候会将其中的value值提交</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563267580512.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563267580512.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563267552839.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563267552839.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>按钮 :</p><ol><li><strong>submit : 提交按钮</strong>。可以提交表单</li><li><strong>button : 普通按钮</strong>  不会进行提交 后面结合CSS进行使用</li><li><strong>image : 将图片作为一个按钮</strong><ul><li>src属性指定图片的路径</li></ul></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1563268116391.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563268116391.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563268141334.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563268141334.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>type的其他属性: </p><blockquote><p><img src="https://blog.chasingwind.top/1563268876880.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563268876880.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563268850564.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563268850564.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;select&gt;</code> : 下拉列表</p><ul><li><code>&lt;option&gt;</code> :子元素,下拉列表的选项</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563278573453.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563278573453.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这里的value的作用就是提交的时候province对应的值 </p><p>selected 是说默认选择</p><p><img src="https://blog.chasingwind.top/1563278799097.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563278799097.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p><code>&lt;textarea&gt;</code> : 文本域</p><ul><li>rows : 指定多少个字符作为宽度</li><li>cols : 指定多少个字符作为长度</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563279114592.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563279114592.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1563279130357.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563279130357.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ul></li></ol><h2 id="CSS概述"><a href="#CSS概述" class="headerlink" title="CSS概述"></a>CSS概述</h2><ol><li><p>概念 : Cascading Style Sheets 层叠样式表  用于页面美化和布局控制</p><ul><li>层叠 : 多个样式可以作用在同一个html的元素上，同时生效</li></ul></li><li><p>相比用html标签中的属性控制的好处</p><ul><li>功能强大</li><li>将内容展示和样式控制分离<ul><li>降低耦合度。解耦</li><li>让分工协作更容易</li><li>提高开发效率</li></ul></li></ul></li><li><p>CSS的使用 : CSS与html结合方式</p><ol><li><p>内联样式</p><blockquote><p><img src="https://blog.chasingwind.top/1563287571388.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563287571388.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>内部样式</p><ul><li>在head标签内，定义style标签，style标签的标签体内容就是css代码</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563287789130.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563287789130.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>外部样式</p><ol><li>定义css资源文件</li><li>在<code>&lt;head&gt;</code>标签内，<strong>定义<code>&lt;link&gt;</code>标签，引入外部的资源文件</strong></li></ol><blockquote><p>通过<code>&lt;head&gt;</code>标签中用<code>link</code>标签来引入外部CSS文件<br><img src="https://blog.chasingwind.top/1563288003165.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563288003165.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>也可以这样引用外部资源文件   (了解)</p><p><img src="https://blog.chasingwind.top/1563288197615.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563288197615.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>CSS文件内容</p><p><img src="https://blog.chasingwind.top/1563288032384.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563288032384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>注意</p><p>作用范围: 内联样式 &lt; 内部样式 &lt; 外部样式</p><p>常用的方式是内部样式和外部样式</p></li></ol></li><li><p>CSS语法 :</p><p>格式 :</p><pre><code class="html">选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;</code></pre><blockquote><p><img src="https://blog.chasingwind.top/1563288744437.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563288744437.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>注意 :每一对属性需要使用；隔开，最后一对属性可以不加；但是建议加上</p></li></ol><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><ol><li><p>分类 : </p><ol><li><p>基础选择器</p><ol><li><p>id选择器：选择<strong>具体的id属性值</strong>的元素.建议在一个html页面中id值唯一</p><blockquote><p><img src="https://blog.chasingwind.top/1563289338744.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563289338744.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>元素选择器：选择具有<strong>相同标签名称</strong>的元素</p><blockquote><p><img src="https://blog.chasingwind.top/1563289899897.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563289899897.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见 , id选择器的优先级比元素选择器的高</p></blockquote></li><li><p>类选择器：选择<strong>具有相同的class属性值</strong>的元素。</p><blockquote><p><img src="https://blog.chasingwind.top/1563289943387.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563289943387.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见 ,类选择器优先级高于元素选择器</p></blockquote></li></ol></li><li><p>扩展选择器</p><ol><li><p>选择所有元素</p><ul><li><code>*&#123;&#125;</code></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563325179612.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563325179612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>并集选择器</p><ul><li><code>选择器1,选择器2&#123;&#125;</code></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563325340952.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563325340952.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>子选择器 : 筛选选择器1元素下选择器2的元素</p><ul><li><code>选择器1 选择器2&#123;&#125;</code></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563325500596.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563325500596.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>父选择器 : 筛选选择器2的父元素选择器1</p><ul><li><code>选择器1 &gt; 选择器2&#123;&#125;</code></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563325615558.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563325615558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>属性选择器 : 选择元素名称 ,属性名 = 属性值的元素</p><ul><li><code>元素名称[属性名=&quot;属性值&quot;]&#123;&#125;</code></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563325865983.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563325865983.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>伪类选择器 : 选择一些元素具有的状态</p><ul><li><code>元素 : 状态&#123;&#125;</code></li><li>如 : 超链接<code>&lt;a&gt;</code>  每个标签具有的状态并不同<ul><li>状态 :</li><li>link：初始化的状态</li><li>visited：被访问过的状态</li><li>active：正在访问状态</li><li>hover：鼠标悬浮状态</li></ul></li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563326188188.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563326188188.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol><h3 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h3><ol><li><p>字体,文本</p><ul><li>font-size : 字体大小</li><li>color : 文本颜色</li><li>text-align：对齐方式</li><li>line-height：行高 </li></ul></li><li><p>背景</p><ul><li>background：复合属性</li></ul></li><li><p>边框和轮廓</p><ul><li>border：复合属性</li></ul></li><li><p>尺寸</p><ul><li>width：宽度</li><li>height：高度</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1563328194594.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563328194594.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>盒子模型 : 用来控制布局</p><ul><li><p>margin : 外边距</p><blockquote><p>以div2作为参考的话 使用外边距</p><hr><p><img src="https://blog.chasingwind.top/1563338918897.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563338918897.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>padding : 内边距</p><ul><li><p>默认情况下 ,内边距会影响盒子的大小</p><blockquote><p><img src="https://blog.chasingwind.top/1563338971216.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563338971216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小</p><blockquote><p><img src="https://blog.chasingwind.top/1563339011237.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563339011237.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>float : 浮动</p><p>left :</p><p>right : </p><blockquote><p><img src="https://blog.chasingwind.top/1563339404841.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563339404841.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>内外边距是相对的,需要根据我们的主元素来进行参考</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="2019/07/11/JDBC/"/>
      <url>2019/07/11/JDBC/</url>
      
        <content type="html"><![CDATA[<p>JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。</p><a id="more"></a><h1 id="JDBC基础"><a href="#JDBC基础" class="headerlink" title="JDBC基础"></a>JDBC基础</h1><ol><li><p>JDBC基本概念</p><ul><li>概念: Java DataBase Connectivity ,   Java数据库连接  , 用Java语言操作数据库</li><li>JDBC本质: 就是官方(Sun公司)定义的一套操作所有关系型数据库的规则,也就是接口.  各个数据库厂商去实现这套接口,提供数据库驱动jar包. 我们可以使用这套接口(JDBC) 编程,真正执行的代码是驱动jar包中的实现类      —-&gt; 多态</li></ul><blockquote><p><img src="https://blog.chasingwind.top/1562826660177.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562826660177.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>快速入门</p><ol><li><p>导入驱动jar包</p><ol><li>复制jar包到项目中的自己创建的libs目录下</li><li>右键–&gt; Add as Library</li></ol></li><li><p>注册驱动</p></li><li><p>获取数据库连接对象 Connection</p></li><li><p>定义sql</p></li><li><p>获取执行sql语句的对象 Statement</p></li><li><p>执行sql,返回结果</p></li><li><p>处理结果</p></li><li><p>释放资源</p><blockquote><p><img src="https://blog.chasingwind.top/1562834262546.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562834262546.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>注意 : JDK9之后的改变</li><li>注册驱动的时候是 com.mysql.cj.jdbc.Driver</li><li>获取数据库连接对象的时候需要设置时区,同时需要在MySQL数据库中的my.ini配置文件进行时区的设置</li></ul></li></ol></li><li><p>JDBC操作中的各个对象</p><ol><li><p>DriverManager 类: 驱动管理对象</p><ul><li><p>功能:</p><ol><li><p>注册驱动 : 告诉程序该使用哪一个数据库驱动jar包</p><p>Drivermanager类中的 registerDriver方法</p><p><img src="https://blog.chasingwind.top/1562835236158.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562835236158.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>而我们注册驱动写的程序是</p><p><img src="https://blog.chasingwind.top/1562835286499.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562835286499.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>那么他们之间的关系是什么呢?</p><p>查看源码:</p><p>在com.mysql.cj.jdbc.Driver类中的静态代码块区域 使用的就是registerDriver方法进行驱动的注册的</p><p><img src="https://blog.chasingwind.top/1562835400876.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562835400876.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在MySQL5之后可以省略注册驱动的步骤,在次目录下会自动帮我们进行注册 但是,建议自己进行注册,避免不必要的麻烦</p><blockquote><p><img src="https://blog.chasingwind.top/1562835532144.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562835532144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul><ol start="2"><li><p>获取数据库连接</p><ul><li><p>方法:</p><blockquote><p><img src="https://blog.chasingwind.top/1562835851270.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562835851270.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>参数:</p><p>url:指定连接的路径</p><ul><li><p>语法: jdbc:mysql://ip地址(或域名):端口号/数据库名称?serverTimezone</p></li><li><p>例如:jdbc:mysql://localhost:3306/db2?serverTimezone</p></li><li><p>简写: 当ip是localhost,端口是3306  可以简写为</p><p>jdbc:mysql:///db2?serverTimezone</p></li></ul><p>user:用户名</p><p>password:密码</p></li></ul></li></ol></li><li><p>Connection:数据库连接对象,代表了当前代码和数据库之间的桥梁</p><ol><li><p>功能:</p><ol><li><p>获取执行sql的对象</p><blockquote><p><img src="https://blog.chasingwind.top/1562836110020.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836110020.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1562836137619.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836137619.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>管理事务:</p></li></ol><ul><li><p>开启事务</p><blockquote><p><img src="https://blog.chasingwind.top/1562836227066.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836227066.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>   参数设置成false   就会开启事务</p></blockquote></li><li><p>提交事务</p><blockquote><p><img src="https://blog.chasingwind.top/1562836281726.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836281726.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>回滚事务</p><blockquote><p><img src="https://blog.chasingwind.top/1562836305276.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836305276.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li></ol></li><li><p>Statement:执行sql的对象</p><ol><li><p>execute : 可以执行任意的sql语句</p><blockquote><p><img src="https://blog.chasingwind.top/1562836683173.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836683173.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>很少用这个语句</p></blockquote></li><li><p>executeUpdate :  执行DML(insert , delete , update)  , DDL(create , alter , drop)语句</p><blockquote><p><img src="https://blog.chasingwind.top/1562836720388.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836720388.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>返回值为int ,表示的是sql语句影响的行数  ,返回值&gt;0则执行成功,否则执行失败</p></blockquote></li><li><p>executeQuery : 执行DQL(select)语句</p><blockquote><p><img src="https://blog.chasingwind.top/1562836869969.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836869969.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>返回值是ResultSet  结果集对象</p></blockquote></li></ol></li><li><p>练习<br>account表 添加一条记录这里才是完整的带有错误处理的JDBC</p><blockquote><p><img src="https://blog.chasingwind.top/1562840098084.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562840098084.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>遇到的问题 : sql语句中用双引号会报错  以后都用单引号    account表 修改一条记录  同1account表 删除一条记录  同1</p></li><li><p>ResultSet:结果集对象,封装查询的结果 </p><p>那么怎样将查询的结果给取出来呢?                       ==&gt;<strong>游标</strong></p><p>涉及的方法: ResultSet接口中的方法</p><ol><li><p>boolean next() : 游标向下移动一行 判断当前行是否是最后一行末尾(是否有数据),如果是最后一行,则返回false,  如果不是最后一行, 返回true</p></li><li><p>getXxx(参数) : </p><ul><li>Xxx代表数据类型   </li><li>参数: <ol><li>int : 代表列的编号,列的编号从1开始 </li><li>String : 代表列的名称 如 :getInt(id)</li></ol></li></ul></li><li><p>通过上述的两个方法,就可以获取封装的数据了。 但是每次获取数据并不是一整行的数据,而是这一行中的某一列对应的数据</p></li><li><p>游标默认指向的是表中数据名称的行 也就是非数据行</p></li></ol><blockquote><p><img src="https://blog.chasingwind.top/1562852086405.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562852086405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><hr><p><img src="https://blog.chasingwind.top/1562852111312.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562852111312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>ResultSet也是资源  使用完毕后需要进行释放</p></blockquote><ol start="6"><li><p>上面针对的是一条数据 当有多条数据的时候代码复用性很差 而且,有时候我们并不知道ResultSet集合中有多少条数据 当查询的条数多于集合中的数据的时候 <strong>就可能会产生错误</strong></p><ul><li><p>正确使用游标的方式:</p><ol><li>游标向下移动一行</li><li>判断是否有数据 使用next()的返回值进行判断</li><li>获取数据</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1562852823838.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562852823838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这才是标准的写法  使用while(rs.next())进行循环 并将rs.next()作为循环的条件</p></blockquote></li></ul></li></ol></li><li><p>练习</p><blockquote><ol><li><p>抽取JDBC工具类</p><p>目的: 降低代码的冗余度</p><blockquote><p><img src="https://blog.chasingwind.top/1562943228463.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562943228463.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>jdbc.properties  配置文件</p><p><img src="https://blog.chasingwind.top/1562943317145.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562943317145.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>调用</p><p><img src="https://blog.chasingwind.top/1562943421137.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562943421137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><hr></li><li><p>模拟登陆练习</p><p>模拟登陆,判断账号密码是否正确</p><blockquote><p><img src="https://blog.chasingwind.top/1562945604282.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562945604282.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>注意的是  sql语句的书写  </p></blockquote></li></ol></blockquote></li></ol></li><li><p>PreparedStatement:执行sql的对象</p><blockquote><p>PreparedStatement与Statement的关系  :  PreparedStatement是Statement的子接口</p><p><img src="https://blog.chasingwind.top/1562834734255.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562834734255.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></blockquote><ul><li><p>在上面的模拟登陆练习中有一个小小的bug</p><blockquote><p><img src="https://blog.chasingwind.top/1562978322633.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562978322633.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>这个用户名和密码并不在数据库中, 但却登录成功了</p></blockquote><p>这就是SQL注入问题</p><ol><li><p>SQL注入问题 : 在拼接SQL时,有一些SQL的特殊关键字参与字符串的拼接,会造成安全问题</p><ul><li>用户名 ：用户随便输 ,密码 : a’ or ‘a’ = ‘a</li><li>SQL : SELECT * FROM USER WHERE id = ‘18545’ AND PASSWORD = ‘a’ OR ‘a’ = ‘a’;</li></ul></li><li><p>解决SQL注入问题 : 使用PreparedStatement对象来解决</p><blockquote><p><img src="https://blog.chasingwind.top/1562978907502.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562978907502.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1562978961517.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562978961517.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>PreparedStatement中的SQL语句的形式</p><p><img src="https://blog.chasingwind.top/1562979017329.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562979017329.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见,在PreparedStatement中的SQL语句   参数使用? 来作为占位符</p><hr><p>静态SQL : 所有的参数,在生成SQL的时候都是拼接好的</p><p>预编译SQL : 参数并没有拼接好, 而是使用占位符?来进行替代</p></blockquote></li><li><p>PreparedStatement使用步骤</p><ol><li><p>导入驱动jar包</p></li><li><p>注册驱动</p></li><li><p>获取数据库连接对象  Connection</p></li><li><p>定义sql语句</p><ul><li>sql的参数使用?来进行代替 例如: SELECT * FROM USER WHERE id = ? AND PASSWORD = ?;</li></ul></li><li><p>执行获取SQL语句的对象</p><blockquote><p>Connection接口中的方法</p><p><img src="https://blog.chasingwind.top/1562979828535.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562979828535.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>Connection.preparedstatement(String sql)</p></blockquote></li><li><p>给?赋值</p><ul><li><p>方法 : preparedstatement 中的    setXxx(参数1,参数2)方法</p><blockquote><p><img src="https://blog.chasingwind.top/1562980041805.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562980041805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>参数1 : SQL语句中的?的位置编号    ?位置编号从1开始</p><p>参数2 : ?处的值</p></blockquote></li></ul></li><li><p>执行SQL语句,返回结果  不需要传递参数</p><blockquote><p><img src="https://blog.chasingwind.top/1562980181099.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562980181099.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>处理结果</p></li><li><p>释放资源</p><blockquote><p><img src="https://blog.chasingwind.top/1562980932296.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562980932296.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1562981007287.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562981007287.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>注意  :  我们后面都会用PreparedStatement而不是Statement了</p><ul><li>PreparedStatement可以防止SQL注入问题</li><li>PreparedStatement效率更高</li></ul></li></ol></li></ul></li></ol><h1 id="JDBC事务管理"><a href="#JDBC事务管理" class="headerlink" title="JDBC事务管理"></a>JDBC事务管理</h1><ol><li><p>事务 : 一个包含一个或者多个步骤的业务操作。如果这个业务操作被事务管理,则这多个步骤要么同时成功,要么同时失败</p></li><li><p>操作</p><ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li><p>使用Connection对象来管理事务</p><ol><li><p>开启事务</p><blockquote><p><img src="https://blog.chasingwind.top/1562836227066.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836227066.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>参数设置成false   就会开启事务</p></blockquote></li><li><p>提交事务</p><blockquote><p><img src="https://blog.chasingwind.top/1562836281726.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836281726.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>回滚事务</p><blockquote><p><img src="https://blog.chasingwind.top/1562836305276.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562836305276.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li><li><p>演示</p><blockquote><p><img src="https://blog.chasingwind.top/1562982912623.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562982912623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>经过事务管理  发生异常 account并未发生变化</p><p><img src="https://blog.chasingwind.top/1562983029970.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562983029970.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>如何使用Connection来管理事务</p><ol><li><p>开启事务</p><ul><li>在执行sql之前开启事务</li></ul></li><li><p>提交事务</p><ul><li>当所有sql执行完提交事务</li></ul></li><li><p>回滚事务</p><p>在catch中回滚事务</p></li></ol></li></ol><h1 id="JDBC连接池"><a href="#JDBC连接池" class="headerlink" title="JDBC连接池"></a>JDBC连接池</h1><ul><li><p>用户访问数据库的时候不是直接向系统底层获取连接,而是向<strong>数据库连接池</strong>中获取连接 这样可以减少系统资源的开销</p></li><li><p><strong>数据库连接池</strong> : 其实就是一个存放数据库连接的容器  ,  当系统初始化好后 , 容器中会申请一些连接对象,当用户来访问数据库的时候,从容器中获取连接对象,用户访问完之后,会将连接对象归还给连接池</p></li><li><p>好处:</p><ul><li>节约资源</li><li>用户访问高效</li></ul></li><li><p>实现数据库连接池</p><ol><li><p>DataSource接口</p><blockquote><p>获取连接:</p><p><img src="https://blog.chasingwind.top/1562987707881.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562987707881.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>归还连接 : Connection.close()</p><p>​    如果连接对象Connection是从连接池中获取的,那么调用Connection.close()方法,则不会再关闭连接了,<strong>而是归还连接</strong></p></blockquote></li><li><p>数据库厂商来实现</p><ol><li><p>C3P0 : 数据库连接池技术</p><ol><li><p>使用步骤</p><ol><li>导入jar包  c3p0-0.9.5.2.jar   和  依赖的jar包 mchange-commons-java-0.2.12.jar 以及数据库的驱动jar包</li><li>定义配置文件<ul><li>名称 : c3p0.properties 或者 c3p0-config.xml</li><li>路径 :  直接将文件放在src目录下即可。</li></ul></li><li>创建核心对象  :  数据库连接池对象  CombopooledDataSource</li><li>获取连接   :   getConnection()</li></ol></li><li><p>实现</p><blockquote><ol><li><p>首先 将jar包进行导入  以及  xml 文件   </p><p><img src="https://blog.chasingwind.top/1562999125977.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562999125977.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p><img src="https://blog.chasingwind.top/1562999201719.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562999201719.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>代码</p><p><img src="https://blog.chasingwind.top/1562999218816.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562999218816.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>Console控制台显示</p><p>这里打印出来的是日志信息</p><p><img src="https://blog.chasingwind.top/1562999252956.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562999252956.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>可以使用自己定义的数据库连接池配置</p><p><img src="https://blog.chasingwind.top/1562999785800.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562999785800.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>代码:</p><p><img src="https://blog.chasingwind.top/1563000117665.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563000117665.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>不过 一般情况下都是使用默认的配置</p></li></ol></blockquote></li></ol></li><li><p>Druid : 数据库连接池的实现技术 , <strong>阿里巴巴提供的</strong></p><ol><li><p>使用步骤</p><ol><li>导入jar包   druid-1.0.9.jar 和 数据库驱动jar包</li><li>定义配置文件<ol><li>是properties形式的配置文件</li><li>可以叫任意名称 任意目录  需要手动指定位置</li></ol></li><li>加载配置文件</li><li>获取数据库连接池对象<ul><li>通过工厂类来获取   DruidDataSourceFactory</li></ul></li><li>获取连接  getConnection</li></ol></li><li><p>实现</p><blockquote><p><img src="https://blog.chasingwind.top/1563001336425.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563001336425.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>定义一个工具类来进行连接池的简化</p><ol><li><p>定义一个类 JDBCUtils</p></li><li><p>提供静态代码块加载配置文件，初始化连接池对象</p></li><li><p>提供方法</p></li><li><p>获取连接方法：通过数据库连接池获取连接</p></li><li><p>释放资源</p></li><li><p>获取连接池的方法</p></li><li><p>实现</p><blockquote><p><img src="https://blog.chasingwind.top/1563002692943.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563002692943.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>使用工具类</p><blockquote><p><img src="https://blog.chasingwind.top/1563003323681.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563003323681.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ol></li></ol></li></ul><h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring  JDBC"></a>Spring  JDBC</h1><ol><li><p>Spring 框架对JDBC的简单封装 , 提供了一个JDBCTemplate对象简化JDBC的开发</p></li><li><p>使用步骤</p><ol><li><p>导入jar包</p></li><li><p>创建JDBCTemplate对象, 依赖于数据源DataSource</p><ul><li>JDBCTemplate template = new JDBCTemplate(ds);</li></ul></li><li><p>调用JDBCTemplate的方法来进行CRUD 的操作</p><ol><li>Update() : 执行DML语句</li><li>queryForMap() : 查询结果,将结果封装成Map集合, 当且仅当<strong>结果集中只有一条数据</strong>的时候使用</li><li>queryForList() : 查询结果,将结果封装成List集合, 当<strong>结果集有多条数据</strong>的时候,将每一条数据都存储为键值对的形式</li><li>query() : 查询结果,将<strong>结果封装成指定的JavaBean存储到List集合中</strong></li><li>queryForObject() : 查询,<strong>一般用于查询聚合函数的结果</strong>,将结果封装成某种类型</li></ol></li><li><p>演示</p><blockquote><p>DML</p><p><img src="https://blog.chasingwind.top/1563004967280.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563004967280.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>我们只需要关系sql语句的执行  而不需要关心其他的操作</p></blockquote><blockquote><p>需求</p><ol><li><p>修改1号数据的 salary 为 10000</p></li><li><p>添加一条记录</p></li><li><p>删除刚才添加的记录</p><p><img src="https://blog.chasingwind.top/1563007755734.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563007755734.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><hr><ol><li><p>查询id为1001的记录，将其封装为Map集合</p><p><img src="https://blog.chasingwind.top/1563008191782.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563008191782.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>当查询的<strong>结果集只有一条数据</strong>的时候 封装为map集合 键值对的形式</p><p>当<strong>查询的结果集有多条数据</strong>的时候 会报错</p><hr></li><li><p>查询所有记录，将其封装为List</p><p>当查询的结果集中的数据有多条的时候 , 使用List集合</p><p><img src="https://blog.chasingwind.top/1563008398848.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563008398848.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr><p>可见 这里的List&lt;Map&lt;String , Object&gt;&gt; 也就是将每一条是数据封装成map集合,然后将map集合中的数据存储到list集合中</p><hr></li><li><p>查询所有记录，将其封装为Emp对象的List集合</p><ul><li><p>这里的query(sql 语句, RowMapper接口)</p></li><li><p>RowMapper是告诉query将结果封装成什么样的对象</p></li><li><p>当然一般用已经实现的BeanPropertyRowMapper  这个类已经实现了RowMapper接口</p></li><li><p>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p></li><li><p>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p></li></ul><p><img src="https://blog.chasingwind.top/1563009390742.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563009390742.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><hr></li><li><p>查询总记录数</p><p><img src="https://blog.chasingwind.top/1563010308310.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1563010308310.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><ul><li>queryforObject(sql语句 , 返回值结果类型.class)  一般是<strong>用来查询聚合函数的</strong></li></ul><hr></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库进阶</title>
      <link href="2019/06/21/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/"/>
      <url>2019/06/21/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>本篇主要讲述了 MySQL数据库的设计, 数据库的备份与还原, 多表查询, 事务以及DCL(管理用户以及授权)</p><a id="more"></a><h2 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h2><ul><li><p>概念 : 对<strong>表中的数据</strong>进行限定 , 从而保证数据的正确性,有效性和完整性.</p><ul><li><p>没有约束的时候  添加的数据可以任意 这样就不太合适</p><p><img src="https://blog.chasingwind.top/1561081381653.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561081381653.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>分类: </p><ol><li>主键约束  :  primary key</li><li>非空约束  :  not null</li><li>唯一约束  :  unique</li><li>外键约束  :  foreign key</li></ol></li><li><p>主键约束</p><blockquote><ol><li><p>注意</p><ul><li>含义: 非空且唯一</li><li>一张表中只可以有一个字段为主键</li><li>主键就是表中记录的唯一标识</li></ul></li><li><p>创建表的时候添加约束</p><ul><li>主键的唯一性</li></ul><p><img src="https://blog.chasingwind.top/1561084062207.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561084062207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>主键的非空性</li></ul><p><img src="https://blog.chasingwind.top/1561084101103.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561084101103.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在表创建完成后进行主键约束的添加以及修改</p><ul><li>删除主键 因为主键在表中的唯一性 所以不需要指定字段</li><li>当然 指定字段也是可以的</li></ul><p><img src="https://blog.chasingwind.top/1561084317780.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561084317780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>添加主键</li></ul><p><img src="https://blog.chasingwind.top/1561084434538.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561084434538.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>自动增长</p><ul><li><p>如果某一列是数值类型的,使用auto-increment  可以完成值的自动增长</p></li><li><p>创建表的时候添加</p></li></ul><p><img src="https://blog.chasingwind.top/1561084898790.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561084898790.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>注意: 自动增长的时候 标号只跟上一条数据有关</p><p><img src="https://blog.chasingwind.top/1561084996593.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561084996593.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>删除自动增长</p></li></ul><p><img src="https://blog.chasingwind.top/1561085397483.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561085397483.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><ul><li>这样并不会删除主键</li></ul><ul><li><p>添加自动增长</p><p><img src="https://blog.chasingwind.top/1561085524532.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561085524532.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>注意  大多数情况下  自动增长都是和主键一起使用的  </p></li></ul></blockquote></li><li><p>非空约束  :  not null ,值不能为null</p><blockquote><ol><li><p>创建表的时候添加约束</p><p><img src="https://blog.chasingwind.top/1561082403459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561082403459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在表创建完成后进行非空约束的添加以及修改</p><p><img src="https://blog.chasingwind.top/1561082589803.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561082589803.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li><li><p>唯一约束  :  unique , 值不能重复</p><blockquote><ol><li><p>创建表的时候添加唯一约束</p><p><img src="https://blog.chasingwind.top/1561083172855.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561083172855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在表创建完成后对唯一约束进行添加以及删除</p><ul><li><p>删除唯一约束  DROP INDEX</p><p><img src="https://blog.chasingwind.top/1561083451110.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561083451110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>添加唯一约束</p><p><img src="https://blog.chasingwind.top/1561083573865.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561083573865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>注意:</p><p><img src="https://blog.chasingwind.top/1561083297445.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561083297445.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></blockquote></li><li><p>外键约束  :  foreign key  —&gt;让表与表产生关系,从而保证数据的正确性</p><ul><li><p>问题: 下面的数据中存在大量的数据冗余问题</p><p><img src="https://blog.chasingwind.top/1561105643480.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561105643480.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>问题解决: 将表中的信息拆分成两张表</p><p><img src="https://blog.chasingwind.top/1561106026537.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561106026537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样表的结构就变成了这样的:</p><p><img src="https://blog.chasingwind.top/1561106062862.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561106062862.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样就将之前的部门的名称修改成了部门的编号</p><p><img src="https://blog.chasingwind.top/1561106109437.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561106109437.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>其实数据还是存在问题的 </p><ul><li>当我们将部门表中的某一行删除的时候,在员工表中还存在着部分编号的引用</li><li>现实中的逻辑是  当部门没有人的时候才可以将部门表中的部门信息删除</li></ul></li><li><p>为了解决上述问题,就可以使用<strong>外键约束</strong>,将员工表中的部门编号去关联部门表中的主键id</p><blockquote><ol><li><p>在创建表的时候添加外键</p><p>create table 表名(</p><p>​    ………..</p><p>​    外键列</p><p>​    constraint  外键名称  foreign key  (外键列名称)  references  主表名称(主表列的名称)</p><p>);</p><p><img src="https://blog.chasingwind.top/1561108151878.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561108151878.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>此时去删除部门表的某一行就会出错  因为和主表有外键约束</p><p><img src="https://blog.chasingwind.top/1561108248688.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561108248688.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>另外  当你去员工表中添加一行 部门编号在部门表中不存在的时候 也会报错</p><p><img src="https://blog.chasingwind.top/1561108373354.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561108373354.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样就保证了数据的正确性</p><ul><li>constraint  约束,约束条件</li><li>references  参考,参照,引用    在这里翻译为”关联”我觉得更为合适</li></ul></li><li><p>在表创建完成后进行外键的删除以及添加</p><ul><li><p>删除外键</p><p>语法: <strong>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</strong></p><p><img src="https://blog.chasingwind.top/1561108564964.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561108564964.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在表创建完成之后添加外键</p><p>语法:<strong>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称);</strong> </p><p><img src="https://blog.chasingwind.top/1561109943456.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561109943456.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>级联操作</p><ul><li><p>当我们需要将部门表中的部门编号修改的时候 </p><ol><li>首先 将员工表中的这个部门的员工的所在部门编号修改为NULL</li><li>然后 将部门表中的这个部门修改成相应的编号</li><li>最后 将员工表中的部门NULL 修改成对应的操作</li></ol></li><li><p>级联更新操作就是  当我们修改部门表中的部门编号的时候, 员工表中的部门编号会相应的自动修改</p><p><img src="https://blog.chasingwind.top/1561110381577.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561110381577.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>级联删除操作  当我们删除部门表中的某一行的时候  那么 在员工表中部门编号为此部门编号的行 都会被删除</p><p><img src="https://blog.chasingwind.top/1561110933941.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561110933941.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>弊端 :  删除的时候风险比较大  因为关联的数据都会被删除</p></li><li><p>实际开发中  级联的使用比较谨慎!!</p></li></ul></li></ol></blockquote></li></ul></li></ul><hr><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><ol><li><p>多表之间的关系</p><ul><li>分类:</li></ul><ol><li><p>一对一</p><ul><li><p>人和身份证</p></li><li><p>分析:一个人只有一个身份证,一个身份证只对应一个人</p></li></ul></li><li><p>一对多(多对一)</p><ul><li><p>部门和员工</p></li><li><p>分析:一个部门有多个员工,一个员工只属于一个部门</p></li></ul></li><li><p>多对多</p><ul><li><p>学生和课程</p></li><li><p>一个学生可以选择很多课程,一个课程可以被多个学生选择</p></li></ul></li></ol><ul><li><p>实现关系:</p><ol><li><p>一对一</p><ul><li><p>任意一方 添加  <strong>唯一外键</strong>, 指向另一方的 主键</p></li><li><p>一对一的关系合成一张表岂不是更实在.</p><blockquote><p><img src="https://blog.chasingwind.top/1561207145547.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561207145547.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>一对多(多对一)</p><ul><li><p>在  多  的一方建立外键,指向  1  的一方的主键</p><blockquote><p><img src="https://blog.chasingwind.top/1561206429565.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561206429565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>多对多</p><ul><li><p>借助  中间表  来实现,中间表 至少 包含两个字段 ,这两个字段作为中间表的外键,分别指向两张表的主键</p><blockquote><p><img src="https://blog.chasingwind.top/1561206932097.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561206932097.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>案例分析</p><ul><li><p>tab_category</p><blockquote><p><img src="https://blog.chasingwind.top/1561210216643.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561210216643.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>tab_route</p><blockquote><p><img src="https://blog.chasingwind.top/1561210244412.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561210244412.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>tab_user</p><blockquote><p><img src="https://blog.chasingwind.top/1561210267002.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561210267002.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>tab_favorite</p><blockquote><p><img src="https://blog.chasingwind.top/1561210293584.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561210293584.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>中间表中的两个字段成为联合主键(中间表的)  然后将这个联合主键作为两个主表的外键</p></blockquote></li><li><p>架构图</p><blockquote><p><img src="https://blog.chasingwind.top/1561210320638.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561210320638.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以清晰的看出一对多(多对一)的tab_category和tab_route</p><p>以及借助中间表(tab_favorite)来实现的多对多的关系tab_route和tab_user</p></blockquote></li></ul></li></ol></li></ul></li><li><p>数据库设计的范式</p><ul><li>概念  :  在设计数据库时,需要遵循的一些规范,  要遵循后面的范式, 要求必须遵循前面的所有范式, 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，<strong>这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小</strong></li></ul><p>分类: 第一范式(1NF),第二范式(2NF),第三范式(3NF),BC范式,第四范式(4NF),第五范式(5NF)</p><ul><li><p>第一范式(1NF)  :   每一列都是不可分割的原子数据项</p><p>也就是说不能存在这样的表  系这一列还可以分割成两个原子项</p><blockquote><p><img src="https://blog.chasingwind.top/1561254541772.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561254541772.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>修改后 就变成了原子列  </p><blockquote><p><img src="https://blog.chasingwind.top/1561254662267.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561254662267.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><p>第一范式是数据库设计中最基本的要求  因为在创建表的时候是不可能存在复合列的</p><ul><li><p>第二范式(2NF)  :  在1NF的基础上，<strong>非码属性必须完全依赖于码</strong>（在1NF基础上消除非主属性对主码的部分函数依赖）</p><p>几个概念：</p><p>可将  –&gt; 读作  “确定”</p><blockquote><ol><li>函数依赖：A–&gt;B,如果通过**A属性(属性组)**的值，可以确定唯一B属性的值。则称B依赖于A</li></ol><ul><li>例如：学号–&gt;姓名。  （学号，课程名称） –&gt; 分数</li></ul><ol start="2"><li>完全函数依赖：A–&gt;B， 如果<strong>A是一个属性组</strong>，则B属性值得确定需要依赖于<strong>A属性组中所有的属性值</strong></li></ol><ul><li>例如：（学号，课程名称） –&gt; 分数</li></ul><ol start="3"><li>部分函数依赖：A–&gt;B， 如果<strong>A是一个属性组</strong>，则B属性值的确定只需要依赖于<strong>A属性组中某一些值</strong>即可。</li></ol><ul><li>例如：（学号，课程名称） – &gt; 姓名</li><li>这里只需要学号就可以确定姓名的</li></ul><ol start="4"><li>传递函数依赖：A–&gt;B, B – &gt;C . 如果通过<strong>A属性(属性组</strong>)的值，可以确定<strong>唯一B属性的值</strong>，在通过<strong>B属性（属性组）的</strong>值可以确定<strong>唯一C属性</strong>的值，则称 C 传递函数依赖于A</li></ol><ul><li>例如：学号–&gt;系名，系名–&gt;系主任</li><li>系主任传递依赖于学号</li></ul><ol start="5"><li>码：如果在一张表中，一个<strong>属性或属性组，被其他所有属性所完全依赖</strong>，则称<strong>这个属性(属性组)为该表的码</strong><ul><li>通俗的来书就是,通过这个<strong>属性或属性组</strong> ,  可以确定<strong>其他所有的属性</strong></li></ul></li></ol><p>例如：该表中码为：属性组  <strong>（学号，课程名称）</strong></p><ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除了码属性组的属性</li></ul></blockquote></li></ul></li></ol><ul><li><p>第二范式就是在第一范式基础上  <strong>消除非主属性对主码的部分函数依赖</strong></p><blockquote><p><img src="https://blog.chasingwind.top/1561255931359.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561255931359.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>在表中  码是(学号,课程名称)</li><li>分数完全依赖于码</li><li>姓名,系名,系主任  部分函数依赖于码  也就是部分依赖</li></ul></blockquote><p>   消除部分依赖:将表进行拆分</p><blockquote><p><img src="https://blog.chasingwind.top/1561256234455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561256234455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可见 在选课表中  分数完全依赖与码(学号,课程名称)</p><p>​         在学生表中   姓名,系名,系主任完全函数依赖于码 (学号)</p></blockquote></li><li><p>第三范式(3NF)  :  在2NF基础上，任何非主属性不依赖于其它非主属性（<strong>在2NF基础上消除传递依赖</strong>）</p><p>在上面的表中, 存在   学号–&gt;系名,系名–&gt;系主任  的传递函数依赖</p><blockquote><p><img src="https://blog.chasingwind.top/1561257266774.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561257266774.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><ol><li>命令行的方式<ul><li>语法<ul><li>备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</li><li>还原：<ol><li>登录数据库</li><li>创建数据库</li><li>使用数据库</li><li>执行文件 source 文件路径</li></ol></li></ul></li></ul></li><li>图形化工具</li></ol><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul><li><p>笛卡尔积</p><ul><li><p>有两个集合A, B ,取这两个集合的所有的组成情况 </p></li><li><p>总的组成情况的个数= A集合的元素个数 * B集合的元素个数</p><blockquote><p><img src="https://blog.chasingwind.top/1561258807732.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561258807732.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>要完成多表查询  ,  需要消除无用的数据  这就需要用到下列的三种方式</p></li></ul></li><li><p>多表查询的分类</p><ol><li><p>内连接查询  :  </p><ol><li><p>隐式内连接 :  使用where条件消除无用的数据</p><blockquote><p><img src="https://blog.chasingwind.top/1561259520191.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561259520191.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样的话  当名称太长的时候   我们可以起别名来代替  </p><p><img src="https://blog.chasingwind.top/1561259650975.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561259650975.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>开发规范:  进行相应的备注  以便查阅</p><p><img src="https://blog.chasingwind.top/1561259768259.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561259768259.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>显示内连接</p><ul><li><p>语法:</p><ol><li>SELECT 查询字段 FROM 表1 INNER JOIN 表2 ON 连接条件;</li></ol><ul><li>INNER可省略</li></ul><ol start="2"><li>SELECT 查询字段 FROM 表1 JOIN 表2 ON 连接条件;</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1561260312627.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561260312627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>内连接查询的逻辑</p><ol><li>从哪些表中查询数据</li><li>查询的条件是什么</li><li>查询哪些字段</li></ol></li></ol></li><li><p>外连接查询 : </p><ul><li><p>此时新加入的员工  还没有分配部门的时候</p><blockquote><p><img src="https://blog.chasingwind.top/1561273350079.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561273350079.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>这样并没有完成需求</p><blockquote><p><img src="https://blog.chasingwind.top/1561273520455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561273520455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol><li><p>左外连接</p><p>语法:  <strong>SELECT 查询内容 FROM 表1 LEFT [OUTER]  JOIN 表2 ON 连接条件;</strong></p><p>完成需求:</p><blockquote><p><img src="https://blog.chasingwind.top/1561275388627.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561275388627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol><ul><li><p>结果显示关键词left<strong>左边表中的所有数据</strong>,<strong>右边表数据数据少了补NULL值,数据多了不显示</strong></p></li><li><p>注:  OUTER可省略</p></li></ul><ol start="2"><li><p>右外连接</p><p>语法:  <strong>SELECT 查询内容 FROM 表1 RIGHT [OUTER]  JOIN 表2 ON 连接条件;</strong></p><p>完成需求:</p><blockquote><p><img src="https://blog.chasingwind.top/1561274114817.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561274114817.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>右连接是以右边为参照,左边少了补NULL,多了删除</li></ul></li></ol></li></ul></li><li><p>子查询</p><ul><li><p>概念  :  查询中嵌套查询  ,  称为 嵌套的查询为子查询</p><blockquote><p><img src="https://blog.chasingwind.top/1561275995124.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561275995124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>子查询的不同情况</p><ol><li><p>子查询的结果单行单列</p><ul><li><p>子查询可以作为条件 使用运算符去判断 </p><blockquote><p><img src="https://blog.chasingwind.top/1561276341833.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561276341833.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>子查询的结果多行单列</p><ul><li><p>使用IN来进行判断</p><blockquote><p><img src="https://blog.chasingwind.top/1561277061212.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561277061212.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>子查询的结果多行多列</p><ul><li><p>子查询作为一张虚拟表进行表的查询</p><blockquote><p><img src="https://blog.chasingwind.top/1561277736317.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561277736317.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>还可以用内连接进行查询</p><blockquote><p><img src="https://blog.chasingwind.top/1561277972553.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561277972553.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul></li><li><p>多表查询练习</p><blockquote><p>表结构</p><p><img src="https://blog.chasingwind.top/1561286925750.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561286925750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>完成需求  :  </p><blockquote><p><img src="https://blog.chasingwind.top/1561287872548.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561287872548.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1561287910471.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561287910471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>将工资范围作为条件  使用BETWEEN…AND</p><p><img src="https://blog.chasingwind.top/1561288794376.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561288794376.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1561289110129.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561289110129.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1561289631094.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561289631094.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>使用子查询来实现</li></ul><p><img src="https://blog.chasingwind.top/1561290107256.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561290107256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p>查询所有的数据</p><p><img src="https://blog.chasingwind.top/1561291034248.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561291034248.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用左外连接</p><p><img src="https://blog.chasingwind.top/1561291298568.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561291298568.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ul></li></ol></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol><li><p>事务的基本介绍</p><ol><li><p>概念  :  如果一个包含<strong>多个步骤</strong>的业务操作 , 被事务管理 , 那么这些操作就变成了一个整体 , 要么同时成功,要么同时失败.</p><blockquote><p><img src="https://blog.chasingwind.top/1561293058070.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561293058070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>操作</p><ol><li>开启事务  :  start transaction;</li><li>回滚  :  rollback;</li><li>提交  :  commit;</li></ol><blockquote><p><img src="https://blog.chasingwind.top/1562805803702.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562805803702.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ol start="4"><li><p>MySQL数据库中的事务默认自动提交</p><ul><li>一条DML语句自动提交一次事务</li><li>开启事务的话,需要<strong>手动提交事务</strong>. 不提交的话 数据只是在临时状态 </li><li>Oracle数据库默认手动提交</li></ul></li><li><p>修改事务的默认提交方式</p><ul><li><p>查看事务的提交方式</p><p><img src="https://blog.chasingwind.top/1562806186759.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562806186759.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>修改默认的事务提交方式</p><p><img src="https://blog.chasingwind.top/1562806347044.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562806347044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>设置成手动提交之后 如果数据修改了 而没有commit的话 数据只是在临时状态 ,表中的数据并未改变</p></li></ul></li></ol></li></ol></li><li><p>事务的四大特征(<strong>重点</strong>)</p><ol><li><strong>原子性（Atomicity）</strong> : 被事务管理的SQL语句成为不可分割的最小操作单位, 要么同时成功,要么同时失败</li><li><strong>持久性（Consistency）</strong> : 当事务提交或回滚之后,数据库会持久化地保存数据</li><li><strong>隔离性（Isolation）</strong> : 多个事务之间相互独立</li><li><strong>一致性（Durability）</strong> : 事务操作前后,数据总量不变</li></ol></li><li><p>事务的隔离级别</p><ul><li><p>概念 : 多个事务之间是隔离的,相互独立的. 但是如果多个事务操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题</p></li><li><p>存在的问题</p><ul><li><strong>脏读</strong> : 一个事务读取到另一个事务中的没有提交的数据</li><li><strong>不可重复读(虚读)</strong> : 在同一个事务中,两次读取到的数据不一样<ul><li>比如说一个操作中,事务未提交之前查询结果与提交之后的查询结果不一样,但是进行查询的语句是一样的</li></ul></li><li><strong>幻读</strong> : 一个事务操作(DML)数据表中所有的数据 , 另一个事务添加了一条数据,则第一个事务查询不到自己的修改<ul><li>与多线程加锁相似  ,将表加锁</li></ul></li></ul></li><li><p>隔离级别:</p><ol><li><p>read  uncommitted : 读未提交</p><ul><li>产生的问题 : 脏读、不可重复读、幻读</li></ul></li><li><p>read committed : 读已提交———&gt;(Oracle默认)</p><ul><li>产生的问题 :不可重复读、幻读</li></ul></li><li><p>repeatable read : 可重复读———&gt; (MySQL默认)</p><ul><li>产生的问题 :幻读</li></ul></li><li><p>serializable : 串行化</p><ul><li>解决所有的问题</li></ul></li><li><p>注意 : 隔离级别从小到大  <strong>安全性越来越高</strong>,  但是同时  <strong>效率越来越低</strong></p></li><li><p>数据库隔离级别的查询与设置</p><ul><li><p>– 查询事务隔离级别<br>SELECT @@tx_isolation;</p><p>– 设置事务的隔离级别<br>SET GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别;</p></li></ul></li></ol></li></ul></li></ol><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><ul><li><p>DCL :管理用户,授权</p><ol><li><p>管理用户</p><ol><li><p>添加用户</p><blockquote><p><img src="https://blog.chasingwind.top/1562809501689.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562809501689.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>删除用户</p><blockquote><p><img src="https://blog.chasingwind.top/1562809633489.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562809633489.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>修改用户密码</p><blockquote><p><img src="https://blog.chasingwind.top/1562809926289.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562809926289.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1562810155389.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562810155389.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>查询用户</p><ul><li><p>注意 : 用户的数据存储在mysql数据库中的user 表中</p><blockquote><p><img src="https://blog.chasingwind.top/1562808968445.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562808968445.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/1562809234903.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562809234903.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>% 通配符 : 表示可以在任意主机使用用户登录数据库</p></li></ul></li></ol></li><li><p>权限管理</p><ol><li><p>查询权限</p><blockquote><p><img src="https://blog.chasingwind.top/1562811793114.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562811793114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>授予权限</p><blockquote><p><img src="https://blog.chasingwind.top/1562812119778.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562812119778.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>撤销权限</p><blockquote><p><img src="https://blog.chasingwind.top/1562812139436.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1562812139436.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ol></li></ol></li></ul><p>​     </p><ul><li>DBA : 数据库管理员</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库基础</title>
      <link href="2019/06/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
      <url>2019/06/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>MySQL是一个轻量级关系型数据库管理系统,由于体积小、速度快、总体拥有成本低，开放源码、免费，一般中小型网站的开发都选择Linux + MySQL作为网站数据库。</p><a id="more"></a><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><ol><li><p>数据库 DataBase  简称:DB</p></li><li><p>什么是数据库</p><ul><li>用于存储和管理数据的仓库</li></ul></li><li><p>数据库的特点</p><ol><li>持久化存储数据,其实数据库就是一个文件系统</li><li>方便存储和管理数据</li><li>使用统一的方式操作数据库</li></ol></li><li><p>常见的数据库软件</p><ol><li>MySQL：开源免费的数据库，小型的数据库，已经被 Oracle 收购了。 MySQL6.x 版本也开始收费。后来Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购 </li><li>Oracle：收费的大型数据库， Oracle 公司的产品 </li><li>DB2 ： IBM 公司的数据库产品,收费的。常应用在银行系统中。 </li><li>SQL Server： MicroSoft 公司收费的中型的数据库。 C#、 .net 等语言常使用。 </li><li>SQLite:  嵌入式的小型数据库，应用在手机端，如： Android</li></ol></li><li><p>MySQL数据库的优点</p><ul><li>MySQL是一个轻量级关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。目前MySQL被广泛地应用在Internet上的中小型网站中，由于体积小、速度快、总体拥有成本低，开放源码、免费，一般中小型网站的开发都选择Linux + MySQL作为网站数据库。</li><li>MySQL是一个关系型数据库管理系统，MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，就增加了速度并提高了灵活性。</li></ul></li></ol><p>注:为什么使用数据库存储文件</p><table><thead><tr><th align="left">存储位置</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td align="left">内存</td><td>速度快</td><td>不能永久保存,数据是临时状态</td></tr><tr><td align="left">文件</td><td>数据可以永久保存</td><td>操作数据不方便,不便于管理</td></tr><tr><td align="left">数据库</td><td>1.数据可以永久保存<br />2.查询速度快<br />3.对数据的管理方便</td><td>占用资源,需要购买</td></tr></tbody></table><ol><li><p>数据库的安装与卸载,配置</p><ul><li><p>我们安装MySQL其实安装的是MySQL的服务器软件,他会在windows的注册列表里注册MySQL的服务(service),服务就是一些没有界面的应用程序</p></li><li><p>查看服务 cmd–&gt;   services.msc</p><p><img src="https://blog.chasingwind.top/1560956021391.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560956021391.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>关闭mysql服务 net stop mysql</p><p><img src="https://blog.chasingwind.top/1560956292037.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560956292037.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>开启mysql服务 net start mysql</p><p><img src="https://blog.chasingwind.top/1560956322427.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560956322427.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>数据库的连接</p><ol><li><p>本地数据库的连接</p><p><img src="https://blog.chasingwind.top/1560956580413.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560956580413.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>远程数据库的连接   mysql -h远程的ip地址 -uroot -p 远程的密码</p><p><img src="https://blog.chasingwind.top/1560956898001.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560956898001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>mysql –host=连接的ip –user=root –password=___</p><p><img src="https://blog.chasingwind.top/1560957384356.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560957384356.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></li><li><p>数据库的退出</p><p><img src="https://blog.chasingwind.top/1560956691788.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560956691788.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1560957032347.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560957032347.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>注:以上关闭和开启都需要在管理员的模式下</p></li><li><p>并且上述服务的名称必须和你的服务名称相同 当你的服务名称是mysql1,那么后面就需要的是mysql1</p></li></ul><ol start="5"><li><p>MySQL的目录结构</p><ul><li><p>安装目录</p></li><li><p>配置文件my.ini</p><p><img src="https://blog.chasingwind.top/1560957514959.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560957514959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>数据目录  上图中的data目录 建议不要将data目录与安装目录放在一起</p><p>1 数据库—&gt;  文件夹</p><p>2 表—&gt;  文件</p><p>3 数据—&gt;   数据</p><p><img src="https://blog.chasingwind.top/1560958259594.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560958259594.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li></ol></li><li><p>MySQL数据库基础中的数据库,表,数据的关系</p><p><img src="https://blog.chasingwind.top/1560958392044.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560958392044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>MySQL服务器:安装MySQL服务的电脑</li></ul></li></ol><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ol><li><p>什么是SQL</p><p><strong>SQL = Structured Query Language 结构化查询语言</strong> </p><p>其实就是定义了操作所有的<strong>关系型数据库</strong>的<strong>规则</strong></p><p>—–&gt; 关系型数据库必须遵守SQL</p><p>每一种数据库操作的方式存在不一样的地方称为”方言”</p></li><li><p>SQL通用语法</p><ol><li><p>SQL语句可以单行或多行书写,以分号结尾</p><p><img src="https://blog.chasingwind.top/1560989862124.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560989862124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在这里输入的语句才是SQL语句</p><p>以分号结尾:</p><p><img src="https://blog.chasingwind.top/1560989936571.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560989936571.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>可使用空格和缩进来增强语句的可读性</p></li><li><p>MySQL数据库基础的SQL语句不区分大小写,但是关键字建议使用大写</p><p><img src="https://blog.chasingwind.top/1560990110572.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560990110572.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><ol start="4"><li><p>3种注释</p><ol><li><p>单行注释</p><ul><li><p>‘– 注释内容’</p></li><li><p>‘# 注释内容’–&gt;MySQL特有</p><ul><li>注意空格</li></ul><p><img src="https://blog.chasingwind.top/1560990533920.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560990533920.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1560990573594.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560990573594.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>多行注释</p><ul><li><p>‘/* 注释 */‘</p><p><img src="https://blog.chasingwind.top/1560990650498.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560990650498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li></ol></li><li><p>SQL的分类</p><ol><li><p>Data Definition Language (DDL 数据定义语言) 如：建库，建表 </p></li><li><p>Data Manipulation Language(DML 数据操纵语言)，如：对表中的记录操作增删改 </p></li><li><p>Data Query Language(DQL 数据查询语言)，如：对表中的查询操作 </p></li><li><p>Data Control Language(DCL 数据控制语言)，如：对用户权限的设置 </p></li></ol><ul><li><p>分类及对应的作用</p><p><img src="https://blog.chasingwind.top/1560991021123.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560991021123.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li></ol></li></ol><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><ol><li><p>操作数据库:CRUD(增删改查)</p><ol><li><p>C: Create 创建</p><ul><li><p>创建数据库 <strong>create database 数据库名称;</strong></p><p><img src="https://blog.chasingwind.top/1560992013289.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560992013289.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>如果数据库不存在才进行创建数据库</p><p><img src="https://blog.chasingwind.top/1560992224455.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560992224455.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>创建指定字符集的数据库</p><p><img src="https://blog.chasingwind.top/1560992420281.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560992420281.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>R: Retrieve 查询</p><ul><li><p>查看所有的数据库名称</p><p><img src="https://blog.chasingwind.top/1560991493805.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560991493805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p><strong>show create database 数据库名称;</strong></p><ul><li>查询创建数据库MySQL的语法</li><li>查看数据库对应的字符集,这里是utf-8</li></ul><p><img src="https://blog.chasingwind.top/1560991701314.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560991701314.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>U: Update 修改</p><ul><li><p>修改数据库的字符集 </p><p><strong>alter database 数据库名称 character set 字符集名称;</strong></p><p><img src="https://blog.chasingwind.top/1560992833283.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560992833283.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注: 当修改成字符集UTF-8的时候输入的应该是UTF8;</p><p><img src="https://blog.chasingwind.top/1560993042907.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560993042907.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>D: Delete 删除</p><ul><li><p>删除数据库</p><p><img src="https://blog.chasingwind.top/1560993305331.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560993305331.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>判断存在再删除</p><p><img src="https://blog.chasingwind.top/1560993361100.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560993361100.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>使用数据库</p><ul><li><p>上面的操作都是在数据库之外 也就相当于在下面的目录中</p></li><li><p>只有进入到相应的数据库的文件夹才可以对其中的文件进行操作</p><p><img src="https://blog.chasingwind.top/1560993519052.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560993519052.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>查询当前正在使用的数据库名称 <strong>select database();</strong></p></li><li><p>并对相应的数据库进行使用 <strong>use 数据库名称;</strong></p><p><img src="https://blog.chasingwind.top/1560993715314.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560993715314.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样就相当于我们进入了db1文件夹</p><p><img src="https://blog.chasingwind.top/1560993814823.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560993814823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li></ol></li><li><p>操作表</p><ol><li><p>C: Create 创建</p><ul><li><p>语法  </p><p><strong>create table 表名(</strong></p><p>​        列名1 数据类型1**,**</p><p>​        列名2 数据类型2**,**</p><p>​        列名3 数据类型3**,**</p><p>​        …         …</p><p>​        列名n 数据类型n</p><p><strong>);</strong></p><p>注:最后一列不需要加”,”</p></li></ul></li></ol><p>常用的数据类型:</p><table><thead><tr><th align="left">类型</th><th>英文</th></tr></thead><tbody><tr><td align="left">整数类型</td><td>int</td></tr><tr><td align="left">小数类型</td><td>double(小数的位数,保留的位数)</td></tr><tr><td align="left">日期类型</td><td>date: 只包含年月日,yyyy-MM-dd<br />datetime: 包含年月日时分秒,yyyy-MM-dd HH:mm:ss<br />timestamp: 时间戳类型  包含年月日时分秒,yyyy-MM-dd HH:mm:ss</td></tr><tr><td align="left">字符串类型</td><td>varchar(最大长度)</td></tr></tbody></table></li></ol><ul><li><p>timestamp: 如果这个字段不手动赋值的话,或者赋值为null,那么就会使用当前系统默认的时间,来自动赋值</p></li><li><p>varchar(最大长度),其中的长度是以字符为单位的,zhangsan 8个字符,张三 2个字符</p><p> <img src="https://blog.chasingwind.top/1560998522589.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560998522589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>复制一张表  <strong>create table 表名 like 被复制表名;</strong></p><p><img src="https://blog.chasingwind.top/1560998684451.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560998684451.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li></ul><ol start="2"><li>R: Retrieve 查询</li></ol><ul><li><p>查询某个数据库中的所有的表的名称  <strong>show tables;</strong></p><p><img src="https://blog.chasingwind.top/1560996525577.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560996525577.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>查询表结构 <strong>desc 表名;</strong></p><p><img src="https://blog.chasingwind.top/1560996877526.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560996877526.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul><ol start="3"><li>U: Update 修改</li></ol><ul><li><p>修改表名   <strong>alter table 表名 rename to 新的表名</strong></p><p><img src="https://blog.chasingwind.top/1560999384597.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560999384597.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul><ul><li><p>修改表的字符集   <strong>alter table 表名 character set 字符集名称;</strong></p><p><img src="https://blog.chasingwind.top/1560999516779.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560999516779.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>添加一列  <strong>alter table 表名 add 列名 数据类型;</strong></p><p><img src="https://blog.chasingwind.top/1560999680262.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560999680262.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>修改列的名称 类型   </p><ul><li>修改列的列名和类型  <strong>alter table 表名 change 列名 新的列名 新的类型 ;</strong></li></ul><p><img src="https://blog.chasingwind.top/1560999982801.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560999982801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>只修改列的类型  <strong>alter table 表名 modify 列名 新的类型;</strong></p><p><img src="https://blog.chasingwind.top/1561000145925.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561000145925.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>删除列   <strong>alter table 表名 drop 列名;</strong></p><p><img src="https://blog.chasingwind.top/1561000316774.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561000316774.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul><ol start="4"><li>D: Delete 删除</li></ol><ul><li><p><strong>drop table 表名;</strong></p></li><li><p><strong>drop table if exists 表名;</strong></p><p><img src="https://blog.chasingwind.top/1560998584459.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1560998584459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul><ol start="5"><li><p>客户端图形化工具 : SQLyog</p><p><img src="https://blog.chasingwind.top/1561000740937.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561000740937.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><h2 id="DML-增删改表中的数据"><a href="#DML-增删改表中的数据" class="headerlink" title="DML: 增删改表中的数据"></a>DML: 增删改表中的数据</h2><ol><li><p>添加数据</p><ul><li><p>基本语法</p><p><strong>insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n);</strong></p><p><img src="https://blog.chasingwind.top/1561028624403.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561028624403.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>注意:</p><ol><li><p>列名和值要一一对应</p></li><li><p>如果表名后,不定义列名,则默认给所有列添加值</p><p><img src="https://blog.chasingwind.top/1561028918779.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561028918779.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>除了数字类型,其他类型都需要用引号(单双均可)</p><p><img src="https://blog.chasingwind.top/1561029117451.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561029117451.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol></li></ul></li><li><p>删除数据</p><ul><li>语法</li></ul><p><strong>delete from 表名 [where 条件成立]</strong></p><p><img src="https://blog.chasingwind.top/1561029370231.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561029370231.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><p><strong>truncate table 表名;</strong>  –&gt;删除表 然后创建一个一模一样的空表</p><p><img src="https://blog.chasingwind.top/1561029681333.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561029681333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>注意:</p><ol><li>当没有WHERE条件的时候 delete会将表中的所有的数据删除</li><li>删除所有的数据<ol><li>delete from 表名;   – 不推荐使用 ,有多少条数据执行多少次删除操作</li><li>truncate table 表名;  –删除表 然后创建一个一模一样的空表 这条语句就相当于只执行了 drop table;  create table ;  两条语句  效率更高</li></ol></li></ol></li></ul><ol start="3"><li><p>修改数据</p><ul><li><p>语法</p><p><strong>update 表名 set 列名1 = 值1 , 列名2 = 值2,…. [where 条件];</strong></p><p><img src="https://blog.chasingwind.top/1561030174460.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561030174460.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>注意</p><ol><li>如果没有where条件 那么表中的所有的数据都会被修改</li></ol></li></ul></li></ol><h2 id="DQL-查询表中的数据"><a href="#DQL-查询表中的数据" class="headerlink" title="DQL: 查询表中的数据"></a>DQL: 查询表中的数据</h2><ol><li><p>语法</p><p><strong>select</strong></p><p>​    <strong>字段列表</strong></p><p><strong>from</strong></p><p>​    <strong>表名列表</strong></p><p><strong>where</strong></p><p>​    <strong>条件列表</strong></p><p><strong>group by</strong></p><p>​    <strong>分组字段</strong></p><p><strong>having</strong></p><p>​    <strong>分组之后的条件</strong></p><p><strong>order by</strong></p><p>​    <strong>排序</strong></p><p><strong>limit</strong></p><p>​    <strong>分页限定</strong></p></li><li><p>基础的查询</p></li><li><p>多个字段的查询</p></li></ol><p><img src="https://blog.chasingwind.top/1561034929548.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561034929548.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>​        2. 去除重复</p><p><img src="https://blog.chasingwind.top/1561035151876.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561035151876.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>当去除重复的字段是多个的时候,所有的字段的值都必须相同才能去除</li></ul><p><img src="https://blog.chasingwind.top/1561035424142.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561035424142.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="3"><li>计算列</li></ol><p><img src="https://blog.chasingwind.top/1561035740513.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561035740513.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>但是上述的null 计算的结果不合理,   </li><li>因为在含有null参与的运算中,计算结果都是null</li></ul><p><strong>ifnull(exp1,exp2)函数</strong>  —&gt; 如果exp1为null,就替换为exp2</p><p><img src="https://blog.chasingwind.top/1561035983542.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561035983542.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="4"><li><p>起别名</p><p><img src="https://blog.chasingwind.top/1561036215233.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561036215233.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>当然 在列名后面 添加空格 然后添加别名也是可以的</p><p><img src="https://blog.chasingwind.top/1561036314519.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561036314519.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li><li><p>条件查询</p><ol><li><p>where子句后面跟条件</p></li><li><p>运算符</p><ol><li>&lt;、&gt;、&lt;=、&gt;=、=、&lt;&gt;(不等于)</li></ol></li></ol></li></ol><p><img src="https://blog.chasingwind.top/1561037795760.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561037795760.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>SQL中的等于就是 = ,一个等于号</li></ul><p><img src="https://blog.chasingwind.top/1561037909670.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561037909670.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1561037983083.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561037983083.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="2"><li>BETWEEN…AND</li></ol><ul><li>between A and B  包含A和B</li></ul><p><img src="https://blog.chasingwind.top/1561038201107.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561038201107.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="3"><li><p>IN(集合)</p><p><img src="https://blog.chasingwind.top/1561038513890.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561038513890.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>LIKE(模糊查询)</p><ul><li>占位符<ol><li>_ : 单个任意字符</li><li>% : 多个任意字符</li></ol></li></ul><p><img src="https://blog.chasingwind.top/1561039003957.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561039003957.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1561039109167.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561039109167.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1561039247528.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561039247528.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>IS NULL</p><ul><li>NULL值不可以用基本运算符运算</li></ul><p><img src="https://blog.chasingwind.top/1561038708650.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561038708650.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>AND 或者 &amp;&amp;   (与)</p></li></ol><p><img src="https://blog.chasingwind.top/1561038120787.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561038120787.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="7"><li>OR 或者  ||   (或)</li></ol><p><img src="https://blog.chasingwind.top/1561038406444.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561038406444.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="8"><li>NOT 或者  !   (非)</li></ol><p><img src="https://blog.chasingwind.top/1561038787914.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561038787914.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="4"><li>排序查询</li></ol><ul><li><p>语法: <strong>order by 子句;</strong></p><ul><li><strong>order by 排序字段1 排序方式1 ,  排序字段2 排序方式2,….;</strong></li></ul></li><li><p>排序方式</p><ul><li>ASC : 升序    — &gt; ascend</li><li>DESC: 降序    — &gt; descend</li></ul></li><li><p>排序方式默认的是升序</p></li><li><p>多个字段的排序  靠前的是主排序,靠后的为次排序  当主排序相同的时候,才会使用次排序</p><p><img src="https://blog.chasingwind.top/1561039772111.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561039772111.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>上图中 <strong>主排序</strong>是数学升序    ,当数学成绩相同的时候 ,使用英语成绩降序为<strong>次排序</strong></li></ul></li></ul><ol start="5"><li>聚合函数: 将一列数据作为整体,进行纵向的计算</li></ol><ul><li><p>注: 聚合函数的计算会排除NULL值</p><ul><li>选择不包含NULL的列进行计算</li><li>IFNULL函数</li></ul><p><img src="https://blog.chasingwind.top/1561079129029.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561079129029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul><p><img src="https://blog.chasingwind.top/1561043029049.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561043029049.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol><li><p>count : 计算数量,个数</p><ol><li><p>一般选择没有NULL的列 : 主键</p><p><img src="https://blog.chasingwind.top/1561043160091.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561043160091.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>count(*)</p><p><img src="https://blog.chasingwind.top/1561043196058.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561043196058.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>count(*)  代表只要一条数据中有一列不是NULL,都算作一条数据</li></ul></li></ol></li><li><p>max : 计算最大值</p><p><img src="https://blog.chasingwind.top/1561043324776.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561043324776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>min : 计算最小值</p><p><img src="https://blog.chasingwind.top/1561043354477.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561043354477.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>sum : 计算和</p><p><img src="https://blog.chasingwind.top/1561043383019.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561043383019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>avg : 计算平均值</p><p><img src="https://blog.chasingwind.top/1561043410290.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561043410290.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>分组查询</p></li></ol><ul><li><p>语法: group by 分组字段;</p></li><li><p>注意:</p><ol><li><p>分组之后查询的字段必须是 <strong>分组字段</strong>或者<strong>聚合函数</strong></p><p><img src="https://blog.chasingwind.top/1561044338434.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561044338434.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>where 和 having 的区别</p><ol><li>where 在<strong>分组之前</strong>进行条件的限定  如果不满足条件 ,则不参与分组</li><li>having 在<strong>分组之后</strong>进行限定 如果不满足结果, 则不会被查询出来</li><li>where后不可以跟聚合函数</li><li>having后可以进行聚合函数的判断 </li></ol><p><img src="https://blog.chasingwind.top/1561044458796.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561044458796.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/1561044554302.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561044554302.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>给聚合函数起别名 后面可以用来进行查询</p><p><img src="https://blog.chasingwind.top/1561044669083.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561044669083.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ul></li></ol></li></ul><ol start="7"><li>分页查询</li></ol><ul><li><p>语法: limit 开始的索引 , 每页查询的条数;</p><p><img src="https://blog.chasingwind.top/1561045036960.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561045036960.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>表中的数据的索引从0开始</li></ul></li><li><p>*<em>公式: 开始的索引 = (当前的页码 - 1) * 每页显示的条数*</em></p><p><img src="https://blog.chasingwind.top/1561045243255.png" class="lazyload" data-srcset="https://blog.chasingwind.top/1561045243255.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>当数据不够的时候,会将剩下的所有的数据都显示出来</p></li><li><p>LIMIT是MySQL数据库基础的”方言”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花津南路(完....)</title>
      <link href="2019/05/31/%E8%8A%B1%E6%B4%A5%E5%8D%97%E8%B7%AF/"/>
      <url>2019/05/31/%E8%8A%B1%E6%B4%A5%E5%8D%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>花津南路, 生活学习四年的地方,我想,总该要留些作为纪念的吧。慢慢地发现这座城市还是比较的美好</p><a id="more"></a><h2 id="2019-06-11"><a href="#2019-06-11" class="headerlink" title="2019-06-11"></a>2019-06-11</h2><ul><li><p>镜湖</p><blockquote><p><img src="https://blog.chasingwind.top/611JH03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611JH03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/611JH02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611JH02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/611JH01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611JH01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>中江桥</p><blockquote><p><img src="https://blog.chasingwind.top/611ZJQ01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611ZJQ01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/611ZJQ02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611ZJQ02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/611ZJQ03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611ZJQ03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/611ZJQ04.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611ZJQ04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><ul><li>噪点奇多  看来是时候入手一个大光圈镜头了</li></ul><hr></li><li><p>Others</p><blockquote><p><img src="https://blog.chasingwind.top/611Others01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611Others01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/611Others02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611Others02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/611Others03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/611Others03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="2019-06-16"><a href="#2019-06-16" class="headerlink" title="2019-06-16"></a>2019-06-16</h2><ul><li><p>学校的荷花</p><blockquote><p><img src="https://blog.chasingwind.top/616HH01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/616HH01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/616HH02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/616HH02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="2019-06-21"><a href="#2019-06-21" class="headerlink" title="2019-06-21"></a>2019-06-21</h2><ul><li><p>八佰伴附近</p><blockquote><p><img src="https://blog.chasingwind.top/622BBB01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/622BBB01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/622BBB02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/622BBB02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/622BBB03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/622BBB03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/622BBB04.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/622BBB04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>AHNU赭山校区</p><blockquote><p><img src="https://blog.chasingwind.top/622ASD01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/622ASD01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><blockquote><p><img src="https://blog.chasingwind.top/622ASD02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/622ASD02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>夜晚的镜湖</p><blockquote><p><img src="https://blog.chasingwind.top/622JH01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/622JH01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul><h2 id="2019-06-26"><a href="#2019-06-26" class="headerlink" title="2019-06-26"></a>2019-06-26</h2><ul><li><p>滨江公园</p><blockquote><p><img src="https://blog.chasingwind.top/626BJGY01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626BJGY02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>长江二桥</p><blockquote><p><img src="https://blog.chasingwind.top/626BJGY03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626BJGY04.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>长江江景</p><blockquote><p><img src="https://blog.chasingwind.top/626BJGY05.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY05.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626BJGY07.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY07.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626BJGY09.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY09.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626BJGY08.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY08.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>世茂滨江</p><blockquote><p><img src="https://blog.chasingwind.top/626BJGY06.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626BJGY06.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ04.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ05.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ05.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ06.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ06.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ07.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ07.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626SMBJ08.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626SMBJ08.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>天主教堂</p><blockquote><p><img src="https://blog.chasingwind.top/626TZJT01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626TZJT01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626TZJT02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626TZJT02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626TZJT03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626TZJT03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626TZJT04.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626TZJT04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li><li><p>Others</p><blockquote><p><img src="https://blog.chasingwind.top/626Others01.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626Others01.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626Others02.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626Others02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://blog.chasingwind.top/626Others03.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/626Others03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 旅行志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行志--2019上海</title>
      <link href="2019/05/20/%E6%97%85%E8%A1%8C%E5%BF%97-2019%E4%B8%8A%E6%B5%B7/"/>
      <url>2019/05/20/%E6%97%85%E8%A1%8C%E5%BF%97-2019%E4%B8%8A%E6%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>2019年”五一”上海之旅, 这篇记录最大的目的其实是我用来练习MarkDown语法用的, 大家随便看看就好啦。</p><a id="more"></a><h1 id="一篇迟到的上海之旅"><a href="#一篇迟到的上海之旅" class="headerlink" title="一篇迟到的上海之旅"></a>一篇迟到的上海之旅</h1><h2 id="Apr-the-28th"><a href="#Apr-the-28th" class="headerlink" title="Apr the 28th"></a>Apr the 28th</h2><blockquote><p>啦啦啦~ 去上海啦~</p></blockquote><p><img src="https://blog.chasingwind.top/%E7%81%AB%E8%BD%A6%E7%A5%A8.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E7%81%AB%E8%BD%A6%E7%A5%A8.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="火车票"></p><h2 id="Apr-the-29th"><a href="#Apr-the-29th" class="headerlink" title="Apr the 29th"></a>Apr the 29th</h2><blockquote><ul><li><p>一觉醒来就到了上海~</p></li><li><p>现在才七点多,我姐还在休息,我就自己去逛逛~</p></li><li><p>打开地图,地铁到徐家汇,就去走走</p></li></ul></blockquote><ul><li><p><strong>地铁站</strong></p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%9C%B0%E9%93%81%E7%AB%99.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%9C%B0%E9%93%81%E7%AB%99.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="火车站地铁"></p></blockquote></blockquote></li></ul><ul><li><p><strong>高楼林立徐家汇</strong></p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E5%BE%90%E5%AE%B6%E6%B1%87.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E5%BE%90%E5%AE%B6%E6%B1%87.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="徐家汇"></p></blockquote></blockquote></li><li><p><strong>街道上的外星人和败家之眼瞩目</strong></p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E8%A1%97%E9%81%93.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E8%A1%97%E9%81%93.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="外星人和败家之眼"></p></blockquote></blockquote></li></ul><hr><ul><li><p>接着就是去<strong>交通大学</strong>啦! </p></li><li><p>这是交大徐汇校区的某一个校门,鉴于我分不清东西南北,也没找到交大的正大门<br>交大真的特别漂亮~~</p></li></ul><ul><li><strong>交大校门</strong></li></ul><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E4%BA%A4%E5%A4%A7.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%BA%A4%E5%A4%A7.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="交通大学"></p></blockquote></blockquote><blockquote><blockquote><p>进去之后,我太感动了!!! 此刻我也是<del>交大人</del>(雾)</p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E4%BA%A4%E5%A4%A7%E6%AC%A2%E8%BF%8E.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%BA%A4%E5%A4%A7%E6%AC%A2%E8%BF%8E.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="交大欢迎您"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E4%BA%A4%E5%A4%A7%E4%B8%BB%E5%B9%B2%E9%81%93.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%BA%A4%E5%A4%A7%E4%B8%BB%E5%B9%B2%E9%81%93.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="交大主干道"></p></blockquote></blockquote><ul><li><strong>交大校园</strong></li></ul><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%95%99%E5%AD%A6%E6%A5%BC1.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%95%99%E5%AD%A6%E6%A5%BC1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="教学楼"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%95%99%E5%AD%A6%E6%A5%BC2.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%95%99%E5%AD%A6%E6%A5%BC2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="教学楼"></p></blockquote></blockquote><ul><li><strong>交大图书馆(新上院)</strong></li></ul><blockquote><blockquote><p>交大新上院(图书馆)的古色古香~</p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%96%B0%E4%B8%8A%E9%99%A2.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%96%B0%E4%B8%8A%E9%99%A2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图书馆"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%96%B0%E4%B8%8A%E9%99%A22.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%96%B0%E4%B8%8A%E9%99%A22.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图书馆"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%96%B0%E4%B8%8A%E9%99%A2%E9%81%93%E8%B7%AF.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%96%B0%E4%B8%8A%E9%99%A2%E9%81%93%E8%B7%AF.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图书馆"></p></blockquote></blockquote><ul><li><strong>交大部分学院楼</strong></li></ul><p>经管学院</p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E7%BB%8F%E7%AE%A1%E5%AD%A6%E9%99%A2.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E7%BB%8F%E7%AE%A1%E5%AD%A6%E9%99%A2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="经管学院"></p></blockquote></blockquote><p>法学院</p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%B3%95%E5%AD%A6%E9%99%A2.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%B3%95%E5%AD%A6%E9%99%A2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="法学院"></p></blockquote></blockquote><p>国际与公共事务学院</p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E5%9B%BD%E9%99%85%E4%B8%8E%E5%85%AC%E5%85%B1%E4%BA%8B%E5%8A%A1%E5%AD%A6%E9%99%A2.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E5%9B%BD%E9%99%85%E4%B8%8E%E5%85%AC%E5%85%B1%E4%BA%8B%E5%8A%A1%E5%AD%A6%E9%99%A2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="国际与公共事务学院"></p></blockquote></blockquote><p>Others</p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/Other.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/Other.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Other"></p></blockquote></blockquote><h2 id="Apr-the-30th"><a href="#Apr-the-30th" class="headerlink" title="Apr the 30th"></a>Apr the 30th</h2><p>吨吨吨~~</p><p>​    </p><h2 id="May-the-1st"><a href="#May-the-1st" class="headerlink" title="May the 1st"></a>May the 1st</h2><p>嚯嚯嚯~~~</p><h2 id="May-the-2nd"><a href="#May-the-2nd" class="headerlink" title="May the 2nd"></a>May the 2nd</h2><p>去淮海中路看了<del>人人人人</del></p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%B7%AE%E6%B5%B7%E4%B8%AD%E8%B7%AF.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%B7%AE%E6%B5%B7%E4%B8%AD%E8%B7%AF.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="淮海中路"></p></blockquote></blockquote><h2 id="May-the-3rd"><a href="#May-the-3rd" class="headerlink" title="May the 3rd"></a>May the 3rd</h2><p>不想去看<del>人人人</del></p><h2 id="May-the-4th"><a href="#May-the-4th" class="headerlink" title="May the 4th"></a>May the 4th</h2><ul><li>上午的蓝天~~</li></ul><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E8%93%9D%E5%A4%A91.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E8%93%9D%E5%A4%A91.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="蓝天"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E8%93%9D%E5%A4%A92.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E8%93%9D%E5%A4%A92.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="蓝天"></p></blockquote></blockquote><ul><li><p>下午想着应该没那么多人了,出发外滩</p><ul><li>错综复杂的立交桥</li></ul></li></ul><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E7%AB%8B%E4%BA%A4%E6%A1%A51.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E7%AB%8B%E4%BA%A4%E6%A1%A51.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="立交桥"></p></blockquote></blockquote><p>​    </p><ul><li><p>沿途建筑风景</p><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%B2%BF%E9%80%941.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%B2%BF%E9%80%941.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="沿途"></p></blockquote></blockquote></li></ul><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%B2%BF%E9%80%941.1.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%B2%BF%E9%80%941.1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="沿途"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%B2%BF%E9%80%942.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%B2%BF%E9%80%942.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="沿途"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%B2%BF%E9%80%943.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%B2%BF%E9%80%943.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="沿途"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E6%B2%BF%E9%80%944.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E6%B2%BF%E9%80%944.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="沿途"></p></blockquote></blockquote><ul><li>外滩<blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E5%A4%96%E6%BB%A91.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E5%A4%96%E6%BB%A91.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="外滩"></p></blockquote></blockquote></li></ul><blockquote><blockquote><ul><li>我认为我拍的最好的一张了</li></ul></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E5%A4%96%E6%BB%A92.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E5%A4%96%E6%BB%A92.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="外滩"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E5%A4%96%E6%BB%A93.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E5%A4%96%E6%BB%A93.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="外滩"></p></blockquote></blockquote><ul><li>陆家嘴呀 ~</li></ul><blockquote><blockquote><ul><li>开箱上海三件套</li></ul></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E4%B8%89%E4%BB%B6%E5%A5%972.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%B8%89%E4%BB%B6%E5%A5%972.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="陆家嘴"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E4%B8%89%E4%BB%B6%E5%A5%971.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%B8%89%E4%BB%B6%E5%A5%971.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="陆家嘴"></p></blockquote></blockquote><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E4%B8%89%E4%BB%B6%E5%A5%973.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%B8%89%E4%BB%B6%E5%A5%973.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="陆家嘴"></p></blockquote></blockquote><ul><li>上海地标——东方明珠</li></ul><blockquote><blockquote><p><img src="https://blog.chasingwind.top/%E4%B8%9C%E6%96%B9%E6%98%8E%E7%8F%A0.jpg" class="lazyload" data-srcset="https://blog.chasingwind.top/%E4%B8%9C%E6%96%B9%E6%98%8E%E7%8F%A0.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="东方明珠"></p></blockquote></blockquote><h2 id="May-the-5th"><a href="#May-the-5th" class="headerlink" title="May the 5th"></a>May the 5th</h2><p>吨吨吨~</p><h2 id="May-the-6th"><a href="#May-the-6th" class="headerlink" title="May the 6th"></a>May the 6th</h2><p>回学校啦~</p><hr><ul><li>今天写博客了吗<ul><li><input checked="" disabled="" type="checkbox"> get!</li></ul></li></ul><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 旅行志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
