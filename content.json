{"meta":{"title":"追风少年","subtitle":"ChasingWind","description":"师大追风少年~","author":"WuXinhua","url":"https://www.chasingwind.top","root":"/"},"pages":[{"title":"","date":"2021-02-08T03:05:22.917Z","updated":"2021-02-08T03:05:22.912Z","comments":true,"path":"404.html","permalink":"https://www.chasingwind.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-02-08T03:03:06.984Z","updated":"2021-02-08T03:03:06.966Z","comments":true,"path":"categories/index.html","permalink":"https://www.chasingwind.top/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-02-08T03:04:44.714Z","updated":"2021-02-08T03:04:44.697Z","comments":true,"path":"friends/index.html","permalink":"https://www.chasingwind.top/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2021-03-03T14:44:38.883Z","updated":"2021-02-08T03:02:26.964Z","comments":true,"path":"about/index.html","permalink":"https://www.chasingwind.top/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"","date":"2021-02-08T03:04:13.333Z","updated":"2021-02-08T03:04:13.325Z","comments":true,"path":"mylist/index.html","permalink":"https://www.chasingwind.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-02-08T03:03:40.135Z","updated":"2021-02-08T03:03:40.130Z","comments":true,"path":"tags/index.html","permalink":"https://www.chasingwind.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"编程基础之计算机组成原理(计算篇)","slug":"编程基础之计算机组成原理-计算篇","date":"2021-03-25T06:28:16.000Z","updated":"2021-04-08T15:29:43.179Z","comments":true,"path":"2021/03/25/编程基础之计算机组成原理-计算篇/","link":"","permalink":"https://www.chasingwind.top/2021/03/25/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%AE%A1%E7%AE%97%E7%AF%87/","excerpt":"进制运算的基本知识 二进制数据的表示方法 二进制数据的运算","text":"进制运算的基本知识 二进制数据的表示方法 二进制数据的运算 进制运算的基本知识进制概述 进位制是一种记数方式，亦称进位计数法或位值计数法 有限种数字符号来表示无限的数值（十进制只需要0~9就能表示无限多个数字） 使用的数字符号的数目称为这种进位制的基数或底数（十进制n = 10[0~9]） 二进制运算的基础 计算机中由于二进制表示数据太长了，通常会使用八进制和十六进制来对数据进行压缩 进制转换 十进制的话 基数r就是10 二进制和十进制之间的转换（整数部分） 二进制转换为十进制：按权展开法 二进制从右往左看1所处的位置 比如 二进制01100101 从右往左看，1所处的位置分别是0，2，5，6，所以按权展开就是上图中右边的表示 十进制转换为二进制：重复相除法 十进制101 除到什么时候为止？ 当商为0 的时候，就不再进行除法 转换为的二进制就是 下图中【取余数】从下到上对应着二进制的从高位到低位 101–&gt;1100101 二进制和十进制之间的转换（小数部分） 二进制转换为十进制：按权展开法 十进制转换为二进制：重复相乘法 重复乘以2，对得到的积拆分为两部分，如果积大于1，则拆分成1+（积-1），否则就是小于1，拆分成0+积。 然后再对（积-1）或者积乘以2，循环直到（积-1）或积为0 最终转换的结果就是从上到下下对应着小数点后面的从左到右 二进制数据的表示方法 有符号数和无符号数 计算机中的负数如何表示？ 计算机中将一个数字分成2部分，分别是符号位和数字位 以下图为例，2个字节长度表示一个数字 符号位0表示正数，1表示负数。 二进制原码表示法 👆就是原码表示法 原码表示法的弊端： 0有两种表示+0和-0，仅仅是符号位不同，数字位都是0，这样就有歧义 原码运算过于复杂，比如一个正数和一个负数相加，首先需要判断绝对值大小，然后用绝对值大的减去绝对值小的，最后结果符号和绝对值大的保持一致 二进制补码表示法 计算机计算需要解决的问题：使用正数代替负数，加法代替减法，使得两个不同符号数之间的操作更加简单 为何引入补码？ 使用正数替代负数 补码定义： 正数补码是它本身 负数补码，从右往左，直到找到第一个1所在的位置，此位置不变，然后将此位置和符号位中间的位全部取反（符号位也不变） 补码计算： -13：源码表示为1,1101，补码表示为1,0011 -7：源码表示为1,0111，补码表示为1,1001 二进制反码表示法 为何引入反码？ 使用加法替代减法 反码定义： 正数的反码是它本身 负数的反码：在原码的基础上除符号位之外全部取反 反码计算： -13：源码表示为1,1101，反码表示为1,0010 -7：源码表示为1,0111，反码表示为1,1000 原码，补码以及反码之间的关系 负数的反码等于原码除符号位之外按位取反 负数的补码等于反码+1 小数的二进制补码表示 规则与整数相同 比如： 原码：1,0.011011，补码：1,1.100101，反码：1,1.100100 二进制数据的运算 定点数和浮点数 定点数：小数点固定在某个位置的数称为定点数 一般用于表示纯小数或者纯整数 实际使用当中用到的最多的还是大于1的小数，通常使用浮点数进行表示 浮点数： 浮点数的表示格式 类比科学计数法 浮点数的表示范围 阶码数值部分： 假设阶码数值为4位 最大值：1111，$1×2^0+1×2^1+1×2^2+1×2^3$ = $2^0+2^1+2^2+2^3$ = $1× \\frac {1-2^4}{1-2}$ = $2^4 -1$ = 15 最小值：-1111，$-2^4 -1$ 注：等比数列求和公式 尾数数值部分：由于尾数规定使用纯小数，即0.110111….这种格式 假设尾数数值为4位 最大值：0.1111=$1×2^{-1}+1×2^{-2}+1×2^{-3}+1×2^{-4}$ = $2^{-1}+2^{-2}+2^{-3}+2^{-4}$ = $2^{-1}× \\frac {1-2^{-1×4}}{1-2^{-1}}$ = $\\frac{2^{-1}×(1-2^{-4})}{2^{-1}×(2^1-1)}$ = $1-2^{-4}$ 最小值：0.0001 = $1×2^{-4}$ = $2^{-4}$ 由此可以计算浮点数可以表示的数字范围：假设阶码m位，尾数n位 单精度浮点数和双精度浮点数： 浮点数的规格化 练习： 先将需要转换的浮点数规格化，再按照阶码符号位，阶码数值位，尾数符号位，尾数数值位来存放，注意各数值位长度 定点数和浮点数的对比 定点数的加减法运算 定点数的加法使用的是补码进行计算的，取模操作是为了将符号位产生的进位丢掉 整数的加法 小数的加法 与整数加法同理 溢出 按照整数的加法的流程计算，由于两个计算数是8位的，结果的长度已经超过了8位，发生了溢出 如何判断是否溢出？– 双符号位判断法 定点数的减法运算 浮点数的加减法运算 步骤：对阶–尾数求和–尾数规格化–舍入–溢出判断 对阶： 尾数求和：与定点数加减法类似 尾数规格化（左移）：双符号位一致，并且符号位和最高位一致 什么时候需要尾数规格化？ 当尾数符号位和尾数最高位一致的时候需要尾数规格化 尾数规格化（右移）：双符号位不一致的时候需要右移（此时双符号位不一致不是定点数溢出的情况） 舍入操作：0舍1入，提升精度，但是可能会溢出 关于为什么补1？由于进位导致的符号位不同，2位变成3位，那么这三位中，高位的前两位必然是相同的 0舍1入溢出的情况 浮点数溢出判断： 运算案例 发现尾数的符号位不相同，所以需要进行尾数规格化（右移） 浮点数的乘除法运算（了解） 浮点数乘法 浮点数除法 流程","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://www.chasingwind.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://www.chasingwind.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"author":"ChasingWind"},{"title":"编程基础之计算机组成原理(组成篇)","slug":"编程基础之计算机组成原理-组成篇","date":"2021-03-22T08:16:16.000Z","updated":"2021-03-25T06:06:16.820Z","comments":true,"path":"2021/03/22/编程基础之计算机组成原理-组成篇/","link":"","permalink":"https://www.chasingwind.top/2021/03/22/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%BB%84%E6%88%90%E7%AF%87/","excerpt":"计算机总线是什么？计算机如何通过总线进行通信 IO设备如何与CPU进行交互？ 计算机存储器的分类以及各种类型的作用？ CPU组成以及CPU执行指令的过程","text":"计算机总线是什么？计算机如何通过总线进行通信 IO设备如何与CPU进行交互？ 计算机存储器的分类以及各种类型的作用？ CPU组成以及CPU执行指令的过程 计算机总线 计算机总线概述 是什么、有什么用 日常生活中，我们常用的USB（Universal Serial Bus，通用串行总线） 为什么使用USB？ 提供了对外连接的接口 不同设备可以通过USB接口进行连接 连接的标准，促使外围设备接口的统一 作用：解决不同设备之间的通信问题 假设没有总线的时候，我们需要对现有系统新增一个输入设备，就需要分别将新增的输入设备连接到存储器运算器和控制器，这将导致线路极其复杂。 在总线的基础上进行连接，只需要将设备连接到总线上即可 总线分类 片内总线 大大简化芯片内部的电路结构 系统总线 连接计算机各种外围设备的总线 CPU、主内存、IO设备、各个组件之间的信息传输线 系统总线的分类 数据总线 双向传输各个部件之间的数据信息 数据总线的位数（总线宽度）是数据总线的重要参数，位数一般与CPU位数相同（32位、64位） 地址总线 用于传输数据的地址而使用的，用于数据的寻址 控制总线 总线的仲裁 为什么需要总线仲裁 为了解决不同设备总线使用权的冲突问题 举例：假设主存现在需要和硬盘和IO设备交换数据，并且现在硬盘和IO设备都处于就绪状态，那么主存是由硬盘先使用还是IO设备先使用呢？ 总线仲裁的方法 链式查询 设备1和设备2同时向仲裁控制器发出总线使用申请，仲裁控制器返回允许使用信号给设备之后，设备就可以使用总线，但是是在优先级高的设备不在使用的情况下。 好处：电路复杂度低（串联），仲裁方式简单 坏处：优先级低的设备难以获得总线使用权，对电路故障敏感 计时器定时查询 步骤一：仲裁控制器对设备编号并使用计数器累计计数 步骤二：接收到仲裁信号后，往所有设备发出计数值 步骤三：计数值与设备编号一致则获得总线使用权 独立请求 每个设备均有总线独立连接仲裁器 设备可单独向仲裁器发送请求和接收请求 当同时收到多个请求信号，仲裁器有权按优先级分配使用权 优点：响应速度快，优先顺序可动态改变 缺点： 设备连线多，总线控制复杂 IO设备 常见的输入输出设备 常见输入设备：字符输入设备（键盘）、图形输入设备（鼠标、数位板、扫描仪）等等 常见输出设备：显示器、打印机、投影仪等等 输入输出接口的通用设计 设计包含：数据线、状态线、命令线、设备选择线 数据线：是I/O设备与主机之间进行数据交换的传送线，分为单向传输线和双向传输线 状态线：IO设备向主机报告状态的信号线，查询设备是否已经正常连接并就绪或者查询设备是否已经被占用 命令线：CPU向设备发送命令的信号线，包括发送读写信号，发送启动停止信号 设备选择线：主机选择I/O设备进行操作的信号线，对连在总线上的设备进行选择。 CPU与IO设备的通信 前提：CPU速度和IO设备速度不一致 程序中断：提供低速设备通知CPU的一种异步方式 当CPU需要和IO设备进行通信的时候（数据传输），当外围IO设备就绪时，向CPU发出中断信号，CPU有专门的电路响应中断信号 模拟打印机与CPU通信时序图 优点：CPU可以高速运转同时兼顾低速设备的响应 缺点：如果频繁中断CPU的话，CPU执行效率会降低 DMA（直接存储器访问） DMA直接连接主存与IO设备，DMA工作时不需要CPU的参与 在我们平常使用的硬盘显卡中都有DMA设备 计算机的存储器存储器概览 存储器分类 按照存储介质分类 按照存取方式分类 存储器的层次结构 需要考虑的因素 按照位价对存储器进行分类 缓存：一般是指CPU寄存器以及高速缓存 主存：指的是计算机内存 辅存：硬盘，U盘等等 层次之间的数据交换 CPU和高速缓存以及主存之间都可以进行数据传输 辅存只与主存进行数据的传输 缓存-主存层次 原理：局部性原理 实现：在CPU与主存之间增加一层速度快（容量小）的Cache（高速缓存） 目的：解决主存和CPU速度不一致的问题 基于局部性原理，我们将这个较小的连续区域单独取出来，这一片就是高速缓存 主存-辅存层次 原理：局部性原理 实现：在主存之外增加辅助存储器（磁盘、SD卡、U盘等） 目的：解决主存容量不足的问题 常见案例：如果我们需要运行一个游戏,这个游戏有20GB,但是我们内存只有8GB,那么这个游戏时怎么运行起来的呢 由于局部性原理，计算机将当前使用到的数据加载到主存中，而未使用到的数据不进行加载，还是存放到辅存中 计算机的主存储器与辅助存储器先思考2个问题：计算机断电，为什么内存数据丢失？为什么磁盘数据不会丢失？ 主存储器–内存 组成部分 主存如何与CPU进行交互？ CPU中的MDR通过数据总线连接读写电路，传输数据 CPU中的MAR通过地址总线连接译码器，指定数据的位置信息 主存最大大小和操作系统位数的关系 32位系统最多支持4GB内存，因为主存地址寄存器最多可以寻址范围是$2^{32}$ 辅助存储器–磁盘 磁盘结构示意图 盘片结构图 磁头位置：表示磁头当前位于哪一个磁道 磁头方向：是往里还是往外 磁盘表面是可磁化的硬磁特性材料 移动磁头径向运动读取磁道信息 磁盘调度算法 案例介绍： 我们将最外面的磁道定义为第1个磁道，最里面的磁道是第5个磁道 目前磁头在磁道4，磁头方向是由里向外读取的，现在想要读取磁道：1 4 2 3 1 5 先来先服务算法 对于多个读写磁盘的请求，将所有的请求放到一个队列中，按照顺序完成读写需求 那么上面的案例的读取顺序就是：1 4 2 3 1 5 最短寻道时间优先 优先访问距离磁头最近的磁道 那么访问顺序就是： 4 3 2 1 1 5或者4 5 3 2 1 1，与磁头方向无关 扫描算法（电梯算法） 每次只向一个方向移动，到达一个方向尽头然后再反方向移动 那么访问顺序就是：4 3 2 1 1 5（由于目前在4磁道，由里往外） 循环扫描算法 读取方向是不变的，一个方向读取完之后，回到起点重新读取 假设这里读取方向是由外向里 那么访问顺序就是：4 5 1 1 2 3 计算机的高速缓存 高速缓存的工作原理 字：是指存放在一个存储单元中的二进制代码组合，可以表示数据，指令，字符串等等，是内存中存储单元的最小单位 字块：存储在连续的存储单元中而被看作是一个单元的一组字 字的寻址 首先，字的地址组成包含2部分 字的地址长度和主存的关系 计算 块地址的数量（$2^m$）≤主存中字块数 块内地址数量（$2^b$）≤字块中字的数量 高速缓存中存储的数据与主存比较类似，也有字和字块的概念 同时，高速缓存中存储的数据是主存中数据的复制 主存字块数远大于缓存字块数 当高速缓存中有CPU需要的数据的时候，会直接从CPU中取数据。 否则，就需要从主存中取数据，这样就会降低CPU的效率 那么该怎么量化从告诉缓存取数据成功的几率呢？–缓存命中率或者访问效率 高速缓存的替换策略 高速缓存替换时机：当高速缓存中没有CPU所需要的数据的时候，就需要从主存载入所需数据到高速缓存中进行替换 替换策略 随机算法 随机选取高速缓存中的某位置的内容进行替换 先进先出算法（FIFO） 把高速缓存看做是一个先进先出的队列，优先替换最先进入队列的字块 最不经常使用算法（LFU） 优先淘汰最不经常使用的字块，需要额外的空间记录字块的使用频率 最近最少使用算法（LRU） 优先淘汰一段时间内没有使用的字块，有多种实现方法，通常使用双向链表实现；实现时，需要始终保证头部是最近使用的 计算机的CPU计算机的指令系统 机器指令的形式 操作码+地址码 操作码字段 比如机器指令中操作码字段长度为8位，那么支持的操作种类就是$2^8$种 三地址指令：地址码字段中包含3个地址 比如下图中 ，将addr1地址的数据和addr2地址的数据通过OP操作，将结果赋值给addr3地址 二地址指令：地址码字段中包含2个地址 比如下图中，将addr1地址的数据和addr2地址的数据经过OP操作，将结果赋值给addr1或者addr2 一地址指令：地址码字段中包含1个地址 比如自增操作 只包含操作码，无地址码的形式 机器指令的操作类型 数据传输：寄存器之间、寄存器与存储单元、存储单元之间传送数据，数据读写、交换地址数据、清零置一等操作 算术逻辑操作： 操作数之间的加减乘除运算，与或非等逻辑运算 移位操作：数据左移（乘2）、数据右移（除2） ，完成数据在算术逻辑单元的必要操作 控制指令：等待指令、停机指令、空操作指令、中断指令等 机器指令的寻址方式：机器指令是如何找到相关数据的？ 指令寻址 顺序寻址：指令按照地址顺序进行执行 跳跃寻址：指令中包含跳转到的指令的地址，通过指令中提供的地址信息完成寻址 比如上图中，先顺序寻址执行地址为101，102，103，104，105的指令，在执行105地址的指令的时候发生了JMP指令，跳跃寻址跳转到102地址 数据寻址 立即寻址 直接寻址 间接寻址 三种数据寻址方式的对比 计算机的控制器 控制器在CPU中，主要包括以下组成部分 程序计数器：用来存储下一条需要执行的指令的地址，当指令被拿出时，指向下一条指令 时序发生器：用于发送时序脉冲，CPU依据不同的时序脉冲有节奏的进行工作 指令译码器：将计算机指令中的操作码翻译成对应的操作，发出控制信号；对于地址码会控制传输地址码以及对应的数据 指令寄存器：从主存或高速缓存中存取计算机指令，使得CPU可以高速运转 主存地址寄存器： 保存当前CPU正要访问的内存单元的地址（通过地址总线进行通信） 主存数据寄存器：保存当前CPU正要读或写的主存数据（通过数据总线进行通信） 通用寄存器：用于暂时存放或传送数据或指令， 可保存ALU（算术逻辑单元）的运算中间结果，容量比一般专用寄存器要大 计算机的运算器 运算器的组成部分 数据缓冲器 分为输入缓冲和输出缓冲 输入缓冲暂时存放外设送过来的数据 输出缓冲暂时存放送往外设的数据 ALU（算术逻辑单元）：完成常见的位运算（左右移、与或非等），算术运算 教科书中ALU示意图 A，B表示输入，F表示输出，K表示多个控制线，用于控制ALU的运算 状态字寄存器：存放运算状态（条件码、进位、溢出、结果正负等），存放运算控制信息（调试跟踪标记位、允许中断位等） 通用寄存器：用于暂时存放或传送数据或指令，可保存ALU的运算中间结果，容量比一般专用寄存器要大 计算机指令执行过程 指令执行过程 取指令 分析指令 执行指令 组件之间通过总线连接 CPU的流水线设计 从上面的指令执行过程可以看出，在取指令以及分析指令的时候主要是控制器在工作的，执行指令才是运算器工作的，这样CPU的利用率不高 改进：采用流水线的方式 效率对比：当m趋近于正无穷的时候，流水线效率是串行效率的3倍","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://www.chasingwind.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://www.chasingwind.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"author":"ChasingWind"},{"title":"编程基础之计算机组成原理(概述篇)","slug":"编程基础之计算机组成原理-概述篇","date":"2021-03-21T04:27:12.000Z","updated":"2021-03-22T09:37:28.329Z","comments":true,"path":"2021/03/21/编程基础之计算机组成原理-概述篇/","link":"","permalink":"https://www.chasingwind.top/2021/03/21/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0%E7%AF%87/","excerpt":"这里简单的介绍了计算机的发展简史以及分类，计算机的体系结构以及为计算机进行分层便于理解，介绍了每一层对应的编程语言。另外还介绍了我们常见的用于衡量容量和速度的单位，之后介绍了计算机中的字符和编码集。","text":"这里简单的介绍了计算机的发展简史以及分类，计算机的体系结构以及为计算机进行分层便于理解，介绍了每一层对应的编程语言。另外还介绍了我们常见的用于衡量容量和速度的单位，之后介绍了计算机中的字符和编码集。 计算机发展简史 计算机发展的四个阶段 第一阶段：电子管计算机，代表是ENIAC（埃尼阿克），特点：集成度低，空间占用大，功耗高，运行速度慢，操作复杂。 第二阶段：晶体管计算机，代表TX-0，PDP-1，特点：集成度相对较高，空间占用相对较小；功耗相对较低，运行速度较快；操作相对简单，交互更加方便。 第三阶段：集成电路计算机，集成电路（IC）。并且这个阶段操作系统也诞生了（IBM的System/360），计算机变得更小，功耗更低，运算速度更快。 第四阶段：超大规模集成电路计算机，Apple和Apple二代诞生了。 微型计算机的发展历史 摩尔定律：集成电路的性能，每18~24个月就会提升一倍（适用于20世纪） 多核CPU的发展 计算机的分类 超级计算机 特点：功能最强、运算速度最快、存储容量最大的计算机；多用于国家高科技领域和尖端技术研究 衡量单位：运算速度TFlop/s，1TFlop/s=每秒一万亿次浮点计算 大型计算机 特点：又称大型机、大型主机、主机等，具有高性能，可处理大量数据与复杂的运算（比如银行系统），在大型机市场领域，IBM占据着很大的份额 迷你计算机（服务器） 特点：也称为小型机，普通服务器。去IOE行动，就是将大型机转换为服务器 制造商：联想、华为、浪潮 工作站 特点：高端的通用微型计算机，提供比个人计算机更强大的性能；类似于普通台式电脑，体积较大，但性能强劲 微型计算机 又称为个人计算机，笔记本电脑 从构成的本质上来讲，个人计算机与前面的分类无异 计算机的体系结构 冯诺依曼体系 概念：将程序指令和数据一起存储的计算机设计概念结构 为什么会诞生冯诺依曼体系？ 设计通用电路而非专用电路，然后将程序语言翻译成通用电路能够理解的语言，然后让通用电路去执行这个程序。 冯诺依曼结构的计算机组件 存储器：存储运行程序和运行所需要的数据 控制器：控制程序流转 运算器：完成运算操作 输入设备 输出设备 现代计算机都是属于冯诺依曼体系结构的计算机 冯诺依曼体系结构的计算机需要完成的功能 能够把需要的程序和数据送至计算机中（输入设备） 能够长期记忆程序、数据、中间结果及最终运算结果的能力（存储器） 能够具备算术、逻辑运算和数据传送等数据加工处理的能力（控制器、运算器） 能够按照要求将处理结果输出给用户（输出设备） 冯诺依曼体系结构图 将存储器和CPU分开存在的问题：CPU和存储器速率之间的问题无法调和 现代计算机的结构 出现的原因：为了解决冯诺依曼体系计算机的瓶颈问题，充分利用CPU 现代计算机的结构：以存储器为核心的结构 这里所指的存储器并不是广义的存储器（硬盘、磁带等等），而是指围绕CPU所产生的更高速的设备，比如内存，CPU寄存器 计算机的层次与编程语言 程序翻译和程序解释 为什么需要这两步？因为人类语言和计算机语言并不相通，这就需要进行语言之间的转换。 理解程序翻译和程序解释 程序翻译：将高级语言L1翻译成等价的计算机语言L0的过程 程序解释：在程序运行过程中，将高级语言L1一句一句解释成计算机语言L0，过程中并不生成目标程序文件 二者的区别：翻译过程生成新的L0程序，解释过程不生成新的L0程序 程序翻译型语言（一次性编译生成目标文件再执行）：C/C++、Object-C、Golang 程序解释型语言（边解释边执行）：Python、PHP、JavaScript 翻译+解释：Java、C# 计算机的层次和编程语言 计算机层次划分 硬件逻辑层：门、触发器等逻辑电路组成；属于电子工程的领域 微程序机器层：编程语言是微指令集； 微指令所组成的微程序直接交由硬件执行 传统机器层：编程语言是CPU指令集（机器指令）；编程语言和硬件是直接相关；不同架构的CPU使用不同的CPU指令集 微指令、微程序和机器指令之间的关系 操作系统层：向上提供了简易的操作界面；向下对接了指令系统，管理硬件资源（包括CPU，硬盘，输入输出设备等等）。操作系统层是软件和硬件之间的适配层。 汇编语言层：编程语言是汇编语言，可以翻译成直接执行的机器语言，由汇编器来完成翻译过程。 高级语言层：比如Java，C++ 应用层：应用软件，比如Word、Excel、PPT等等 计算机的计算单位 容量单位 为了存储更多的内容，需要更大的容量进行表示 生活中常见的问题 速度单位 网络速度 CPU速度 CPU速度一般体现在CPU的时钟频率，单位一般是Hz（秒分之一），每秒钟周期性变动重复次数的计量 用在CPU中就表示高低电平在每秒内变化的次数 计算机的字符和编码集 计算机字符编码集的历史 ASCII码：使用7bits就可以完全表示，包含95个可打印字符以及33个不可打印字符（包括控制字符） 可扩展的ASCII码：8bit共256种 字符编码集的国际化 中文编码集 GB2312：一共7445个字符 GBK：向下兼容GB2312，向上支持ISO标准，共21003个汉字，支持全部中日韩汉字 Unicode：Unicode定义了世界通用的符号集，UTF-*实现了编码，UTF-8以字节为单位对Unicode进行编码","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://www.chasingwind.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://www.chasingwind.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"author":"ChasingWind"},{"title":"Redis进阶","slug":"Redis进阶","date":"2021-03-15T11:57:44.000Z","updated":"2021-03-16T12:24:12.152Z","comments":true,"path":"2021/03/15/Redis进阶/","link":"","permalink":"https://www.chasingwind.top/2021/03/15/Redis%E8%BF%9B%E9%98%B6/","excerpt":"这里填写摘要信息","text":"这里填写摘要信息 走进Redis Redis系统架构 以下是Redis的特点 memcached也是一种内存数据库，但是数据类型是String，同时不支持持久化。 Redis主要数据结构 底层数据结构 String底层用的是Simple Dynamic String，同时存储长度 可以看到集合一般都有两套数据结构来支持，一种是为了性能，一种是为了节省内存。 Ziplist节省内存 数据大的时候用的树LinkedList ，其他三种也是同理 rehash操作，扩容的时候需要迁移数据，对性能产生影响 Redis高性能关键技术 高性能：基于内存操作 单线程：Redis6.0之前，操作如右图，单线程完成，后面新增了主线程之外的线程去进行其他操作 Redis高可用关键技术 一个实例挂了，其他实例顶上来 主从复制： 故障切换 主观下线：某一个哨兵认为主实例下线 客观下线：哨兵统一认为主实例下线 Redis高扩展性关键技术 数据量越来越多，进行扩展 MOVED重定向机制：当客户端发现实例中哈希槽对应不上，就会返回给客户端这个信息 Redis3.2版本 对比 单线程怎么高并发？epoll网络IO多路复用 Redis体验 开源Redis的使用 Redis.conf配置 bind：是否允许远程连接Redis appendonly：是否打开aof，通常设置为appendsec,表示每秒刷新 云Redis开通以及设置 春运迁徙页面","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.chasingwind.top/tags/Redis/"}],"author":"ChasingWind"},{"title":"JVM:类加载子系统","slug":"JVM-类加载子系统","date":"2021-03-08T14:15:33.000Z","updated":"2021-03-09T13:20:56.393Z","comments":true,"path":"2021/03/08/JVM-类加载子系统/","link":"","permalink":"https://www.chasingwind.top/2021/03/08/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"这里填写摘要信息","text":"这里填写摘要信息 内存结构概述 内存图 class字节码文件需要通过类加载子系统加载到内存中 详细内存图 类加载器子系统中包含3个环节： 加载（Loading）：将字节码文件通过类加载器加载到内存中 链接（Linking）：验证–&gt;准备–&gt;解析 初始化（Initialization）：静态变量的显示初始化 类加载器与类的加载过程类加载器分类ClassLoader的使用说明双亲委派机制其他","categories":[{"name":"JVM系列","slug":"JVM系列","permalink":"https://www.chasingwind.top/categories/JVM%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JVM内存与垃圾回收","slug":"JVM内存与垃圾回收","permalink":"https://www.chasingwind.top/tags/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}],"author":"ChasingWind"},{"title":"JVM:Java体系结构","slug":"JVM-Java体系结构","date":"2021-03-05T02:25:53.000Z","updated":"2021-03-09T05:54:04.708Z","comments":true,"path":"2021/03/05/JVM-Java体系结构/","link":"","permalink":"https://www.chasingwind.top/2021/03/05/JVM-Java%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"本节先介绍了Java的历史以及JVM的历史，以便我们对JVM整个发展有更好的了解，方便在以后的学习中更加快速掌握细节知识。","text":"本节先介绍了Java的历史以及JVM的历史，以便我们对JVM整个发展有更好的了解，方便在以后的学习中更加快速掌握细节知识。 JVM与Java体系结构Java以及JVM简介 Java程序运行在JVM之上 Java是跨平台的语言 JVM是跨语言的平台：面向字节码文件，只要其他语言编译后能转成字节码文件，都可以在JVM上运行，所以具有语言无关性。 JVM与C++的垃圾回收机制 为什么需要垃圾回收机制？ 如果内存中垃圾一直不进行回收的话，到最后程序可能会出现OOM异常（Out Of Memory） 垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。 C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。 虚拟机与Java虚拟机 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。 大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 JVM虚拟机 Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成（语言无关性）。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。 Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里 特点：一次编译，到处运行；自动内存管理；自动垃圾回收 JVM在系统中所处的位置 JVM运行在操作系统之上 在Java中的体系结构 .java—javac编译—&gt;.class——&gt;JVM运行字节码文件 JVM整体结构 结构图 此图主要针对HotSpotVM，目前市面上高性能虚拟机代表作之一 上图中间部分，橙色的方法区和堆表示的是多个线程共享；而Java栈和本地方法栈以及程序计数器是每个线程独有的。 执行引擎包括解释器，JIT即时编译器和垃圾回收器。执行引擎的作用：将字节码文件翻译成机器语言 Java代码执行流程 在编译过程中，任何一步出现错误都不能正常生成字节码文件 执行引擎可以将我们写的高级语言翻译成机器语言 JVM的架构模型 Java编译器输入的指令流基本上可以分为2种：基于栈的指令集架构以及基于寄存器的指令集架构。HotSpot是基于栈的指令集架构，HotSpot中除了PC寄存器之外，再也没有与寄存器相关的部分 两种架构之间的区别 基于栈式架构特点 设计和实现更简单，适用于资源受限的系统 避开了寄存器的分配难题：使用零地址指令方式分配 指令流中的指令大部分是零地址指令，执行过程依赖于操作栈。指令集更小（字节码文件中每8位进行对齐），编译器容易实现 不需要硬件支持，只需要操作栈，不与硬件打交道，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机 指令集架构则完全依赖硬件，可移植性差 性能优秀，执行更加高效 完成一项操作使用的指令更少（指令集采用16位进行对齐） 在大部分情况下，基于寄存器的指令集往往都以一地址指令、二地址指令、三地址指令为主。 基于栈和基于寄存机完成同一个操作使用的指令集 计算2+3 基于栈的计算流程： iconst_2 //常量2入栈 istore_1 iconst_3 // 常量3入栈 istore_2 iload_1 iload_2 iadd //常量2/3出栈，执行相加 istore_0 // 结果5入栈 基于指令集的计算流程： mov eax,2 //将eax寄存器的值设为1 add eax,3 //使eax寄存器的值加3 同样的操作，虽然基于栈实现操作需要的指令集小（指令是8位），但是基于栈需要的指令比基于寄存器需要的指令多 查看字节码中的指令 编译之后 生成的字节码在target目录下 反编译javap -v xxxx 代码对应的指令如下 基于栈的架构总结 跨平台性、指令集小但是指令多、执行性能比基于寄存器的架构差 JVM的生命周期 启动 Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个初始类是由虚拟机的具体实现指定的。 运行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时他才运行，程序结束时他就停止。 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程 退出 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止（没有处理这些异常或者错误） 由于操作系统出现错误而导致Java虚拟机进程终止 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。 JVM的发展历程 Sun Classic VM Java1.0，Sun公司发布，世界上第一款商用虚拟机 内部只提供解释器，没有JIT即时编译器 Exact VM HotSpot VM JDK1.3开始成为默认虚拟机 服务器、客户端以及嵌入式都有应用 HotSpot就是体现热点代码探测技术 通过计数器找到最具编译价值代码，触发即时编译或栈上替换 通过编译器和解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡 JRockit VM BEA公司，后被Oracle收购 专注于服务器端应用，不太关注启动速度，因此不包含解释器，全部代码都靠即时编译器编译后执行 JRockit JVM是目前世界上最快的JVM，面向延迟敏感型应用 J9 JVM，IBM公司 KVM和CDC/CLDC HotSpot Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。 KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场 智能控制器、传感器 老人手机、经济欠发达地区的功能手机 所有的虚拟机的原则：一次编译，到处运行。 Azul VM 性能更高，但是与特定硬件平台绑定、软硬件配合的专用虚拟机 Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。 每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。 2010年，AzulSystems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性 Liquid VM Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。 Apache Harmony Micorsoft JVM 当年微软为了在IE3浏览器中支持Java Applets开发的 TaoBao VM 基于OpenJDK HotSpot VM深度定制的、开源的高性能服务器版JVM 创新的GCIH（GC invisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap(堆)中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 GCIH中的对象还能够在多个Java虚拟机进程中实现共享 使用crc32指令实现JVM intrinsic降低JNI的调用开销 PMU hardware的Java profiling tool和诊断协助功能 针对大数据场景的ZenGc taobao JVM应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。 Dalvik VM Android5.0之前使用的虚拟机，Dalvik 只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范，不能直接执行Java的Class文件 基于寄存器架构，不是jvm的栈架构。 执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。 它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。 Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。 GRaal VM 2018年4月，Oracle Labs公开了Graal VM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。 Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。 如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。","categories":[{"name":"JVM系列","slug":"JVM系列","permalink":"https://www.chasingwind.top/categories/JVM%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JVM内存与垃圾回收","slug":"JVM内存与垃圾回收","permalink":"https://www.chasingwind.top/tags/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}],"author":"ChasingWind"},{"title":"MySQL锁机制以及主从复制","slug":"MySQL锁机制以及主从复制","date":"2021-02-24T12:27:00.000Z","updated":"2021-03-04T00:53:51.890Z","comments":true,"path":"2021/02/24/MySQL锁机制以及主从复制/","link":"","permalink":"https://www.chasingwind.top/2021/02/24/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"MySQL中锁的重要性是不言而喻的，在面试中以及平时工作中都会经常使用。理解锁机制，掌握锁的分类以及每一种锁可能会带来的问题将会有很大的帮助。另外，主从复制这一部分的内容需要单独–&gt;TODOList","text":"MySQL中锁的重要性是不言而喻的，在面试中以及平时工作中都会经常使用。理解锁机制，掌握锁的分类以及每一种锁可能会带来的问题将会有很大的帮助。另外，主从复制这一部分的内容需要单独–&gt;TODOList MySQL锁机制 锁是计算机协调多个进程或线程并发访问某一资源的机制 在数据库中，除传统的计算资源（如CPU、RAM、IO等）的争用以外，数据（表）也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 锁的分类 根据数据操作类型分类：读锁、写锁 读锁（共享锁）： 针对同一份数据，多个读操作可以同时进行而不会相互影响。 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。 对数据操作粒度分类：表锁（偏读）、行锁（偏写）、页锁 表锁 特点： 偏向MyISAM存储引擎，开销小，加锁快无死锁，因为锁的是整个表锁粒度大，发生锁冲突概率高并发度最低 表锁案例演示（偏读，偏向MyISAM存储引擎）# 查看表是否有锁 show open tables ; In_use = 0表示当前表未加锁 # 手动为account表上读锁,article表上写锁 lock tables account read, SqlPro.article write ; 为account表上读锁之后进行查询 解锁 ## 解锁 unlock tables ; 解锁之后再次进行查询 读锁和写锁究竟会如何影响我们的操作呢？ 以下案例均在两个Session中实现 加读锁（共享锁） 在Session1中为account加读锁，在Session2中读取account Session1和Session2均可以读取，这就说明了读锁是共享锁 Session1写（insert或者update）加读锁的表 结果是不允许修改 Session1读别的表 不允许。因为目前Session1已经有了一把表锁在手上，而且还未释放锁。 由于MySQL出于自我保护的机制，需要当前表解锁之后才能读其他的表，否则这个表可能会一直被锁而没有后续操作。 Session2写Session1中加了读锁的表 发现Session2一直处于阻塞状态。 当在系统中如果有多个操作都需要写加读锁的表，那么都会处于阻塞状态，这就会大大影响系统的性能了。 在Session1解锁之后 Session2的写操作立即执行了 总结 Session1中某张表加读锁 Session1 Session2 当前Session可以查询加读锁的表 当前Session可以查询Session1中加读锁的表 当前Session不能查询其他没有锁定的表（因为占据着一个锁，未释放锁就不能操作其他的表） 当前Session可以查询或者更新其他未锁定的表 当前Session写加读锁的表报错（读锁不允许进行写操作） 当前Session写Session1中加读锁的表会一直等待（阻塞） 释放锁 在Session1释放锁之后，执行阻塞的对之前加锁的表的写操作 加写锁（排它锁） Session1读、写加写锁的表 都可以执行 Session1读、写其他表 均报错 Session2读取加写锁的表 一直处于阻塞状态 Session1释放写锁之后 Session2读取命令执行 同样 Session2写加写锁的表 同样处于阻塞状态，等待Session1写锁释放之后就会执行 Session1中某张表加写锁 Session1 Session2 可以读写加写锁的表 读取和写加写锁的表会阻塞 不可以读写其他表（因为占据着一个锁，未释放锁就不能操作其他的表） 读写其他的表都可以正常进行 表锁分析 查看当前表的锁的情况 # 查看数据库中表的加锁情况 show open tables; # 查看MySQL表的锁定情况 show status like &#39;table_locks%&#39;; Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加一 Table_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值就加一），此值高说明当前系统存在较严重的表级锁争用情况 总结 MyISAM存储引擎在执行查询（SELECT语句）之前，会自动给涉及的所有表加读锁 MyISAM存储引擎在执行增删改之前，会自动给涉及的所有表加写锁 因此，MyISAM存储引擎的读写调度是写优先，所以不适合作为写为主表的引擎。因为执行写操作，会加写锁，其他线程不能做任何操作（包括读写），大量的写操作会使读很难获取到锁，从而造成永远堵塞。 MySQL的表级锁有两种模式：表共享读锁、表独占写锁 读锁会阻塞写，但不会阻塞读。而写锁会阻塞读和写。 行锁案例演示（偏写，偏向InnoDB存储引擎） 特点 偏向InnoDB存储引擎 开销大，加锁慢，会出现死锁 锁的粒度最小，发生锁冲突的概率最低，并发度也最高 InnoDB和MyISAM最大的不同点：InnoDB支持事务，InnoDB采用行级别的锁 事务（Transaction）：事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常称为ACID属性。 原子性（Atomicity）：事务是一个原子操作。里面的SQL语句要么同时执行，要么都不执行 一致性（Consistent）：ACID里的AID都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个C,实际上它依赖于应用层,也就是依赖于开发者。这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态，什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性.参考文章 隔离性（Isolation）：数据库提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”的环境执行。这也同时意味着事务处理过程中的中间状态对外部是不可见的。 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使系统出现故障也能够保持。 并发事务处理带来的问题 更新丢失：当多个事务更新同一行数据的时候，由于事务之间是隔离的，就会可能出现A事务和B事务在时间上有一定的执行顺序，比如事务A和事务B，修改同一个数据，事务开始的时候，查询的这一行数据是相同的，A事务执行完之后提交，此时数据已经被修改了，但是B事务还是以为数据还是刚开始的时候的。那么A事务执行的更新就丢失了，被B事务修改的内容覆盖了。解决方法：在A事务提交之前，B事务不可访问同一行数据。参考文章 脏读：一个事务正在对一条记录修改，在这个事务未提交之前，这条数据就处于不一致的状态，此时另一个事务也来读取这个数据，如果不加控制，第二个事务就读到了脏数据并在此基础之上做进一步的处理了，就会产生未提交的数据依赖关系。总结：事务A读取了事务B已修改但尚未提交的数据，并在此基础之上进行操作。此时，如果A事务回滚，那么数据就不符合一致性原则。 不可重复读：事务A在读取某些数据之后，过段时间（还在事务中）再次读取以前读过的数据，发现数据已经被事务B被改变并提交，那么事务A再次读取的时候，就会发现数据已经不匹配了。总结：事务A读取到了事务B已经提交的修改数据，不符合隔离性 幻读：一个事务按照相同的查询条件进行查询，过段时间后，重新按照相同条件查询（还在同一个事务中），却发现了其他事务insert了新的记录。总结：事务A读取到了事务B新增的数据，不符合隔离性。 事务的隔离级别 MySQL默认隔离级别：可重复读 案例演示 InnoDB引擎 事务隔离级别是可重复度 并关闭自动提交 分别为a、b创建单值索引，因为如果where条件没有索引的话，行锁会变成表锁 A 修改之后未手动提交，然后查询，发现可以读取到已经修改未提交的数据 此时A还是未提交 B去查询，发现是修改之前的数据 A手动提交事务之后 B手动提交事务之后 二者再次查询 发现都能读取到A修改后的数据 修改同一行数据 A修改之后还未提交 B修改同一行数据 B会处于阻塞状态 A commit之后 B处于阻塞的更新语句也执行了 B commit A修改一行不提交 B修改另一行不提交 两者都不会冲突 二者都commit之后 更新都提交了 索引失效导致行锁变表锁 这个问题很隐蔽，需要多加注意 首先建立一个新表 a是int型 b是varchar型，并为a、b创建索引 正常情况下 A修改第1行数据，B修改第6行数据。二者互不影响，如下图 A修改未提，B修改也未提交。这种情况下B并未阻塞，因为修改的不是同一行数据。 二者都commit之后 数据都修改了 我们知道 如果MySQL数据进行了数据类型转换，会使得索引失效。在行锁的情况下，索引失效会导致行锁变为表锁。 这里varchar类型必须使用&#39;&#39;，否则会发生类型转换导致索引失效 左边where条件b列索引使用的是number类型，原本是varchar类型，导致索引失效 左边update执行完之后 再去执行右边的update ，右边的update被阻塞了！！ 左侧commit之后，右边立即执行了 两个都commit之后 修改成功 总结：如果索引失效，InnoDB默认会将行锁变为表锁！ 间隙锁 什么是间隙锁 当我们的查询条件是范围条件而不是相等条件的时候，InnoDB会给符合条件的已有数据记录的索引项进行加锁；对于键值条件在范围内但并不存在的记录，就叫做“间隙”。 InnoDB也同时会对间隙进行加锁，也就是所谓的间隙锁（Next-Key锁） 危害 间隙锁锁定某个范围的索引值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定期间，无法插入锁定键值范围内的数任何据。 演示 首先设置数据库隔离级别：可重复读 set GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; 初始数据 a字段设置有单值索引 左侧更新（where条件使用索引范围），不提交 右侧insert 右侧会阻塞，即使右侧insert的键是3，在表中并不存在 左侧commit之后 右侧的update也立即执行了 间隙锁解决的问题：幻读（隔离级别：可重复读下） 参考文章 手动锁定某一行 当我们需要确定修改某一条数据时，不希望其他人这条具体数据进行操作 左边两条语句就是指定锁住某一行 并且未提交 右边去更新锁定的行的时候 会被阻塞 左边commit ，右边也被执行了 关于for update和for share 以及lock in share mode for update：排它锁 for share 以及lock in share mode：均为共享锁 行锁总结 查看行锁状况 # 查看当前系统行锁的状况 show status like &#39;innodb_row_lock%&#39; 参数意义 优化建议 尽可能让所有数据检索都通过索引来完成，避免无索引或者索引失效导致行锁升级为表锁 合理设计索引，尽量缩小锁的范围 尽可能减少检索条件，避免间隙锁的出现 尽量控制事务大小，减少锁定资源量和时间长度 MySQL主从复制TODO","categories":[{"name":"MySQL高级","slug":"MySQL高级","permalink":"https://www.chasingwind.top/categories/MySQL%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"MYSQL锁机制","slug":"MYSQL锁机制","permalink":"https://www.chasingwind.top/tags/MYSQL%E9%94%81%E6%9C%BA%E5%88%B6/"}],"author":"ChasingWind"},{"title":"Java IO","slug":"Java-IO","date":"2021-01-02T06:42:25.000Z","updated":"2021-03-04T07:34:01.208Z","comments":true,"path":"2021/01/02/Java-IO/","link":"","permalink":"https://www.chasingwind.top/2021/01/02/Java-IO/","excerpt":"","text":"Java IO的演进IO模型基本说明 IO模型：就是用什么样的通道或者说通信模式和架构进行数据的传递与接收，这在很大程度上决定了程序通信的性能。Java共支持3种网络编程的IO模型：BIO、NIO、AIO IO模型 BIO（Blocking IO，同步阻塞）：每个客户端与服务器之间的通信都需要创建一个单独的连接，也就是一个线程。如果客户端越来越多，则需要更多的线程，那么线程之间的切换也会消耗大量的系统开销。何为同步？如果当前线程在等待客户端的数据，客户端没有发送数据，那么此线程也会一直处于等待，不能做其他的事情。 NIO（Non-Blocking IO，同步非阻塞）：服务器实现模式为一个线程来管理一个多路复用器，客户端所有的请求都会注册到多路复用器上，之后多路复用器就会轮询各个通道，通道中有数据的话，才会创建线程处理请求。否则，就不必分配线程去等待通道中传来数据，这就实现了非阻塞。 AIO（Asynchronous IO，异步非阻塞）：AIO也称为NIO.2，NIO的2.0版本。服务器的实现模式是一个有效请求对应一个线程，客户端的IO请求都是先由操作系统先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间长的应用 BIO、NIO、AIO适用场景分析 BIO适用于连接数目比较小并且架构固定。这种方式对服务器资源要求比较高（一个客户端就需要一个线程），并发局限于应用中 NIO适用于连接数目多并且连接时间比较短（轻操作）的架构。比如聊天服务器，弹幕系统，服务器间通讯等等 AIO方式适用于连接数目多并且连接比较长（重操作）的架构。比如相册服务器，充分调用OS参与并发操作。 Java BIOBIO工作机制 Java BIO就是传统的Java IO编程，相关的类和接口都在java.io包下 BIO（Blocking IO）：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。 传统BIO编程实例 基础BIO模式下，基于IO流通信模式 编程实现 传统的网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定IP地址和端口号），客户端通过连接操作向服务端监听的端口地址发起请求操作，基于TCP协议下进行三次握手连接，连接成功过后，双方通过Socket进行通信 传统的同步阻塞开发模型中，服务端ServerSocket负责IP地址的绑定，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入输出流进行同步阻塞通信。 实现目标：客户端发送消息，服务端接收消息 服务端 客户端 先启动服务端 可以看到右上角服务端一直在运行中 其实是服务端的线程一直在监听客户端的Socket请求 再启动客户端 这个时候服务端进入了等待客户端的数据的状态 客户端发完消息之后 就会断开连接 服务端等到了客户端的消息 由于客户端完成之后连接就断开了 所以服务端完成消息的接受之后，客户端断开，服务端也就断开了 在上面的案例中，服务端会一直等待客户端的数据，如果客户端没有发送数据，服务端就会一直等待，也就是一直处于阻塞状态 多发和多收 服务端 与客户端建立连接之后 while循环一直监听客户端的数据 客户端 输入消息 由于客户端并没有断开连接 服务端接收到消息之后 也并没有暂停 而是再次等待客户端的消息 服务端接收消息之后 还是处于等待客户端消息的状态 上面的案例只是一个服务端对应一个接客户端，那么如何接收多个客户端的消息通信请求呢？ 这个时候我们就需要在服务端引入多线程了，也就是说客户端发起一个请求，服务端就创建一个新的线程来处理这个客户端的请求，这就实现了一个客户端一个线程的模型 分析之前的代码 为何服务端只能接受一个客户端发来的请求？ 所以服务端就需要对每个客户端都创建一个线程单独处理每个客户端的通信需求 启动多个客户端 首先需要配置允许并发运行 启动两个客户端 可以发现服务端都可以接受到 查看线程 每个客户端请求都单独创建了一个线程进行处理 总结 每个Socket被服务端接收，都会创建一个线程，那么线程之间的竞争、切换都会影响性能 每个线程都会占用栈空间以及CPU资源 并不是每个Socket都进行IO操作，但是线程还是需要进行等待 客户端和服务器之间是一对一的线程开销，客户端访问量越大，服务器端将有可能发生线程栈溢出，线程创建失败。最终导致进程宕机或者僵死，无法对外提供服务 伪异步IO编程 在上述传统的BIO中，客户端和服务器之间的线程是一对一的，随着客户端的增多，服务端线程也需要相应的增加，就有可能导致栈溢出的情况 伪异步IO通信可以解决这个问题，在服务端维护一个线程池，固定服务端线程的数量； 伪异步IO通信框架，使用线程池和任务队列来实现，当客户端接入时，将客户端的Socket封装成一个Task（实现Runnable接口）交给后端的线程池中进行处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中的Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机 但是有一个问题就是这种情况支持的客户端的数量是有限的，除非客户端完成任务之后释放连接对应的线程，可以让线程执行其他的任务 服务端代码 创建线程池 存放消息队列 测试 当我们开3个客户端的时候都是可以的 开第四个的时候是无法执行的 因为我们在创建线程池的时候 规定了核心线程数是3，只能处理3个任务，第4个进入到任务队列中进行等待 当关闭其中一个客户端之后 线程就被释放了 接着处理消息队列中的任务 伪异步IO使用线程池实现，虽然避免了为每一个请求创建一个独立线程造成线程资源耗尽的问题，但是底层依然采用的是同步阻塞模型，因此无法从根本上解决问题 如果单个消息处理的缓慢，或者线程池中的全部线程都被阻塞，那么后续Socket中的IO消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。 基于BIO形式下的文件上传 客户端 上传任意文件类型给服务器端进行保存，由于支持上传各种类型的文件，就需要服务器端知道上传的是什么类型的文件，所以客户端既需要告诉服务端文件类型，还需要传输文件本身 服务端 需要根据客户端的上传类型来接收 接收完成之后，其实服务端还在一直等待客户端的数据 我们可以在客户端告诉服务端当前数据已经发送完成 返回-1给服务端，服务端就不需要一直循环等待了 而是结束文件的接收 BIO模式下的端口转发思想 什么是端口转发 之前的BIO案例都是客户端发送消息给服务端，服务端接收消息并进行处理。但是像QQ这种，并不是将消息发送给服务端就完事了，这种其实是客户端与客户端之间的通信，当然中间需要经过服务器转发消息，这就是端口转发 将一个客户端的消息发送给所有的客户端（类比群聊功能） 客户端需要实现发送消息的功能以及接收消息的功能 服务端需要建立与客户端的连接，并且存储在线的Socket集合以便知道转发给哪些客户端 服务端实现 Java NIONIO基本介绍 Java NIO与之前的IO有同样的作用，用于数据传输或者通信。 NIO是非阻塞IO，线程在IO期间可以做其他的事情，比如调用socket.read()时，如果服务器一直没有传输数据，NIO可以让线程处理其他的事情，从而是非阻塞的。 NIO相关的类都在java.nio包下，并对原有的java.io包下的很多类进行了改写 NIO三大核心部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器） Java NIO的非阻塞模式，使一个线程从某通道发出请求或读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时 ，就什么都不会获取，而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待他完全写入，这个线程同时可以去处理别的事情。 通俗来说：NIO是可以做到用一个线程来处理多个操作的。比如有1000个请求过来，NIO可以分配10或者80个线程来处理。不像之前的阻塞IO那样，需要一个线程对应一个请求。 NIO和BIO的比较 BIO底层是以流的方式来处理数据的，比如字节或者字符输入输出流，而NIO是以块的方式来处理数据的，块IO效率比流IO高得多 BIO是阻塞式IO，而NIO是非阻塞式IO BIO基于字节或者字符流进行操作，而NIO是基于Channel（通道）和Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入到通道。Selector（选择器）用于监听多个通道的事件（比如：连接请求、数据到达等等），因此就可以做到一个线程处理多个客户端的请求（通过监听通道中是否有客户端的请求） NIO三大核心 Buffer 缓冲区 缓冲区本质上是一块可以写入数据，可以从中读取数据的内存。这块内存被包装成了NIO Buffer对象，并提供了一组方法，用来方便的访问该内存块。 Channel 通道 通道既支持从中读取数据，同时也支持将数据写入到其中（区别于流，是单向的，比如输入流，输出流）。通道可以非阻塞读取和写入通道，也支持读取和写入缓冲区，也支持异步地读写 Selector选择器 Selector是一个Java NIO组件，可以检查一个或者多个通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率。 每个Channel都会对应一个Buffer 一个线程对应一个Selector，一个Selector对应多个Channel 程序切换到哪个Channel是由事件决定的 Selector会根据不同的事件，在各个通道上切换 Channel负责传输数据，Buffer负责存取数据。 NIO缓冲区 NIO中的Buffer是一个用于特定基本数据类型的容器，由java.nio包定义的，所有缓冲区都是Buffer抽象类的子类。Java NIO中的Buffer主要用于与NIO通道进行交互，数据是从通道读入缓冲区，从缓冲区写入到通道中 Buffer类及其子类：Buffer就像一个数组，可以保存多个相同类型的数据。根据数据类型的不同，有以下Buffer常用子类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer，这些Buffer类及其子类都有相似的方法进行数据的操作，比如都使用如下静态方法来获取一个缓冲区 //创建一个容量为10的存储Byte类型的缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(10); //创建一个容量为10的存储Char类型的缓冲区 CharBuffer charBuffer = CharBuffer.allocate(10); //....... 缓冲区的属性 容量（capacity）：作为一个内存块，Buffer具有一定的大小，也称为容量，缓冲区容量不能为负，并且创建之后不能进行修改 限制（limit）：表示缓冲区中可以操作的数据的大小（limit后的数据不能进行读写操作）。缓冲区的限制不能为负，并且不能大于容量。写入模式，limit设置为容量；读取模式，limit设置为写入的数据量。 位置（position）：下一个要读取或写入数据的索引，不能为负，并且不能大于limit 标记（remark）和重置（reset）：标记是一个索引，通过Buffer中的mark()方法指定Buffer中的一个特定的position，之后可以通过调用reset()方法恢复到这个position Buffer中常用API ​ clear：清空缓冲区并返回缓冲区的引用，可以准备写入，但是使用get读取数据还是可以读取到的，一般我们使用clear之后，需要写入数据对原数据进行覆盖。 flip：position置为0，并且limit设置为当前缓冲区中最后一个数据的position，我的理解是切换为读取数据模式 capacity：获取缓冲区的容量大小 hasRemaining：缓冲区中是否还有元素 limit：返回Buffer中的limit位置 limit(int n)：设置缓冲区界限为n，并且新的limit不能大于容量，不能为负，同时注意mark以及position mark()：对缓冲区设置标记，标记位置就是当前缓冲区的position position()：返回缓冲区中当前的position position()：设置当前缓冲区的position，不能大于limit，并且不能为负数，同时如果新的position大于mark，mark置为-1 remaining()：表示缓冲区中还有多少位置可以进行读写 reset()：将position设置到标记mark rewind()：重置mark并且position置为0 get()：读取数据，除了根据索引读取数据，其他读取数据的时候，position会改变为已读取数据的下一个位置 //读取单个字节 byte b = byteBuffer.get(); //批量读取字节到byte数组中 ByteBuffer byteBuffer1 = byteBuffer.get(new byte[10]); //读取指定索引位置的字节 byte b1 = byteBuffer.get(5); //从索引位置5开始读取5字节数据到byte数组中 byteBuffer.get(new byte[10], 5, 5); put()：写入数据 与get读取类似 使用Buffer读写数据步骤 写入数据到Buffer 调用flip方法，转换为读取模式 从Buffer中读取数据 调用clear方法或者compact方法清除缓冲区 直接缓冲区和非直接缓冲区 ByteBuffer可以有两种方式创建，一种是基于直接内存（操作系统的内存），一种是基于非直接内存（JVM中的堆内存），对于直接内存来说，性能更高，因为比非直接内存少了从本进程内存到直接内存的步骤 //适用直接内存创建缓冲区 ByteBuffer byteBuffer2 = ByteBuffer.allocateDirect(1024); //查看当前缓冲区是否使用的是直接内存 System.out.println(byteBuffer2.isDirect()); 使用直接内存的话，创建的时候比较耗时 一般来说，如果不是能带来明显的性能提升，推荐使用非直接内存 从数据流的角度来看 直接内存：本地IO–&gt;直接内存–&gt;本地IO 非直接内存：本地IO–&gt;直接内存–&gt;非直接内存–&gt;直接内存–&gt;本地IO 适用场景 直接内存适用于：有很大的数据需要存储，并且生命周期很长 频繁IO操作，比如网络并发场景 NIO通道 通道（Channel）：定义在java.nio.channels包下，Channel表示IO源与目标打开的连接。Channel类似于传统的“流”。只不过Channel本身不直接访问数据，需要通过Buffer与数据进行交互 NIO中的Channel与BIO中流的区别 通道可以同时进行读写，是双向的。流只能读或者只能写，是单向的 通道可以实现异步读写数据 通道可以从缓冲区读数据，也可以向缓冲区中写入数据 Channel在NIO中是一个接口，以下是常见的实现类 FileChannel：用于读取、写入、映射和操作文件的通道 DataGramChannel：通过UDP读写网络中的数据通道 SocketChannel：通过TCP读写网络中的数据 ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个新的ServerChannel FileChannel的用法 将数据写入到文件中 获取通道的方式：可以通过使用支持通道的对象调用getChannel方法，支持通道的类如下： FileInPutStream，FileOutPutStream，RandomAccessFile，DatagramSocket，Socket，ServerSocket；还可以通过Files类的静态方法newByteChannel()获取字节通道；还可以通过通道的静态方法open()打开并返回指定通道。 读取本地文件中的内容 完成文件的复制 分散和聚集 分散读取（Scatter）：是指把Channel通道的数据读入到多个缓冲区中去 聚集写入（Gathering）：是指把多个Buffer中的数据聚集到Channel中 transferForm和transferTo方法 在通道之间复制数据 最终生成data01.txt NIO选择器Java AIO总结","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://www.chasingwind.top/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://www.chasingwind.top/tags/IO/"}],"author":"ChasingWind"},{"title":"Docker基础","slug":"Docker基础","date":"2020-11-02T03:19:08.000Z","updated":"2021-03-04T00:45:11.062Z","comments":true,"path":"2020/11/02/Docker基础/","link":"","permalink":"https://www.chasingwind.top/2020/11/02/Docker%E5%9F%BA%E7%A1%80/","excerpt":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。","text":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker概述 为什么会出现Docker 在我们日常开发中，可能会出现这样的问题。在我们本机跑是可以正常执行的，但是发布到测试环境的时候，同一份代码就会出现错误。这就是运行的环境的不同导致的。 一款产品从开发到上线，从操作系统、到运行环境、再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，在多个版本迭代之后，不同版本对环境的兼容性，都是需要考虑的问题 Docker的出现就是为了解决上述类似的问题。开发人员给运维人员的不再是单独的jar包，而是包含代码、配置、系统以及数据的整体可运行的软件，也就是带运行环境的软件（Docker镜像）。 Docker理念 Docker是基于Go语言实现的云开源项目 Docker的主要目标是“Build,Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以说是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行” Docker是在Linux容器的基础上实现的，将应用运行在Docker容器上面，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到其他的机器上面一键部署，简化操作 Docker是解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。 Docker能做什么 虚拟机技术 虚拟机技术就是一种带环境安装的一种解决方案，比如在本机上通过虚拟机安装Linux来充当服务器，运行之后就跟真正的服务器没有区别。 虚拟机的缺点：资源占用多、启动慢、需要模拟硬件来创建“真正可用”的系统 容器虚拟化技术 在介绍容器虚拟化技术之前，需要了解另一种虚拟化技术：Linux容器（Linux Containers，缩写LXC） Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需要的库资源和设置。系统因此变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 Docker和传统虚拟化的不同 传统虚拟技术是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上再运行需要的应用进程 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核（如上图中的Kernel），而且也没有进行硬件模拟。因此更加轻便 虚拟化技术的每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。 hypervisor: 虚拟机监控程序 开发/运维（DevOps） 更快速的应用交付和部署 更便捷的升级和扩缩容 更简单的系统运维 更高效的计算资源利用 企业级使用针对短时高峰访问进行动态扩缩容等等 Docker安装 Docker安装 Docker架构图 Docker的基本组成 镜像（image） Docker镜像就是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建多个容器。 容器（container） Docker利用容器独立运行一个或一组应用。容器是用镜像创建的运行实例。 容器可以被启动、开始、停止、删除。每个容器之间都是相互隔离的、保证安全的平台。 可以将容器看作是一个简易的Linux环境（包含root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 类比 仓库（repository） 仓库是集中存放镜像文件的场所。 仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的仓库是Docker Hub，存放了数量庞大的镜像供用户下载。国内公开的仓库包括阿里云、网易云等等。 小总结 Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看做是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。 image文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器。 至于仓储，就是一个放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中下载就可以了。 安装步骤（CentOS）：链接 HelloWorld 启动Docker命令：systemctl start docker 运行Hello World：docker run hello-world 运行过程分析 Docker run 底层原理 Docker是怎么工作的 Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机的容器上。容器，是一个运行环境，也就是Docker图标中的集装箱。 为什么Docker比VM快 Docker比虚拟机有更少的抽象层。Docker不需要像虚拟机一样虚拟化硬件资源，运行在Docker容器上的程序都是直接使用的实际物理机的硬件资源。因此在CPU、内存利用率上Docker将会有更加明显的优势。 Docker利用的是宿主机的内核。因此，当新建一个容器时，不需要像虚拟机一样重新加载一个操作系统内核。因此减少了加载内核系统这一浪费时间的过程，Docker省略了这个过程，所以创建Docker容器时秒级的。 Docker Engine直接代替了虚拟机监控进程（Hypervisor）以及Guest OS，直接使用宿主机的内核。 Docker命令 帮助命令 docker version docker info docker --help 镜像命令 docker images：列出本地主机上的镜像信息 REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 VIRTUAL SIZE：镜像大小 同一个仓库源中可以有多个TAG，用来区分仓库源中的不同版本，可以使用REPOSITORY:TAG来区分不同版本的镜像 如果不指定镜像的版本标签，Docker默认使用的是latest版本 docker images -a：列出本地所有的镜像（含中间映像层） docker images -qa：显示所有的镜像ID docker images --digests：显示镜像的摘要信息 docker images --no-trunc：显示镜像的完整信息 docker search xxx：从Docker Hub查找镜像 docker search -s 30 tomcat：查找STARS在30以上的tomcat镜像 docker pull xxx：下载镜像 docker pull xxx:TAG：下载指定版本的镜像 不写TAG的话 默认使用的是latest docker rmi xxx：删除某个镜像 无法删除正在运行中的镜像文件 docker rmi -f hello-world：强制删除 图中显示 不带TAG删除的话 默认是latest docker rmi -f 镜像1 镜像2：删除多个镜像 docker rmi -f $(docker images -qa)：删除全部镜像 容器命令 有镜像才能创建容器，以下都是运行在Docker上的CentOS为例进行的（docker pull centos） docker run：新建并启动容器 运行Docker上的CentOS -i，-t可以写成-it，表示以交互模式运行 下图中命令行的用户已经不是阿里云的CentOS了，已经是Docker中的CentOS了 OPTIONS说明 – name=”容器名”，为容器指定一个名字 -d：后台运行容器，并返回容器ID，也即启动守护式容器 -i：以交互模式运行容器 -t：为容器重新分配一个伪输入终端 -P：随机端口映射 -p：指定端口映射，有以下4中格式 ​ ip:hostPort:containerPort ​ ip::containerPort ​ hostPort:containerPort ​ containerPort docker ps列出当前所有正在运行的容器 -a：列出当前所有正在运行的容器+历史上运行过的容器 -l：显示最近创建的容器 -n：显示最近n个创建的容器 -q：静默模式，只显示容器编号 –np-trunc：不截断输出（就是显示完整的容器信息） 退出容器 exit：容器退出且停止 Ctrl+P+Q：容器退出不停止 docker start：启动容器 docker restart：重启容器 docker stop：停止容器 docker kill：强制停止容器 docker rm：删除已经停止的容器 容器命令（重要） 启动守护式容器 docker run -d xxx 后台启动的容器却没有在运行？ 因为：Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是一直挂起的命令（比如运行top，tail），就是会自动退出的 这是Docker的机制问题造成的，后台运行的容器启动后，会立即kill掉，因为Docker觉得后台运行的程序无事可做。 所以，最佳的解决方案是将运行的程序以前台进程的形式运行 查看容器日志 docker logs -f -t --tail 容器id -t：加入时间戳 -f：跟随最新的日志打印 –tail 数字：显示最后多少条 查看容器内运行的进程 docker top 容器id 查看容器内部细节（详细信息） docker inspect 容器ID 进入正在运行的容器并以命令行交互 docker attach 容器ID docker exec -it 容器ID 命令操作 两个命令的区别 attach：进入到Docker，之后再在Docker里面进行操作 exec：在宿主机对Docker进行操作 从容器内拷贝文件到主机上 docker cp 容器ID：容器内路径 目的主机路径 Docker镜像是什么 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包含代码以及运行环境。 UnionFS（Union File System）：联合文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。UnionFS是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。特性就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统包含所有的文件和目录。 Docker镜像加载原理 bootfs（boot filesystem）：主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就存在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统会卸载bootfs。 rootfs（root filesystem）：在bootfs之上。包含典型的Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同操作系统发行版，比如Ubuntu，CentOS等 解释为什么Docker中的CentOS那么小（200M左右） 由于Docker中的CentOS运行在Docker之上，Docker是一个精简的Linux系统，rootfs可以很小，只需要包含最基本的命令、工具和程序库就可以，因为底层直接使用的是宿主机的Kernel，自己只需要提供rootfs就可以了。由此可见对于不同发行版的系统，bootfs基本是一致的，只需要提供对应的rootfs即可。 分层镜像 比如下图中我们从仓库中下载nginx镜像，发现下载的不仅仅是最终的镜像 过程中还下载了其他的文件 也就是说这个镜像是多层构成的 这就解释了在Docker中tomcat为什么需要400+M 因为tomcat需要运行的环境： Kernel–&gt;CentOS–&gt;jdk–&gt;tomcat，虽然我们最后看到的是tomcat，但是他需要这么多文件的支持，这就导致Docker上的tomcat比较大。 Docker为什么采用分层结构 共享资源，比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了。而且镜像的每一层都可以被共享。（UnionFS分层继承） 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为“容器层”，“容器层”之下的都叫做“镜像层”。 Docker镜像commit 之前运行的容器，我们docker run使用的都是默认的镜像配置，当我们需要使用我们自定义的配置的时候，就需要修改镜像文件，然后commit之后生成新的镜像，运行新的镜像就是我们自定义配置的镜像了。 演示案例 tomcat为例，删除tomcat的文档系统，commit生成新的tomcat镜像文件 运行Docker中的comcat -p 主机端口：docker容器端口 首先，需要在阿里云的安全组中配置8888端口，否则的话 是不能进行访问的此端口的 我们访问的时候的地址 出现404错误，我们进入到Docker中tomcat的目录，发现 wenapps目录是空的 docker exec -it 容器ID /bin/bash 而webapps下面还有一个webapps.dist 原来tomcat的文件都存放在这个目录下 重命名 webapps.dist为webapps 本地进行访问 -p以及-P的区别 -p：指定端口 -P：随机端口 在运行一个tomcat 查看正在运行的容器 删除docs目录 commit生成我们自定义的镜像 未删除之前 可以访问到 并且在webapps目录下有docs文件夹 删除docs目录 commit容器副本 生成我们自定义的镜像文件 提交容器副本使之成为一个新的镜像 查看镜像 运行我们自定义的镜像生成的容器 再次访问镜像的时候发现已经找不到文档了 后台运行 -d 后台运行 -it 交互式运行 容器数据卷是什么 在Docker的使用过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，所以这就涉及到Docker容器的数据操作。 容器中数据管理主要有两种方式：数据卷和数据卷容器。 数据卷就是数据(一个文件或者文件夹)。数据卷是特殊的目录，可以绕过联合文件系统，为一个或多个容器提供访问。数据卷设计的目的是数据的永久化，是完全独立于容器的生命周期，不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理。 能干嘛 容器数据持久化 容器之间继承+共享数据 数据卷容器内添加 直接命令添加 创建数据卷 docker run -it -v 宿主机路径:容器内路径 镜像名 -v：volume n. 量；体积；卷；音量；大量；册 上述命令表示（或者理解为）：在宿主机的宿主机目录创建一个文件夹和镜像生成的容器目录下创建一个文件夹，这连个文件夹可以完成宿主机和容器的数据共享。 演示 未创建数据卷之前 Docker中的CentOS根目录的文件夹 未创建数据卷之前 阿里云宿主机的CentOS根目录 创建数据卷 查看宿主机根目录 已经创建文件夹HostVolume 在Docker中运行的CentOS容器的根目录下也已经创建出DockerVolume 查看容器是否挂载成功 docker inspect 容器ID 容器和宿主机之间共享数据 宿主机中添加文件 查看容器中是否也同步添加了文件 在宿主机目录下创建一个文件 查看容器中的挂载的目录下 我们在宿主机创建的问价也已经存在于容器中挂载的目录下 容器中挂载的文件修改 宿主机同步修改的数据 在宿主机中查看文件 发现文件修改也已经同步了 当容器停止运行之后 我们在宿主机对文件进行修改 那么容器中的文件会同步进行修改吗 停止运行容器 在宿主机中创建文件、修改文件 重新启动之前停止运行的容器（是重新启动而非新建容器） 在宿主机创建的文件已经同步了 查看修改的文件 修改的内容也已经同步 创建带权限的数据卷 ​ docker run -it -v 宿主机路径:容器内路径:ro 镜像名 ro : readonly 上述命令表示 Docker容器中的路径下文件 只读，不可以修改此路径下的文件内容，同时也不能创建文件（文件夹） DockerFile添加 是什么 可以简单理解为镜像的配置文件 使用DockFile创建镜像 在宿主机创建目录 用来存放生成的DockerFile 使用VOLUME指令编写DockerFile 使用这种方式 无法指定在宿主机中的目录，因为这个配置是可以通用的，如果指定某个具体的宿主机目录，那么使用此DockerFile生成的镜像，可能运行起来之后，在其他宿主机中没有对应的目录就会出错。但是Docker已经考虑了这个问题，在运行镜像生成容器的时候会随机生成目录。 使用DockerFile创建镜像 查看生成的镜像 并运行生成容器 查看容器内数据卷 查看宿主机内的对应所在的目录 docker inspect 容器ID 在 Docker容器中创建文件 在宿主机中查看 容器中 宿主机中 数据卷容器 定义 容器挂载数据卷之后，其他容器通过挂载这个容器中的数据卷实现容器之间的数据共享，那么被挂载的容器就被称为数据卷容器。 运行容器doc1，doc2和doc3挂载到doc1上 创建容器并命名为doc1 创建容器doc2，并挂载到doc1中 docker run -it --name doc2 --volumes-from doc1 chasingwind/centos 同理 创建doc3 并 挂载到doc1中 🤔：我们创建的doc2的时候，挂载的目录下存在doc1创建的文件，创建doc3的时候，挂载的目录下存在doc1和doc2创建的文件，那么在doc1中是否存在doc2和doc3创建的文件呢？ 存在。这就说明了Docker容器之间挂载之后，每个容器之间的数据是互通的 删除父容器doc1，查看doc2，doc3是否可以共享数据 容器doc2，doc3都创建的时候都挂载在容器doc1下，当我们删除容器doc1之后，容器doc2和doc3是否还能正常共享数据？ 查看容器doc3中是否有容器2创建的文件 总结：容器数据卷被删除之后，挂载的数据卷之间还是可以正常共享数据的。 总结 容器之间挂载之后，可以理解为每个容器的数据都来自同一个副本，只要容器还存在（比如容器被rm -f删除），那么数据都是可以继续进行共享的。数据卷的生命周期一直持续到没有容器使用它为止。 DockerFile解析是什么 DockFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 构建三步骤：编写DockerFile文件，docker build根据DockerFile生成镜像，docker run运行镜像生成容器 以CentOS的DockerFile为例 scratch 类似于Java中的Object，是所有镜像的父类 DockerFile构建过程解析 DockerFile内容基础知识 每条保留字指令都必须为大写字母并且后面都至少要跟随一个参数 指令执行顺序从上到下，顺序执行 **#**表示注释 每条指令都会创建一个新的镜像层，并对镜像进行提交 Docker执行DockerFile的大致流程 Docker从基础镜像运行一个容器（FROM xxxx） 执行一条指令并对容器作出修改 将当前镜像提交生成一个新的镜像层 Docker再基于刚提交的镜像运行一个新的容器 执行DockerFile的下一条指令直到所有指令执行完成，生成最终的镜像文件 DockerFile关键字 FROM 基础镜像，表示当前镜像是基于哪个镜像的 MAINTAINER 镜像作者以及邮箱地址 RUN 容器构建时需要运行的命令 EXPOSE 当前容器对外暴露出的端口号 WORKDIR 指定在创建容器后，终端默认登录进入到的工作目录 ENV 用来在构建镜像的过程中设置环境变量 比如ENV MY_PATH /usr/local，相当于定义了一个变量，这个变量可以在后面的命令中直接使用，比如WORKDIR MY_PATH。 ADD 将宿主机目录下的文件复制进镜像，并且如果是压缩文件，会自动解压缩；如果是URL，也会自动处理 COPY 将从构建上下文中的源路径中的文件/目录复制到新的一层镜像内的目标路径的位置 举例：COPY src dest，或者COPY[“src”,dest”] VOLUME 容器数据卷 CMD 指定容器启动时要运行的命令 DockerFile中可以有多个CMD命令，但只有最后一个生效。 CMD会被docker run之后的参数替换 ENTRYPOINT 指定一个容器启动时要运行的命令 ENTRYPOINT和CMD，都是在指定容器启动程序以及参数 与RUN不同的是，ENTRYPOINT会追加命令而不是覆盖命令 ONBUILD 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，会触发父镜像的ONBUILD 案例 Base镜像（scratch） Docker Hub中的镜像99%都是在Base镜像的基础上之上安装和配置相关的软件实现的 CentOS自定义镜像 阿里云上的Docker镜像是精简版的，其中很多命令都不支持 例如vim和ifconfig两个命令都无法使用 编写DockerFile，生成我们自定义的CentOS 编写 使用自定义的DockerFile文件生成自定义的CentOS镜像 看到最后几条命令 就是在执行我们DockerFile中的命令 后面翻车了 启动不运行 原因是因为CMD和ENTRYPOINT的问题 修改Dockerfile2 重新创建 上面问题出现的原因 参考 简单来说就是： CMD给出的是一个容器的默认的可执行体。也就是容器启动以后，默认的执行的命令。重点就是这个“默认”。意味着，如果docker run没有指定任何的执行命令或者DockerFile里面也没有ENTRYPOINT，那么，就会使用cmd指定的默认的执行命令执行。同时也从侧面说明了ENTRYPOINT的含义，它才是真正的容器启动以后要执行命令。 所以这句话就给出了CMD命令的一个角色定位，它主要作用是默认的容器启动执行命令。（注意不是“全部”作用） 这也是为什么大多数网上博客论坛说的“CMD会被覆盖”，其实为什么会覆盖？因为CMD的角色定位就是默认，如果你不额外指定，那么就执行CMD的命令，否则呢？只要你指定了，那么就不会执行CMD，也就是CMD会被覆盖。 查看创建成功的镜像 运行我们的自定义镜像 可见运行之后 默认进入我们指定的目录 使用vim以及ifconfig 查看镜像的变更历史 ONBUILD命令案例 ONBUILD是在父镜像中定义使用，当有子镜像去继承这个父镜像的时候，子镜像build的时候就会触发父镜像中的ONBUILD命令 父镜像DockerFile 使用此DockerFile创建父镜像文件 子镜像文件DockerFile编写 继承自我们刚刚创建的父镜像 使用DockerFileson创建子镜像 可见在子镜像创建的过程中 执行了父镜像中的ONBUILD命令 Tomcat自定义镜像 在宿主机上创建好文件夹，放置我们需要的文件 这里有压缩文件也有非压缩文件，用于后面比较ADD和COPY的区别 创建DockerFile COPY命令的定义：从构建上下文中的源路径中的文件/目录复制到新的一层镜像内的目标路径的位置 构建上下文的源路径：其实就是DockerFile所在的路径 创建镜像 运行容器 测试 8888访问tomcat 查看宿主机的容器数据卷以及安装的Java Exec 不进入容器实现对容器的操作","categories":[{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.chasingwind.top/tags/Docker/"}],"author":"ChasingWind"},{"title":"MySQL查询截取分析","slug":"MySQL查询截取分析","date":"2020-09-01T06:59:44.000Z","updated":"2021-03-04T00:52:27.369Z","comments":true,"path":"2020/09/01/MySQL查询截取分析/","link":"","permalink":"https://www.chasingwind.top/2020/09/01/MySQL%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90/","excerpt":"本节主要介绍了MySQL的查询截取分析，针对执行查询过程中出现的问题进行分析，包括查询优化，慢查询日志，批量数据脚本，Show Profile，全局查询日志等等，进一步提高SQL执行的效率。","text":"本节主要介绍了MySQL的查询截取分析，针对执行查询过程中出现的问题进行分析，包括查询优化，慢查询日志，批量数据脚本，Show Profile，全局查询日志等等，进一步提高SQL执行的效率。 查询截取分析总体步骤 慢查询开启并捕获 explain+慢SQL分析 show profile查询SQL在MySQL服务器中的执行细节和生命周期情况 SQL数据库服务器参数调优 MySQL查询优化小表驱动大表 也即小的数据集驱动大的数据集 对于EXISTS的理解： SELECT xxx from table WHERE EXISTS(子查询); 将外层主查询的结果，放到子查询中做条件验证，根据验证结果（TRUE或者FALSE）来决定主查询的结果是否保留 但实际的使用情况还需要根据实际进行调整，EXISTS其实也就是IN的一种替代 ORDER BY关键字优化 Order by子句尽量使用Using INDEX排序，最好不要出现Using filesort文件排序。 建立表以及索引 分析各个查询中的排序是否会出现Using filesort 复合索引(age,birthday) 索引排序Using INDEX 当复合索引的最佳左前缀为常量的时候 后面的字段用于排序也是可以的 出现 Using filesort 索引：排好序的快速查找数据结构。这里的排好序，默认是升序（ASC） 但是，如果对索引列同为升序或者同为降序，那么索引还是有作用的 MySQL支持两种排序，一种是使用INDEX进行排序，另一种就是filesort文件排序。当然，使用INDEX索引进行排序效率高于filesort文件排序。 尽可能在索引列上完成排序，遵照索引建的最佳左前缀原则 如果不在索引列上完成排序，filesort有两种算法 单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序； 双路排序：先根据排序的条件去表中取出排序字段以及每一条数据对应的行id，然后再在sort buffer中对排序字段进行排序，此时生成的就是按照排序字段排好序，并且带有未排序之前的表中行的id，然后再次根据这个id去表中取出其他字段 至于mysql优化器使用双路排序还是单路排序是有自己的算法判断的，如果查询的列字段大于max_length_for_sort_data变量，则会使用双路排序（因此建议查询什么字段就取什么字段，而不是select *），反之则会使用单路排序，单路排序速度是更快的，不过比较占据内存，如果在内存空间允许的情况下想要使用单路排序的话，可以增加max_length_for_sort_data变量的大小，max_length_for_sort_data变量默认为1024字节。 使用索引进行排序的情况 GROUP BY关键字优化 Group by 实质是先排序后分组，遵循索引的最佳左前缀原则 无法使用索引列的时候，同样的和order by增加配置文件中参数max_length_for_sort_data和sort_buffer_size的大小可以提高效率 where高于having，能在where中进行限定的就不要再having中进行限定了 慢查询日志是什么 MySQL的慢查询日志是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过给定值的语句，具体是指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中 long_query_time默认值是10，意思是运行时间10秒 通过慢查询日志我们可以查看执行时间超过限制的SQL语句。 如何使用 默认情况下，MySQL是没有开启慢查询日志的。需要我们手动来设置这个参数 当然，如果不是调优需要的话，一般不建议开启这个参数。因为开启慢查询多少会影响性能，慢查询日志支持将日志记录写入到文件中 查看是否已经开启 show variables like &#39;%slow_query_log%&#39;; 开启慢查询日志 set global slow_query_log = 1; 这个开启只对当前数据库成立，当数据库重启之后就会失效。 修改默认的时长 查看当前时长 修改当前时长为3s set global long_query_time = 3; 运行时间大于设定的时长才会被记录，等于的不会记录 tips：修改之后需要重新开启一个sql窗口才能看到修改之后的变化 查看慢查询日志的内容 测试语句 select sleep(4); 慢查询日志内容 查看当前慢查询日志中记录的总条数 show global status like &#39;%slow_queries%&#39;; 日志分析工具mysqldumpslow 此工具可以对慢查询日志进行统计，比如，执行最频繁的SQL语句，执行最耗时的SQL语句等等，避免我们进行人共统计 详细使用方法可以参考参考 批量数据脚本插入大批量的数据不要使用insert，因为insert事务默认提交。可以批量插入数据，设置为手动提交事务，数据插入完成之后再commit。 Show Profile用于查看SQL语句执行的过程 查看并开启功能 运行SQL，并查看运行记录 可能会遇到的问题 Converting HEAP to MyISAM 查询结果太大，内存不够，将数据搬到磁盘 Creating tmp table 创建零时表 Copying to tmp table on disk 把内存中的临时表复制到磁盘（危险！！） 全局查询日志 记录MySQL执行的所有的SQL历史 测试环境可以使用，但也是用的时候开启。 Show Profile功能更加强大","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.chasingwind.top/categories/MySQL/"}],"tags":[{"name":"MySQL高级","slug":"MySQL高级","permalink":"https://www.chasingwind.top/tags/MySQL%E9%AB%98%E7%BA%A7/"}],"author":"ChasingWind"},{"title":"MySQL索引优化分析","slug":"MySQL索引优化分析","date":"2020-08-17T03:00:02.000Z","updated":"2021-03-04T00:53:27.909Z","comments":true,"path":"2020/08/17/MySQL索引优化分析/","link":"","permalink":"https://www.chasingwind.top/2020/08/17/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/","excerpt":"本节主要介绍MySQL索引，以及对一些SQL进行优化分析，这一节是重中之重，一定要好好掌握，包括原理以及用法，在以后的工作中起到很大的作用。","text":"本节主要介绍MySQL索引，以及对一些SQL进行优化分析，这一节是重中之重，一定要好好掌握，包括原理以及用法，在以后的工作中起到很大的作用。 SQL执行效率分析 在SQL语句执行的过程中，常常会遇到SQL语句执行慢的问题，导致的原因通常可以分为以下三个部分： 性能下降SQL慢 执行时间长 等待时间长 导致以上问题的原因大致包括： 查询语句写的🌶🐔 索引失效 关联查询太多JOIN（设计缺陷或不得已的需求） 服务器调优以及各个参数设置（缓冲、线程数等等） 常见的JOIN查询SQL执行顺序 我们写的SQL关键字顺序 数据库的优化器执行时候的关键字顺序 总的来说，优化器需要先知道全部的数据源，然后再从中进行查询 Join图 图中一共有7种Join 案例 t_dept表 t_emp表 7种JOIN INNER JOIN 取出emp和dept表中的部门id相同的数据 并且两个表的id都不为null LEFT JOIN,RIGHT JOIN与此类似 取出emp表中的所有数据，同时根据emp表的部门id去连接dept表。尽管dept表中不存在第10条记录对应的数据，补为null LEFT JOIN并且JOIN的表的条件为null 取出emp表的全部数据，同时筛选出其中部门id是null的员工 FULL OUTER JOIN（MySQL不支持） 使用UNION实现， UNION自带去重功能 图中的语义就是emp和dept的公共部分加上emp的独有加上dept的独有部分 二者的独有部分联结 索引简介 什么是索引？ MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。可以简单理解为排好序的快速查找数据结构，目的在于提高查询效率，可以类比从字典中查找数据。 比如我们需要查找mysql这个字段，没有索引的时候，需要先从az中从a开始直到找到m，然后再从剩下的az中找到y……. 索引两大功能，快速查找和排序。影响到WHERE后面的条件是否使用了索引和ORDER BY排序后面的条件，也就是说索引会对查找和排序都有影响。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。下图就是一种可能的索引方式示例： 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指 针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。 索引存储在.myi文件中，文件比较大，存储在磁盘上 我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然除了B+树索引外，还有哈希索引（hash index）等。 索引的优势 排好序的快速查找数据结构 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 索引的劣势 实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是占空间的 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 索引只是提高效率的一个因素，如果数据库中有大量的表，就需要花时间研究建立最优秀的索引，或优化查询 MySQL索引分类 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引 唯一索引：索引列的值必须唯一，但允许有空值 主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引 复合索引：即一个索引包含多个列 索引基本语法 创建 CREATE [UNIQUE] INDEX 索引名 ON 表名(表中的列名); ALTER TABLE 表名 ADD [UNIQUE] INDEX 索引名 (表中的列名); 中括号[]表示可选择，UNIQUE表示创建的是唯一索引 表中的列名，如果是多列的话，就是复合索引；单列的话就是唯一索引 创建索引 查看索引 图中第一个索引是 表创建的时候数据库默认创建的主键索引 使用ALTER创建索引 这里创建的是复合索引 查看索引 删除 DROP INDEX 索引名 ON 表名; 查看 SHOW INDEX FROM 表名; MySQL索引结构 BTree索引 MySQL使用的就是BTree索引。 BTree 上图就是一颗BTree，浅蓝色的是磁盘块，深蓝色的是数据项，黄色的是指针 如磁盘块 1 包含数据项17和 35，包含指针 P1、P2、P3。P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。 非叶子结点不存储真实的数据，只存储指引搜索方向的数据，比如上图中磁盘块1中的17和35，并不真实存在于数据表中。 真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。 查找过程 如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短（相比磁盘的 IO）可以忽略不计， 通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间， 锁定磁盘块 3 的 P2 指 针，通过指针加载磁盘块 8 到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。 也就是说我们磁盘的IO次数就是树的高度 3层BTree能存储的数据量 真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的， 如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。 Hash索引 full-text全文检索 R-Tree索引 哪些情况需要创建索引 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其它表关联的字段，外键关系建立索引 单值/组合索引的选择问题， 组合索引性价比更高 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段 哪些情况不要创建索引 表记录太少 经常增删改的表或者字段 Where 条件里用不到的字段不创建索引 数据重复且分布平均的表字段不适合建索引，就是说，如果某个字段值重复率太高，就不适合建索引。比如，100万条数据中，某个字段只有T和F两种，这两个值分布都是在50%，那么这个字段就没必要创建索引，不会提高查询的效率。 EXPLAIN性能分析在MySQL Query Optimizer（优化器）和MySQL数据库硬件以及配置都稳定的情况下，通过EXPLAIN来分析SQL的性能。 EXPLAIN是什么 使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN可以做什么 表的读取顺序（id） 数据读取操作的操作类型（select_type） 哪些索引可以使用(possible_keys) 哪些索引被实际使用(keys) 表之间的引用（ref） 每张表有多少行被优化器查询（rows） EXPLAIN怎么使用 EXPLAIN+SQL语句 解释各个字段的含义 执行EXPLAIN+SQL语句的结果 id：select查询序列号，是一组数字，表示查询中执行select子句或者操作表的顺序 id相同：按照table列的顺序，由上到下的顺序执行 id不同：id越大，优先级越高，越先被执行 id既有相同，又有不同的，二者同时存在 DERIVED，衍生 上图中，首先执行的就是id为2的组（只有一个）中的t3，然后再在id为1的组中根据table列的顺序由上到下执行，先执行derived2，再执行t2。 derived2表示：derived2这个临时表是根据id为2的表t3衍生出来的。就是上图中的s1 select_type：查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询 SIMPLE：简单的select查询，查询中不包含子查询或者UNION PRIMARY：查询中若包含任何复杂的子部分，则最外层被标记为PRIMARY SUBQUERY：在select或where列表中包含了子查询 DERIVED：在from列表中包含的子查询被标记为DERIVED（衍生），MYSQL会递归执行这些子查询，把结果放在临时表中 UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION被包含在FROM子句的子查询中，外层SELECT则被标记为DERIVED UNION RESULT：从UNION表获取结果的SELECT table：显示这一行数据是关于哪张表的 type：访问类型排列 最好到最差的排列顺序：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL 一般来说：查询至少达到range级别，最好达到ref级别 system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计 const： 表示通过索引一次就能找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，MySQL就能将该查询转换为一个常量 eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描 这里好比 t1是员工表，t2是部门表 查出来的是全公司唯一的总裁 ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。 这就好比，查找一个公司职位是程序员的人，查出来的是多个 range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。 index：Full Index Scan，index和ALL的区别就在于index类型只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但是index是从索引中读取，而all是从硬盘中读取） ALL：Full Table Scan，遍历全表找到匹配行 possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。 keys：实际使用的索引。如果为NULL，则没有使用索引，存在的情况有多种，比如索引没有建立，索引失效等等。还有一种就是如果存在多个索引，那么实际使用的是哪一个索引。 查询中若使用了覆盖索引，则该索引仅出现在key列中，possible_keys理论上使用的索引为null 覆盖索引：select后面查询的列和索引列相对应（个数和顺序都一样） key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。 Key_len显示的是索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得到的，不是通过表内检索出来的 第一个13是如何计算得到的：UTF-8，一个char占3个字节，同时，col1 DEFALUT是NULL，MySQL需要使用一个字节来标记NULL，也就是4 * 3 + 1 = 13。 同理，下面的26也是这样计算所得 ref：显示索引的哪一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。 执行表t1的时候，explain告诉我们使用到了idx_col1_col2这个索引，并且通过ref知道这个索引用于匹配哪些值 rows：根据表统计信息以及索引的选用情况，大致估算出找到所需的记录所需要读取的行数。 Extra：额外信息（除上述9个之外的信息） Using filesort：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。 这种情况是需要避免的，否则排序是重新进行的。 Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。 所以在我们进行排序和分组查询的时候，条件一定要使用索引顺序，这样的话，效率会高很多；否则就会使用临时表，这其中需要经历创建临时表，对临时表进行操作，删除临时表的过程，是很耗费时间的。 Using INDEX：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行。直接通过查找索引而定位到数据，效率可以的！ 如果同时出现Using where，表明索引被用来执行索引键值的查找； 如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作。 再说覆盖索引， 覆盖索引：select数据列只用从索引列中就可以获得，不必读取数据行。MySQL可以根据索引返回select的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。 如果要使用覆盖索引，一定要注意select列表中只取出需要的列（与索引列顺序，个数一致），不可以使用select *。否则的话使用的就不是索引覆盖，而仅仅是Using INDEX。 Using where：表示SQL使用了where条件对数据进行了过滤。 USing join buffer：使用了连接缓存，这个就是说join的表太多，可以将配置文件的缓冲区调大一点。 impossible where：where子句的值总是false。 索引优化索引分析建表SQL参考 单表 建立文章article表 CREATE TABLE IF NOT EXISTS `article`( `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, `author_id` INT(10) UNSIGNED NOT NULL, `category_id` INT(10) UNSIGNED NOT NULL, `views` INT(10) UNSIGNED NOT NULL, `comments` INT(10) UNSIGNED NOT NULL, `title` VARBINARY(255) NOT NULL, `content` TEXT NOT NULL ); 查询category_id为1且comments大于1的情况下，views最多的article_id。 对查询语句进行EXPLAIN分析 分析发现查询不仅遍历了全表查找数据，而且还使用了文件排序。 并且没有使用到索引，因为我们还没有创建索引。 尝试建立索引 由于上面的查询使用到了category_id，comments和views，尝试建立这三者的复合索引。 在建立索引之后再次进行查询的操作 发现虽然解决了全表扫描的问题并且使用了索引，但是还是出现了文件排序 出现的原因：按照BTree的工作原理，先排序category_id，如果遇到相同的category_id，再排序comments，如果遇到相同的comments再排序views。 因为where的第二个字段comments&gt;1（range）是一个范围并且处于中间字段，MySQL无法对后面的views部分进行检索，也即range类型查询字段后面的索引无效。 重新建立索引 首先需要将之前的索引删除 尝试跳过comments建立索引 进行查询分析 不仅使用了索引，并且访问类型也变成了ref，同时文件排序也不存在了。 两表 创建两张表，class和book表，两个表之间的联系就是card列对应相等 那么问题就出现了，两张表我们建立索引，建立在哪张表上面呢？class.card还是book.card？ 未创建索引的时候 结果出现了全表扫描的情况，效率比较低 在左连接左表建立索引 再次执行EXPLAIN分析SQL语句，一个是遍历索引，一个是遍历全表的数据，并且rows还是全表 在左连接右表上建立索引 首先删除之前的索引 在book表上建立索引 再次执行相同的SQL，发现在book表的时候type为ref，非唯一性索引扫描；并且rows行也是1。 总结就是：左连接需要在右边的表建立索引；右连接需要在左边的表建立索引。 拿左连接举例来说： LEFT JOIN 条件用于确认如何从右表搜索行，左边的表中的数据全都有。所以，右边的表是我们的关键点，需要建立索引。 三表 创建phone表，其中也有card字段。 未建立索引的时候 三张表都是全表扫描（ALL） 在左连接的右表建立索引 分别在两个左连接的右表创建索引 再次执行EXPLAIN分析，发现之前的两个全表扫描已经变成了非唯一性索引扫描（ref），相比之前的ALL，效率提高很多。 JOIN语句的优化 用小结果集驱动大的结果集，比如说LEFT JOIN，右表的表结果应该比左边的表结果小。 优先优化内层嵌套的查询，比如JOIN一个表，先优化JOIN的表，而不是主表 保证JOIN语句中被驱动表上JOIN条件字段已经被索引 当无法保证被驱动表的JOIN字段被索引且内存资源充足的情况下，可以修改JoinBuffer的设置。 避免索引失效 创建staffs表并插入数据 建立索引 查看索引中字段的顺序 案例 使用索引中的NAME作为条件进行查找 使用索引中的NAME，age作为条件进行查找数据 使用NAME，age，pos作为条件进行查找 可见，要想结果更加精确，那么是需要付出更多的代价的（key_len）。 最佳左前缀法则 当我们去掉NAME，使用age和pos作为条件进行查询的时候 发现并没有用到索引 而且是全表扫描 当我们仅仅使用pos作为条件的时候 结果也是如此 当我们跳过中间的索引age，直接使用第一个索引NAME和第三个索引age的时候，我们会发现，key_len是74，仅仅是索隐列NAME的长度，ref也只有一个。也就是说索引只使用了一部分（NAME），pos索引并没有使用到。所以，最佳左前缀法则还有一点就是不能跳过索引的中间列。 最佳左前缀法则：如果索引使用了多个列（复合索引），要遵守最佳左前缀法则，就是说查询从索引的最左前列开始并且不跳过索引中的列。 比如上面的案例，要么使用NAME；要么使用NAME，age；要么使用NAME，age，pos。这样的话索引才不会失效。 不要在索引列上做任何的操作（计算，函数，类型转换），会导致索引失效而转向全表扫描 对索引列进行计算 下图中的LEFT(NAME,4)表示取得NAME值的前4个 可见，对索引列进行计算的话。索引并没有起作用，导致了索引失效。 存储引擎不能使用索引中范围条件右边的列（范围之后全失效） 全值匹配 当age使用范围之后，范围之后的索引全部失效。 下图中可以看出，key_len是78，说明使用到了索引中的NAME和range。 但是NAME和range其实还是有区别的，NAME是用于检索，而age却用在排序。 尽量使用覆盖索引（索引列和查询列一致），减少select *的使用 当我们使用select * 而我们只取索引列的数据 Using INDEX 表示相应的select操作中使用了覆盖索引，避免访问了表的数据行 MySQL在使用不等于（!=或者&lt;&gt;）的时候会无法使用索引导致全表扫描 IS NULL或者IS NOT NULL也无法使用索引 LIKE以通配符开头（’%abc…’）,MySQL索引失效变成全表扫描 前后都有通配符 全表扫描 前面有通配符 依旧是全表扫描 当通配符只出现在后面的时候 发现是 范围扫描 还有一个就是 当我们like以常量开头，之后无论有没有%都不会影响索引， 索引都可以正常使用 但是 问题就是 我们在实际问题中或许还是需要使用前后都有通配符的情况的，这该怎么解决呢？ 解决like(&#39;%abc...%&#39;)索引失效的问题 如果两边都有%，我们可以通过覆盖索引来提升性能 创建tbl_user表 未创建索引之前，全部都是全表扫描 创建索引NAME，age，email 同样的上面的所有的查询语句 type已经变成了扫描索引，提升效率。 但是 如果我们查询的列比覆盖索引的列多，那么还是会全表扫描 字符串不加单引号索引失效 我们向tbl_user表中添加一个数据 NAME为2000 当2000带单引号 能查出来数据 当2000不带单引号 也能查出来数据 这是因为MySQL在优化分析的时候，因为我们创建的表结构NAME是varchar类型的数据，MySQL拿到数字类型的时候，会将数字类型转换为varchar类型。这期间存在着隐式类型转换。 执行EXPLAIN分析 当使用字符串的时候，使用到了索引，并且type是ref类型 使用数字类型的时候 NAME这个索引就失效了 变成了全表扫描 结合第2点 不要在索引上做任何操作（类型转换） 同时理解 少用or，用它连接时索引失效 练习题分析 建表 建立索引 分析 当where条件为常量并且顺序和索引的顺序一致的时候，毫无疑问，4个索引都用到了 当where条件为常量的时候，但是顺序和索引顺序完全颠倒或者说不一致的时候，4个索引还是全部都使用到了 原因：MySQL查询优化器会自动对我们的SQL进行优化，因为上面的4个都是常量，所以顺序无关，MySQL会优化成与我们创建的索引的顺序相同。 使用到了3个索引，范围之后全失效。c1,c2用来索引数据，c3用来对数据进行排序 这里用到了4个索引 分析：首先 优化器对SQL进行优化 优化成按照索引的顺序 也就是等同于下图 由于范围c4是最后一个字段 后面已经没有了 所以4个索引都使用到了 ordey by后面会有更加详细的介绍 这里使用到了两个索引 其实c3也用到了 只不过是用于排序而非查找，没有统计到explain的keys中 去掉c4 还是只使用到了两个索引 同样c3也是用于排序 order by c4 相比上面的ordey by c3，这里多出了文件排序 order by c2,c3，并且前面的where条件有c1的时候 Extra并没有出现 Using filesort 当我们直接使用c2,c3进行排序的时候 就会出现Using filesort 为了避免出现文件排序 那么where条件和ordey by顺序要衔接上，比如我们要order by c2,c3，那么where中要有使用到有效的索引c1就不会出现文件排序 有效的索引 不会导致后面的排序用的字段的索引失效 下图中的索引c2,c3就失效了 出现了文件排序 order by顺序的问题 order by c3,c2 出现了Using filesort 文件排序 同样是order by c3,c2 这里却没有出现文件排序 原因：因为在where条件中c2就是一个常量， 所以在order by c3,c2的时候 ,MySQL优化器会将order by优化成order by c3,常量值。也就是说排序已经不受c2的影响，等同于ordey by c3。 group by 分组 按照索引的顺序进行分组 出现了Using temporary group by分组 ， 分组之前必排序。所以说group by和order by索引优化几乎是一致的 group by分组如果索引没用起来的话，那么就会有临时表产生，影响效率（Using temporary） 一般性建议 对于单值索引，尽量选择对于当前查询过滤性更好的索引 对于复合索引的选择，当前查询中过滤性最好的字段在索引字段顺序中，位置越靠前越好。 对于复合索引的选择，尽量选择可以能够包含当前查询中的where子句中更多字段的索引。 尽可能通过分析统计信息和调整查询的写法来达到选择合适索引的目的。 参考文献 深入理解MySQL索引之B+Tree","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.chasingwind.top/categories/MySQL/"}],"tags":[{"name":"MySQL高级","slug":"MySQL高级","permalink":"https://www.chasingwind.top/tags/MySQL%E9%AB%98%E7%BA%A7/"}],"author":"ChasingWind"},{"title":"Java8新特性","slug":"Java8新特性","date":"2020-08-04T00:33:30.000Z","updated":"2021-03-04T00:47:45.076Z","comments":true,"path":"2020/08/04/Java8新特性/","link":"","permalink":"https://www.chasingwind.top/2020/08/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"本节介绍Java8的一些新特性，包括Stream流的操作，其中包括并行流和串行流；Lambda表达式的基础语法和用法，以便在工作中更好地进行使用。","text":"本节介绍Java8的一些新特性，包括Stream流的操作，其中包括并行流和串行流；Lambda表达式的基础语法和用法，以便在工作中更好地进行使用。 Lambda表达式什么是Lambda表达式 Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁，更灵活的代码。作为一种更紧凑的代码风格，使Java语言表达能力得到提升。 Lambda表达式解决的问题 匿名内部类 以前我们实现比较器的时候，使用匿名内部类来实现比较 我们分析一下 可以发现在比较器中真正有用的只是return这句话 使用Lambda表达式解决 减少代码冗余 假设目前有一个员工对象 当我们的需求是筛选出列表中年龄大于35岁的员工的时候，可以采用如下代码实现 当我们改变需求 筛选出工资大于4000元的员工的时候 所以这样的处理方式 代码的冗余度比较高 优化1：使用策略设计模式 首先，创建一个通用接口 然后，根据需求实现创建对应的类实现接口 比如，这里的需求是筛选出年龄大于35的员工 最后，调用方法时直接传入相应的实现类 如果 当我们改变需求 我们只需要根据需求写一个接口的实现类，使用的时候调用filter传入对应的实现类即可，而不需要修改其他的代码。 上面的代码还可以进行优化，因为在上面的代码中，如果我们又新增了一个需求，那么我们还需要创建一个类，麻烦并且多余，这个时候，就可以使用匿名内部类来实现。 这就又出现了代码冗余度高的问题 Lambda表达式简化 Lambda表达式的基础语法 操作符：-&gt;，操作符将Lambda表达式拆分成两部分，左侧是Lambda表达式的参数列表，右侧（称为Lambda体）是Lambda表达式中所需要执行的功能（也即对接口中方法的实现）。 左侧参数列表从哪里来 需要实现的接口的参数列表 右侧功能又是根据什么实现 接口功能的实现 语法格式 无参无返回值类型 使用匿名内部类和Lambda表达式 有一个参数，并且无返回值 如果方法只有一个参数 小括号可以省略 方法有多个参数，有返回值，并且Lambda体中有多条语句 当实现的方法中 有多个参数，有返回值，但是Lambda体中只有一条语句的时候，可以将&#123;&#125;和return省略 类型推断 在上面的案例中我们可以发现，我们在参数列表中并没有写参数的数据类型 当然也可以写上 那么不写的时候，编译器是怎样知道数据类型的呢？ JVM编译器经过上下文推断，得出参数列表的数据类型。比如上图中的，是根据Comparator&lt;Integer&gt;来推断出来的数据类型 什么时候可以用Lambda表达式 Lambda表达式的使用需要函数式接口的支持 函数式接口 接口中只有一个抽象方法的接口称为函数式接口（JDK1.8之后，接口中的方法可以有普通方法，使用default可以修饰普通方法）。 那么为什么在Comparator接口中有两个”抽象方法“呢 我们实现接口的时候发现 只需要实现compare接口就可以了 实际上，接口完全有可能重新声明Object类的方法，如toString或clone，这些声明有可能会让方法不再是抽象的。（java API中的一些接口会重新声明Object方法来附加javadoc注释。Comparator API就是这样一个例子） 函数式接口可以使用注解@FunctionalInterface来进行检查当前接口是否是函数式接口 Java内置函数式接口 消费型接口 接收一个参数，无返回值 供给型接口 无参数 有返回值 函数型接口 有参数 有返回值 断言型接口 对参数进行判断 返回布尔类型 以上接口还有许多子接口，可以根据需要进行调用 方法引用和构造器引用（了解） 我觉得这种代码可阅读性太差了 了解就好了 方法引用 什么是方法引用 若Lambda体中的内容已经有方法已经实现了，那么我们直接进行引用而不需要重新实现。可以理解为Lambda表达式的另一种表现形式 方法引用的语法格式 对象::实例方法名 println方法的参数和返回值 Consumer接口中方法的参数和返回值 类::静态方法名 Comparator接口 Integer类中的compare静态方法 类::实例方法名 这种形式算是一种特例，当Lambda表达式中第一个参数作为方法的调用方，第二个参数作为方法的参数列表的时候，就可以使用类::实例方法名实现方法的引用 注意事项 方法的参数列表和返回值需要与接口中方法的参数参数列表和返回值一致 当Lambda表达式中第一个参数作为方法的调用方，第二个参数作为方法的参数列表的时候，就可以使用类::实例方法名实现方法的引用 构造器引用 语法格式：类名::new 使用 在Employee类中 既有无参构造器 又有多个参数的构造器 那么，使用构造器引用的时候使用的是哪一个构造方法呢 其实，使用的构造器的参数列表需要和接口中方法的参数列表一致 Supplier接口中的方法 所以上述的构造器引用使用的是无参构造 调用有参数的构造器 这次使用的构造器引用使用的就是有一个参数的构造 因为Function接口中的方法就是 Stream API 什么是Stream Stream称为流，它是数据渠道，用于操作数据源（集合、数组等等）所生成的元素序列。集合讲的是数据，流讲的是计算。 而Java8中的Stream，用来对集合进行操作，产生一个新的流，并且数据源（数组，列表等等）不会发生任何变化，而是产生一个新的流。 Stream的特点 Stream自己不会存储元素 Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream Stream操作是延迟执行的，也就是说他们会等到需要结果的时候才会执行。 Stream操作的3个步骤 创建Stream：通过数据源（集合、数组等等）获取流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作：一个终止操作，执行中间操作链，并产生结果 创建Stream 常见的创建流的方法 可以通过集合、数组以及流提供的方法获取 中间操作 多个中间操作可以连接起来形成一个流水线，除非流水线触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为惰性求值。 筛选与切片 filter：接收Lambda，从流中排除某些元素 当我们没有执行终止操作的时候 stream是不会执行的 还可以发现 stream会对list进行内部迭代 limit：截断流，使其元素不超过给定数量 limit短路效果 当stream找到满足条件的数据之后，就不再继续执行，可以提高效率 skip(n)：跳过元素，返回一个去除前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补 distinct：筛选流中的元素，根据流所生成元素的hashCode()和equals()去除重复元素 使用之前，必须重写元素的hashCode()和equals() 映射 map：接收Lambda，将元素转换成其他形式或提取信息。接收一个方法作为参数，该方法会被应用到每个元素上，并将其映射成一个新的元素。 map方法的参数是一个Function函数型接口 flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 这里在执行终止操作的时候其实生成了多个流， 使用flatMap，将多个流串联成一个流 也就是说，使用flatMap后生成一个流{a,a,a,s,s,s,s,…..} map和flatMap类比add和addAll 排序 sorted()：自然排序（使用Comparable接口中的compareTo方法进行排序） 比如String，其中就实现了Comparable接口，重写了其中的CompareTo方法 sorted(Comparator com)：自定义排序（使用自定义的Comparator进行排序） 终止操作 终止操作会从流的流水线生成结果，其结果可以是任何不是流的值。例如：List、Integer，甚至是void。 查找与匹配 allMatch：检查经过中间操作的结果集中的元素是否都满足 anyMatch：检查经过中间操作的结果集中的元素是否至少有一个满足 noneMatch：检查经过中间操作的结果集中的元素一个都不满足 findFirst：返回经过中间操作的结果集中的第一个元素 返回的是Optional，是一个容器类，是Java8为了解决空指针异常设置的类。 在这里findFirst可能存在为空的情况，所以将结果放到容器Optional中 findAny：返回经过中间操作的结果集中的任意元素 count：返回经过中间操作的结果集中的元素总个数 max：返回经过中间操作的结果集中的元素最大值 min：返回经过中间操作的结果集中的元素最小值 forEach：内部迭代 归约 reduce：将流中元素反复结合起来，得到一个值。 使用归约进行累加操作 上图中，使用的接口 运行过程是这样的，第一次在二元运算中，x是初始值0，y是asList中的元素1，运行一次后x为1，y为asList中的元素2……..直到最后累加完成 计算所有员工的工资总和 Map-reduce模型：先从所有的数据中获取值，然后进行归约操作 而这次返回值是Optional，上面的返回值是Integer。因为在计算工资的时候，可能存在所有的员工都没有值的情况，所以结果有可能为空。但是在上面计算加和的时候，是有初始值0的，所以最终的结果不可能为空。 收集 collection：将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。 collection中的参数是Collector接口，其中的方法实现决定了我们究竟对流执行什么样的收集操作（如收集到List、Set、Map），同时Collectors为我们提供了静态方法，方便我们创建常见的收集器实例 转换为List 转换为HashSet 对收集的元素进行汇总操作 对元素进行分组操作 多级分组 分区 满足条件的分在一个区，不满足条件的分在一个区。 对结果进行分析，形成一个对象，对象中包含之前我们介绍的汇总的方法 将结果连接 并行流和串行流 在Java8中对于并行的处理效率高了很多，更加充分利用了CPU的效率 参考文章 接口中的默认方法和静态方法 在Java8中的接口中，可以拥有实现的方法，称为默认方法（default修饰）。 除了默认方法，还可以有静态方法。 新时间日期API 以前的时间日期API是线程不安全的，而新的时间日期API是线程安全的。 新时间日期API中常用的方法 LocalDate、LocalTime、LocalDateTime 这三个类的实例是不可变对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。 这三个类的使用方法类似 往后推日期 往前推日期 获取日期和时间 Instant：时间戳（以Unix元年：1970年1月1日 00：00：00之间的毫秒值） Duration、Period Duration：计算两个时间之间的间隔 Period：计算两个日期之间的间隔 时间校正器 使用withXxx()方法进行日期的修改操作 使用时间校正器类进行日期的修改操作 with方法可以传入一个时间校正器TemporalAdjuster的实例，而TemporalAdjusters则为我们提供了更加快捷的方式创建实例。 时间日期格式化 DateTimeFormatter","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://www.chasingwind.top/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://www.chasingwind.top/tags/Java8/"}],"author":"ChasingWind"},{"title":"MyBatis-Generator工具的使用","slug":"MyBatis-Generator工具的使用","date":"2020-07-16T06:18:49.000Z","updated":"2021-03-04T00:51:21.415Z","comments":true,"path":"2020/07/16/MyBatis-Generator工具的使用/","link":"","permalink":"https://www.chasingwind.top/2020/07/16/MyBatis-Generator%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"工欲善其事必先利其器，善于使用工具可以大大提高工作效率，再现今社会效率就是王道。事情都是怎么简单怎么做，偷懒使社会进步。一些琐碎的事情，能交给工作去做就使用工具做，只有从琐碎的重复的劳动中摆脱出来，才能有时间专注其他，才能更好的思考业务，更好的做设计，才能提高代码质量，做出好的产品！","text":"工欲善其事必先利其器，善于使用工具可以大大提高工作效率，再现今社会效率就是王道。事情都是怎么简单怎么做，偷懒使社会进步。一些琐碎的事情，能交给工作去做就使用工具做，只有从琐碎的重复的劳动中摆脱出来，才能有时间专注其他，才能更好的思考业务，更好的做设计，才能提高代码质量，做出好的产品！ MyBatis-Generator插件简介 为什么会使用到这个插件？ 可以根据配置帮我们生成简单的PO类，能生成mapper映射文件（其中包括基本的增删改查功能）、能生成mapper接口。 在工作中遇到的使用Example类来实现的动态SQL查询，其中使用的就是通过插件生成的xxExample类 MYBatis-Generator插件在IDEA中的配置 首先，在项目的pom.xml配置文件中添加MyBatis-Generator插件 &lt;plugins&gt; &lt;!-- mybatis代码生成插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; 根据pom.xml文件中配置的配置文件的位置以及文件名生成配置文件 &quot;https://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;报红的话，可以先不用管，后面把配置文件中的配置完成后，就可以使用插件了 建议把这个配置文件生成IDEA模板，方便以后在新的项目中使用 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!--mysql 连接数据库jar 这里选择自己本地位置; 如果不知道maven本地仓库地址，可以使用EveryThing工具全局搜索mysql-connector-java，找到jar包位置； 也可以手动下载一个jar放在指定位置，进行引用。 --&gt; &lt;classPathEntry location=&quot;/usr/local/maven_repo/mysql/mysql-connector-java/8.0.19/mysql-connector-java-8.0.19.jar&quot;/&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释,true：是,false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://116.62.48.203:3306/forest_blog&quot; userId=&quot;root&quot; password=&quot;xxxxxxx&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 指定javaBean生成的位置 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.liuyanzhao.ssm.blog.dto&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false；如果多个数据库改为true分目录 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 指定mapper映射文件生成的位置 targetPackage、targetProject同javaModelGenerator中作用一样--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 指定mapper接口生成的位置 targetPackage、targetProject同javaModelGenerator中作用一样 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.liuyanzhao.ssm.blog.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 domainObjectName：生成的domain类的名字,当表名和domain类的名字有差异时一定要设置，如果不设置，直接使用表名作为domain类的名字； 可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； --&gt; &lt;table tableName=&quot;link&quot; domainObjectName=&quot;LinkDetailDto&quot;&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 使用Maven运行插件 查看生成的实体类，Mapper接口以及映射文件 实体类 查看实体类 其中各个属性就是数据库中对应表的字段，以及对应的getter和setter方法 xxxExample类 Example类包含一个内部静态类 Criteria，利用Criteria我们可以在类中根据自己的需求动态生成sql where字句，不用我们自己再修改mapper文件添加或者修改sql语句了，能节省很多写sql的时间。 其中方法包括对各个属性的sql的基础操作，我们可以按照需要使用 Mapper接口 映射文件 其中包括基础的增删改查的操作 Example类的使用 Example类可以帮我们实现简单的查询的操作，而不需要去创建对应的Mapper以及映射文件，省去了很多麻烦","categories":[{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.chasingwind.top/tags/MyBatis/"},{"name":"代码生成工具","slug":"代码生成工具","permalink":"https://www.chasingwind.top/tags/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"}],"author":"ChasingWind"},{"title":"MySQL架构介绍","slug":"MySQL架构介绍","date":"2020-07-14T01:52:18.000Z","updated":"2021-03-04T00:52:39.186Z","comments":true,"path":"2020/07/14/MySQL架构介绍/","link":"","permalink":"https://www.chasingwind.top/2020/07/14/MySQL%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"MySQL配置文件 我的服务器上是通过RPM的方式安装的MySQl，配置文件是在/etc目录下的my.cnf文件 二进制日志log-bin：主要用于记录主从日志 错误日志log-err：默认关闭，记录严重的警告和错误信息，每次启动和关闭的详细信息等 查询日志log：默认关闭，记录查询的sql语句，如果开启会降低MySQL的整体性能，因为记录日志也是需要消耗系统资源的 数据文件：数据库所在的位置 进入到对应的数据库中 frm文件:存放当前表的表结构 myd文件：当前表的数据 myi文件：当前表的索引 MySQL逻辑架构介绍 MySQL分层设计 连接层 最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层 引擎层 存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。 存储层 数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。 优点：插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求实际的需要选择合适的存储引擎。 MySQL存储引擎 比较常用的两个分别是MYISAM，InnoDB。 使用 show engines;命令可以查看支持的引擎类型 默认使用的是InnoDB 使用show variables like &quot;%storage_engine%&quot;;可以查看当前是数据库使用的引擎 MyISAM和InnoDB的对比","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.chasingwind.top/categories/MySQL/"}],"tags":[{"name":"MySQL高级","slug":"MySQL高级","permalink":"https://www.chasingwind.top/tags/MySQL%E9%AB%98%E7%BA%A7/"},{"name":"MySQL架构","slug":"MySQL架构","permalink":"https://www.chasingwind.top/tags/MySQL%E6%9E%B6%E6%9E%84/"}],"author":"ChasingWind"},{"title":"SpringBoot与Web开发","slug":"SpringBoot与Web开发","date":"2020-07-03T05:39:16.000Z","updated":"2021-03-04T00:55:56.813Z","comments":true,"path":"2020/07/03/SpringBoot与Web开发/","link":"","permalink":"https://www.chasingwind.top/2020/07/03/SpringBoot%E4%B8%8EWeb%E5%BC%80%E5%8F%91/","excerpt":"本节介绍了SpringBoot开发Web的流程，使用模板引擎来开发前端页面，动态展示后台返回的数据，再次加深SpringMVC自动配置和扩展，理解SpringBoot默认配置的思想，掌握SpringBoot的错误处理机制，以及配置嵌入式的Servlet容器等等。","text":"本节介绍了SpringBoot开发Web的流程，使用模板引擎来开发前端页面，动态展示后台返回的数据，再次加深SpringMVC自动配置和扩展，理解SpringBoot默认配置的思想，掌握SpringBoot的错误处理机制，以及配置嵌入式的Servlet容器等等。 使用SpringBoot开发Web的流程 创建SpringBoot应用，选择我们需要使用到的模块 SpringBoot已经帮我们完成了许多默认的配置，我们只需要修改一小部分就可以使用了 编写自己的业务代码 SpringBoot对静态资源的映射规则 以前在使用SpringMVC框架的时候，静态资源是放在src/main/web-app目录下的，然后配置视图解析器，对方法的返回值进行解析，返回对应的视图 SpringMVC中的静态文件存储的路径 但是在SpringBoot中的web项目中并没有这个目录 那么SpringBoot是怎样将静态资源映射到SpringMVC中的呢？ 查看SpringMVC的自动配置类，当浏览器访问路径是/webjars/** 红框中表示的意思就是 所有/webjars/下面的请求，都在都去 classpath:/META-INF/resources/webjars/ 找资源 webjars：以jar包的方式引入静态资源，而不是像以前我们把静态资源文件自己导入到web-app目录下 而且导入这些jar包，可以通过使用Maven依赖的方式 比如，我们导入jquery 对比这个目录和前面的SpringMVC找资源的路径是一致的 那么 请求的路径就应该是（这里以请求jquery.js文件为例） 同时，还可以在配置文件中设置和静态资源有关的参数 查看SpringMVC的自动配置类，当浏览器访问路径是/** 进入到这个方法中 查看staticPathPattern，得知访问路径是/** /** 表示访问当前项目的任何资源，如果没有其他的处理器（比如上面的webjars会处理 /webjar/** ）处理，就去图中的位置找资源 进入getResourceLocations(this.resourceProperties.getStaticLocations())方法中，这个方法就是获取资源路径的 查看其中的参数 最终看到的路径是 另外还有一个是当前项目的根路径/ classpath：类路径，包括main下面的java和resources目录 所以，可以保存静态资源的目录如下图 上面的几个文件夹就是静态资源文件夹，表示，你访问的静态资源的路径如果没有人处理的话，就会去这些路径下找这些静态资源 比如，静态资源的路径 访问路径localhost:/xxx 就会去静态资源文件夹中找xxx 配置欢迎页映射 欢迎页默认的文件名是index.html，在静态资源目录下 在配置文件中也可以指定我们自己定义的静态文件存放的目录 这样配置之后，那么SpringBoot中默认的配置的静态资源的路径就失效了 模板引擎上面的介绍都是请求的静态资源，不方便后面展示数据（不像JSP，可以对查出来的数据进行遍历展示），但是SpringBoot默认是jar包的打包方式并且使用的嵌入式的Tomcat，所以默认不支持JSP，这就有了模板引擎。 模板引擎简介 常见的模板引擎 JSP、Velocity、Freemarker、Thymeleaf 模板引擎的原理 解析模板中的表达式，将数据填充进去，生成一个最终的文件 Thymeleaf模板引擎 SpringBoot推荐的Thymeleaf；语法更简单，功能更强大； 使用Thymelaf 引入依赖 &lt;!--引入模板引擎Thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; Thymeleaf如何使用 查看SpringBoot自动配置类中的关于Thymeleaf的类 配置类 表示的意思就是 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； Thymeleaf入门官方文档 在HTML页面中引入Thymeleaf的命名空间 &lt;html lang=&quot;en&quot; xmlns:th=&quot;https://www.thymeleaf.org&quot;&gt; 演示 Controller层 加入Thymeleaf组件之后，return不再去static静态资源目录下找对应的页面了 而是去templates目录下找对应的页面 success.html页面需要放在templates目录下 th:text的作用是将标签中的内容设置为表达式中的内容 访问页面 获取到数据了 Thymeleaf的语法规则 th:html的任意属性，用来替换原生属性的值 比如 那么我们访问的额页面中的各个属性就是Thymeleaf替换过后的值 常用的属性有 表达式语法 $&#123;...&#125;：获取变量值，支持OGNL表达式 获取对象的属性、调用方法 使用内置的基本对象： ctx : the context object.vars: the context variables.locale : the context locale.request : (only in Web Contexts) the HttpServletRequest object.response : (only in Web Contexts) the HttpServletResponse object.session : (only in Web Contexts) the HttpSession object.servletContext : (only in Web Contexts) the ServletContext object. 使用示例：$(seeeion.id) 内置的一些工具对象 execInfo : information about the template being processed.messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.uris : methods for escaping parts of URLs/URIsconversions : methods for executing the configured conversion service (if any).dates : methods for java.util.Date objects: formatting, component extraction, etc.calendars : analogous to #dates , but for java.util.Calendar objects.numbers : methods for formatting numeric objects.strings : methods for String objects: contains, startsWith, prepending/appending, etc.objects : methods for objects in general.bools : methods for boolean evaluation.arrays : methods for arrays.lists : methods for lists.sets : methods for sets.maps : methods for maps.aggregates : methods for creating aggregates on arrays or collections.ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). *&#123;...&#125;：选择表达式：和$&#123;...&#125;在功能上是一样； *&#123;...&#125;算是在$&#123;...&#125;功能的基础上进行的增强 不使用*&#123;...&#125;的话 需要这样写 @&#123;...&#125;：定义URL； ~&#123;...&#125;：片段引用表达式 SpringMVC自动配置以及扩展SpringBoot中已经自动配置好了SpringMVC，我们可以直接使用，用法参考官方文档 SpringBoot对SpringMVC做的自动配置 分析SpringBoot对SpringMVC的自动配置SpringBoot自动配置好了SpringMVC，以下是SpringBoot对SpringMVC的默认配置： SpringMVC的自动配置类WebMvcAutoConfiguration 其实实现自动配置的功能是他的内部类WebMvcAutoConfigurationAdapter（自动配置适配器）中的方法实现的 根据官方文档进行分析 包含ContentNegotiatingViewResolver和BeanNameViewResolver。 自动配置了ViewResolver（视图解析器），视图解析器的作用就是根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发或者重定向） 可以看到自动配置类中viewResolver方法的返回值就是ContentNegotiatingViewResolver视图解析器对象，上面的注解@Bean将这个对象注入到容器中 这个方法是自动配置类的内部类中的方法 那么ContentNegotiatingViewResolver视图解析器是如何解析视图的呢？ 先看第1步获取候选的视图对象的方法getCandidateViews(viewName, locale, requestedMediaTypes) 所以，ContentNegotiatingViewResolver的作用就是：组合所有的视图解析器的； 回到自动配置类的内部类中，查看配置视图解析器的逻辑 首先，创建了一个视图解析器对象 查看这个视图解析器类 其中用到了视图解析器，那么这些视图解析器是如何获取的呢 那么viewSolvers变量中存储的就是所有的视图解析器了 所以，如果我们自己需要定制视图解析器的话，我们就可以向容器中添加一个视图解析器，那么ContentNegotiatingViewResolver就会将这个视图解析器自动组合进来 测试自己添加视图解析器 我们发送的任何请求，都会先经过DispatcherServlet中的doDispatch方法中，在这个方法处打断点，查看DispatcherServlet中使用到的视图解析器是什么 Debug启动，使用浏览器发送一个请求 可以看到我么自定义的ViewResolver也被添加进去了 支持静态资源的访问，包括对Webjars的支持 自动注册Converter，GenericConverter和Formatter类。 Converter：转换器，用于类型转换 比如，我们的请求中携带的数据是一个对象的JSON数据，但是方法中是一个对象，那么如何将String类型的数据转换为一个对象呢？ 这种场景就使用到了转换器，SpringBoot已经帮我们配置好了转换器 Formatter：格式化器 页面带来的数据转换为对应的格式，比如需要将请求中的2020.06.02转换为2020/06/02的形式。 这里涉及到两步，首先需要对类型进行转换，然后再对格式进行转换。 对于转换器和格式化器，如果需要自定义的话，我们只需要将其加入到容器中即可 支持HttpMessageConverters 消息转换器：用来转换SpringMVC中消息请求和响应的数据格式的，比如方法的返回值是一个对象，如何转换为JSON数据返回呢 这个小的配置类中只有一个有参构造方法，所以这些参数都是从容器中获取的，其中ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider变量中存储的就是HttpMessageConverters 查看这个HttpMessageConverters 也就是说，HttpMessageConverter是从容器中获取的 如果我们需要自定义HttpMessageConverter，我们只需要将其加入到容器中即可 官方文档中也是如此 自动注册MessageCodesResolver：用于定义错误代码生成规则 自动使用ConfigurableWebBindingInitializer：用于初始化Web数据绑定器，比如将请求中的数据绑定到JavaBean，其中功能包括，格式转换以及格式化 以上只是SpringBoot对web中的MVC进行配置，我们可以到SpringBoot的自动配置类中查看对web模块的所有配置 通过上面对于web中MVC模块的分析，我们可以得到一个修改SpringBoot中默认配置的模式 SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component） 如果有就用用户配置的，如果没有，才自动配置； 如果有些组件可以有多个（比如ViewResolver）将用户配置的和自己默认的组合起来； 扩展SpringMVC 继续查看官方文档中的内容 如果需要更多的功能，我们可以编写一个配置类（Configuration），是WebMvcConfigurer类型的，但是不添加@EnableWebMvc，通过这个方法对SpringMVC进行功能上的扩展，这样既保留了自动配置的功能，同时还可以使用我们扩展的功能 实现一个自定义的配置 创建一个配置类，使用注解@Configuration表明当前类是一个配置类，同时这个类还需要是WebMvcConfigurer（接口）类型的 由于Spring5.0之后（或者SpringBoot2.x）开始支持Java接口的默认实现，所以这里有些不一样的地方 在更新之前 我们使用的是WebMvcConfigurer的抽象的实现类WebMvcConfigurerAdapter 我们在自定义的配置类中就可以通过继承WebMvcConfigurerAdapter来实现我们需要的功能 由于Java的版本更新，在Java 8中，可以使用default关键词为接口添加默认的方法，查看接口中的方法，其实是与上面的抽象类中的方法一样 在更新之后，可以直接实现WebMvcConfigurer这个接口 下面都以更新之后进行举例，其实大体上二者差别不大 需要扩展什么功能，就实现什么方法 比如这里我们扩展视图控制器 当我们请求/test的时候，也跳转到success页面 扩展实现的原理 WebMvcAutoConfiguration是WebMVC的自动配置类 在这个自动配置类中内部类WebMvcAutoConfigurationAdapter实现了WebMvcConfigurer这个接口，也就是上面我们自定义的配置类实现的接口。 顺便说一句话，我们之前的静态资源映射就是调用的这个内部类中的方法实现的 查看上面的内部类的注解@Import(EnableWebMvcConfiguration.class)，也就是说在做自动配置的时候（包括SpringBoot的自动配置和我们自定义的配置），会导入EnableWebMvcConfiguration这个类 查看这个EnableWebMvcConfiguration类，又是一个自动配置类的内部类 查看这个内部类的父类 @Autowired作用在方法上表示方法的参数需要去容器中获取 这个方法表示将容器中所有的类型为WebMvcConfigurer的bean存储在这个列表中 然后调用的是WebMvcConfigurerComposite类中对应的方法 这些方法都是遍历容器中的所有的WebMvcConfigurer，然后调用每个WebMvcConfigurer里面对应的方法，从而让这些配置生效 比如说，我们有两个自定义的配置类都实现了WebMvcConfigurer接口，其中都有addViewControllers这个方法，那么上图中就会调用addViewControllers这个方法将我们定义的两个配置类中的方法生效。 在SpringMVC的自动配置类中，也实现了WebMvcConfigurer这个接口，所以上面的@Import(EnableWebMvcConfiguration.class)不仅会把我们自定义的配置生效，同时自动配置也会生效 总的来说，就是SpringMVC自动配置和我们自定义的配置都会生效 全面接管SpringMVC 在我们自定义的配置类上加上注解@EnableWebMvc，SpringMVC的自动配置全部失效，使用的都是我们自定义的配置 原理分析 查看@EnableWebMvc这个注解 导入了DelegatingWebMvcConfiguration这个类 继承自WebMvcConfigurationSupport 再看自动配置类 表示如果容器中没有WebMvcConfigurationSupport这个组件那么配置就生效 但是我们使用的@EnableWebMvc这个注解已经间接向容器中导入了这个组件，所以自动配置就失效了 导入的WebMvcConfigurationSupport中包含了SpringMVC最基本的功能； 修改SpringBoot默认配置的思想 通过上面对于web中MVC模块的分析，我们可以得到一个修改SpringBoot中默认配置的模式 SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component） 如果有就用用户配置的，如果没有，才自动配置； 如果有些组件可以有多个（比如ViewResolver）将用户配置的和自己默认的组合起来； 在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 Restful风格 CRUD练习引入静态资源 引入资源 访问首页 没有引入Thymeleaf依赖的时候 引入Thymeleaf进来之后 使用我们之前的扩展MVC的方式来实现页面的跳转 测试 两个访问路径都可以访问到页面 静态资源中的href和th:href，其他src也是同理 比如：&lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/sgin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; 在默认项目路径为空（ContextPath）时，打jar包单独运行时，二者效果一致。 在使用Maven内嵌Tomcat或打war包部署到Servlet容器（Tomcat服务器），或者在项目内执行App启动类，且有配置项目路径时。 二者区别如下： href始终从端口开始作为根路径，如https://localhost:8080/asserts/css/signin.css th:href会寻找项目路径作为根路径，如https://localhost:8080/自动添加项目路径/asserts/css/signin.css 不使用th:xxx的时候 虽然设置了contextPath，但是这个资源的路径还是使用的是相对路径 添加th:xxx之后 路径会自动带上contextPath 国际化配置 国际化功能使页面显示的信息不仅可以通过浏览器的默认语言进行设置，还可以通过页面中的中英文进行切换 SpringMVC中的国际化实现 编写国际化配置文件 使用ResourceBundleMessageSource管理国际化资源文件 在jsp页面使用fmt:message取出国际化内容 SpringBoot中的国际化实现（以登录页面为例） 编写国际化配置文件，将页面中需要国际化显示的消息抽取出来 创建properties配置文件，在resources目录下创建i18n目录，创建默认的配置文件login.properties中文配置文件login_zh_CN.properties和英文配置文件login_en_US.properties 创建默认的配置文件和中文的配置文件之后，IDEA会识别我们是在做国际化，会将目录生成用于配置国际化的设置 将login.html页面中需要国际化的消息抽取出来 使用IDEA提供的Resource Bundle视图来配置不同语言的国际化消息 login.properties是当没有指定语言的配置信息时，默认显示的 抽取页面中的消息并进行配置 查看SpringBoot为我们自动配置的处理国际化的自动配置类 查看类MessageSourceAutoConfiguration basename就是去除国家和语言的基础名 进入配置类中可以发现basenamem默认是messages 所以，其实我们的配置文件可以直接放在类路径下叫messages.properties；这样我们就可以在不需要做任何配置的情况下使用国际化功能了 我们的配置文件放在/resources/i18n目录下了，可以通过配置来指定国际化配置 在页面中设置国际化内容 Thymeleaf中使用#&#123;...&#125;获取国际化内容 运行程序 因为浏览器默认使用的语言是中文 可见 使用的并不是默认配置 而是中文语言的配置 将浏览器的语言设置为英文 使用的就是英文国际化的配置 通过页面中的按钮来实现国际化 上面的效果是根据浏览器的语言信息来实现国际化的功能的，那么如何实现通过点击页面中中文 English来实现对应的国际化的显示呢 实现原理：SpringMVC中的Locale（区域信息对象）中的LocaleResolver（区域信息解析器） 查看Mvc自动配置类中的LocaleResolver 查看AcceptHeaderLocaleResolver类中处理区域信息解析器的方法，根据请求头中的Accept-language来获取国际化环境 查看请求头 也就是说 SpringBoot默认的区域信息解析器是通过从请求头中获取区域信息的 所以我们如果通过按钮来切换国际化的话，我们就需要使用自定义的区域信息解析器 首先，根据我们点击不同的按钮中携带不同的参数来区分当前是哪个区域信息 使用Thymeleaf之后，需要这样写 点击按钮 查看浏览器中的路径 实现自定义的区域信息解析器 如何使用自定义的区域信息解析器 查看自动配置类 所以 我们只需要将我们自定义的区域信息解析器注入到容器中 注意这个方法名 必须为localeResolver 因为不配置Bean的名字的话，默认是方法名注入到容器中。只有这样，自动配置类中的@ConditionalMissingBean才能生效 登录功能提示：当我们修改了页面之后，不重新启动程序，实时显示页面的话 禁用Thymeleaf的缓存 重新编译 Command+F9，重新编译 修改login.html页面中表单提交到的路径 编写LoginController 这里是简单模拟登录，用户名不为空，密码为123456即可 点击登录之后 看到请求路径是/user/login 点击登录 登录成功 页面样式未加载 登录失败 需要将msg显示在页面上 登录失败的时候 重新回到login页面 并显示错误提示信息 解决表单重复提交的问题 当登录成功之后，在页面刷新 出现的问题就是 表单会重复提交 这样出现的原因就是 在发送请求的时候是POST请求 然后转发到dashboard页面的 所以刷新的时候会重新发送这个请求 那么表单就重复提交了 解决方法：重定向到dashboard页面 然后将main.html映射到dashboard 查看页面 样式也正常显示 使用拦截器进行登录检查 上面虽然解决了表单重复提交的问题 但是我们直接在其他浏览器直接请求 https://localhost:8080/main.html的时候，也可以成功访问，这样就跳过了登录验证 那么 如何验证用户已经登录呢 在login方法中存储登录的用户的session 创建拦截器类 并添加到容器中 将自定义的拦截器添加到容器中 并设置拦截路径 测试 直接复制登录之后的链接到另一个浏览器中 由于没有session信息 那么就会被拦截 员工列表CRUD（Restful风格实现） Restful方式实现的增删改查和以前用的请求的区别 URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 Restful CRUD请求参考 页面的公共部分抽取 图中的红色框中的部分是每个页面都重复的部分 我们可以抽取出来 然后再在每个需要使用的地方插入公共部分即可 参考Thymeleaf 抽取公共代码片段 插入公共代码片段 其中~&#123;&#125;可以省略 插入片段的语法规则 ~{templatename::selector}：模板名::选择器~{templatename::fragmentname}:模板名::片段名 插入片段的三种方式和各自的区别 th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 公共片段 &lt;footer th:fragment=&quot;copy&quot;&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt; ----------------------------------- 引入方式 &lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt; 效果 &lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt; &lt;/div&gt; ----------------------------------- 引入方式 &lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt; 效果 &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt; ----------------------------------- 引入方式 &lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt; 效果 &lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/div&gt; 审查dashboard获取页面的侧边栏 抽取topbar作为公共代码片段 这里使用的方式~&#123;templatename::fragmentname&#125;:模板名::片段名 在list.html页面引用公共片段 审查元素 审查元素抽取侧边栏 这里使用的方式~&#123;templatename::selector&#125;：模板名::选择器 在list页面使用选择器插入公共代码片段 dashboard.html页面请求 对应的Contoller 以及转发到的页面 引入片段的时候传入参数 可参数化的片段签名 在上面的功能中还存在一个问题，当我们点击员工列表的时候，没有高亮显示 查看dashboard.html页面 DashBoard高亮显示是由于这个class中的active 为了更加简便 把所有的公共部分单独放在一个页面中 在list和dashboard都引入topbar和sidebar 这样大大简化了代码 高亮显示实现 在bar.thml中抽取的片段中根据参数来动态修改class属性值 然后在引用的时候带上不同的参数 将查询到的员工数据展示在页面上 查看之前的Controller 在页面上进行展示 员工添加 首先点击添加按钮，来到添加页面 点击添加按钮 发送请求 转发到add.html页面 在页面中获取select标签的option 填写数据，然后提交，进行员工的添加 修改页面，使用post提交表单，同时name属性值需要与Employee中的属性对应，这样在Controller中才能正确封装（不额外使用注解） Controller 保存用户，并重定向到之前的用户列表页面 测试 存在的问题 日期格式 结果报错400 是因为提交的日期格式不正确 日期的格式化：SpringBoot已经自动配置了日期格式化器 我们可以在配置文件中设置，默认是yyyy/MM/dd 员工修改 点击编辑按钮，来到修改页面 然后 在Controller中根据用户的id查询用户封装到request域中 然后转发到编辑页面 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 比如上图中的方法参数id域请求中的id绑定在一起 在编辑页面显示员工的数据 修改用户 并提交 由于form表单只支持post和get的方式 这里的请求需要的是put方式 如何在页面发送put请求呢？ SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的，我们在配置文件中开启就可以使用了spring.mvc.hiddenmethod.filter.enabled=true），功能就是将请求转为指定的方式 页面创建一个post表单 创建一个input项，name=”_method”;value就是我们指定的请求方式 修改用户的方法 我们实现的save方法来实现用户的修改 由于需要知道修改的用户的id，而表单中没有这个字段，所以添加一个id字段 修改用户 测试可以成功修改 员工删除 页面发送delete请求 Controller中删除，并重定向到员工列表页 优化 使用js动态添加form 错误处理机制SpringBoot默认错误处理 当我们使用浏览器请求不存在的资源时 默认错误页面 当我们使用Postman发送请求的时候 SpringBoot为我们响应的是JSON数据 查看SpringBoot的默认配置类 配置嵌入式Servlet容器使用外置的Servlet容器","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.chasingwind.top/categories/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.chasingwind.top/tags/SpringBoot/"}],"author":"ChasingWind"},{"title":"SpringBoot日志","slug":"SpringBoot日志","date":"2020-07-03T05:39:05.000Z","updated":"2021-03-04T00:55:47.934Z","comments":true,"path":"2020/07/03/SpringBoot日志/","link":"","permalink":"https://www.chasingwind.top/2020/07/03/SpringBoot%E6%97%A5%E5%BF%97/","excerpt":"SpringBoot的日志框架包含多种多样，我们在比较各种日志门面和日志实现之后，一般选用SLF4J来作为日志门面实现系统的日志功能，我们需要理解日志门面和日志实现之间的区别。","text":"SpringBoot的日志框架包含多种多样，我们在比较各种日志门面和日志实现之后，一般选用SLF4J来作为日志门面实现系统的日志功能，我们需要理解日志门面和日志实现之间的区别。 日志框架介绍 日志是什么 日志：记录系统实时运行状态的信息。 日志门面和日志实现 日志门面：是日志实现的抽象层。 日志实现：具体的日志功能的实现。 对比JDBC和数据库驱动的关系 日志框架中的日志门面就相当于JDBC 而各种数据库驱动就相当于各种日志实现 为什么不直接使用日志实现，而是又弄了一个叫日志门面的东西？ 为了在应用中屏蔽掉底层日志框架的具体实现。这样的话，即使有一天要更换代码的日志框架，只需要修改jar包，最多再改改日志输出相关的配置文件就可以了。这就是解除了应用和日志框架之间的耦合。 常见的日志框架包含：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4JJUL（java.util.logging） Log4j2 Logback 我们选用的是日志门面的是SLF4J；选择的日志实现是Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL； SpringBoot选用 SLF4j和Logback； 我们在使用的时候直接使用日志门面而避免使用日志实现。 SLF4J的使用 如何使用SLF4J？ 参考SLF4J官方文档 由于每一种日志实现都有自己的配置文件，使用SLF4J日志门面后，配置文件中需要配置的是日志实现的配置。 遗留问题 在以前的各种框架中，使用的日志系统都是不一样的，那么怎样统一呢 比如，系统使用的日志框架（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis 如何将日志都统一到slf4j？ 将系统中其他日志框架的依赖先排除出去（比如，使用Spring框架的时候，让他不导入commons-logging，但是不导入的话就运行不起来了，所以需要第2步） 用中间包来替换原有的日志框架（包名和类名与之前的都是一样的，但是底层已经换成了SLF4J的实现） 我们导入slf4j其他的实现 参考 对于JCL，Log4J和JUL来说， commons-logging和java.util.logging commons-logging和log4j SpringBoot中的日志关系 SpringBoot中日志功能的底层依赖关系 在pom.xml中右键 查看依赖之间的关系 黄框中可以看出：jul和log4j都是借用适配层的jar文件作为中间者，最后依赖抽象层log4j 总结： SpringBoot底层使用的是slf4j日志门面和logback日志实现来进行日志的记录功能 SpringBoot也把其他的日志通过中间替换包都转换为slf4j 中间替换包 比如，查看jul-toslf4j.jar中的SLF4JBridgehandler Adds a SLF4JBridgeHandler instance to jul’s root logger. 表示将SLF4JBridgeHandler作为jul的实例，也就是说jul这个时候其实已经是SLF4J了 如果引入其他框架，一定要把这个框架中的默认日志依赖移除 因为不移除的话，引入的框架中的jar包的包名和类名都会和中间替换包的包名和类名相同，这样的话就会出现依赖冲突 Spring框架使用的是commons-logging，查看他的依赖 exclusion：移除依赖 也就是说，当我们引入其他框架的时候，首先需要把其中自带的日志依赖移除 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可； 日志使用 使用SpringBoot的默认配置 不需要任何配置，直接使用 日志级别：由低到高排序为， trace&lt;debug&lt;info&lt;warn&lt;error 日志级别可以进行调整，调整之后，日志只会输出这个级别以及比这个级别高级别的日志。 日志级别的使用场景：当我们在上线应用的时候，调整输出的日志级别为info，这样日志中就不显示trace和debud的日志信息 测试SpringBoot的日志级别 发现SpringBoot的默认日志级别是info 调整默认日志级别，在配置文件中设置edu.ahnu包下的日志级别为trace 没有指定级别的就用SpringBoot默认规定的级别；root级别（info） 可见，trace也已经输出 上面的配置的话 只能将日志信息打印在控制台 通过配置文件配置日志的输出路径以及文件名 还可以配置日志的输出格式 没有配置之前的格式 配置控制台和日志文件中的格式 配置之后的控制台的日志格式 配置格式参考 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n 查看默认配置 指定配置文件 参考官方文档 给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 不同日志实现使用的配置文件的命名 Spring更加推荐的命名是：使用日志实现-spring.xml命名的配置文件 原因如下（以日志实现logback为例）： logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能（比如指定当前的运行环境） 如在logback-spring.xml使用springProfile标签指定不同环境时候的日志样式： &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 切换日志框架 SpringBoot默认使用的是SLF4J+logback的日志框架（以下切换全都不推荐，只是用来明白切换的原理） slf4j+log4j 首先 分析整个依赖树，排除默认使用的logback 然后 去除 log4j-over-slf4j.jar的依赖（因为我们现在需要换成这个） 到现在为止，就把其他的日志门面转换为了slf4j 然后 导入适配层slf4j-log4j12.jar，适配层的依赖同时也把日志实现的log4j的依赖导入了 加入loa4j.properties在resources中即可使用 slf4j+log4j2 默认的日志starter使用的是spring-boot-starter-logging 先把默认的日志starter排除，然后直接添加依赖spring-boot-starter-log4j2的依赖","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.chasingwind.top/categories/SpringBoot/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://www.chasingwind.top/tags/%E6%97%A5%E5%BF%97/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.chasingwind.top/tags/SpringBoot/"}],"author":"ChasingWind"},{"title":"SpringBoot基础","slug":"SpringBoot基础","date":"2020-07-03T05:39:00.000Z","updated":"2021-03-04T00:55:39.590Z","comments":true,"path":"2020/07/03/SpringBoot基础/","link":"","permalink":"https://www.chasingwind.top/2020/07/03/SpringBoot%E5%9F%BA%E7%A1%80/","excerpt":"本节介绍了SpringBoot的基础内容，包括对SpringBoot的简介，以及配置的介绍。主要包括SpringBoot是如何实现自动配置的，这是必须要掌握的内容。","text":"本节介绍了SpringBoot的基础内容，包括对SpringBoot的简介，以及配置的介绍。主要包括SpringBoot是如何实现自动配置的，这是必须要掌握的内容。 SpringBoot简介 SpringBoot官网 SpringBoot简化Spring的开发流程，可以整合各种框架，来完成企业级开发 SpringBoot帮我们自动配置好相关环境，我们只需要简单配置即可 SpringBoot的优点 快速创建独立运行的Spring项目以及主流框架的集成，配置很简单 使用嵌入式的Servlet，不需要像之前一样安装Tomcat服务器，打成war包才能运行，而是打包成jar包，直接使用java -jar命令运行程序 starters启动器帮助我们完成自动依赖和版本控制，比如：我们需要使用JDBC，就不需要我们导入各种相关的jar的依赖，而是使用starters即可 大量的自动配置。简化开发，也可以修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 与Spring的关系 SpringBoot帮助我们整合各种框架，我们作为用户直接使用SpringBoot即可，但是需要我们掌握Spring的相关知识 微服务（MicroServices）架构风格 单体应用程序 传统的应用的优点：开发，测试，部署以及负载均衡比较容易 但是缺点也很明显：随着需求的增长，软件会越来越大，并且如果某一块有问题了，那么整个应用就需要重新打包，再进行部署 微服务应用 一个应用应该是一组小型服务，每个服务之间通过HTTP来进行互通 每一个功能单元之间是相互独立的，每一个服务都是可以替换和独立升级的单元 缺点就是：部署和运维比较困难，其实这个就相当于是一个大的分布式应用 SpringBoot构建微服务 使用SpringBoot构建我们的应用 使用SpringCloud来完成服务之间的互连，来完成分布式 SpringCloud Data来完成数据的流式处理 入门程序 创建Maven项目，这里创建的是简单的Java项目（后面会直接使用SpringBoot Initializer来快速创建） 导入依赖，这里依赖的版本是统一管理的 &lt;!--统一为SpringBoot的启动器约定版本信息--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写主程序，启动SpringBoot应用 编写相关的Controller和Service 我们不需要再进行相关的配置 编写Controller @ResponseBody注解 @ResponseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。 启动主程序 我们不需要配置Tomcat就可以进行访问 在启动日志中可以发现 Tomcat已经默认配置好的 访问hello 部署程序 在pom.xml中添加SpringBoot的Maven插件 &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 使用package插件打包 运行jar包 使用命令java -jar 我们本地并没有安装Tomcat服务器，这个程序是怎么运行并可以访问的？ 我们打开这个jar包 在BOOT-INF目录下 classes目录下是我们编写的程序 lib目录下 是相关的jar包 其中就有SpringBoot嵌入式的Tomcat以及Tomcat 入门程序分析 pom.xml中的spring-boot-starter-parent依赖 我们的项目中的pom.xml中依赖的SpringBoot所有启动器（starter）的父项目 点击上图中的artifactId的属性值进入 启动器的父项目中 再点击上图中的artifactId 进入到spring-boot-dependencies中 可以看到使用到的依赖 其中就规定了使用到的依赖的版本信息 而不需要我们再手动配置 被称为 SpringBoot的版本仲裁中心 以后我们导入依赖默认不需要写版本号 当然，在dependencies中没有规定的依赖还是需要我们手动配置的 导入的spring-boot-starter-web依赖 spring-boot-starter-web：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； spring-boot-starters 当我们点击进去之后 可以发现spring-boot-starter-web依赖的父项目是spring-boot-startes（SpringBoot版本为1.5.9，版本2.3.0中没有这个依赖） Spring-boot-starts中有许多模块，详细的介绍看下面的第3点 spring的web相关的依赖 同时还依赖web相关 Spring-boot-starters介绍 官网文档 SpringBoot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器，其中，版本由SpringBoot统一控制 主程序类 @SpringBootApplication @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 进入到这个注解中 发现其中包含很多注解，其中两个重要的注解见图 @SpringBootConfiguration @SpringBootConfiguration：Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类； 进入到这个注解中 发现其中还有一个我们比较熟悉的注解 @Configuration：标注当前类为配置类，使用注解的方式替换以前的配置文件 点进去注解 发现其实**@Configuration** 就是容器中的一个组件 @EnableAutoConfiguration @EnableAutoConfiguration：开启自动配置的功能，以前我们需要配置的东西，SpringBoot帮我们自动配置 进入到注解中 其中有 @AutoConfigurationPackage 注解@AutoConfigurationPackage：自动配置包，作用就是：将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； 进入到这个注解中 注解@Import(AutoConfigurationPackages.Registrar.class)：Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class来判断该导入哪些组件； 进入到Registrar类中 Debug启动 查看获取到的结果 使用IDEA的计算功能 计算参数new PackageImport(metadata).getPackageName() 由此可得：@AutoConfigurationPackage注解的作用就是将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； 同时，如果类不在主配置类所在的包及其子包下的话 即使使用了IoC容器的注解 也是无法扫描到的 @Import(EnableAutoConfigurationImportSelector.class) 给容器中导入EnableAutoConfigurationImportSelector.class这个类选择的组件 EnableAutoConfigurationImportSelector：导入组件选择器，选择导入哪些组件 查看他的父类 父类中的方法selectImports() 返回一个String数组，其中存储的就是组件的全类名 作用就是告诉Spring容器导入哪些组件 Debug查看数组中有哪些组件 发现组件名都是（xxxAutoConfiguration） 自动配置类，作用就是给容器中导入这个场景所需要的组件，并进行自动配置 有了这些自动配置类，就免去了我们手动编写配置注入组件等工作 这些自动配置类从哪里得到的 上面的selectImports() 方法中调用的方法getCandidateConfigurations 获取候选的配置文件 进入到此方法中 其中调用的方法（第一个参数的值就是EnableAutoConfiguration.class） SpringFactoriesLoader.loadFactoryNames( EnableAutoConfiguration.class,getBeanClassLoader()); 进入到loadFactoryNames 那么 这个第一步中的资源 在哪里呢 查看类路径下的配置文件 仔细观察发现 这里的自动配置的类与我们之前Debug时候的selectImports方法获取的组件的数组是一样的 所以SpringFactoriesLoader.loadFactoryNames这个方法的作用就是从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的工厂名。 在此基础之上，然后将这些获取到的工厂名作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们实现； 这些自动配置类所在的包 各个注解之间的关系 快速创建SpringBoot应用 选择使用Spring Initializer创建项目，并选择JDK版本 设置相关的信息 选择需要使用的模块 设置项目名，就可以完成整个项目的创建 查看pom文件 测试 删除用不到的文件 在测试的Controller中 上面的两个注解可以使用一个注解代替 点进去查看 查看项目的资源文件夹（resources） static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； SpringBoot配置配置文件 SpringBoot使用一个全局配置文件，在resources目录下，配置文件的名称是固定的，但是有两种文件格式都可以使用 application.properties application.yml 配置文件的作用是修改SpringBoot自动配置的默认值 YAML简介 YAML：YAML Ain’t Markup Language YAML A Markup Language：是一个标记语言 YAML isn’t Markup Language：不是一个标记语言； XML和YAML对比 YAML server: port: 8081 XML &lt;server&gt; &lt;port&gt;8081&lt;/port&gt; &lt;/server&gt; YAML：以数据为中心，比json、xml等更适合做配置文件，不用带标签名； YAML基本语法 基本语法 key:（空格） value 来表示一对键值对（必须有空格） 以空格的缩进来表示层级关系，只要是左对齐的一列数据，都是同一层级的 server: port: 8081 path: /hello 这里的port和path表示的就是同一层级 同时 属性和值都是大小写敏感的 值的分类 字面量：普通的值（数字，字符串，布尔类型） key：value，字面值直接写 字符串类型不需要写引号，如果写的话，单引号和双引号的表示意义是不一样的 单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: ‘zhangsan \\n lisi’：输出；zhangsan **\\n** lisi 双引号：不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: &quot;zhangsan \\n lisi&quot;：输出；zhangsan **换行** lisi 对象、Map（键值对） 缩进写法 friends: lastName: zhangsan age: 20 行内写法 friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set） 缩进写法 pets: - cat - dog - pig 行内写法 pets: [cat,dog,pig] 使用YAML配置文件注入值 创建一个对象，其中包含各种类型的数据 编写application.yml，其中设置person的各种属性的值 导入配置文件处理器，以便在编写配置文件的时候有提示信息 在下面的第3步配置完成后 重新启动SpringBoot的主程序才能有提示 &lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 将配置文件中的属性值映射到Person中 由于这个配置文件是SpringBoot的全局配置文件，我们要怎样把其中的属性值映射到Person类中的属性上呢？ @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； 参数prefix = “xxxx” 将配置文件中的xxx属性（第一层级）下的值进行一一映射，因为配置文件中可能不止一个配置信息，比如上面的配置中包含server和person，所以需要指定注入哪个数据 同时 只有在容器中的组件才能使用Spring中提供的组件 所以这个类还必须加入到容器中 测试 获取设置的属性值 可以正确获取到属性值 使用properties配置文件注入值 编写配置文件，设置属性值 运行测试类 发现中文乱码 解决中文乱码的问题 由于IDEA默认使用的是utf-8 而properties之前使用的都是ASCII码 所以修改一下运行时的编码方式就可以了 表示的是需不需要把properties文件在运行的时候转换为ASCII码 重新测试 使用@Value注解的方式注入值 @Value注解 以前在xml文件中 为属性注入值 &lt;bean class=&quot;Person&quot;&gt; &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 在类中使用的话 @Value和@ConfigurationProperties对比 松散语法： 比如为Person类中的成员变量firstName注入值 以下三种方式都是可以的 JSR303数据校验 首先 加入依赖 &lt;!--添加JSR303依赖 用于校验功能--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 然后 在类上面使用@Validated注解 在需要校验的参数上使用需要校验的类型 比如 我们在firstName上使用注解@Email 就会对注入的值进行校验 当发现注入的值不是邮箱类型的时候 就会报错 两个注解我们如何进行选择 我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； @PropertySource和@ImportResource在前面为Person类注入的时候，使用的注解@ConfigurationProperties默认使用的是全局配置文件，但是这个全局配置文件中并不适合把所有的配置信息都放在里面。所以我们可以把与SpringBoot无关的配置单独放在其他的配置文件中，然后使用下面的注解指定配置文件对数据进行注入。 @PropertySource：加载指定的配置文件 我们把application.yml中的配置删除之后，将其中的配置放在一个新的配置文件中 @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；此注解标注在一个配置类上 SpringBoot中没有Spring的配置文件，同时我们自己编写的配置文件也不能使用 之前我们使用配置文件的方式向IoC容器中加入组件 测试查看IoC容器中没有注入的组件 在配置类上使用@ImportSource 测试 发现IoC容器中已经注入了我们需要的组件 使用配置类来实现给容器中添加组件 SpringBoot并不推荐使用@ImportSource来实现组件的注入，而更加推荐使用配置类来实现 把@ImportSource注解注释掉之后 创建config配置类文件夹，创建配置类，使用@Bean注解将方法的返回值作为对象添加到IoC容器中，发现成功在IoC容器中注入组件了 配置文件占位符 随机数 测试 使用占位符获取在此之前已经配置的值，如果没有的话使用：指定默认值 测试 配置文件的加载顺序ProfileProfile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境，比如我们在项目中可能使用到的有开发环境，生产环境以及线上环境，而这些配置是不同的，那么就可以使用下面的方式来进行环境的切换 多个profile+激活指定的profile 我们可以在resources目录下编写多个生产环境的profile文件，其中，profile的命名规则如下：application-xxx.properties或者application-xxx.yml 并在主配置文件中指定需要使用的profile是哪一个 yml多个文档块+激活指定的profile 文档块：yml文件中使用---分隔开的配置信息 激活指定的profile 其中的配置才能生效 命令行的方式指定 对于已经打成jar包的 可以在使用命令行运行的时候指定profile java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=xxx（比如：dev）； 在测试的时候，配置传入命令行参数 使用命令行的方式会覆盖之前的激活的profile中的配置 虚拟机参数 -D是固定开头 配置文件的加载位置以及优先级 SpringBoot启动会扫描以下位置的application.properties或者application.yml文件作为Spring Boot的默认配置文件 –file:./config/：项目文件夹下的config文件夹下的配置文件 –file:./：项目文件夹下的配置文件 –classpath:/config/：类路径下的config文件夹下的配置文件 –classpath:/：类路径下的配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置；同时，所有的配置文件之间是互补的关系。 这里并不是说 高优先级中有的配置就不会再去加载低优先级的配置了 SpringBoot会将所有优先级的配置加载进来，如果有相同的配置信息的话，使用的是高优先级中的配置； 如果低优先级中有的配置在高优先级中没有的话，那么这个低优先级中的配置也会生效，也就是说这些配置文件之间是互补的关系。 还可以运行jar包的时候使用spring.config.location来改变默认的配置文件的位置 在运维的时候可能使用的比较多 我们在服务器的本地编写好配置文件 在运行项目的jar包的时候改变默认的配置文件 比如， java -jar 项目名.jar –spring.config.location=配置文件所在的磁盘路径/application.properties 同样的，指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； 外部配置加载顺序 在上面的配置中，都是在开发的时候指定的配置文件，当我们开发好之后也是可以通过在jar包外指定配置文件的 SpringBoot也可以从以下位置加载配置；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 优先级从高到低 命令行参数 项目打包的时候 只打包src目录下的文件 而项目下的除了src目录中的内容是不会打包的 那么可能就存在配置文件在这些目录中的情况 这样的话 就不会生效了 可以使用命令行参数的方式改变配置，比如，修改端口号和访问路径 java -jar 项目名.jar --server.port=8087 --server.context-path=/abc 多个配置用空格分开； --配置项=值 来自java:comp/env的JNDI属性 Java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 6 7 8 9 如何记？ 优先加载带profile的，都有perofile的，优先使用jar包外的application.properties jar包外的配置文件，二者在同一个目录下 运行的时候直接使用java -jar 项目名.jar ，不需要输入任何参数，那么优先使用的配置文件就是这个外部的application.properties @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 自动配置原理（☆☆☆☆☆）在配置文件application.properties和application.yml中可以配置哪些属性呢？ 可以参考官方文档中给出的配置 其实能写在配置文件中的配置都是有依据的，通过对自动配置原理进行分析可以得知 自动配置原理分析（重点） SpringBoot启动的时候加载主配置类，开启了自动配置功能**@EnableAutoConfiguration** @EnableAutoConfiguration的功能 @AutoConfigurationPackage：将SpringBoot主程序所在的包及其子包中的组件扫描进IoC容器中 @Import(AutoConfigurationImportSelector.class)：使用AutoConfigurationImportSelector为容器中导入组件 AutoConfigurationImportSelector类中的方法selectImports selectImports方法调用同一个类中的getCandidateConfigurations方法 getCandidateConfigurations方法获取候选配置,其中使用SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());来获取配置 SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader()); SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象 在第4步已经将META-INF/spring.factories中的内容包装成Properties对象之后 从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中查看META-INF/spring.factories中的EnableAutoConfiguration.class类 查看这些值 都是xxxxAutoConfiguration，也就是自动配置类，这样的每一个类都是一个组件，被加入到容器中，进行自动配置 一句话总结：@EnableAutoConfiguration注解的功能就是，将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；之后，完成自动配置的功能 每一个自动配置类完成自动配置的功能 这里以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理 进入到这个自动配置类中 首先看类上面的注解 @Configuration：表示当前类是一个配置类，代替我们以前使用的配置文件，可以向容器中添加组件 @EnableConfigurationProperties(ServerProperties.class)：启用ServerProperties.class类的ConfigurationProperties功能，并将配置文件中的值和ServerProperties的属性绑定起来。并且把ServerProperties加入到IoC容器中 查看ServerProperties.class类： 其中的@ConfigurationProperties注解的功能就是：从配置文件中获取指定的值和当前类中的属性进行绑定 所以说，在配置文件中可以进行的所有的配置都可以追溯到某一个Properties类中，比如这里的（ServerProperties类） @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)：判断当前应用是否是Web应用，如果是的话，那么这个配置类就会生效；否则不生效 底层使用的是Spring的@Conditional注解，根据不同的条件判断当前配置是否生效，如果满足指定的条件，整个配置类里面的配置就会生效； @ConditionalOnClass(CharacterEncodingFilter.class)：判断当前项目有没有CharacterEncodingFilter这个类以此来决定是否启用这个自动配置类；此类是SpringMVC中进行乱码解决的过滤器； @ConditionalOnProperty(prefix = “server.servlet.encoding”, value = “enabled”, matchIfMissing = true)：判断配置文件中是否存在某个配置 spring.http.encoding.enabled（prefix+value）；如果不存在，判断也是成立的（matchIfMissing = true） 一句话总结：自动配置类会根据当前不同的条件判断，决定这个配置类是否生效。 一旦这个配置类生效，这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； SpringBoot的总结 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； 如果有对应的自动配置类，我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 给容器中自动配置类添加组件的时候，会从对应的xxxProperties类中获取某些属性。这些属性我们就可以在配置文件中进行配置； 通过分析，我们可以看到每一个组件的命名都是统一的 xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； @Conditional注解 在上面分析的过程中，有很多@ConditionalOnXxx注解，底层使用的都是Spring的@Conditional注解，表示必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效； 常见的@ConditionalOnXxx注解 META-INF/spring.factories中的那么多自动配置类并不是都生效的，在这些自动配置类上几乎都有@ConditionalOnXxx注解进行条件的判断，满足的话才能生效 那么，我们怎么知道哪些自动配置类生效了？ 启用SpringBoot的Debug模式生成自动配置报告来了解哪些自动配置类生效了，哪些没有生效 在配置文件中配置Debug模式 启动SpringBoot主程序，查看控制台 启用的： 没有启用的： 不满足条件的：","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.chasingwind.top/categories/SpringBoot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.chasingwind.top/tags/Spring/"},{"name":"SpringBoot入门","slug":"SpringBoot入门","permalink":"https://www.chasingwind.top/tags/SpringBoot%E5%85%A5%E9%97%A8/"}],"author":"ChasingWind"},{"title":"ElasticSearch","slug":"ElasticSearch","date":"2020-07-03T05:38:39.000Z","updated":"2021-03-04T00:45:46.856Z","comments":true,"path":"2020/07/03/ElasticSearch/","link":"","permalink":"https://www.chasingwind.top/2020/07/03/ElasticSearch/","excerpt":"一个基于Lucene开发的全文检索服务器。简称es,es是一个开源的高扩展性的分布式全文检索引擎，实时性的存储、检索数据是它的最大的特点。","text":"一个基于Lucene开发的全文检索服务器。简称es,es是一个开源的高扩展性的分布式全文检索引擎，实时性的存储、检索数据是它的最大的特点。 ElasticSearch基本介绍 ElasticSearch简介 一个基于Lucene开发的全文检索服务器。简称es,es是一个开源的高扩展性的分布式全文检索引擎，实时性的存储、检索数据是它的最大的特点。 ElasticSearch使用案例 Github在2013年抛弃Solr而转为使用ElasticSearch来处理PB级别的数据搜索 新浪处理实时日志 阿里构建自己的日志分析和分析体系 ElasticSearch对比Solr Solr利用ZooKeeper进行分布式管理，而ElasticSearch使用的是自带的分布式协调管理功能 Solr支持更多的数据格式，而ElasticSearch仅支持json格式 Solr官方提供的功能更多，而ElasticSearch更注重核心的功能，高级功能可以通过插件进行扩展 Solr在传统的搜索应用中表现好于ElasticSearch，而在处理实时搜索的时候，ElasticSearch表现更加优秀 查询的原理（倒排索引） 首先，在ES服务器中对文档内容进行分词，并且将分词的内容存储在一个单独的分词库中 当用户去查询数据的时候，会将用户的查询内容进行分词 根据分词的结果去分词库中匹配内容，最终得到的是文档的id 根据id表示去存放数据的地方获取数据 ElasticSearch安装 ElasticSearch在Linux服务器上的安装 下载.tar.gz文件， 使用华为镜像进行下载更快 解压安装包到安装目录 注意一点的是 ElasticSearch使用的是Java开发的，所以需要JDK的支持 7.7.0需要JDK至少为11版本 tar -xvzf elasticsearch-7.7.0-linux-x86_64.tar.gz 解压之后的目录 在lib目录下可以看到，ElasticSearch其实底层使用的是Lucene 修改config文件夹中的配置文件elasticsearch.yml 阿里云服务器的话 必须使用内网ip而不是公网ip 不然启动的时候会报错 同时需要创建data文件夹存储索引库 logs文件夹作为日志文件夹 # ---------------------------------- Cluster ----------------------------------- # # Use a descriptive name for your cluster: #配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。 cluster.name: my-application # # ------------------------------------ Node ------------------------------------ # # Use a descriptive name for the node: #节点名称 node.name: node-1 # ----------------------------------- Paths ------------------------------------ # # Path to directory where to store the data (separate multiple locations by comma): #索引库存储路径 path.data: /usr/local/src/https://blog.chasingwind.top/data # # Path to log files: #日志存储路径 path.logs: /usr/local/src/https://blog.chasingwind.top/logs # # ----------------------------------- Memory ----------------------------------- # # Lock the memory on startup: # #bootstrap.memory_lock: true # # Make sure that the heap size is set to about half the memory available # on the system and that the owner of the process is allowed to use this # limit. # # Elasticsearch performs poorly when the system is swapping the memory. # # ---------------------------------- Network ----------------------------------- # # Set the bind address to a specific IP (IPv4 or IPv6): #设置外网访问 network.host: 阿里云服务器的内网ip # # Set a custom port for HTTP: #对外服务端口号 http.port: 9200 transport.tcp.port: 9300 # # For more information, consult the network module documentation. # # --------------------------------- Discovery ---------------------------------- # # Pass an initial list of hosts to perform discovery when this node is started: # The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;] # #discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;] # # Bootstrap the cluster using an initial set of master-eligible nodes: # cluster.initial_master_nodes: [&quot;node-1&quot;] 启动 到bin目录下启动elasticsearch 启动过程中遇到的错误 启动过程中被Killed，查看日志，发现内存不够，由于ES是运行在JVM上，JVM本身除了分配的heap内存以外，还会用到一些堆外(off heap)内存。 在小内存的机器上跑ES，如果heap划分过多，累加上堆外内存后，总的JVM使用内存量可能超过物理内存限制。 如果swap又是关闭的情况下，就会被操作系统oom killer杀掉。 修改ES中config目录下的jvm.options文件 vim jvm.options将-Xms1g-Xmx1g改为-Xms256m-Xmx256m就启动成功了 内存大小看你自己的情况 我的虚拟机2G的内存 后面安装Kibana的话 给的是256 否则无法启动 启动成功无法访问 为阿里云的实例添加安全组策略 进行访问，使用阿里云的公网ip:9200 ElasticSearch安装界面化工具 使用同为ElasticSearch旗下的页面管理工具Kibana 下载安装，直接使用命令wget https://mirrors.huaweicloud.com/kibana/7.7.0/kibana-7.7.0-linux-x86_64.tar.gz 修改配置文件 配置的是阿里云的私网ip，但是访问的时候，依然使用的是公网ip 同时配置实例的安全组策略 启动bin目录下的kibana 注意 需要在ElasticSearch已经启动的情况下启动 否则无法访问 访问页面 通过公网ip访问Kibana 目前没有索引库中的数据 后面需要进行添加的操作。 设置中文 ElasticSearch和Kibana后台启动 使用./elasticsearch和./kibana命令启动的话，把启动命令页面关闭，那么服务也随之关闭 使用后台启动的方式启动服务 ElasticSearch：./bin/elasticsearch -d Kibana：nohup /usr/local/src/Kibana/bin/kibana &amp; ElasticSearch相关概念 和关系型数据库进行对比 ElasticSearch是面向文档的 关系型数据库 →DataBases（多个数据库）→Tables→Rows→Columns ElasticSearch →Indexes（多个索引库）→Types→Documents→Fields 映射Mapping Mapping映射类似于数据库中表结构的定义，主要作用如下： 定义索引库中的Field域的名字 定义字段类型，比如数值型、布尔型、浮点型等等 定义倒排索引相关的设置，比如，是否索引，是否存储，是否分析 ElasticSearch索引库维护在ElasticSearch 7.x版本中移除了Type，参考移除Type的原因参考 PostMan发送http请求创建索引库 使用PostMan发送http请求创建索引库，并设置Field的Mapping 查看官网示例后发现 7.4 默认不在支持指定索引类型（上面的Type），默认索引类型是_doc（隐含：include_type_name=false） 所以我的服务器安装的7.7的请求是这样的 同时type的名字就是默认的_doc 使用Kibana查看创建的index索引库 可见索引库的type是默认的_doc 使用PostMan向索引库添加Document 指定Document的id 请求的链接中的Type使用默认的_doc，并且为Document指定唯一的id 执行成功 可以看到指定的id在索引库中的字段变为”_id” 不指定Document的id 不指定id的话，ElasticSearch会自动帮我们生成Document的唯一的id 使用Kibana查看索引库中的Document 创建索引模式 创建索引模式 选择index索引库 在这里可以修改Mapping配置 查看索引库中的Document 使用PostMan删除Document 根据Document文档的唯一id删除文档 PostMan发送DELETE请求 删除之前 删除之后 使用PostMan修改文档 由于ElasticSearch底层使用的就是Lucene，所以和Lucene的原理是相同的。先删除文档，而后添加一个新的文档 根据id直接修改文档的内容 使用PostMan进行查询 根据Document的id进行查询 根据关键词进行查询 域Lucene中的TermQuery功能相同 请求体中需要指定关键词所在的域和关键词本身 目前使用的是标准分析器 对于中文的话，一个汉字是一个关键词 响应结果 带分析功能的查询 在ElasticSearch中使用QueryString进行查询，先将查询的语句使用分析器进行分析，之后再根据分析器分析的结果在默认的搜索域中进行查询 功能和Lucene中的QueryParser功能类似 使用PostMan查看分析器的分析效果 通过指定请求中的分析器类型和待分析的语句，在响应中可以查看分析之后的结果 ElasticSearch集成IK-Analyzer中文分析器 下载IK-Analyzer插件,选择和ElasticSearch对应的版本 将插件解压缩，上传到ElasticSearch目录的plugins目录下，并且重启ElasticSearch即可 查看分析效果 IK-Analyzer提供两种分词算法： ik_smart：最少切分 ik_max_word：最细粒度划分 对可以分词的词语再次进行切分 创建索引库并配置IK-Analyzer作为分析器 配置IK-Analyzer作为分析器 Document文档 查询结果 ElasticSearch集群ElasticSearch集群架构以及概念说明 为什么需要搭建集群（Cluster）？ 高可用性：减少服务的不可用时间，使得服务在任何时候都可以使用，不能因为单个节点挂掉，而影响到整个服务 扩大存储空间：多台服务器可以扩大存储空间 ElasticSearch的信息存储机制 分片（Shard） 分片，英文叫做 Shard，顾名思义，分片就是对数据切分成了多个部分。我们知道 Elasticsearch 中一个索引（Index）相当于是一个数据库，如存某网站的用户信息，我们就建一个名为 user 的索引。但索引存储的时候并不是整个存一起的，它是被分片存储的，Elasticsearch 默认会把一个索引分成五个分片，当然这个数字是可以自定义的。分片是数据的容器，数据保存在分片内，分片又被分配到集群内的各个节点里。当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里，所以相当于一份数据被分成了多份并保存在不同的主机上。 副本（Replica） 副本，英文叫做 Replica，同样顾名思义，副本就是对原分片的复制，和原分片的内容是一样的，Elasticsearch 默认会生成一份副本，所以相当于是五个原分片和五个分片副本，相当于一份数据存了两份，并分了十个分片，当然副本的数量也是可以自定义的。这时我们只需要将某个分片的副本存在另外一台主机上，这样当某台主机宕机了，我们依然还可以从另外一台主机的副本中找到对应的数据。所以从外部来看，数据结果是没有任何区别的。 一般来说，Elasticsearch 会尽量把一个索引的不同分片存储在不同的主机上，分片的副本也尽可能存在不同的主机上，这样可以提高容错率，从而提高高可用性。 节点的分类 主节点：即 Master 节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。默认情况下任何一个集群中的节点都有可能被选为主节点。索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择。虽然主节点也可以协调节点，路由搜索和从客户端新增数据到数据节点，但最好不要使用这些专用的主节点。一个重要的原则是，尽可能做尽量少的工作。 数据节点：即 Data 节点。数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对 CPU、内存、IO 要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。 负载均衡节点：也称作 Client 节点，也称作客户端节点。当一个节点既不配置为主节点，也不配置为数据节点时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。 预处理节点：也称作 Ingest 节点，在索引数据之前可以先对数据做预处理操作，所有节点其实默认都是支持 Ingest 操作的，也可以专门将某个节点配置为 Ingest 节点。 一个节点其实可以对应不同的类型，如一个节点可以同时成为主节点和数据节点和预处理节点，但如果一个节点既不是主节点也不是数据节点，那么它就是负载均衡节点。具体的类型可以通过具体的配置文件来设置。 ElasticSearch集群搭建 通过配置每台ElasticSearch的配置文件，设置同一个集群名和各自的ip、端口以及配置其他节点的ip和端口，节点名就可以搭建一个集群，节点配置参考 Java操作索引库增删改创建索引 导入相关的依赖 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;7.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--ElasticSearch的高级API 在7.x版本中使用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.7.0&lt;/version&gt; &lt;/dependency&gt; 在ElasticSearch7.x之前使用 创建Settings对象，配置集群的名字 创建client对象，配置节点的信息 使用client对象创建索引库 关闭client 注意： 端口使用的是TCP端口 9300 在ElasticSearch 7.x版本之后 创建Settings对象。指定分片数和备份数 创建CreateIndexRequest对象，通常把这个方法封装成static方法 将Settings对象封装为Request对象 通过Client对象连接并创建索引 注意： 使用的端口是Http端口9200 使用Kibana查看创建的索引库 设置索引的Mappings 通过XContentBuilder设置Mappings的值并封装到Request对象中 index属性表示当前Field是否可以作为条件进行查询 默认是true store属性表示是否需要额外存储，默认是false， 他其实表示的是在源文档（_source）之外，在倒排索引中为这个字段单独存储，这样可以提高效率 检查索引是否存在以及删除索引 检查索引是否存在 删除索引 索引不存在的话 抛出异常 向索引中添加文档 创建一个Person索引 创建Person实体类，以便进行将数据转换为JSON 添加文档 查看结果 索引person和id使我们指定的 当然 type我们也可以指定 修改和删除文档 修改文档中的内容 可以直接修改文档中的内容 而不需要删除再创建 结果 根据id删除文档 已删除 delete-by-query，删除符合查询条件的文档 删除根据term，match查询的得到的文档 如果需要删除索引库中的大部分内容，不推荐这个方式，因为这种方式底层还是根据id去一个一个删除对应的文档，推荐的做法是向一个新的索引库中添加不需要删除的文档 批量操作 增删改查都是可以批量操作的 使用BulkRequest对象 其中可以添加其他的request对象 实现批量添加 实现批量添加 查看结果 实现批量删除 结果 Java操作索引库查询创建索引库并添加文档 数据的实体类 需要注意的一点就是 这里的格式规定需要与Field中规定的格式一致 创建索引 添加文档 使用BulkRequest批量添加文档 Term查询 根据关键词进行查询，并且这个关键词不进行分词 关于获取响应数据的 查看响应格式 Terms查询 terms查询的功能类似于数据库查询中的in条件，可以有多个关键词 match查询 match查询会根据查询的字段类型不同，采取不同的查询方式 查询的是日期或者是数值的话，match查询会将查询条件字符串转换为日期或者数值对待 如果查询的是一个不能被分词的内容（keyword），match查询不会对查询条件进行拆分 如果查询的是一个可以分词的内容（text），那么match会根据你的查询内容根据一定的方法分词，并去分词库中进行匹配 match查询底层是多个Term查询 match_all：查询全部的数据，不需要指定条件。默认返回的结果中是10条数据,通过size可以设置 match 先把查询的内容进行分词，然后再去分词库进行查找 带Boolean类型的match AND 既包括A，又包括B 包含A或者B都可以 multiMatch 在多个字段中查询包含指定关键词的内容 id查询 根据Document的id进行查询 prefix前缀查询 查询的Field的前缀包含关键词的条目 与百度提示的功能类似 fuzzy模糊查询 ElasticSearch根据输入的查询条件的内容的大概去匹配 这个查询不稳定 wildcard查询 功能和MySQL中的like功能相同，可以在查询的字符串中指定通配符*和占位符？ ？的话 一个?是一个占位符 针对数值类型的range查询 查询的字段必须是数值类型 regexp正则表达式查询 使用正则表达式去匹配 复合查询bool查询 should：查询的结果中包括条件其中的一个即可，相当于或者or must：查询的结果中必须包括，相当于and must_not：查询的结果中不能包括，相当于not boosting查询 boosting查询可以帮助我们去影响文档的score，从而改变结果的排序 positive：只有匹配上positive的查询的文档，才会放在结果集中 negative：如果匹配上了positive，并且也匹配上了negative，那么就可以降低score negative_boost：指定系数，小于1.0。在第2种情况下乘以这个系数实现降低score的功能 在查询的时候，score是如何得到的 搜索的关键字在文档中出现的频次越高，score越高 关键字占文档的比例越高，score越高 关键词被分词的时候，分词在分词库中匹配的越多，score越高 Java实现 表达的意思就是 在smsContent中包含安徽省的情况下 ，如果 smsContent中还包含芜湖 那么这个文档的score就乘以0.5 filter过滤查询 query与filter的对比 query：根据查询条件，去计算文档的匹配度，得到一个score，依此进行文档的排序，并且是不进行缓存的。 filter：根据查询条件去查询文档，不计算分数，而且filter对经常过滤的数据进行缓存。 当查询的数据不需要进行排序的时候，选择filter的效率更高 Java实现 可见，所有的score都是0 效率比query高 高亮查询 高亮查询就是将用户输入的关键字，以一定的样式展示给用户，让用户知道这个结果为什么被检索出来 高亮的数据，是Field自带的属性，在响应的数据中，单独作为一个字段返回 ES提供了一个highlight属性，和query同级别 fields：指定哪些Field字段以高亮形式返回 Fragment_size：指定高亮数据展示多个字符回来 Pre_tags：指定前缀标签 Post_tags：指定后缀标签 Kibana实现 响应数据 Java实现 聚合查询 聚合查询（aggregation）的功能和MySQL中的聚合查询的功能相似，而且更加强大 cardinality去重计数查询 先将返回的文档中的一个指定的field去重 在去重之后统计一共有多少条数据 比如，我要统计所有的文档中的province字段一共有几种 RESTful请求 其中agg这个Name是与结果中相对应的 可以自己任意取 Java实现 range范围统计 统计一定范围内出现的文档个数，比如，针对某一个Field值在0-100，100-200，200-300之间出现的文档的个数 范围统计可以针对普通的数值（range），针对时间的类型（date_range），针对ip类型（ip_range）都可以做相应的统计 数值查询 from包含等于的情况 to不包含等于的情况 RESTful实现 Java代码实现 结果 时间范围统计 Java实现 结果 ip范围统计 extended_stats聚合查询 查询指定Field的最大值，最小值，平均值和平方和等等 Java实现 其他聚合查询 查看官网中的文档Aggregations 深分页Scroll分页功能比较 from+size实现分页的功能 将用户指定的关键词进行分词 根据分词结果去索引库中进行查询，获得文档的id 去每个库中拉取分片获取数据 根据匹配程度score进行排序 根据from的值，将查询到的数据抛去一部分 返回结果 在第4步和第5步是比较耗时的 如果需要下一页的数据 那么就需要重新执行上面的过程 Scroll+size实现分页的功能 将用户指定的关键词进行分词 根据分词结果去分词库中进行检索，获得文档的id 将文档的id存储在ES的上下文中（可以理解为内存），id已经排序，可忽略 根据用户指定的size去ES的上下文中拿去指定个数的id，拿完之后，这些id就从上下文中移除了 如果还需要下一页的数据，直接在ES的上下文中，找后续的内容 此方法不适合实时数据，因为除了第一次，都是在上下文中取文档的id 用户需要下一页的数据，不需要重新执行整个过程，只需要重复第4步和第5步，直到上下文中的数据全部拿空 使用Kibana实现Scroll分页 查询全部的数据，并为文档的id创建上下文 响应回来的有scrollId 下一页 我们只需要指定上下文的id以及时长即可 size的话 还是根据第一次的size来的 不指定时长的话 默认为0 也就是这个scrollId就会被删除 删除scrollId 只需要指定scrollId即可 响应结果 删除之后再查询下一页 就报错 使用Java实现深分页 实现首页，下一页以及最后一页的功能 需要注意的一点是 除了最后一次 都需要设置ScrollId的存活时长 Spring Data ElasticSearchSpringData ElasticSearch简介 Spring Data Elasticsearch基于Spring Data API简化ElasticSearch的操作，将原始的ElasticSearch的客户端API进行封装，项目将核心Spring概念应用于使用Elasticsearch搜索引擎开发解决方案。为我们提供了一个“模板”作为高级抽象，用于存储、查询、排序和面对文档。Spring Data ElasticSearch Spring Data ElasticSearch入门 导入相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 版本信息的话 可以去官网查看对应的版本 创建配置文件 &lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns:elasticsearch=&quot;https://www.springframework.org/schema/data/elasticsearch&quot; xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.1.xsd https://www.springframework.org/schema/data/elasticsearch https://www.springframework.org/schema/data/https://blog.chasingwind.top/spring-elasticsearch-1.0.xsd&quot;&gt; &lt;!--ES 客户端配置--&gt; &lt;elasticsearch:transport-client id=&quot;esClient&quot; cluster-name=&quot;my-application&quot; cluster-nodes=&quot;xinhuacloud.tech:9200&quot;&gt;&lt;/elasticsearch:transport-client&gt; &lt;!--配置包扫描器 扫描接口所在的包--&gt; &lt;elasticsearch:repositories base-package=&quot;edu.ahnu.repository&quot;&gt;&lt;/elasticsearch:repositories&gt; &lt;!----&gt; &lt;bean id=&quot;elasticsearchTemplate&quot; class=&quot;org.springframework.data.elasticsearch.core.ElasticsearchTemplate&quot;&gt; &lt;constructor-arg name=&quot;client&quot; ref=&quot;esClient&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 在官网中的约束文件 创建索引库 创建一个实体类，实体类中的字段就是Document中的Field的内容 创建一个接口，继承ElasticSearchRepository接口 CrudRepository接口 其中的方法 编写测试代码 需要添加spring相关的包 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 添加文档 CrudRepository接口中的save方法","categories":[{"name":"全文检索","slug":"全文检索","permalink":"https://www.chasingwind.top/categories/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.chasingwind.top/tags/ElasticSearch/"}],"author":"ChasingWind"},{"title":"Lucene","slug":"Lucene","date":"2020-07-03T05:37:37.000Z","updated":"2021-03-04T00:49:29.991Z","comments":true,"path":"2020/07/03/Lucene/","link":"","permalink":"https://www.chasingwind.top/2020/07/03/Lucene/","excerpt":"Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎.","text":"Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎. 全文检索的概念 数据的分类 结构化数据 指具有固定格式或有限长度的数据，如数据库，元数据等 非结构化数据 指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件,HTML文件等等 数据的查询 结构化数据的查询 结构化查询语言，也就是SQL 非结构化数据的查询 顺序扫描法：比如顺序匹配字符串 全文检索：先建立索引，再对索引进行搜索的过程。索引的建立虽然比较耗时，但是一旦创建好索引之后，后面就可以一直使用，所以，表现上就是每次查询的速度都很快。 将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。 全文检索的应用场景 搜索引擎 站内搜索 电商搜索 只要是有搜索的地方都可以使用全文搜索 Lucene实现全文检索的流程 Lucene简介 Lucene是Apache基金会下的开源的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供完整的查询引擎和索引引擎，部分文本分析引擎（英文和德文）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。 Lucene实现全文检索的流程 绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括： 确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档 红色表示搜索过程，从索引库中搜索内容，搜索过程包括： 用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果 获得原始文档 原始文档：要基于哪些数据进行搜索，那么这些数据就是原始文档 构建文档对象 对每个原始文档创建Document（文档）对象，文档对象中包含多个键值对形式的Field（域）。每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同） 每个文档都有一个唯一的编号，就是文档id。 分析文档（分词的过程），这里拿英文进行举例 根据空格进行字符串拆分，得到一个单词列表 把单词统一转换为小写 去除标点符号 去除停用词 停用词：无意义的词，比如：a，the，and等等 将每个关键词封装成一个Term对象 Term对象包含两部分： 关键词所在的域（Field） 关键词本身 不同的域中拆分出来的相同的关键词不是同一个Term对象 创建索引 基于关键词列表创建一个索引，保存到索引库（磁盘上的文件，一次创建可以多次使用）中。 索引库中的内容： 索引：最终实现通过搜索被索引的关键词从而找到Document对象。 Document对象 关键词和文档的对应关系 倒排索引结构：根据关键词找到对应的文档，而不是像传统的先找到文档，再在文档中进行搜索 根据内容找文档，使用的是链表的实现方式 图中的链表中的数字表示的就是文档的id 查询索引 用户查询接口：用户输入查询条件的地方，比如百度的搜索框 将用户的输入封装成一个查询对象 查询对象中包括：要查询的域以及要搜索的关键词 执行查询 根据要查询的关键词到对应的域中进行搜索 找到关键词，根据关键词找到对应的文档id（倒排索引结构） 比如搜索语法为“fileName:lucene”表示搜索出fileName域中包含lucene的文档。 搜索过程就是在索引上查找域为fileName，并且关键字为Lucene的term，并根据term找到文档id列表。 渲染结果 根据查询出来的文档的id，将内容渲染出来展示给用户 入门程序实现读取磁盘上的多个文件，在这多个文件中进行全文检索。 环境搭建 Maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;8.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;8.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--用于io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建索引 创建一个Directory对象，指定索引库保存的位置 基于Directory对象创建一个IndexWriter对象，参数为索引库保存的位置和IndexWriterConfig对象 读取磁盘上的文件，对应每个文件创建一个Document对象 向Document文档对象中添加域 把Document文档对象写入到索引库 关闭IndexWriter对象 运行结果 运行生成的文件如图 可以使用luke来查看索引库中的内容 查询索引库 创建Directory对象，指定索引库的位置 创建IndexReader对象 创建IndexSearcher对象，构造方法中的参数是IndexReader对象 创建Query对象，这里使用最简单的TermQuery 执行查询，得到结果TopDocs对象 取出查询结果的总记录数，毕竟不能把所有的数据都查询出来，有的数据几万条，使用分页来处理 取出文档列表 打印文档中的内容 关闭IndexReader对象 查询索引库中content域中的spring 运行结果 中文分析器 分析器对象分析效果查看 分析器是将域对象（Field）中的内容分解为索引表中的最基本的Term单元，上面默认使用的是StandardAnalyzer对象 StandardAnalyzer对象在哪里使用的呢？ IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig()); IndexWriterConfig对象的无参构造中默认设置的默认分析器 public IndexWriterConfig() &#123; this(new StandardAnalyzer()); &#125; 查看分析器的分析效果 使用所有分析器的顶层抽象父类Analyzer中的analyzer.tokenStream()方法返回TokenStream对象，该对象中就包含了最终的分析结果 实现步骤 创建一个Analyzer对象 使用分析器对象的tokenStream方法获取TokenStream对象 为TokenStream对象设置一个引用，便于遍历 调用TokenStream对象reset方法，将指针指向初始的位置 使用while循环遍历TokenStream对象 关闭TokenStream对象 分析的内容 The Spring Framework provides a comprehensive programming and configuration model. 分析结果 中文分析器 上述的标准分析器对于中文的分析效果 英文分析出来了，但是中文的话，是一个字一个字进行拆分 这样的问题就是 当我们要去索引库查询，比如 查询 “分析器”这个单词 那么命中的结果就是0 因为索引库中根本就不存在这个关键词 第三方中文分析器IK-Analyser 导入pom依赖 &lt;!--中文分析器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.magese&lt;/groupId&gt; &lt;artifactId&gt;ik-analyzer&lt;/artifactId&gt; &lt;version&gt;8.3.0&lt;/version&gt; &lt;/dependency&gt; 可以配置分析器使用的扩展词典和停用词词典，我这里没有配置使用的是默认的词典 分析结果 在创建索引库的时候设置使用IK-Analyser 设置IndexWriterConfig对象 索引库维护虽然索引库已经建立，但是索引库并不是一成不变的，后期可能会对索引库进行增删改的操作，所以需要对索引库进行维护。 添加文档与创建索引的过程相同，之前是一次添加好多个原始文档，这里的添加是添加需要的文档。 常用的Field域对象的使用，不同类型的数据该用哪一种Field域对象进行存储 是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。将数据进行分词并存储到Field域中就是在这个时候进行的。 是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。 是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。是否存储的标准：是否要将内容展示给用户 之前的程序改造 对于文件的路径和文件的大小 添加文档 添加文档到索引库中，并不会把之前的索引覆盖 存储与否并不影响查询，知识影响我们能不能把值取出来 删除文档 初始化 删除全部文档 根据查询删除 修改文档 修改的原理：先删除原来的文档，然后添加一个新的文档，原先文档的id并不会被占用。 执行过后，索引库中不再有name中包含spring的文档 ，然后增加一个文档 索引库的查询 TermQuery：根据关键词进行查询，需要指定查询的域以及关键词 数值范围查询 可以查询出使用LongPoint，IntPoint存储数值类型的数据 QueryParser：先将需要查询的语句进行分词，之后基于分词的结果再进行查询操作 比如，要去搜索引擎搜索一句话，那么显然不能使用TermQuery进行查询的操作 使用QueryParser先对查询的内容进行分词，然后再进行查询的操作 添加依赖 &lt;!--queryparser--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;8.3.0&lt;/version&gt; &lt;/dependency&gt; 使用步骤 结果","categories":[{"name":"全文检索","slug":"全文检索","permalink":"https://www.chasingwind.top/categories/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"}],"tags":[{"name":"Lucene","slug":"Lucene","permalink":"https://www.chasingwind.top/tags/Lucene/"}],"author":"ChasingWind"},{"title":"后台管理系统功能实现(二)","slug":"后台管理系统功能实现2","date":"2019-10-16T13:11:19.000Z","updated":"2021-03-04T00:43:05.720Z","comments":true,"path":"2019/10/16/后台管理系统功能实现2/","link":"","permalink":"https://www.chasingwind.top/2019/10/16/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B02/","excerpt":"本节主要完成用户操作，角色操作，资源权限操作以及权限关联与控制的操作。另外，还对用户的操作加入了日志，使用AOP的方式实现日志的操作，并存储到数据库中。","text":"本节主要完成用户操作，角色操作，资源权限操作以及权限关联与控制的操作。另外，还对用户的操作加入了日志，使用AOP的方式实现日志的操作，并存储到数据库中。 用户操作 在上一节中我们完成了用户的登录与退出，这一节我们完成其他的关于用户的操作 用户的查询 查询所有用户的流程分析 当我们点击菜单中的用户管理 执行对应的Controller Controller层中的方法 Service层 Dao层中的方法 设置账号的状态 成功展示 用户的添加 添加用户的流程分析 添加完成后跳转的页面 添加密码的时候将密码存储到数据库中的时候密码是加密的 关于密码加密 在之前的Service中 我们将UserInfo转换为User的时候 密码前面需要添加&quot;&#123;noop&#125;&quot;就是对密码进行加密 如果我们处理了密码加密 那么在后续的Service中转换的时候就不需要&quot;&#123;noop&#125;&quot;这个字段了 在user-add.jsp页面完成添加 添加用户的信息的表单 添加用户的Controller 添加用户的Service 添加用户的Dao 对密码进行加密（配置文件的方式） 在Service中对密码进行加密 使用SpringSecurity为我们提供的BCryptPasswordEncoder类来完成加密的操作 我们可以在配置文件中来完成配置 首先，在配置文件中将加密类交给IoC来进行管理 在Service中对密码进行加密 这样在Dao中拿到的就是加密之后的密码 测试 保存成功 新添加的用户的登录 我们在向数据库中添加用户的时候 对密码进行了加密处理 而我们在登录的时候 需要从数据库中查询进行验证的过程中，需要对密码进行解密处理 这样才能成功登录 我们可以在配置文件中告诉Service 密码是加密的 这样 在我们登录的过程中 密码就会进行解密 然后进行验证 另外还有一点就是 我们已经对密码进行了加密 这个时候就不需要“{noop}”了 使用新用户登录 可以登录成功 另外 还需要对之前的用户的密码进行加密 将加密之后的结果存储在数据库中 用户详情 查询用户的所有信息 用户详情流程分析 需要在查询用户的时候将用户的Role以及Role关联的Permission同时查询出来 并且要将这些信息都展示在页面上 user-list.jsp向Controller发送请求 向user/findById发送请求 并且携带用户的id进行请求 Controller层处理请求 Service层 Dao层 我们需要根据用户的id查询出用户的信息(UserInfo) , 以及Role的信息(Role),还有Role关联的权限(Permission)的信息 首先是UserInfo实体类 其中有Role的引用 在UserDao中进行封装 Role实体类中包含Permission的引用 RoleDao中 需要封装Permission的信息 PermissionDao中的方法 根据Role的id查询Permission 效果演示 因为我还没有给用户添加权限 所以用户的角色没有下拉框的内容 角色操作查询所有角色 流程分析 在页面左侧点击角色管理 向Controller发送请求 展示所有的角色 Controller层 页面中用的是roleList来接收数据的 Service层 Dao层 查找所有的角色 角色的添加 流程分析 在role-list.jsp页面中点击新建跳转页面到role-add.jsp role-add.jsp页面中 ​ 提交到的路径 Controller中的方法save用来保存角色 重定向到findAll Service Dao 测试 当我们新建 输入信息之后 保存 然后测试成功 资源权限操作查询所有资源权限 点击页面左边菜单的资源权限管理 向Controller发送请求 Controller 跳转到permission-list.jsp Service Dao 添加资源权限 点击新建跳转到permi-add.jsp 单击保存时执行的Controller中的方法 Controller中的方法 Service中的方法 Dao中的方法 测试成功 权限关联与控制用户关联角色 流程分析 先根据用户的id查询出这个用户的信息（在user-role-add.jsp中需要使用） 根据用户的id查询出此用户还没有的角色信息 向user_role表中插入数据 在user-list.jsp页面中添加对用户的角色 点击用户后面的添加角色按钮 跳转到的页面是Controller中的findUserByIdAndAllRole方法 传递的是用户的id Controller中的findUserByIdAndAllRole方法 根据用户的id查询用户的信息 以及根据用户的id查询用户没有的角色信息 最后将这些数据转发到user-role-add.jsp页面中进行展示 Service层 因为findAll在之前已经实现过了 这里只需要实现查询没有的角色信息就行了 Dao层 根据用户的id查询用户没有的角色信息 user-role-add.jsp页面效果 点击添加角色后 就会将用户的信息以及用户还没有的角色的信息转发到此页面 在这个页面中进行展示 给用户添加角色，向users_role表中添加数据 当我们点击保存的时候 就会执行addRoleToUser方法 可以根据name属性传递参数 Controller层中的addRoleToUser方法 在此方法中 我们可以使用注解@Param获取页面中传递来的name属性 并且 我们可以给用户添加多个角色信息 所以使用的是数组来存储Role的id 因为在向数据库中的表users_role表中添加数据的时候 需要userId和roleId Service中的方法 通过遍历来向users_role表中添加多条数据 Dao中的方法 @Param注解 当方法中有多个参数的时候需要使用@param注解进行匹配 测试成功 用户可以正常添加角色信息 角色关联权限 流程分析 先查询出这个角色的权限 查询这个角色还没有的权限 向role_permission表中插入数据 流程是与上面的相同的，这里不做介绍 权限控制服务器端方法级别权限控制 在服务器端我们可以通过Spring Security提供的注解对方法来进行权限控制。Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、**@Secured注解和支持表达式的注解，这三种注解默认都是没有启用的**，需要 单独通过global-method-security元素的对应属性进行启用 JSR-250注解 首先在pom.xml中添加依赖 首先需要在spring-security.xml中开启注解支持 在指定的方法上使用注解 JSR-250中的注解 @RolesAllowed：表示访问对应方法时所应该具有的角色 @RolesAllowed({“USER”, “ADMIN”}) 该方法只要具有”USER”, “ADMIN”任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN 就是说我们虽然在spring-security.xml配置的角色是 但是我们还是可以将ROLE_省略的 @PermitAll：表示允许所有的角色进行访问，也就是说不进行权限控制 @DenyAll是和PermitAll相反的，表示无论什么角色都不能访问 测试 admin用户具有的角色有ADMIN和USER 可以访问产品管理页 tiger用户只有USER角色 当访问产品管理页的时候 出现403Forbidden(权限不足) 我们可以在页面中进行配置权限不足的页面 在web.xml中配置错误页面 在webapp目录下创建403.jsp页面 @Secured注解 @Secured是SpringSecurity本身提供的注，不需要导入依赖 首先在spring-security.xml中开启注解支持 在对应的方法上使用（权限不能省略前缀） 我们在订单管理页上使用注解 测试 admin用户可以进行访问 tiger用户没有ADMIN权限 403权限不足 支持表达式的注解 Spring Security允许我们在定义URL访问或方法访问所应有的权限时使用Spring EL表达式，在定义所需的访问权限时如果对应的表达式返回结果为true则表示拥有对应的权限，反之则无 常用表达式 开启支持 在方法上使用注解 @PreAuthorize： 在方法调用之前,基于表达式的计算结果来限制对方法的访问 @PostAuthorize： 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常 @PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果 @PreFilter 允许方法调用,但必须在进入方法之前过滤输入值 使用 当使用admin用户登录的时候 可以访问用户管理页面 当使用tiger用户登录的时候 权限不足 使用表达式进行权限控制 这里是对某个特定的用户授权 标识只有tiger用户才能添加用户 当使用admin用户访问的时候 权限不足 页面端标签控制权限 在pom.xml中导入依赖 在对应的jsp页面中导入 &lt;%@taglib uri=&quot;https://www.springframework.org/security/tags&quot; prefix=&quot;security&quot;%&gt; 常用的标签authentication authentication：代表的是当前认证对象，可以获取当前认证对象信息，例 如用户名 在之前的页面中 用户登录的时候显示的用户名都是固定的xxx 我们可以使用authentication标签来获取用户名 在对应的位置使用标签获取用户名 常用标签authorize authorize：用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示，根据用户的权限是否显示页面中内容 比如说 我们让具有ADMIN角色的用户才能看到用户管理页 需要开启使用表达式 AOP日志 用于记录用户的在系统中的每一步操作，将操作的信息存储到数据库中 创建表以及实体类 日志表sysLog 创建表sysLog CREATE TABLE sysLog( id VARCHAR2(32) default SYS_GUID() PRIMARY KEY, visitTime timestamp, username VARCHAR2(50), ip VARCHAR2(30), url VARCHAR2(50), executionTime int, method VARCHAR2(200) ) 创建实体类SysLog 基于AOP来处理日志信息 使用前置通知和后置通知来获取用户操作的信息，然后将这些信息插入到数据库中 创建日志AOP 前置通知 前置通知 用来获取操作开始的时间，执行的类以及执行的方法 在前置通知中已经完成了SysLog类中的 后置通知 后置通知 用于获取操作者，访问的ip，执行的URL，执行时长 获取用户访问的URL 获取用户的ip地址 通过request对象可以轻易获取，我们可以使用原生的RequestServlet来获取，首先需要在web.xml中配置RequestContextListener 然后在LogAop中注入 获取当前正在操作的用户的用户名 可以通过SecurityContext中获取 还可以使用Session来获取 从属性值SPRING_SECURITY_CONTEXT中获取SecurityContext对象 获取执行持续的时间 这里不是报错 将数据封装为SysLog类 并调用Service Service层 Dao层 向数据库中存储 测试 当我们进行访问的时候 数据库中正常存入了数据 当我们访问订单数据的时候 报错了 因为我们在获取方法参数的时候 结果是对象类型的数组 而在fuindAll方法中参数是int 需要改成Integer，可以正常访问 并且数据库中正确存入数据 查询日志信息 流程分析 点击菜单中的 访问日志 执行Controller中测方法 SysLogController中的方法 Service中的方法 Dao中的方法 测试 可以正常查询到日志信息","categories":[{"name":"项目","slug":"项目","permalink":"https://www.chasingwind.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://www.chasingwind.top/tags/SSM/"}],"author":"ChasingWind"},{"title":"后台管理系统功能实现(一)","slug":"后台管理系统功能实现1","date":"2019-10-13T15:52:19.000Z","updated":"2021-03-04T00:42:22.749Z","comments":true,"path":"2019/10/13/后台管理系统功能实现1/","link":"","permalink":"https://www.chasingwind.top/2019/10/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B01/","excerpt":"本节主要讲述了添加商品的操作，以及订单的相关的操作，主要的是SpringSecurity的使用，用来验证以及授权用户从在用户登录的时候完成用户的验证。","text":"本节主要讲述了添加商品的操作，以及订单的相关的操作，主要的是SpringSecurity的使用，用来验证以及授权用户从在用户登录的时候完成用户的验证。 产品操作 在上一节的基础上，其实还存在一些小问题。 在页面中，出发时间状态一栏中没有数据 但是在数据库中存储的时候是存储了数据的 数据库中存储的数据 而在product-list.jsp页面中显示的是String类型的 departTimeStr和String类型的productStatusStr 所以 我们需要做的就是在Product类中将departureTime转换为字符串形式的departureTimeStr以及将productStatus转换为productStatusStr 设置状态 设置时间 我们可以做成一个工具类来实现 在子模块中ssm_utils 在Product类中进行转换 在页面中显示出了数据 注意：每次执行之前都需要先clean，install父工程，然后clean，install子模块web项目之后，才能运行Tomcat 主页main.jsp 在默认的首页index.jsp中我们将它转发到新的页面main.jsp 当我们再次运行的时候 访问的是index.jsp 添加商品 添加商品的流程分析 从product-list.jsp页面跳转到product-add.jsp 在product-add.jsp中点击新建按钮输入商品信息 表单提交到的路径 Controller层 Service层 Dao层执行的SQL语句 @Insert(&quot;insert into product(productNum,productName,cityName,departureTime,productPrice,productDesc,productStatus) values(#&#123;productNum&#125;,#&#123;productName&#125;,#&#123;cityName&#125;,#&#123;departureTime&#125;,#&#123;productPrice&#125;,# &#123;productDesc&#125;,#&#123;productStatus&#125;) &quot;) public void save(Product product); 事务管理已经在Service层中使用注解的方式实现了 当我们点击保存的时候 出现了400客户端错误 造成错误的原因是日期格式类型转换异常 因为在页面提交到服务器端的时候日期对应的是字符串类型的 而在Product类中我们需要的是Date类型的 所以就会出现类型转换异常 类型转换 可以使用在SpringMVC中自定义类型转换器来实现 使用注解@DateTimeFormat 执行成功 跳转到findAll的页面 订单操作查询所有订单 订单查询流程分析 创建表 创建Member表 CREATE TABLE member( id varchar2(32) default SYS_GUID() PRIMARY KEY, NAME VARCHAR2(20), nickname VARCHAR2(20), phoneNum VARCHAR2(20), email VARCHAR2(20) ); insert into MEMBER (id, name, nickname, phonenum, email) values (&#39;E61D65F673D54F68B0861025C69773DB&#39;, &#39;张三&#39;, &#39;小三&#39;, &#39;18888888888&#39;, &#39;zs@163.com&#39;); 创建Traveller表 CREATE TABLE traveller( id varchar2(32) default SYS_GUID() PRIMARY KEY, NAME VARCHAR2(20), sex VARCHAR2(20), phoneNum VARCHAR2(20), credentialsType INT, credentialsNum VARCHAR2(50), travellerType INT ); insert into TRAVELLER (id, name, sex, phonenum, credentialstype, credentialsnum, travellertype) values (&#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;, &#39;张龙&#39;, &#39;男&#39;, &#39;13333333333&#39;, 0, &#39;123456789009876543&#39;, 0); insert into TRAVELLER (id, name, sex, phonenum, credentialstype, credentialsnum, travellertype) values (&#39;EE7A71FB6945483FBF91543DBE851960&#39;, &#39;张小龙&#39;, &#39;男&#39;, &#39;15555555555&#39;, 0, &#39;987654321123456789&#39;, 1); 创建Order表 CREATE TABLE orders( id varchar2(32) default SYS_GUID() PRIMARY KEY, orderNum VARCHAR2(20) NOT NULL UNIQUE, orderTime timestamp, peopleCount INT, orderDesc VARCHAR2(500), payType INT, orderStatus INT, productId varchar2(32), memberId varchar2(32), FOREIGN KEY (productId) REFERENCES product(id), FOREIGN KEY (memberId) REFERENCES member(id) ); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;0E7231DC797C486290E8713CA3C6ECCC&#39;, &#39;12345&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;,&#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;676C5BD1D35E429A8C2E114939C5685A&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;5DC6A48DD4E94592AE904930EA866AFA&#39;, &#39;54321&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;676C5BD1D35E429A8C2E114939C5685A&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;2FF351C4AC744E2092DCF08CFD314420&#39;, &#39;67890&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;A0657832D93E4B10AE88A2D4B70B1A28&#39;, &#39;98765&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;E4DD4C45EED84870ABA83574A801083E&#39;, &#39;11111&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;96CC8BD43C734CC2ACBFF09501B4DD5D&#39;, &#39;22222&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;55F9AF582D5A4DB28FB4EC3199385762&#39;, &#39;33333&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;9F71F01CB448476DAFB309AA6DF9497F&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;CA005CF1BE3C4EF68F88ABC7DF30E976&#39;, &#39;44444&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;9F71F01CB448476DAFB309AA6DF9497F&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); insert into ORDERS (id, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid) values (&#39;3081770BC3984EF092D9E99760FDABDE&#39;, &#39;55555&#39;, to_timestamp(&#39;02-03-2018 12:00:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 2, &#39;没什么&#39;, 0, 1, &#39;9F71F01CB448476DAFB309AA6DF9497F&#39;, &#39;E61D65F673D54F68B0861025C69773DB&#39;); 订单与旅客中间表 -- 订单与旅客中间表 drop table order_traveller; CREATE TABLE order_traveller( orderId varchar2(32), travellerId varchar2(32), PRIMARY KEY (orderId,travellerId), FOREIGN KEY (orderId) REFERENCES orders(id), FOREIGN KEY (travellerId) REFERENCES traveller(id) ) insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;0E7231DC797C486290E8713CA3C6ECCC&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;2FF351C4AC744E2092DCF08CFD314420&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;3081770BC3984EF092D9E99760FDABDE&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;55F9AF582D5A4DB28FB4EC3199385762&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;5DC6A48DD4E94592AE904930EA866AFA&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;96CC8BD43C734CC2ACBFF09501B4DD5D&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;A0657832D93E4B10AE88A2D4B70B1A28&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;CA005CF1BE3C4EF68F88ABC7DF30E976&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid) values (&#39;E4DD4C45EED84870ABA83574A801083E&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); 创建实体类 实体类Member 并提供get/set方法 实体类Traveller 并提供get/set方法 实体类Orders 并提供get/set方法 创建Controller 创建Service接口以及实现类 创建Dao接口 实现查询所有的方法 因为查询Orders的时候 还需要产品信息（一对一） 这里使用的是注解的形式实现的 在这里我们封装的是Status而非对应的StatusStr的形式 但是在页面中显示的时候需要的是对应的Str的形式 所以我们需要在Orders实体类中进行转换 Orders类中的信息转换 因为需要在查询订单的时候查询产品的信息 那么就需要指定封装到的Orders中对应的属性与数据库中的列 并且封装Product产品信息的时候 需要调用ProductDao中的方法 流程梳理 点击菜单页面的订单管理 执行orders/findAll方法 执行对应的Controller中的方法 orders-list.jsp页面中取出数据 这里取出的就是对应的Str形式的数据 Controller调用Service中方法 Service调用Dao中的方法 Dao中的方法 订单分页 PageHelper是国内非常优秀的一款开源的MyBatis分页插件，它支持基本主流与常用的数据库。 PageHelper的使用 导入Maven依赖 在Spring的配置文件applicationContext.xml中进行配置 配置参数解释 helperDialect ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver201 reasonable ：分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum&lt;=0 时会查询第一页， pageNum&gt;pages （超过总数时），会查询最后一页。默认 false 时，直接根据参数进行查询。 基本使用 一定在执行数据库中的查询之前 进行分页 中间不能执行其他的任何操作 不然分页就失效了 PageHelper的原理就是 在执行查询之前会在查询语句的后面拼接分页条件 修改页面aside.jsp 请求的时候需要携带当前页的页码以及当前页显示的条数 修改Controller 限定请求参数以及默认值 携带分页的参数 修改Service 参数中需要携带请求的分页的参数 修改Controller 上面还没有进行数据的存储以及页面的跳转 我们存储的数据不仅仅是数据库中的数据，还需要存储分页相关的数据，比如，分页的总页数，分页的当前页码等等 所以，我们可以使用PageHelper提供的PageInfo这个Bean来存储信息 PageInfo类中存储的不仅仅是分页的数据 还可以将我们数据库中的数据存储进去 我们将页面跳转到orders-page-list.jap 修改页面orders-page-list.jap 我们接收的就是 这样就完成了默认情况下的分页 完成首页下一页等等 使用PageInfo中封装的数据来完成 控制每页展示的条数 当我们选择的时候 就会请求服务器 当我们选择的时候 会调用函数 传递size 订单详情 流程分析 在orders-list.jsp页面中点击详情 跳转到指定的Controller中的方法中 点击的时候 携带订单的Id信息 完成Controller 这里还没有完成页面的跳转 完成Service 完成Dao 封装到Orders 订单对应多个游客信息 在TravellerDao中借助订单号查询 借助的是中间表进行的查询 完成页面的跳转 页面详情页面使用的是orders-show.jsp,并且在页面中使用的是orders 所以完成Controller 页面显示 上面的证件类型 以及 旅客类型是空的 因为 显示的是字符串的类型 而数据库中存储的是整型的 需要在Traveller类中进行转换 权限控制表以及实体类的创建 表结构 表与表之间的关系 用户表Users（根据后面的需要 修改成了UserInfo类，用于SpringSecurity框架的认证） 角色表Role 权限表Permission 在数据库中创建表以及中间表 -- 用户表 CREATE TABLE users( id varchar2(32) default SYS_GUID() PRIMARY KEY, email VARCHAR2(50) UNIQUE NOT NULL, username VARCHAR2(50), PASSWORD VARCHAR2(50), phoneNum VARCHAR2(20), STATUS INT ) -- 角色表 CREATE TABLE role( id varchar2(32) default SYS_GUID() PRIMARY KEY, roleName VARCHAR2(50) , roleDesc VARCHAR2(50) ) -- 用户角色关联表 CREATE TABLE users_role( userId varchar2(32), roleId varchar2(32), PRIMARY KEY(userId,roleId), FOREIGN KEY (userId) REFERENCES users(id), FOREIGN KEY (roleId) REFERENCES role(id) ) -- 资源权限表 CREATE TABLE permission( id varchar2(32) default SYS_GUID() PRIMARY KEY, permissionName VARCHAR2(50) , url VARCHAR2(50) ) -- 角色权限关联表 CREATE TABLE role_permission( permissionId varchar2(32), roleId varchar2(32), PRIMARY KEY(permissionId,roleId), FOREIGN KEY (permissionId) REFERENCES permission(id), FOREIGN KEY (roleId) REFERENCES role(id) ) 创建相应的实体类，并提供对应的get/set方法 User实体类 Role实体类 Permission实体类 SpringSecurity框架简单入门 Spring Security ，是 Spring 项目组中用来提供安全认证服务的框架。 认证 : 简单来说，就是判断用户的用户名和密码是否和数据库（或者说正确的用户名和面）中相等，比如说，在登录过程中，验证用户名和密码是否正确 授权：简单来说，就是用户是否有权限执行某些功能，而这些权限我们已经在数据库中进行了描述或者在配置文件中进行了声明 Spring Security可以通过数据库或者配置文件进行使用，也就是说我们可以将用户配置在配置文件中，从配置文件或者数据库中获取用户 基于配置文件的SpringSecurity入门案例 创建新的项目 在pom.xml中添加依赖 坐标依赖以及插件 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在web.xml中配置filter &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;https://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;https://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; //必须是springSecurityFilterChain这个名字 &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 在resources目录下创建spring-security.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot; xmlns:security=&quot;https://www.springframework.org/schema/security&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd https://www.springframework.org/schema/security https://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;security:http auto-config=&quot;true&quot; use-expressions=&quot;false&quot;&gt; &lt;!-- intercept-url定义一个过滤规则 pattern表示对哪些url进行权限控制，ccess属性表示在请求对应 的URL时需要什么权限， 默认配置时它应该是一个以逗号分隔的角色列表，请求的用户只需拥有其中的一个角色就能成功访问对应 的URL --&gt; &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot;/&gt; &lt;!-- auto-config配置后，不需要在配置下面信息 &lt;security:form-login /&gt; 定义登录表单信息 &lt;security:http-basic /&gt; &lt;security:logout /&gt; --&gt; &lt;/security:http&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name=&quot;user&quot; password=&quot;&#123;noop&#125;user&quot; authorities=&quot;ROLE_USER&quot;/&gt; &lt;security:user name=&quot;admin&quot; password=&quot;&#123;noop&#125;admin&quot; authorities=&quot;ROLE_ADMIN&quot;/&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;/beans&gt; 表示所有的资源都会被拦截，只有用户“ROLE_USER”才能进行访问资源 配置用户的用户名和密码 以及角色(在这真正的开发中是在数据库中的，这里是进行演示) 运行 在终端输入命令tomcat7:run 默认进入到的是localhost:配置的端口号 但其实是一个登陆页面 在配置文件中 默认提供的 用户名和密码错误 zhangsan 123 使用user user 访问到的是index.jsp 使用admin admin 没有权限访问（403） 因为在配置中我们配置的是只有”ROLE_USER”角色才能访问资源 错误和正确的页面 可以进行自定义 使用配置文件进行配置 Spring Security使用数据库认证 在Spring Security中如果想要使用数据进行认证操作，有很多种操作方式，这里我们介绍使用UserDetails、 UserDetailsService来完成操作。 UserDetails是一个接口，我们可以认为UserDetails作用是用于封装当前进行认证的用户信息，但由于其是一个接口，所以我们可以对其进行实现，也可以使用Spring Security提供的一个UserDetails的实现类User来完成操作 UserDetailsService也是一个接口，其中只有一个方法loadUserByUsernam用于规范认证的方法 UserDetails接口 User类实现了UserDetails接口 其中的一些属性如图 这是SpringSecurity为我们提供的 UserDetailService接口 UserDetail和UserDetailService用于认证的使用流程 之前我们使用数据库认证登录的流程 使用SpringSecurity来完成用户的认证 就不需要使用Controller了 而胡思使用SpringSecurity来当作控制器 并且在Service中需要实现接口UserDetailService，重写其中的方法 返回值是UserDeatil，但是我们从数据库周静查询的返回值是User 这该怎么进行转换呢 使用SpringSecurity实现用户登录 导入登录页面以及失败跳转的页面，成功的话跳转到main.jsp页面中 成功跳转到pages/main.jsp也就是我们的主页面 在工程的pom.xml中导入依赖 在web.xml中配置filter 在WEB-INF目录下的web.xml中进行配置filter 配置SpringSecurity的配置文件 在resources目录下创建SpringSecurity配置文件spring-security.xml 以上的配置说明了 告诉SpringSecurity框架拿到用户名和密码之后需要访问的是哪一个Service 配置认证管理器 告诉SpringSecurity框架 这个Service是哪一个 实创建UserService以及他的实现类 让UserService继承UserDetailsService 实现UserService 并将userService交给IOC进行管理 这样SpringSecurity框架就知道了使用我们实现的UserService来完成认证的操作 这样的话我们就完后了图中的内容 并且在web.xml中加载spring-security.xml classpath:和classpath*:的区别 classpath和classpath*区别： classpath：只会到你的class路径中查找找文件。 classpath*：不仅包含class路径，还包括jar文件中（class路径）进行查找。 注意： 用classpath*:需要遍历所有的classpath，所以加载速度是很慢的；因此，在规划的时候，应该尽可能规划好资源文件所在的路径，尽量避免使用classpath*。 完成从数据库查询用户，并进行返回 Service中方法的返回值的是UserDetails对象，而我们从数据库中查询出来的是我们自己的实体类UserInfo，如何将我们自己的实体类UserInfo对象转换为UserDetails对象？ 我们自己的实体类UserInfo 实现UserDao接口 我们从数据库中查询出来的是UserInfo对象 UserService中对UserDao查询的结果进行处理 UserDao查询的结果是一个UserInfo对象，怎样把UserInfo转换为UserDetails呢？ UserDetails接口有一个实现类User类 我们可以将UserInfo封装为User User类中的属性 我们可以使用User类中的构造方法 将我们的UserInfo类转换为User类 这样 就将我们从数据库中查询出来的UserInfo类对象转换为了UserDetails对象 这样SpringSecurity框架就可以从Service中拿到UserDetails对象，也就是拿到了登录用户的用户名和密码等信息，框架底层就可以进行认证，完成页面的跳转 登录测试 进行登录测试 即使输入正确的用户名和密码输入，也是登录失败 因为 只有角色为只有ROLE_USER,ROLE_ADMIN角色才能进行访问 在上面我们将UserInfo对象转换为User对象的时候 使用的是User的构造函数 第三个参数是authorieties 也就是将UserInfo对象的角色也封装到User对象中 图中的密码前面加了“{noop}” 因为我们没有配置加密 所以需要这个前缀 在这里进行模仿为用户授权 （因为在后面 角色还是需要从数据库中进行查询的） authorities参数需要的是GrantedAuthority，我们存入的是他的实现类 SimpleGrantedAuthority 从数据库中获取用户角色 在配置文件中 我们配置的是 只有ROLE_USER,ROLE_ADMIN角色才能进行访问 也就是说 我们还需要完成从数据库中完成用户角色的查询 依此来判断用户是否有权限进行访问 也就是说 当我们获取UserInfo的时候 还需要将Role封装进去 UserInfo类 当我们进行UserInfo的封装的时候 也将用户的Role进行封装 由于一个用户可以具有多个角色 所以是Many 在RoleDao中根据用户的Id查询用户的角色 数据库中的User表以及Role表添加数据 以及中间表的关联 在Service中 我们就可以获取UserInfo中封装的roles角色信息了 另外 在UserInfo类中还有一个属性status 代表账户是否可用 0 不可用 1可用 我们可以通过User的另一个构造方法 进行设置 进行测试 当用户的状态status是1并且角色是有权限的时候 是可以登录成功的 当用户的status是0的时候 即使用户名和密码以及权限都有的话 也会登录失败的 小注意事项 用户的退出 借助SpringSecurity帮助我们完成用户的退出的功能 用户退出的页面 在spring-security.xml配置文件中完成配置 配置信息 在页面中指定logout 对应的具体的操作 由SpringSecurity来帮我们完成 测试成功 SpringSecurity源码简析","categories":[{"name":"项目","slug":"项目","permalink":"https://www.chasingwind.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://www.chasingwind.top/tags/SSM/"}],"author":"ChasingWind"},{"title":"SSM项目环境搭建","slug":"后台管理系统环境搭建","date":"2019-10-13T02:26:44.000Z","updated":"2021-03-04T00:43:23.707Z","comments":true,"path":"2019/10/13/后台管理系统环境搭建/","link":"","permalink":"https://www.chasingwind.top/2019/10/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"本节主要是进行项目的环境的搭建，介绍了项目的基本内容。主要完成了基本的数据库的搭建还有SSM框架的搭建，编写各种配置文件还有进行环境的测试。最后可以完成测试，完成搭建的目标。","text":"本节主要是进行项目的环境的搭建，介绍了项目的基本内容。主要完成了基本的数据库的搭建还有SSM框架的搭建，编写各种配置文件还有进行环境的测试。最后可以完成测试，完成搭建的目标。 项目介绍此项目是使用SSM搭建的后台管理系统，其中包括了后台对于产品的操作，订单操作，用户操作，权限管理，权限关联和控制还有最后的AOP日志的实现。 技术选型页面使用的是AdminLTE框架来完成的，数据库使用的是Oracle，框架使用的是Spring+MyBatis+SpringMVC来进行搭建的 数据库环境搭建 Oracle数据库时是基于用户进行管理数据的，所以首先需要创建一个用户 创建用户 为用户授权 这里使用的是connect和resource角色 图中我们设置的是角色权限，是对某一张表的操作权限 创建product表 使用刚刚创建的用户ssm来登录，创建product表 表结构 常见表 CREATE TABLE product( id varchar2(32) default SYS_GUID() PRIMARY KEY, productNum VARCHAR2(50) NOT NULL, productName VARCHAR2(50), cityName VARCHAR2(50), DepartureTime timestamp, productPrice Number, productDesc VARCHAR2(500), productStatus INT, CONSTRAINT product UNIQUE (id, productNum) ) 添加数据 记得添加数据之后需要Commit 可以看到id这个字段我们是没有进行操作的 也就是insert的时候没有给字段和值 这个会自动添加 insert into PRODUCT ( productnum, productname, cityname, departuretime, productprice, productdesc, productstatus) values ( &#39;itcast-002&#39;, &#39;北京三日游&#39;, &#39;北京&#39;, to_timestamp(&#39;10- 10-2018 10:10:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 1200, &#39;不错的旅行&#39;, 1); insert into PRODUCT ( productnum, productname, cityname, departuretime, productprice, productdesc, productstatus) values ( &#39;itcast-003&#39;, &#39;上海五日游&#39;, &#39;上海&#39;, to_timestamp(&#39;25- 04-2018 14:30:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 1800, &#39;魔都我来了&#39;, 0); insert into PRODUCT ( productnum, productname, cityname, departuretime, productprice, productdesc, productstatus) values ( &#39;itcast-001&#39;, &#39;北京三日游&#39;, &#39;北京&#39;, to_timestamp(&#39;10- 10-2018 10:10:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 1200, &#39;不错的旅行&#39;, 1); 搭建Maven工程 创建父工程 创建Project，不使用骨架创建 创建子模块 创建Module ssm_dao（不使用骨架），指定Module所在的父工程 同理，创建ssm_service 同理，创建ssm_domain 同理，创建ssm_utils 最后，创建ssm_web，使用webapp骨架进行创建 此时的目录结构是这样的 父工程SSM_Project以及各个子模块 导入jar包的坐标 在&lt;veision&gt;和&lt;module&gt;之间放置 &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;oracle.version&gt;11.2.0.1.0&lt;/oracle.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt; &lt;version&gt;$&#123;oracle.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 编写产品实体类 在domain模块下创建Product类 并实现set和get方法 Dao接口 创建ProductDao接口 创建查询所有的方法 注意: 在这里需要引入Product依赖 Service接口以及实现类 SSM整合 在web模块下面创建java和resources目录 创建applicationContext.xml和springmvc.xml 配置applicationContext.xml配置文件 加入约束 配置扫描Dao和Service，需要在pom.xml中加入Dao和Service的依赖 Spring整合MyBatis，就是将SqlSession交给Spring来管理 其中需要注入数据库连接信息，数据库连接池使用的是C3P0，并且在resources目录下创建db.properties存储数据库的连接信息 将Dao接口生成代理注入Spring容器中 配置事务管理器 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;https://www.springframework.org/schema/context&quot; xmlns:aop=&quot;https://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;https://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd https://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd https://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--配置扫描包 扫描Dao和Service 这里需要在web模块的pom.xml中添加依赖--&gt; &lt;context:component-scan base-package=&quot;edu.ahnu.dao&quot;&gt;&lt;/context:component-scan&gt; &lt;context:component-scan base-package=&quot;edu.ahnu.service&quot;&gt;&lt;/context:component-scan&gt; &lt;!--Spring整合MyBatis 也就是让Spring来管理SqlSession对象--&gt; &lt;!--数据库的连接信息 在resources目录--&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;!-- 配置连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; &lt;!-- 把SqlSessionFactory交给IOC管理--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!--配置Dao所在的包 将Dao接口生成代理注入Spring--&gt; &lt;bean id=&quot;mapperScannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;edu.ahnu.dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring的声明式事务管理 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; &lt;/beans&gt; 配置springmvc.xml 加入约束 配置扫描，这里只扫描Controller 配置视图解析器 设置静态资源不过滤（在webapp目录下创建存储静态资源的目录） 开启SpringMVC对注解的支持 使用子类实现动态代理 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;https://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;https://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;https://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd https://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd https://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd &quot;&gt; &lt;!--只扫描Controller--&gt; &lt;context:component-scan base-package=&quot;edu.ahnu.controller&quot;&gt;&lt;/context:component-scan&gt; &lt;!--配置视图解析器--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--jsp所在的目录--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot;&gt;&lt;/property&gt; &lt;!--后缀名--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--设置静态资源不过滤--&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt; &lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot; /&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt; &lt;mvc:resources location=&quot;/plugins/&quot; mapping=&quot;/plugins/**&quot; /&gt; &lt;!-- 开启对SpringMVC注解的支持 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 使用cglib进行代理 不需要接口 而是通过子类的方式 支持AOP的注解支持，AOP底层使用代理技术 JDK动态代理，要求必须有接口 cglib代理，生成子类对象，proxy-target-class=&quot;true&quot; 默认使用cglib的方式 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; &lt;/beans&gt; 配置web.xml 配置加载类路径下的配置文件contextConfigLocation 配置监听器，用来监听request的创建和销毁 配置前端控制器 配置中文乱码过滤器 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;https://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;https://xmlns.jcp.org/xml/ns/javaee https://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- 配置加载类路径的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置监听器，监听request域对象的创建和销毁的 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决中文乱码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置默认加载的页面--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 配置db.properties数据库连接信息 配置数据库的连接信息 jdbc.driver=oracle.jdbc.driver.OracleDriver jdbc.url=jdbc:oracle:thin:@localhost:1521:orcl jdbc.username=ssm jdbc.password=xxxxx 创建控制层 创建ProductorController 调用Service层的findAll方法，Service层调用Dao层的方法，在Dao接口上写SQL语句 查询产品的流程图 index.jsp页面和product-list.jsp页面 index.jsp页面 product-list.jsp使用的是AdminLTE提供的页面，同时还需要导入静态文件 存储数据以及转发页面 product-list.jsp页面中使用的是productList来存储数据的 在Controller中存储数据以及转发的页面 进行测试 配置Tomcat 使用Maven中集成的Tomcat插件进行测试 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; 配置Maven中的Tomcat 配置运行的项目是Web子模块 并且执行的命令是tomcat7:run 运行项目 运行之前的准备 运行 运行 到这里 可以成功运行 并且可以从数据库中查出数据 至此,SSM项目整合成功可以运行","categories":[{"name":"项目","slug":"项目","permalink":"https://www.chasingwind.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SSM项目","slug":"SSM项目","permalink":"https://www.chasingwind.top/tags/SSM%E9%A1%B9%E7%9B%AE/"}],"author":"ChasingWind"},{"title":"SVN","slug":"SVN","date":"2019-10-11T11:36:00.000Z","updated":"2021-03-04T00:56:43.118Z","comments":true,"path":"2019/10/11/SVN/","link":"","permalink":"https://www.chasingwind.top/2019/10/11/SVN/","excerpt":"SVN是subversion的缩写，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理。","text":"SVN是subversion的缩写，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理。 SVN的基本介绍 SVN是Subversion的简称，是一个自由开源的版本控制系统。 Subversion将文件存放在中心版本库里，这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况，这样就可以借此将数据恢复到以前的版本，并可以查看数据的更改细节 SVN是一种集中式管理代码的版本控制系统，原理就是把代码都保存到一个固定的位置（仓库），每次从这个位置拷贝更新代码，进行编辑；再把修改后的代码提交到该目录中。多人协作开发也是如此。因此需要一个类似Oracle或者Mysql的服务器用于保存和管理库文件（要保存的代码等文件）的服务端——VisualSVN Server。还需要一个用户的操作端，用于提交更新检出代码，常用的有IDEA的SVN插件，以及TortoiseSVN（小乌龟）。 早期版本控制使用的是CVS,后来SVN替代了CVS,随着android兴起，出现Git版本控制工具，后续我们会学到。 中心版本库以及SVN的一些操作 存在的问题: 怎样让系统允许用户共享信息，而不会让他们因意外而互相干扰？ 解决方法一：复制-修改-合并方案（Subversion的默认模式） 在这种模型里，每一个客户读取项目配置库建立一个私有工作副本——版本库中文件和目录的本地映射。用户并行工作，修改各自的工作副本，最终，各个私有的复制合并在一起，成为最终的版本，这种系统通常可以辅助合并操 作，但是最终要靠人工去确定正误。 也就是说，如果有人同时修改了同一个部分的代码，还是需要人工手动进行正误的判断的。 解决方法二：锁定-修改-解锁方案 在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。 此模式不适合软件开发这种工作。 SVN架构 SVN支持Linux和Windows，更多是安装在Linux下。 SVN服务器有2种运行方式：独立服务器和借助apache运行。两种方式各有利弊，用户可以自行选择。 SVN存储版本数据也有2种方式：SVN服务器端存储数据的方式 BDB一种事务安全型表类型和FSFS一种不需要数据库的存储系统。 因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点 在此章节中，使用的操作客户端的工具是TortoiseSVN以及IDEA中SVN插件，SVN服务器使用的是VisualSVN VisualSVN 下载 下载地址：SVN 安装 端口号可能会被占用 修改成不会被占用的就行了 服务器界面 创建仓库 选择存储数据的方式 这里选择的是FSFS 填写仓库名 选择初始化仓库结构是空结构的还是默认结构的 这里选择的是空结构的 选择权限控制 进行创建 创建用户和组 Users为仓库创建可以访问的用户 Group可以添加用户对用户分组进行管理 可以对用户和组进行权限管理 在仓库上邮件–&gt;Properties–&gt;进行权限的配置 通过浏览器访问服务器（因为是基于Http协议的） 获取访问路径 登陆之后的界面 在后面，我们还可以通过客户端工具TortoiseSVN进行访问 SVN目录结构以及作用 可以创建非空的目录 目录结构 trunk 主干目录，此目录下的文件为基准文件 branches 用于开发的分支目录 tags 用于发布的版本目录 假设有一个项目OA,我们完成了1.0版本，这时就可以打一个tags 后续我们在OA项目上添加一个新的模块(及时通讯),我们就可以开一个分支,又有一个公司需要在我们OA基础上添加 财务管理模块，我们又可以打一个分支。 我们后续针对OA的1.0版本在升级，我们不需要原来附加功能,就可以在原来的主干上继续开发，形成OA2.0版本， 开发完成后就可以在打一个tags TortoiseSVN的基本操作 TortoiseSVN是Windows系统中的SVN客户端的图形化界面 TortoiseSVN的使用 下载 TortoiseSVN：下载 安装后需要重启电脑，这样才能够正常显示后面的图标 安装中需要选择 安装本地的svn.exe文件 浏览仓库 在客户端浏览仓库 输入仓库的访问路径 输入用户名和密码 勾选框是保存认证 下次再去浏览仓库的额时候就不需要再次进行认证了 还可以清除认证信息 Checkout 当用户连接到服务器之后，可以进行Checkout操作，从服务器第一次下载源代码 Checkout的一些选项 Checkout之后，文件夹会出现一个隐藏的文件夹.svn Add 表示把文件添加到本地仓库 此时文件上出现的图标 注意：当前只是在本地仓库中，远程的服务器仓库中并没有这个文件 Commit 把本地仓库中的文件提交到SVN服务器中 成功提交本地仓库中的文件之后 图标变成绿色的了 切换历史版本 历史版本的选择 选择历史版本 点击OK 这样就切换到了历史版本 Delete 删除的仅仅是本地仓库中的文件 服务器中的文件还是存在的 还需要Commit才能代表服务器端也被删除了 导入导出 导入是将本地文件导入到SVN中 导出就是把整个仓库下载下来，和Checkout的区别就是导出项目的时候没有.svn隐藏文件，也就是说他是不受SVN的控制的 TortoiseSVN冲突的产生 多个用户同时操作同一个文件的时候，就可能产生冲突 用户A和用户B初始的时候的版本是一致的 比如说当前版本号是1 用户A修改文件之后Commit，此时服务器中的版本号就是2 用户B没有Update到最新的版本2，还是在版本1的基础上修改文件之后也进行提交，对应的服务器中的版本号也会是2 此时就会产生冲突 解决冲突 对冲突进行编辑 进行编辑 这里就是对比客户端的数据和服务器端的数据，对于不同的数据进行选择，作为最终的数据 可以看得到在合并的窗口中是最终版本的数据 这就是之前所说的 还是需要人工审核的 Save-&gt;Marked as resolved标记已解决冲突 此时冲突就解决了 可以进行提交 为了避免冲突的产生，我们每一次对文件进行修改之前，都把数据更新到最新的版本再进行修改提交 IDEA下SVN的使用 前提是我们已经安装了TortoiseSVN 在IDEA中进行配置 需要选择svn.exe可执行文件 将工程提交到SVN服务器端 Share Project 将工程提交到SVN服务器 添加服务器端仓库的路径 选择项目存放的位置 Share 然后选择版本 此时 当前项目已经纳入SVN管理了 此时只是创建了项目的目录 还没有进行数据的提交 所以目录中还是空的 加入管理之后，在上方的状态栏会出现5个SVN图标 依次表示的是 Update Project 更新项目 Commit changes 提交项目上所有变化文件 Compare with the Same Repository Version 当前文件与服务器上该文件的版本的内容进行比较。如果当前编辑的文件没有修改，则是灰色不可点击。 Show history 显示当前文件的历史记录 Revert 还原当前被修改的文件到违背修改的版本状态下（还原到指定的版本） 在下方的状态栏会出现SVN的信息 Local Changes 本地修改过的文件都会出现在这里 Repository SVN仓库所有提交记录 Incoming 本地还没有更新的别人提交的代码 Commit操作 上方状态栏的Commit 下方状态栏的Commit 点击项目菜单 Commit界面 此时，在服务器端才能看到我们提交的数据 Add，Update Add将文件添加到本地仓库 Update将本地数据更新到服务器端最新版本 Checkout整个项目到IDEA工作空间中 选择项目到IdeaProjects中 Ignored 忽略要提交的文件：并不是在Commit的时候都需要将所有的文件进行提交，比如jar包就不需要进行提交，还有IDEA自身依赖的文件，比如文件夹.idea和.iml文件 配置忽略上传的文件 可以设置忽略上传的文件,文件夹,正则表达式匹配的文件 解决冲突 当出现冲突的时候 解决冲突 在这里看差别以及修改 然后提交 SVN打分支以及主干合并到分支 分支的定义规则: Project name+日期时间+功能点 Tags的定义规则 Project name+版本号 版本号定义为三段数字 编号 xxx.xxx.xxx 第一个:革命性的产品升级版 第二个:新功能版 第三个:修正bug SVN打分支 首先将服务器端的数据Checkout下来 指定分支的路径 这是仓库中的branches目录下就有了对应的分支，打tags同理 主干合并到分支 首先保证主干是最新的（Update），然后在分支这边进行操作 填写对应的路径即可","categories":[{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"https://www.chasingwind.top/tags/SVN/"}],"author":"ChasingWind"},{"title":"Maven高级","slug":"Maven高级","date":"2019-10-10T06:30:28.000Z","updated":"2021-03-04T00:49:44.862Z","comments":true,"path":"2019/10/10/Maven高级/","link":"","permalink":"https://www.chasingwind.top/2019/10/10/Maven%E9%AB%98%E7%BA%A7/","excerpt":"之前讲解的是Maven的基础使用，本节讲解的是Maven的高级应用，主要是Maven项目的拆分与聚合的思想以及实际操作，并且介绍了Maven的远程仓库和私服的概念","text":"之前讲解的是Maven的基础使用，本节讲解的是Maven的高级应用，主要是Maven项目的拆分与聚合的思想以及实际操作，并且介绍了Maven的远程仓库和私服的概念 Maven基础回顾 Maven是一个项目管理工具 Maven的两个主要的功能 依赖管理 Maven对项目中jar包的管理过程。传统工程我们直接把jar包放置在项目中。Maven工程真正的jar包放置在仓库中，项目中只用放置jar包的坐标。 仓库的种类 : 本地仓库，远程仓库【私服】，中央仓库。 仓库之间的关系：当我们启动一个Maven工程的时候，Maven工程会通过pom文件中jar包的坐标去本地仓库找对应jar包。 默认情况下，如果本地仓库没有对应jar包，maven工程会自动去中央仓库下载jar包到本地仓库。 在公司中，如果本地没有对应jar包，会先从私服下载jar包， 如果私服没有jar包，可以从中央仓库下载，也可以从本地上传。 一键构建 Maven自身集成了Tomcat插件，可以对项目进行编译，测试，打包，安装，发布等操作。 Maven中传统的Web工程 环境搭建 创建数据库maven,创建表 创建Web工程 pom.xml文件的内容 这里是为了演示后面的效果 将所有的依赖全部删除 Maven导入jar包的冲突的解决 当我们导入jar包的时候,会同时将依赖的jar包也进行导入 可见 当我们仅仅导入spring-context的时候 实际导入的jar包是左边的 当我们导入spring-context和spring-beans的时候 可以看到导入的两个jar包都会依赖spring-core，这时候因为两个jar包的版本并不相同，那么spring-core究竟会导入哪一个版本的呢??? 当我们把spring-beans放在spring-context上面的时候 可见导入的spring-core是4.2.8版本的 直接依赖：项目中直接导入的jar包，就是该项目的直接依赖包。比如上面的spring-beans和spring-context 传递依赖：项目中没有直接导入的jar包，可以通过项目直接依赖的jar包传递到项目中去。比如上面的spring-core等等… 当我们直接导入spring-core的jar包的时候，直接依赖和间接依赖的冲突？ Maven工程要导入jar包的坐标，就必须解决jar包的冲突 解决方法1: 声明优先原则，哪个jar包先声明，那么他的jar包坐标下的依赖包，可以优先进入项目中 解决方法2：路径近者优先原则：直接依赖路径比传递依赖路径近，当有直接依赖和间接依赖同时存在的时候，优先进入项目中的是直接依赖。 解决方法3：直接排除jar包的依赖包,也就是直接导入直接依赖的jar包,不导入jar包的依赖包 三大框架的jar包依赖 &lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt; &lt;/properties&gt; &lt;!-- 锁定jar包版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 项目依赖jar包 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 添加tomcat7插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; pom.xml中的标签介绍 &lt;dependencymanagement&gt;标签 : 锁定jar包版本，防止jar包的版本被传递依赖改变，传递依赖指的就是项目A被项目B依赖，那么A项目中的jar包就会传递到B项目中 Maven工程拆分与聚合私服(远程仓库)安装第三方jar包","categories":[{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://www.chasingwind.top/tags/Maven/"}],"author":"ChasingWind"},{"title":"Oracle数据库进阶","slug":"Oracle数据库进阶","date":"2019-10-08T16:12:19.000Z","updated":"2021-03-04T00:54:13.726Z","comments":true,"path":"2019/10/09/Oracle数据库进阶/","link":"","permalink":"https://www.chasingwind.top/2019/10/09/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/","excerpt":"本节主要介绍了Oracle数据库的对象,其中包括视图和索引,还有Oracle编程,介绍了PL/SQL编程语言,主要还是存储过程以及存储函数的使用以及使用Java操作数据库。","text":"本节主要介绍了Oracle数据库的对象,其中包括视图和索引,还有Oracle编程,介绍了PL/SQL编程语言,主要还是存储过程以及存储函数的使用以及使用Java操作数据库。 Oracle对象视图 视图就是提供一个查询的窗口，所有的数据来自于原表，视图中是不存放数据的。 因为创建视图需要dba权限 查询之前的环境使用的是在具有dba权限 的用户下创建的emp表 修改视图 发现 除了视图中的数据发生了改变 , 原表中的数据也发生了改变 因为 所有的数据来自于原表，视图中是不存放数据的。 修改视图的操作是不推荐的 创建只读视图 视图的作用 视图可以屏蔽表中的敏感字段 不在视图中显示 比如上面的视图 你就无法看到原表中工资的情况 保证数据的统一 比如说：一个公司，总部的数据和分部的数据需要使用同一个数据，进行统一，给分部一个视图，这样的话，当总部的数据发生改变，分部使用的数据也是改变之后的，这就保证了数据的统一 索引 在表的列上构建一个二叉树（B-tree，也就是B树），大幅度提高查询效率，但是会影响增删改的效率，因为每次增删改，树的结构就会发生变化，B树就需要重新构造以保持平衡的性质 单列索引：构建在单列上的索引 单列索引的触发条件指的是 ：当查询的条件必须是索引列的原始值的时候，才能够触发索引，否则的话，使用的只是普通的查询 单行函数，模糊查询作为条件都会影响索引的触发 复合索引：构建在多列上的索引 索引的触发 Oracle编程PL/SQL编程语言 PL/SQL编程语言是对SQL语言的扩展，使得SQL语言具有过程化编程的特性 PL/SQL比一般的过程化编程语言，更加灵活高效 PL/SQL主要用来编写存储过程和存储函数等 PL/SQL中的声明函数 相当于Java中的main方法的作用 执行的开始 PL/SQL中的变量的定义 基本类型变量 引用型变量 记录类型变量 将表中的一行作为一个变量(相当于一个对象) 变量的定义: 变量名 变量类型 := 变量值 变量名 表中的列名%type 变量名 表%rowtype 变量的赋值: := select中的into 变量名 PL/SQL中的if判断 注意else if 这里是elsif PL/SQL中的循环loop while循环 exit循环 for循环 PL/SQL中的游标 游标就相当于Java中的集合，可以存放多个对象，多行记录。 当定义游标的时候 后面的select语句的条件是需要我们输入的时候 我们就可以在cur(xx)中定义 在open的时候输入的变量xx 存储过程 存储过程就是已经编译好的PL/SQL,放置在数据库端的Procedure表中,可以直接被调用，一般用于存储固定业务的步骤 我们使用Java操作数据库必须先拿到连接Connection，而PL/SQL因为本身就在数据库端，不需要连接就可以直接操作数据库 创建存储过程 当子程序中有错误的时候 调用存储过程 存储函数 存储函数作用和存储过程是一样的 定义存储函数 存储函数所在的表是Functions 返回值类型 是不能写成number(xx)的 也就是说不能指定返回值的长度 但是可以在定义的变量中指定存储的长度 使用存储函数 存储过程和存储函数的区别 存储过程 : procedure , 无返回值 存储函数 : function , 有返回值,这个特性可以作为自定义函数使用 存储过程想要实现有返回值的业务, 就需要使用out参数 , 本质上还是这个参数被赋值, 而不是真正的有返回值 下面这种情况 就不能使用存储过程使用out参数作为输出来使用了 in和out类型参数 在上面存储过程以及存储函数的使用中，参数默认都是in out类型的参数，用来在存储过程中存储执行的结果 使用存储过程为out参数赋值 in和out类型参数的区别 凡是涉及到into或者:=赋值操作的参数,都必须使用out修饰 触发器 概念和分类 就是制定一个规则，在我们做增删改操作的时候，只要满足该规则，自动触发，无需调用。 语句级触发器： 不包含for each row的触发器 行级触发器：包含for each row的触发器 ​ for each row 的作用是可以使用:new 和:old对象或者说是一行记录 触发器的使用 语句级触发器 当我们成功插入一条数据的时候 在控制台输出 ‘插入成功’ 也就说明触发器执行了 行级触发器 当我们需要新的和老的记录的时候使用 上面的raise_application_error(-20001,&#39;不能降薪&#39;); 表示抛出异常 第一个参数的范围是-20001到-20999之间, 不能重复 表示异常的编号 第二个参数表示异常的提示信息 当我们去执行降薪操作的时候 会弹出异常 并且表中的数据也没有被修改 触发器实现主键自增的功能 将序列作为主键 因为序列的话 每查询一次都会+1 下面的两种情况 都可以使用上面的自增长 在序列的基础上自增 别忘记commit Java调用存储过程和存储函数 环境准备 Oracle10g版本对应的jar包——————-&gt;ojdbc14.jar Oracle11g版本对应的jar包——————-&gt;ojdbc6.jar 使用Java连接数据库 String driver = &quot;oracle.jdbc.driver.OracleDriver&quot;; String url = &quot;jdbc:oracle:thin:@ip地址:1521:orcl&quot;; String username = &quot;&quot;; String password = &quot;&quot;; 使用Java连接Oracle数据库 Java调用存储过程和存储函数 CallableStatement接口 存储函数&#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 存储过程&#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储过程 调用存储函数","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.chasingwind.top/tags/Oracle/"}],"author":"ChasingWind"},{"title":"Oracle数据库基础","slug":"Oracle数据库基础","date":"2019-10-08T06:14:43.000Z","updated":"2021-03-04T00:54:01.501Z","comments":true,"path":"2019/10/08/Oracle数据库基础/","link":"","permalink":"https://www.chasingwind.top/2019/10/08/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","excerpt":"本节主要介绍了Oracle数据库的一些基本概念,Oracle数据库的体系结构以及和MySQL数据库的区别,另外还有关于Oracle数据库的一些基本的操作。","text":"本节主要介绍了Oracle数据库的一些基本概念,Oracle数据库的体系结构以及和MySQL数据库的区别,另外还有关于Oracle数据库的一些基本的操作。 Oracle简介Oracle是一家软件开发公司，因为开发的名为Oracle数据库而名声大噪。Oracle在中国就是甲骨文公司。 Oracle数据库以数据存储量大，处理速度快，安全性高，容错性强等出色特征，长期占有全球数据库市场的重要地位。 Oracle数据库的安装 安装Oracle数据库 使用PLSQL图形化界面连接Oracle数据库（需要在配置Oracle数据库连接的基础上） Oracle数据库的体系结构数据库 Oracle 数据库是数据的物理存储。这就包括（数据文件 ORA 或者 DBF、控制文件、联机日志、参数文件）。 其实 Oracle 数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是 Oracle 就只有一个大数据库。 侧重于硬件 实例 一个 Oracle 实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构 （Memory Structures)组成。一个数据库可以有 n 个实例。 但是一般一个数据库只运行一个实例 用户 用户是在实例下建立的。不同实例可以建相同名字的用户 用户是Oracle管理表的基本单位 表空间 是一个逻辑概念 每个表空间由同一个磁盘上的一个或多个文件组成,这些文件就是数据文件 数据文件 数据文件（.dbf/.ora）是数据库的物理存储单位，数据库的数据是存储在表空间中的，而真正存储是存储在某一个或者多个数据文件中的 而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于 一个表空间。 一旦数据文件被加入到某个表空间后，就不能删除这个数据文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。 注: 表的数据，是由用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。 图中是一个数据库 用户可以对表空间中的数据文件进行操作 用户可以具有不同的权限 由于 Oracle 的数据库不是普通的概念，Oracle是由用户和表空间对数据进行管理和存放的。 但是表不是由表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！ Oracle数据类型 varchar2 长度是可变的 比如 指定varchar2(10) 就表示存储最多10个字符 但是你存进去一个汉字的话 取出来的长度是1 而char(10) 你存进去一个汉字 取出来长度就是10 Oracle的基本操作 Oracle中除了起别名使用双引号或者直接写别名，其他的都是使用单引号 创建表空间 创建表空间 表空间里面可以创建多个.dbf数据文件 将来我们的数据 是由用户放入到表空间中 表空间把数据存储到数据文件中的 一旦数据文件被加入到某个表空间后，就不能删除这个数据文件，如果要删除某个数据文件，只能删除其所属于的表空间才行 删除表空间 这样就可以把数据文件(.dbf)删除了 创建用户 创建新的用户 在Oracle中管理表的基本单位是 用户 而每个用户的权限是不同的 所以我们需要对用户的权限进行设置 为了便于对用户进行授权 在Oracle数据库中使用角色来存储不同的权限 角色就是相关权限的命令集合，使用角色的主要目的就是为了简化权限的管理。 connect 用于常见数据库连接 resource 具有应用开发人员所需要的其它权限，比如建立存储过程、触发器等 dba 超级管理员角色 创建表 修改表结构 增删改数据 需要手动提交数据 Oracle中文乱码显示问题 首先需要配置系统环境变量 并且需要重启Oracle服务 序列 默认从1开始 依次递增 主要给主键赋值使用 序列不属于任何一张表 但是可以在逻辑上与表进行绑定 dual: 虚表 因为在Oracle中查询必须使用from关键字 dual只是为了补全语法使用的 查询当前值 必须在由当前值的情况下 虽然是默认从1开始 但是你不执行一次的话 是没有当前值的 所以查询当前值 需要在nextval执行一次后执行 在插入数据的时候使用 即使rollback了 序列的值也会增加 这就会出现不连续的情况 不过也没关系 我们只需要保证主键非空唯一就行了 Oracle的查询Scott用户介绍 Scott用户管理的表空间里面的表常常作为示例来使用 默认密码tiger 使用之前需要进行进行解锁 用户的表空间中的表 表之间的关系 单行函数 作用于一行，返回一个值 字符函数 大小写控制函数 字符控制函数 索引从1开始 trim的时候 如果有重复的字符(不区分大小写的情况下 ) 是无法删除的 如果没有重复的字符 是区分大小写的 数值函数 日期函数 Oracle 中提供了很多和日期相关的函数，包括日期的加减，在日期加减时有一些规律 日期 – 数字 = 日期 日期 + 数字 = 日期 日期 – 日期 = 数字 转换函数 日期转字符串 字符串转日期 通用函数 任何数和null进行运算 结果都是null nvl(参数1,参数2) 参数1为null的话 就用参数2代替null进行计算 相当于MySQL中的ifnull(参数1,参数2) 条件表达式 MySQL和Oracle通用的写法 等值判断 给员工起中文名 这里的作用有点像Java中的case 当省略else的时候 不匹配的值都是null 范围判断 这里1500-3000范围不需要写&lt;3000是因为 只有小于3000才能进入到&gt;1500的判断中来 Oracle特有的写法（不常用） 起别名 使用单引号的话 会报错的 多行函数（聚合函数） 作用于多行，返回一个值 count(1) 查询总数量 count(1)==count(主键)==count(*) count(*)底层使用的就是count(1) sum() 总和 max() 最大值 min() 最小值 avg() 平均值 分组查询 分组查询中select后面只能使用分组查询的条件和聚合函数，也就是不可以是某个数据的单独的特性，而应该是整个组的特性 group by where 对满足条件的数据进行分组 在group by 之前 having 对分组之后的数据进行筛选 在group by 之后 多表查询 笛卡尔积 等值连接(内连接) 为了筛选出笛卡尔积中的有用的数据 使用等值连接 等值连接没出现之前就是使用内连接 他们的作用相同 左(右)外连接 解决为null的时候 查询不出来的情况 Oracle中特有的外连接(不常用) 自连接 表自身连接 站在不同的角度把一张表看成不同的表 需求 查询员工的姓名 以及员工的领导姓名 子查询 子查询返回一个值 这里有一个隐患就是 因为ename不保证唯一(因为不是主键) 此时当你使用=的时候 就会出现错误 保险起见 这里应该使用in 如果保证子查询唯一的话 也是可以使用=的 子查询返回一个集合 子查询返回一张表 将这里的结果作为一张表 参与查询 分页查询 Oracle中的分页 行号rownum：不属于任何一张表，但是每张表都可以用 当我们在select的时候，每查询出一条记录，就会该行加上一个行号，行号从1开始，依次递增，不间断。 解决方法就是 ： 先进行工资排序 ， 再将它作为子表 然后再用rownum rownum &lt; 11 and rownum &gt; 5 查询出来的是空表 原因 : 因为查询的时候 先执行的是where条件 再执行select加行号的操作 rownum初始化的时候是1 ,1 &lt; 11 然后1 并不大于5 条件不满足 这样的话 就没有记录 就无法添加行号1 上面也说了 行号rownum 从1开始依次递增 不间断 所以查询就是空的 结论 : 行号rownum不能写成大于一个正数 间接使用 rownum &gt; 5 因为rownum不属于任何一张表 所以不能使用表名.rownum的方法 但是可以给行号取别名使用 在实际的使用中的范围需要是动态的","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.chasingwind.top/tags/Oracle/"}],"author":"ChasingWind"},{"title":"Git","slug":"Git","date":"2019-09-29T13:32:54.000Z","updated":"2021-03-04T00:46:12.273Z","comments":true,"path":"2019/09/29/Git/","link":"","permalink":"https://www.chasingwind.top/2019/09/29/Git/","excerpt":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] Git 是 [Linus Torvalds](https://baike.baidu.com/item/Linus Torvalds/9336769) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件","text":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] Git 是 [Linus Torvalds](https://baike.baidu.com/item/Linus Torvalds/9336769) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件 Git概念 Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] Git 是 [Linus Torvalds](https://baike.baidu.com/item/Linus Torvalds/9336769) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 最初是使用在Linux上的代码版本管理工具的,现在各个系统都有对应的版本. Git和SVN的区别 SVN是集中式版本管理工具 SVN需要有一台服务器来击中管理代码 Git是分布式版本管理工具, 没有中央服务器 使用Git的用户自己的电脑中就有一个和远程仓库中相同的版本库 本地仓库：每一个开发人员的电脑上都有一个本地仓库，实现在本地仓库实现代码的管理，如果开发项目只需要一个人来完成，那么只需要一个本地仓库就足够了 远程仓库：多人协作开发一个项目，就需要进行代码的交换，这个时候就需要一个共享版本库（远程仓库），远程仓库和本地仓库的内容是相同的 Git的工作流程 从远程仓库中克隆（Clone） Git 资源作为本地仓库。 从本地仓库中Checkout代码然后进行代码修改 在提交（Add）前先将代码提交到暂存区。 提交（Commit）到本地仓库。本地仓库中保存修改的各个历史版本。 在修改完成后，需要和团队成员共享代码时，可以将代码Push到远程仓库。 流程图 Git的安装 Windows下安装 直接默认进行安装,一直下一步就行了 安装好之后,右键菜单中就会出现Git Git GUI 和 Git Bash 在 Git Bash中是支持Linux 命令的 由于原生的Git使用起来并不是很方便 ,可以使用tortoisegit 安装的时候选择OpenSSH,并且需要执行Git所在的目录,所以需要在安装TortoiseGit之前需要先安装Git Git的使用使用Git创建版本库(本地仓库) 在需要的目录下创建本地仓库(Repository),即使.git目录 Git Bush 使用命令git init 创建一个本地仓库 Git GUI 首先打开Git GUI 点击创建新的仓库 选择本地仓库的目录 点击Create之后就会创建本地仓库 Tortoise Git 在需要的目录点击创建新的本地仓库 不勾选点击OK 查看.git目录中的内容 向本地仓库添加文件 如果想向本地仓库添加文件的话, 文件必须在工作目录下 工作目录 这里的工作目录就是包含.git的目录, 这里指的就是repo目录,也就是和.git所在的目录 本地仓库目录.git 向本地仓库添加文件 首先,文件需要在工作目录中 然后,使用Add把文件添加到暂存区中, 添加完成后文件上就会显示一个+号 最后,使用Commit将暂存区中Add的文件提交到当前分支中 Commit的时候需要选择分支, master分支是在创建版本库的时候默认创建的 填写日志信息并提交 在工作目录中的文件上显示√ 可以简单理解为: 需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改到本地仓库。 使用TortoiseGit查看本地仓库中已经提交的内容 Tortoise–&gt;Repo Broswer 可以查看我们提交的文件 修改文件并提交 可以直接使用TortoiseGit的提交,这里就包括了Add+Commit的两个操作 填写日志 点击Commit 查看提交记录,对比修改的内容 在需要查看的文件上点击右键 点击Show log查看日志 选中需要对比的文件 进行比较 这里就可以查看到修改的内容了 删除文件 删除工作目录中的文件并删除本地仓库中的文件 首先,需要在工作目录中的文件删除 但是此时本地仓库中其实还是存在着这个文件的 所以,如果我们不小心删除了文件 , 是可以还原回来的 点击需要还原的文件就可以还原了 ‘ 删除本地仓库中的文件, 其实就是将删除文件的这个修改提交到本地仓库 直接Commit 再次查看就会发现本地仓库中已经不存在了 不删除工作目录中的文件删除本地仓库中的文件 当我们需要保留本地的配置文件的时候,就是说把不需要的文件在本地仓库中删除,而在工作目录中保留 使用删除并保留本地副本 但是此时在本地仓库中还是存在文件的 提交之后,可以删除本地仓库中的文件,但是在工作目录中还是存在的 将Java工程添加到本地仓库 忽略的文件","categories":[{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.chasingwind.top/tags/Git/"}],"author":"ChasingWind"},{"title":"SSM整合","slug":"SSM整合","date":"2019-08-31T06:53:30.000Z","updated":"2021-03-04T00:56:28.838Z","comments":true,"path":"2019/08/31/SSM整合/","link":"","permalink":"https://www.chasingwind.top/2019/08/31/SSM%E6%95%B4%E5%90%88/","excerpt":"前面的三个框架学到这里该来一个整合了，将Spring，SpringMVC还有MyBatis框架搭建成一个完成的开发环境，所以还是很重要的内容。","text":"前面的三个框架学到这里该来一个整合了，将Spring，SpringMVC还有MyBatis框架搭建成一个完成的开发环境，所以还是很重要的内容。 搭建开发环境 整合的思路：使用Spring去整合SpringMVC和MyBatis框架，使用XML+注解的方式进行配置 数据库环境的搭建 创建web项目 导入相关的依赖 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!--版本锁定--&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;8.0.11&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--单元测试junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--MySQL数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl表达式--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!--MyBatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建java和resources文件夹还有三层架构的包以及JavaBean的包 首先需要创建edu.ahnu之类的GroupId 创建Account的JavaBean 创建Dao Dao中的方法我们可以不使用实现类来实现 所以只需要编写AccountDao接口 创建Service以及实现类 创建web层的Controller 整体的目录结构 Spring框架代码的编写框架的整合是在Spring的基础上进行的，所以我们首先需要完成Spring的搭建 这里使用applicationContext.xml而不能使用spring.xml 因为后面的Spring整合SpringMVC的时候需要监听配置文件的加载 监听器只能监听到applicationContext.xml 首选在resources目录下创建spring.xml配置文件来管理Service和Dao层 在配置文件中添加约束 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;https://www.springframework.org/schema/context&quot; xmlns:aop=&quot;https://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;https://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd https://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd https://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;/beans&gt; 开启注解扫描，要扫描的是service和dao层的注解，要忽略web层注解，因为web层让SpringMVC框架去管理 Ctrl+N搜索Controller注解的全路径 然后使用Copy References获取类所在的包的路径 在Service上添加注解 进行测试 控制台中的信息 是缺少log4j配置文件 在resources中添加配置文件就行了 至此, Spring框架就可以正常使用了 SpringMVC环境搭建 在web.xml中配置前端控制器和解决中文乱码的过滤器 在resources目录下创建springmvc.xml 加入约束 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;https://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;https://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd https://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 设置静态资源不过滤 &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt; &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt; 测试 去请求Controller中的方法 首先 完成jsp文件的编写 index.jsp success.jsp 控制器类 注意这里的文件路径的创建 进行测试 可以完成页面的跳转 Spring整合SpringMVC这里的整合需要完成的就是，启动服务器,加载配置文件,注入Service层方法,在Controller方法中可以调用Service层的方法 要想在Controller中使用Service对象，就需要依赖注入（DI），但是有一个问题！ 在服务器启动的时候，在web.xml中配置了前端控制器去加载sprngmvc.xml配置文件，在这个配置文件中只扫描Controller注解，别的注解不扫描，也就是说我们的Spring的配置文件就没有加载过，那么其中的扫描就不会生效，那么Service类就不会加入到IoC容器中 ，那么就无法使用依赖注入 所以，我们需要做的就是在服务器启动的时候加载Spring的配置文件，同时扫描就会生效，Service类就会被放到容器中，我们就可以使用依赖注入的方式创建Service对象 Spring整合SpringMVC的原理 监听器可以使用Spring为我们提供好的Spring-web中的类ContextLoaderListener,使用他来加载我们的配置文件,而我们只需要进行配置就行了 在web.xml中进行配置Spring的监听器 但是这个监听器默认只会加载WEB-INF目录下的applicationContext.xml文件 但是我们的配置文件放在了resources目录下 所以需要告诉监听器加载的文件的路径 这样就完成了Spring的配置文件的加载 也就会进行注解的扫描 创建对应的bean注入到IoC容器中 可以使用依赖注入的方式来创建对象 调用Service中的方法 成功执行 MyBatis环境搭建在这里使用的是注解的形式,当然也可以使用xml的方式来进行配置 另外还需要核心配置文件SqlMapperConfig.xml来配置数据库的连接信息 在AccountDao的方法上添加注解 在resources目录编写核心配置文件SqlMapConfig.xml 进行测试 测试findAll() 成功获取到数据库中的数据 测试saveAccount 在数据库中保存成功 Spring整合MyBatis基础整合怎样才能算才算整合成功? Service层(Spring)调用Dao层(MyBatis)去做相应的操作,执行成功 我们需要把Dao使用的代理对象存放到容器中,在Service中注入才能使用 在applicationContext.xml配置文件中进行MyBatis的配置 工厂可以帮我们创建SqlSession对象 SqlSession对象可以帮我们拿到代理对象 有了代理对象就可以将代理对象存放在IoC容器中 配置AccountDao 是为了让Spring直到要帮我们生成哪些接口的代理对象 在配置完成之后 我们就不再需要SQLMapperConfig.xml文件了 可以将它删除 还有jdbcConfig.properties也不再需要 在AccountDao上添加注解 将AccountDao交给IoC来管理 在AccountService中注入AccountDao 进行测试 在Controller类中 我们将从数据库查询到的数据进行封装 在页面中获取信息 结果 获取到了我们的数据 开启事务配置声明式事务管理 在index.jsp中测试保存用户 在Controller中编写对应的方法 这里我们使用的是重定向到之前的查询所有的方法 测试 查询的结果","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.chasingwind.top/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"https://www.chasingwind.top/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.chasingwind.top/tags/SpringMVC/"}],"author":"ChasingWind"},{"title":"SpringMVC返回值类型和响应数据类型","slug":"SpringMVC返回值类型和响应数据类型","date":"2019-08-29T12:37:40.000Z","updated":"2021-03-04T00:56:08.313Z","comments":true,"path":"2019/08/29/SpringMVC返回值类型和响应数据类型/","link":"","permalink":"https://www.chasingwind.top/2019/08/29/SpringMVC%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要","text":"这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 响应数据和结果视图响应返回值类型: String返回字符串，视图解析器会根据返回的字符串去跳转到对应的页面 最基本的响应 Controller控制器类中的方法 点击跳转 通过页面的跳转完成数据响应到页面上 一般我们用在将我们从数据库中查询到的数据 存放在request域中 跳转到指定的页面之后，可以获取Request域中的数据 在页面中我们可以取出数据进行操作 响应返回值类型: void 默认情况: 默认去跳转到以请求路径为名的文件 当没有方法返回值的时候 方法是执行了的 跳转会报错 错误显示 没有testVoid.jsp(默认的是我们请求的路径的名字)资源 也就是说 当返回值为void的时候 视图控制器会去根据我们在springmvc.xml中的配置的响应的目录和后缀名去查找名称为我们配置的方法的path值的文件 没有的话 就会报错 使用request和response请求转发到指定的页面 使用请求转发来指定跳转的页面 还可以使用重定向的方式 重定向不能访问WEB-INF目录下的文件 这里是在webapp目录下新建的success.jsp文件 还有一个作用就是 将数据直接响应到页面 这样还是跳转到配置路径为名的页面 但是不会再报错 响应返回值类型: ModelAndView ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图 完成的功能: 既可以完成数据的封装, 还可以跳转到指定的页面 同样的 在跳转到的页面可以获取域中的数据 其实在返回String类型的时候 底层使用的也是ModelAndView SpringMVC提供的转发和重定向 控制器中的方法在提供了 String 类型的返回值之后，默认就是请求转发,就是上面的返回值是String类型的情况,使用的是视图解析器。我们也可以写成： 请求转发 需要注意的是，如果用了 forward：则路径必须写成实际视图 url，不能写逻辑视图。也就是使用的不再是视图解析器 路径需要我们自己提供 它相当于于“request.getRequestDispatcher(“url“).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器中的方法。 重定向 重定向需要注意的是 我们不需要再提供项目的名称 底层已经帮我们实现 异步请求以及响应当客户端发送的是Ajax异步请求的时候，在后台我们需要把响应的信息转换成JSON的字符串进行响应。 异步环境的搭建 在webapp目录下创建js文件夹存储引入的jQuery.js文件 在页面中引入jQuery 并添加按钮绑定单击事件 结果 页面不显示弹出内容 原因是 在前端控制器中 配置的拦截所有的页面 这个静态文件jQuery.js也被拦截了 需要告诉前端控制器 在springmvc.xml中设置不拦截静态资源 进行测试 可以将弹窗弹出 发送Ajax请求 单击按钮发送Ajax请求到服务器 在方法中接收请求中的数据 将上面拿到的JSON数据封装到JavaBean中，响应给客户端 当请求中的JSON的data中的数据的key值等于要封装的JavaBean的属性值的时候 可以使用已经封装好的方法进行数据的封装 使用jackson来完成 在pom.xml导入依赖 但是此时在客户端收到的数据是JSON格式的 所以返回对象是不行的 需要将对象转换为JSON格式 使用@ResponseBody注解 @ResponseBody 用于将方法的返回值以特定的格式写入到response的body区域，进而将数据返回给客户端。当方法上面没有写ResponseBody,底层会将方法的返回值封装为ModelAndView对象 假如是字符串则直接将字符串写到客户端, 假如是一个对象，此时会将对象转化为json串然后写到客户端 控制层方法的返回值是如何转化为json格式的字符串的呢？其实是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。如果是bean对象，会调用对象的getXXX（）方法获取属性值并且以键值对的形式进行封装，进而转化为json串。如果是map集合，采用get(key)方式获取value值，然后进行封装。 在客户端的Ajax请求中就可以使用回调函数来完成数据的操作 测试 客户端拿到了我们的数据 而且是Object类型的 也就是jackson帮我们完成了封装 在以前 这样的处理还需要转换为流对象 ….. 改正上面的两个错误 第一个就是json的MIME类型 第二个就是jackson的版本过低会报错 改成2.9.8 SpringMVC实现文件上传 使用Web来实现文件的上传 首先使用表单来完成文件的选择 在后端的方法中来解析上传的文件 这里需要导入jar包 提交的表单 内容会被封装到Request对象中 我们可以在Request中获取 最终会将文件上传到target目录下的uploads目录下 使用SpringMVC来完成文件的上传 原理 我们需要做的就是 配置文件解析器 并且在控制器类的方法的参数中将上传的文件项作为参数 两点注意 第一点就是form表单中 第二点就是 在配置文件解析器的时候的id 必须是multipartResolver SpringMVC跨服务器的文件上传 在实际开发中，我们会有很多处理不同功能的服务器。例如： 应用服务器：负责部署我们的应用 数据库服务器：运行我们的数据库 缓存和消息服务器：负责处理大并发访问的缓存和消息 文件服务器：负责存储用户上传文件的服务器。 准备两个tomcat服务器(一个是应用服务器,一个作为图片服务器)，并创建一个用于存放图片的web工程 在文件服务器的 tomcat 配置中加入，允许读写操作。文件位置: web.xml 在图片服务器中添加依赖 编写代码 SpringMVC异常处理以及拦截器异常处理当我们处理过程中出现异常的时候，如果我们不使用异常处理器的话，异常就会一直向上抛出，直到浏览器显示异常。这样的异常提示很不友好，所以，我们可以通过异常处理器来完成异常页面的显示 如果我们程序中有错误的话，并且我们不进行处理 就会在浏览器显示错误信息 使用异常处理器进行错误处理 编写自定义异常类（做提示信息） 捕获异常 编写异常处理器 配置异常处理器（跳转到提示页面） 在springmvc.xml中进行配置 编写error.jsp 也就是将来需要跳转到的页面 获取异常的信息 进行测试 异常会在控制台输出 但是在页面上会跳转到我们的error.jsp 并且 提示我们自定义类的异常的信息 拦截器Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器(Controller控制器类)进行预处理和后处理(分别是拦截和放行)。 拦截器和Servlet中过滤器的区别 过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 过滤器在 url-pattern 中配置了*/**之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 拦截器的使用 编写拦截器类，实现接口 这里先使用预处理方法 配置拦截器 在springmvc.xml中进行配置 测试 可见 在Controller控制器方法执行之前 先执行了拦截器中的方法 拦截器类中的方法 上面我们使用了其中的预处理的方法preHandle 当我们使用的返回值是false时候 是不会放行的 这个时候我们可以使用方法来进行请求转发或者重定向等等 比如 可以用在将用户未登录的时候 进行拦截 跳转到提示用户登录的页面 这样就不会跳转到之前的成功页面了 注意各个方法执行的时机 拦截器链 多个拦截器 在springmvc.xml文件中进行配置","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.chasingwind.top/tags/SpringMVC/"}],"author":"ChasingWind"},{"title":"SpringMVC概述以及入门","slug":"SpringMVC概述以及入门","date":"2019-08-27T15:04:49.000Z","updated":"2021-03-04T00:56:18.026Z","comments":true,"path":"2019/08/27/SpringMVC概述以及入门/","link":"","permalink":"https://www.chasingwind.top/2019/08/27/SpringMVC%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/","excerpt":"本节介绍了SpringMVC的基本概念以及SpringMVC的入门案例的编写，对请求参数中的数据进行绑定，自定义类型转换器还有一些常用的注解。","text":"本节介绍了SpringMVC的基本概念以及SpringMVC的入门案例的编写，对请求参数中的数据进行绑定，自定义类型转换器还有一些常用的注解。 SpringMVC的基本概念 三层架构 表现层(SpringMVC) : 接收客户端发送的请求 , 与后台进行交互 , 然后将结果进行封装,响应给客户端浏览器 业务层(Spring) 持久层(MyBatis) MVC模型 表现层的框架一般都会使用MVC模型 MVC 设计模型 M Model 模型—&gt;JavaBean V View 视图—&gt;JSP C Controller 控制器—&gt;Servlet SpringMVC框架 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。 Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成 为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。 SpringMVC的优势 模块化设计, 每个模块单独完成对应的功能 分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 等等….. SpringMVC和Struts2框架的对比分析(面试) 共同点 都是表现层框架 , 都是基于MVC模型的 底层都离不开原始的ServletAPI(Request和Response) 处理请求的机制都是一个核心控制器 区别 SpringMVC的入口是Servlet , Struts2的入口是Filter SpringMVC(单例) 是基于方法设计的，而 Struts2 是基于类(多例)，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。 SpringMVC 使用更加简洁,同时还支持 JSR303, 处理 Ajax 的请求更方便 (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。) Struts2 的 OGNL 表达式使页面的开发效率相比 SpringMVC 更高些，但执行效率并没有比 JSTL 提升，尤其是 struts2 的表单标签，远没有 html 执行效率高。 SpringMVC的入门入门案例的分析以及编码 入门案例的需求 环境搭建 创建maven-webapp项目 在项目的目录下创建java,resources目录 并且右键MakeAs… pom.xml中导入依赖 配置前端控制器(就是一个Servlet) 在web.xml中进行配置DispatcherServlet 在resources下创建配置文件springmvc.xml (不需要后缀名) 部署到本地的Tomcat 入门案例代码编写 我们需要写一个index.jsp 此jsp中有一个超链接 当我们点击的时候 会跳转到另一个jsp页面 这里通过超链接进行跳转使用的是GET的方式 编写Controller控制器类 用来接收超链接的请求 点击超链接之后 要让Controller中的方法执行 就需要这个类的对象 在springmvc.xml中控制反转的方式创建对象 引入约束文件 开启SpringMVC扫描的包 在Controller类上面添加表现层的注解@Controller , 用于创建对象 有了控制器对象之后 , 需要点击这个超链接发送请求,然后去执行这个方法 在方法上面使用注解@RequestMapping 请求映射 , 将我们的请求映射到当前的方法 需要填写请求的路径path 在web.xml中配置加载SpringMVC的配置文件springmvc.xml 上面完成的功能 : 发送请求,通过控制器就能执行其中的方法sayHello 还需要在方法中完成页面的跳转 SpringMVC的默认的规则 返回的字符串表示的是跳转到的jsp文件的名字 在WEB-INF目录下创建success.jsp文件 是需要跳转到的页面 指定控制器类中的方法执行完 , 去找到这个success.jsp页面 在springmvc.xml中配置视图的解析器InternalResourceViewResolver 这个类会帮助我们进行页面的跳转 需要配置的是跳转到的页面所在的目录以及页面的后缀名 开启SpringMVC注解的支持 在springmvc.xml配置文件中进行配置 在超链接中添加跳转的路径(相对路径) href属性中不能写/ 因为写这个的话 作用是在根目录下查找hello文件 以“/”开头的，那就表示直接回到起点重新开始。网址如果有太多层目录,这时候我们简单粗暴地用“/”开头，就直接回到根目录，然后再顺着向下查找对应的资源文件。所以要记得，其它相对路径的规则前面是不加“/”的哟！ 这样就完成了需求 , 进行测试 index.jsp 点击跳转 成功进行了跳转 入门程序的流程分析 启动服务器，加载相关的配置文件 在web.xml中 配置的前端控制器(DispatcherServlet)在服务器启动的时候就会被创建出来 这个对象会去类路径下加载springmvc.xml配置文件 在springmvc.xml中 , 回去扫描注解所在的包 , 通过控制反转创建控制器类对象放入Ioc容器中(@Controller) , 创建视图解析器对象(完成页面的跳转) , 通过RequestMapping注解配置请求会执行的方法 发送请求，后台处理请求 点击超链接发送请求 执行DispatcherServlet(前端控制器) , 因为在Servlet中匹配了所有的请求 根据请求的URL（超链接中）对应到ResultMapping的值，找到执行的具体的方法 方法执行完返回success 控制器去找视图解析器对象 在springmvc.xml中配置视图解析器 视图解析器会帮助我们跳转到success.jsp 控制器会将这个页面响应给客户端 案例中的组件介绍 SpringMVC框架基于组件方式执行流程 , 每个组件完成单独的功能 前端控制器（DispatcherServlet） : 控制整个流程的执行 用户请求到达前端控制器，它就相当于 MVC模式中的 C(Controller控制器)，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求, DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器（HandlerMapping） : 映射到某个类中的某个方法 HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器（HandlerAdapter） : 适配@Controller的bean对象, 去执行对象中的方法 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 处理器（Handler）:也叫作Controller 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 视图解析器（View Resolver） : 跳转到具体的页面 View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 RequestMapping注解 作用 : 用于建立请求 URL 和处理请求方法之间的对应关系。 出现位置 类上 请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的 URL 可以按照模块化管理: 当在一个类中有多个方法的时候 在类上面配置访问的一级目录 在方法上配置访问的二级目录 请求的路径就可以编写两级的路径 才只能对应到具体的方法 方法上 请求 URL 的第二级访问目录。 RequestMapping中的属性 path : 指的是映射的路径(请求的URL) , 和value属性的作用相同 value : 和path的作用相同 method : 指定接收的请求的方式 , 只有对应的请求方式才会执行这个对应的方法 比如 我配置这里的/hello为POST 但是超链接访问的方式是GET 那么就会报405错 Method Not Allowed params : 用于限制请求参数的条件 , 支持简单的表达式. 要求请求中的参数的key和value必须和params中的配置的一样 这里的意思就是 请求的参数中必须包含username 不添加的时候 会报错 添加username 还可以指定表达式 只有请求参数中符合表达式才可以完成方法的执行 比如 : 而请求中未添加username的值zhangsan 或者添加的不是zhangsan 都会报错 正确的请求 headers : 限制请求消息头的条件 , 也就是限制在发送请求中必须包含的请求头 请求参数的绑定获取客户端请求中的参数 , 就是请求参数的绑定 绑定机制 表单提交的数据都是key=value格式的,比如: username=haha&amp;password=123 SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的, 这样就可以对用户请求的数据进行操作了 要求：提交表单的key和方法的参数的名称是相同的 支持的数据类型 基本数据类型和字符串类型 请求的URL 参数绑定 并执行方法 params.jsp页面 点击超链接 就会跳转到success页面 并且超链接中绑定的有参数 在控制台输出了对应的数据 说明已经获取到了请求的参数 JavaBean类型 请求中的参数的name的值要等于JavaBean中的属性的值, 只有这样 , SpringMVC才会帮助我们正确地进行封装 在方法中填写需要封装的JavaBean就行 在控制器类中只需要告诉SpringMVC封装到的JavaBean 提交表单 这里先不要用中文 会乱码 控制台输出 当需要封装的JavaBean中有别的类的引用的时候 在这里User类中有引用类型Account 在Account类中的属性 我们是将account中的属性封装到account , 再将account作为属性封装到User对象中 所以在请求参数中这样填写name 映射的方法的参数还是User对象 测试 结果 解决POST请求中文乱码问题 在web.xml进行配置 使用的是过滤器 测试之前的中文数据 控制台正常输出 集合数据类型(List,Map集合等等) 在User里面封装List和Map 在表单中填写 测试 List和Map都进行了封装 自定义类型转换器 在我们的请求中，数据都是以String类型进行传输的，请求参数绑定的过程中，可以正确地转换为对应的类型，其实就是SpringMVC帮我们进行了数据类型的转换 但是有些类型不支持转换，比如我们自定义的日期格式2019-08-29默认转换的话就会出现异常，所以需要我们进行自定义类型的转换 表单数据封装到Account 当我们使用提供的格式填写日期的时候 控制台正常输出 并且没有出现异常 但是当我们使用其他格式的日期时 已经出现了客户端4XX错误 也就是在数据封装的时候类型转换出现了错误 使用自定义数据类型转换器 定义一个类，实现Converter接口，该接口有两个泛型&lt;S,T&gt;，S表示传入的字符串，T表示需要转换成的类型 实现接口中的convert方法 在springmvc.xml中配置自定义类型转换器 将我们自定义的类型转换器设置生效 在标签&lt;mvc:annotation-driven&gt;中配置自定义的来类型转换器 测试 输入的日期格式 转换的结果 成功转换 并未报错 获取原生的Servlet的API 直接在需要的方法中添加参数 获取成功 常用的注解@RequestParam 作用：将请求中指定名称的参数赋值给控制器中的形参。 属性 value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 可以用来解决当请求中的参数与你要封装到的参数的名称不同的时候 请求中的参数是name 而需要在方法中绑定的参数是username 而非请求参数中的name 在控制台的输出显示 并没有成功地进行封装 此时就可以使用注解@RequestParam来进行匹配 其中的value属性就是指定请求参数中的参数 再次进行请求 就封装上了 至于required属性的话 默认值就是true 可以不进行配置 这个属性为true的作用就是 请求参数中必须有含有指定的属性的名字 比如 当你的请求中的参数是uname而不是name 机会报错 甚至是username的时候 也会出现错误 @RequestBody 作用：获取请求体中的内容，直接使用得到是 key=value&amp;key=value…结构的数据。 GET 请求方式不适用，因为GET请求方式中没有请求体。 属性 POST方式 在方法的参数上使用注解 参数的名字不能和请求中的属性名相同 成功获取到请求体 因为在http协议中传输的时候会进行URL编码 这里是进行了URL编码的结果 @PathVaribale RESTful风格的URL路径 请求的路径相同，但是在请求的时候(请求的超链接)使用不同的请求方式（GET，POST，PUT，DELETE等等）来区别不同的方法来执行。 当请求的路径和请求的方式都相同的时候，就可以使用占位符来区别不同的执行方法 Restful风格结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 注解@PathVariable 作用: 用于绑定 URL 中的占位符。例如：请求 url 中 /delete/{id}**，这个{id}**就是 url 占位符。 在请求路径中添加占位符来区别不同执行方法 使用注解获取URL中的占位符 @RequestHeader 作用 : 用于获取请求的消息头 不能这样获取消息头 需要指定消息头的键的名称 这样的结果就是报错 需要指定你要获取的对应的消息头 @CookieValue 作用 : 用于把指定 Cookie 名称的值传入控制器方法参数。获取Cookie的值 同样也需要指定获取的Cookie的键的名称 @ModelAttribute 作用 它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可 以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 演示作用在方法上 作用在方法上 在请求的连接中请求的是testModelAttribute 但是在结果中 先执行的是添加注解的方法 使用场景 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 比如 我们表单中提交的不完整的时候 可见 封装的对象中的date就是null 我们可以借助这个注解 在控制器方法执行前 把这个date的值从数据库中查询获取并封装 然后将这个封装的完整的对象返回给控制器方法 这样的话 控制器方法中的封装的对象属性既不会是null了 提交的表单数据 通过@ModelAttribute在控制器方法之前将未提供的表单数据进行封装 结果 date被封装上数据 演示作用在参数上 还是上面的案例 这里是当注解修饰的方法没有返回值的时候 采取的做法就是 将封装的对象存到map集合中 在控制器方法中的参数上 通过注解来取出集合中的这个对象 这样同样可以将数据封装进去 @SessionAttributes 作用: 用于多次执行控制器方法间的参数共享, 作用在类上 属性: value：用于指定存入的属性名称 type：用于指定存入的数据类型。 多次请求之间的Session共享 可以使用原生的Request 也可以使用Model来将数据存储到Request域中 可以看到 数据已经存储在request域中 SessionAttributes的使用 在类上添加注解 使用注解可以将数据添加到Session域中 Session域中已经存储了数据 那么在Session域中就可以对这些数据进行操作 比如 取Session 删除Session","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.chasingwind.top/tags/SpringMVC/"}],"author":"ChasingWind"},{"title":"Spring中的JdbcTemplate以及事务控制","slug":"Spring中的JdbcTemplate以及事务控制","date":"2019-08-25T01:52:38.000Z","updated":"2021-03-04T00:55:26.410Z","comments":true,"path":"2019/08/25/Spring中的JdbcTemplate以及事务控制/","link":"","permalink":"https://www.chasingwind.top/2019/08/25/Spring%E4%B8%AD%E7%9A%84JdbcTemplate%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","excerpt":"本节介绍了我们之前一直使用的Spring中的JdbcTemplate中的一些常用点的介绍，另外介绍了声明式的事务控制的实现的方式，分别使用XML，注解和纯注解的方式实现事务控制。","text":"本节介绍了我们之前一直使用的Spring中的JdbcTemplate中的一些常用点的介绍，另外介绍了声明式的事务控制的实现的方式，分别使用XML，注解和纯注解的方式实现事务控制。 Spring中的JdbcTemplate Spring中的new BeanPropertyRowMapper&lt;&gt;()是将结果封装成对象,再装进集合中 Spring已经为我们提供好了方法 我们只需要指定new BeanPropertyRowMapper&lt;封装的实体类&gt;(实体类的字节码文件) JedcDaoSupport的使用 : 用于抽取多个Dao中的重复代码，通过继承JdbcDaoImpl来实现 Spring中基于声明式事务控制通过Spring的AOP的方式添加事务控制 , 类比我们自己之前使用动态代理实现的事务管理器 Spring中的事务控制的API JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计业务层的事务处理解决方案。 Spring 框架为我们提供了一组事务控制的接口。 Spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。 PlatformTransactionManager接口 接口中有commit和rollback 可以作为通知bean 他的实现类有 二者的区别就是一个使用数据源(数据库的连接信息等等)一个没有使用 TransactionDefinition接口 事务的定义信息 事务的隔离级别：Spring默认使用的是数据库的隔离级别 事物的传播行为：什么情况下必须有事务（增删改，Required），什么情况下事务可有可无（查询，Supports） 事务是否只读：查询的时候设置为只读 TransactionStatus接口 事务状态 存储点 : 事务是按步提交 , 一旦设置存储点 , 每个存储点就是事务的一步, 执行成功就提交这一步,所有步骤都成功,提交事务. 失败的话 , 回滚到存储点之前 使用步骤 配置事务管理器 配置事务信息 配置切入点表达式 基于XML配置 添加约束 DataAccess中的 配置事务管理器 并注入数据源 配置事务的通知 使用tx:advice配置事务的通知 属性id : 事务通知的唯一标识 属性transaction-manager : 给事务通知提供一个事务管理器引用 配置AOP中的切入点表达式 建立事务通知和切入点表达式的对应关系 需要将这个接口中的提交和回滚的方法对应到需要增强的Service中 建立切入点表达式和事务通知的关系 &lt;aop:advisor&gt;定义通知器 (通知器跟切面一样，也包括通知和切点) &lt; aop:advisor&gt;和&lt; aop:aspect&gt;其实都是将通知和切面进行了封装，原理基本上是一样的，只是使用的方式不同而已。 配置事务的属性 在事务通知的内部(&lt;tx:advice&gt;)进行配置 name : 需要进行事务管理的方法 isolation : 用于指定事务的隔离级别 , 默认是DEFAULT , 表示使用数据库的默认的隔离级别 propagation : 用于指定事务的传播行为 ,表示一定会有事务进行管理 .默认值是REQUIRED , 增删改的选择 ;查询使用SUPPORTS read-only : 指定事务是否只读 默认值是false , 用于查询的情况才能为true timeout : 用于指定执行事务的超时时间 , 默认值是-1 , 以秒为单位 rollback-for : 用于指定一个异常 , 当产生该异常的时候 , 事务回滚. 产生其他的异常的时候 , 事务不回滚 . 没有默认值. 表示任何异常都回滚 no-rollback-for : 用于指定一个异常 , 当产生该异常的时候 , 事务不回滚. 产生其他的异常的时候 , 事务回滚 没有默认值. 表示任何异常都回滚 如果以上两个都不指定的话 是默认回滚的 一般我们只需要进行配置的话 还可以使用通配符的方式 下面的优先级较上面的高 但是匹配的是以findXxx类型的查询方法 总配置图 表示的是 对于edu.ahnu.service.impl包下的所有的方法进行增强 增强的方法是txAdvice(事务管理) 测试 在无异常的情况下转账成功 在有异常的情况下进行了回滚的操作 基于注解配置 添加约束 配置Spring创建容器的时候需要扫描的包 配置Service和Dao Service Dao Dao需要注入JdbcTemplate 配置JdbcTemplate 注入数据源 Spring中基于注解的配置 配置事务管理器 开启Spring对注解事务的支持 在需要事务支持的地方使用@Transactional注解 对于不使用默认的 需要单独在方法生进行配置 测试通过 Spring基于纯注解的事务控制在基于注解的配置的基础上进行配置 首先 配置Spring扫描的包 对应的操作 配置Jdbc以及数据库的连接的信息 在JdbcConfiguration类中进行配置上面的两个信息 并且在主配置文件中 进行指定对应的配置文件的路径 然后就是 开启注解支持 在主配置中添加注解支持的配置 事务管理器的配置 创建TransactionConfig类进行配置 在主配置文件中配置 在测试类中指定主配置文件 进行测试 发现成功 甚是欣喜!","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.chasingwind.top/tags/Spring/"}],"author":"ChasingWind"},{"title":"Spring中的AOP及其配置","slug":"Spring中的AOP及其配置","date":"2019-08-24T01:52:09.000Z","updated":"2021-03-04T00:55:12.795Z","comments":true,"path":"2019/08/24/Spring中的AOP及其配置/","link":"","permalink":"https://www.chasingwind.top/2019/08/24/Spring%E4%B8%AD%E7%9A%84AOP%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE/","excerpt":"这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要","text":"这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 完善Account案例以及问题分析 在Service中添加转账的方法 上面的问题就是 在两次updateAccount之间 出现了 异常 这样导致的就是 在A账户减了钱 B账户的钱没有增加 问题分析 上面出现的问题是什么导致的呢 ? 首先不是没有事务 , 因为在增删改中 我们也没有进行事务的提交 但是却可以执行成功 这说明增删改是有事务管理的 那么分析 这里可以看到每次执行都是一个新的连接 而每个连接都是由一个事务进行管理 那么也就是说 这个转账由4个事务进行管理 每个操作执行完成 就会提交 就导致了 异常之前的事务都提交了 异常之后的 无法执行 也就不能提交 将转账使用一个Connection来控制 也就是一个事务进行控制 ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。 ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 使用ThreadLocal对象把Connection和当前线程绑定,从而在一个线程中只有一个控制事务的对象 编写ConnectionUtil工具类 事务管理相关的工具类 要进行事务控制 首先需要把Connection设置为手动提交事务 通过我们自己的commit进行事务的提交 然后提供相应的方法 将Service中的方法添加事务控制 这样就有了事务控制 在Dao中使用我们自己提供的Connection对象 这里进行了修改 使用的是QueryRunner 修改方法 使得每个方法使用的是我们自己提供的事务管理 在beans.xml进行配置 首先 不能让这个连接从数据库连接池中获取 进行其他的依赖注入 进行测试 当出现异常的时候 数据库中的两个数据都未发生改变 正常执行的时候 说明已经完成了事务管理 并且使用的是一个Connection对一个操作进行的管理 进行优化 配置文件中实在是太乱了…. 在Service中使用事务控制 虽然达到了效果 但是代码重复太多 而且方法之间有较强的依赖 比如 在每个操作中都需要开启事务(TransactionManager中的方法),关闭事务等等… 那么怎么实现在下图中 既可以实现事务管理 又可以避免方法之间的依赖呢 动态代理 特点 : 字节码随用随创建 作用 : 不修改源码的基础上对方法进行增强 分类: 基于接口的动态代理 基于子类的动态代理 动态代理的体现 在数据库连接池中的close方法 不是将连接关闭 而是将连接放回到连接池 其中就是对close方法进行了增强 基于接口的动态代理 涉及的类 : Proxy 提供者 : JDK官方 如何创建代理对象 使用Proxy类中的newProxyInstance方法 创建代理对象的要求 被代理的类最少实现一个接口 , 如果没有则不能使用 newProxyInstance方法的参数 ClassLoader : 用于加载被代理的对象字节码 , 写的是要去代理的对象的类加载器 Class[ ] : 字节码数组, 用于让代理对象和被代理对象有相同的方法 , 通过实现同一个接口来实现 , 这样代理商和厂家就有了相同的功能 , 而代理商可以在此基础上进行增强方法 , 这就是上面的要求的原因. 写的是代理商和厂家之间实现的”约定”(接口) InvocationHandler : 用于提供增强的代码 。在此我们要写如何进行代理 , 一般都是写一个该接口的实现类 , 通常情况下使用的是匿名内部类 , 谁要使用代理商 , 谁写这个代码(我们现在是消费者 , 要去联系代理商 , 所以这个增强的方法 是我们(消费者)自己写) 实现 被代理对象(厂家) 代理对象(代理商)和被代理对象(厂家)之间的约定(接口) 作为消费者 通过代理商买电脑 然后代理商去执行厂家中的方法 在此过程中进行方法的增强 图中的 method.invoke(被代理对象,被代理对象的方法的参数); 基于子类的动态代理 涉及的类 : Enhancer 提供者 : 第三方cglib库 如何创建代理对象 使用Enhancer类中的create方法 创建代理对象的要求 被代理的类不能是最终类(final修饰),最终类不能创建子类, 也就无从谈起代理 create方法的参数 Class : 用于指定被代理对象的字节码 Callback : 用于提供增强的代码 , 一般写的都是该接口的子接口的实现类 MethodInterceptor(方法拦截) 实现 添加依赖 解决案例中的问题我们希望的是 使用的Service既可以使用事务管理 而且这个Service中的对于事务管理的方法的依赖不在里面 用于创建Service的代理对象的工厂 修改配置文件中的依赖 在测试中指定就是说 在依赖注入的时候需要按照名字注入 测试 异常与不异常 都已经经过了事务管理 这里就不进行展示了 AOP概念 什么是AOP? 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 简单地说，就是把程序中的重复的代码抽取出来，在要执行的时候,，使用动态代理技术， 在不修改源码的基础上，对已有的方法进行增强。 AOP的作用以及优势 作用：在程序运行期间，不修改源码对已有的方法进行增强 优势 ：减少重复代码，提高开发效率，维护方便 AOP的实现方式：动态代理技术 Spring中的AOP 通过配置的方式（XML或者注解）实现动态代理 Spring中AOP相关术语 JoinPoint（连接点）：可以理解为代理对象与被代理对象之间的接口或者子类中的所有的方法，可以将这些方法作为增强方法，在不改变源代码的基础上对方法起到增强的作用。 Pointcut（切入点）：可以理解为代理对象与被代理对象之间的接口或者子类中的所有的被增强的方法，因为所有的连接点并不都需要进行代理。 Advice（通知/增强）：通知就是指拦截（使用接口实现动态代理中的invoke方法/使用子类实现动态代理的intercept方法）到连接点之后要做的事情 Introduction（引介）：引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field（字段）。 Target（目标对象）：被代理的对象 Weaving（织入）：把增强应用到目标对象来创建新的代理对象的过程，比如：上面的案例中，原有的Service不支持事务控制，而我们通过动态代理创建了一个新的代理对象，在返回代理对象的过程中添加了事务的支持，那么加入事务支持的整个过程叫做织入 Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类（代理对象） Aspect（切面）：是指切入点（需要增强的方法）和通知（哪些方法方法什么时候执行）的结合 Spring中我们需要完成的 开发阶段（我们做的） 编写核心业务代码（开发主线） 把公用代码抽取出来，制作成通知。（开发阶段最后再做） 在配置文件中，声明切入点与通知间的关系，即切面。 运行阶段（Spring框架完成的） Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 Spring的AOP配置的环境搭建 添加相应的依赖 AccountService接口 实现接口中的方法 PrintLog来模拟通知 我们使用自己编写动态代理的方法来实现 beans.xml的配置 测试 通过动态代理我们就实现了在不修改源码的基础上对方法进行了增强 Spring中基于XML的AOP配置 上面通过自己编写动态代理和配置beans.xml还是有点麻烦 其实Spring为我们提供了通过XML配置的方式实现AOP 基础配置 添加相应的依赖 在配置文件中添加AOP的约束 在配置文件置中配置AOP 将通知Bean也进行配置(交给Spring管理) 使用&lt;aop:config&gt; 标签 表示开始AOP的配置 使用&lt;aop:aspect&gt; 标签 表示开始配置切面 标签中的属性 id : 给切面唯一的标识 ref : 指定通知类Bean的id 在&lt;aop:aspect&gt;标签内部 使用对应的标签来配置通知的类型 我们在这里是在让printLog方法在切入点之前执行 所以是前置通知 &lt;aop:before&gt; 表示前置通知 其中的属性 method : 表示通知Logger类中哪一个方法是前置通知 pointcut : 用于指定切入点表达式, 该表达式的含义指的是对连接点中哪些方法进行增强 pointcut属性值的写法 : execution(切入点表达式) 切入点表达式的写法 : 访问修饰符 返回值类型 包名.包名….类名.方法名(参数列表) exp: public void edu.ahnu.service.impl.AccountServiceImpl.saveAccount() 总配置图 首先 我们有一个需要增强的类 accountService ———&gt; 配置accountService对象 我们增强的是 在accountService 切入点方法执行之前 执行printLog方法 ——–&gt;配置Log通知类 然后我们配置了切面 引用通知Log 在这个切面中有一个方法printLog 在切入点执行之前执行 这个切入点 就是配置的切入点表达式 这里的&lt;aop:before method=&quot;&quot; pointcut=&quot;&quot;&gt; 表示的是 对pointcut切入点方法进行增强 , 增强的方法是method方法 而且是前置通知 测试 一样可以执行成功 并且进行了方法的增强 切入点表达式的写法 这个表达式可以被aspectjweaver解析 这样的配置 只能对切入点中的一个方法进行配置 全通配写法 : * *..*.*(..) 这样就实现了对所有的切入点都进行增强的功能 全通配写法的由来 : 访问修饰符可省略 返回值可以使用通配符,表示任意返回值 包名可以使用通配符, 表示任意包。但是有几级包，就要写几个*. , *..表示当前包及其子包 类名和方法名都可以使用*实现通配 参数列表 : 可以直接写数据类型 , 基本类型直接写名称(比如: int) , 引用类型写包名.类名的方式(比如 : java.lang.String) 有参数的时候, 可以使用通配符* 使用..表示有无参数均可 , 有参数的话可以是任意类型 上面的写法存在的问题就是 这样匹配的是全部的类 开发中, 我们只需要在需要实现的类中进行方法的增强 比如 这里 我们应该写成AccountServiceImpl中的类需要增强 通知的类型配置 在printLog中添加需要通知 在beans.xml中进行配置 测试 因为程序没有异常 所以并没有执行到异常通知 通过理解之前通过动态代理配置事务管理也可以知道 异常是在catch中的 而正确返回执行的是try 那自然就不会执行catch了 切入点表达式的配置 在上面的配置中 配置的切入点都一样 我们可以 将它提取出来 使用标签&lt;aop:pointcut&gt; 配置 属性id : 指定表达式的唯一标识 属性express : 指定表达式的内容 在配置通知的时候 使用pointcut-ref属性来配置表达式的内容 这里的&lt;aop:pointcut&gt;是在&lt;aop:aspect&gt;内部进行配置的， 所以只能在此切面内部使用 还有一种就是配置在切面之外 但是需要在&lt;aop:config&gt;标签内 这样的话 所有的切面都可以使用了 配置环绕通知 当我们仅仅配置环绕通知的时候 使用&lt;aop:arounnd&gt;进行配置 环绕通知的方法 测试中的调用 我们调用的是saveAccount方法 但是输出的却是环绕通知方法arroundPrintLog的内容 问题分析 在上面的情况中 也就是当我们配置环绕通知后 , 切入点方法没有执行 , 反而执行的是环绕通知的方法 对比我们在动态代理中的代码 在环绕通知中添加切入点方法 使用Spring框架中的 ProceedingJoinPoint接口中的proceed()方法, 此方法的作用就是明确调用切入点方法 该接口可以作为环绕通知的方法参数 , 在程序执行的时候 , Spring框架会为我们提供该接口的实现类供我们使用 进行环绕通知的编写 这里可以感觉到 这就是Spring的动态代理啊 在proceedingJoinPoint.proceed(args);执行之前的通知就是前置通知 在proceedingJoinPoint.proceed(args);之后执行的通知就是后置通知 其他跟动态代理都一样的…. 可以理解为他是Spring为我们提供通过代码的方式手动控制增强方法何时执行的方式 测试 可以发现增强了方法 Spring中基于注解的AOP配置在注解的配置中可以按照之前的XML的配置的过程将它改为注解的方式配置 在beans.xml文件中添加约束并且配置要扫描的包 在AccountService和PrintLog上面添加注解 并且在切面类上加注解@Aspect 在切入点方法上添加注解 注意这里的切入点的配置 是一个方法 并且使用注解 测试 当我们把环绕通知注释之后 以防止影响结果 出现了执行顺序的问题 这是Spring的一个问题 所以谨慎选择Spring中AOP的此种注解方式的配置 测试环绕通知 执行的顺序是正常的","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.chasingwind.top/tags/Spring/"}],"author":"ChasingWind"},{"title":"Spring基于注解的IOC","slug":"Spring基于注解的IOC","date":"2019-08-23T01:51:42.000Z","updated":"2021-03-04T00:55:02.794Z","comments":true,"path":"2019/08/23/Spring基于注解的IOC/","link":"","permalink":"https://www.chasingwind.top/2019/08/23/Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC/","excerpt":"本节讲述了在IOC中的常用的注解，以及通过案例实现单表查询的功能的XML的实现和注解方式的实现。再次基础上，完全使用注解来实现相同的功能。","text":"本节讲述了在IOC中的常用的注解，以及通过案例实现单表查询的功能的XML的实现和注解方式的实现。再次基础上，完全使用注解来实现相同的功能。 Spring中IOC的常用注解 无论是基于XML还是注解的方式实现的配置，它们要实现的功能是相同的，都是为了降低程序间的耦合 注解按照功能分类 之前的xml配置 在使用注解的配置之前 需要在beans.xml中添加约束 并且告诉Spring我们使用注解在哪一个包下面 以便Spring进行扫描 用于创建对象的注解作用和xml配置中的&lt;bean&gt;标签的作用相同 @Component @Component 作用 : 用于把创建的当前类对象存入Spring容器中 属性 : value : 用于指定bean的id , 可以不写 , 不写的话id默认为当前类名的首字母小写 运行结果 @Controller : 一般用于表现层 @Service : 一般用于业务层 @Repository : 一般用在持久层 这三个的作用和@Component的作用一模一样 , 这样做只是Spring框架为我们提供明确的三层模型的注解 , 使得三层对象更清晰 用于注入数据的注解作用和xml配置中的&lt;bean&gt;标签下的&lt;property&gt;作用相同 @Autowired @Autowired 作用 : 自动按照类型注入 出现的位置 : 变量或者方法上等等 备注 : 在使用注解注入时 , set方法不是必须的 未注入之前 由于accountDao变量为空 会报错 当容器中含有唯一的一个bean对象的类型和要注入的变量的类型匹配 , 就可以注入成功 ; 将accountDao变量注入 可以正常测试 当容器中没有可以与注入的变量类型相匹配的类型的时候 , 注入失败 当容器中含有多个bean对象的类型和要注入的变量的类型匹配 的时候 , 在这多个bean对象中根据变量名进行匹配 , 如果有变量名匹配 , 就注入 ; 否则 , 报错 此图中就没有对应的变量名 所以注入失败 accountDao1 accountDao2 当有多个accountDao类型的时候 但是没有匹配的变量名 注入的变量名为accountDao的时候 报错 注入的变量名为accountDao1 执行的方法时Dao1中的方法 注入的变量名为accountDao2的时候 执行的方法时Dao2中的方法 @Qualifier @Qualifier 作用: 在按照类注入的基础上再按照名称注入，这样就解决了在变量名不需要修改的情况下，实现按照对应的名称注入。 属性 : value : 用于指定注入的bean的id 备注 : 在给类成员注入的时候不能单独使用,需要配合@Autowired使用 , 在给方法参数注入的时候可以(后面讲解) 可以看到 在变量名还是accountDao的情况下 配置的value的值是容器中的对应的bean对象的accountDao1 执行的也是对应的方法 注入accountDao2 @Resource @Resource 作用 : 直接按照bean的id注入 属性 : name : 用于指定注入的bean的id(已经在beans.xml中进行配置) 指定 name属性的值为 accountDao1 指定 name属性的值为 accountDao2 以上3个注解 都只能注入其他已经存在于Ioc容器中的bean类型的数据(accountDao1 , accountDao2) 而基本类型和String类型无法通过上面的注解实现 集合类型只能通过XML配置文件注入 @Value @Value 作用 : 用于注入基本数据类型和String类型 属性 value : 用于指定数据的值 , 可以使用Spring中的SpEL(Sprig中的EL表达式 , 形式为$&#123;表达式&#125;) 用于改变作用范围的注解作用和&lt;bean&gt;标签中使用scope属性的作用相同 @Scope @Scope 作用: 用于指定bean的作用范围,也就是对象的作用范围, 所以作用在类上 属性 value : 指定范围的取值 , 常用的有: singleton(单例) , prototype(多例) 配置bean的作用范围为prototype 用于和生命周期相关的 和生命周期相关的 : 作用和&lt;bean&gt;标签中的init-method和destory-method的作用相同 @PostConstruct : 用于指定初始化方法 @PreDestory : 用于指定销毁方法 使用XML方式实现案例 Service层 Dao层 配置文件 beans.xml 其实这里注入数据库连接信息dataSource使用set方法不太合适 最好使用构造方法的方式注入 同时注意到template 的 scope是prototype 否则的话 会出现线程安全问题 修改的地方 因为在druid连接池中 使用的数据库配置的名字是 driverClassName 测试 其他的测试都一样的 在这里不测试 使用注解方式实现案例 在上面的使用xml方式的基础上进行修改 修改配置文件 使用注解的方式实现IoC和DI Service @Autowired自动按照类型注入 此时已经不需要set方法了 Dao 纯注解方式实现案例@Configuration和@ComponentScan 在上面的两种方式的配置中，都需要使用配置文件beans.xml。 为了完全消除配置文件 需要解决下面的两个问题 就需要新的注解 第一个就是告诉Spring需要扫描的包 第二个就是通过配置文件注入信息 @Configuration : 指定当前类是一个配置类 @ComponentScan : 可以用于指定Spring在创建容器时要扫描的包 属性 : value : 与base-package作用相同 , 都是用于指定创建容器时扫描的包 basePackages 使用此注解等同于在配置文件中的 使用上面的两个注解实现 首先 需要一个配置类 在配置类上进行注解的配置 然后 在一个配置类中配置要扫描的包 @Bean @Bean : 用于把当前方法的返回值作为bean对象存入Spring容器中 属性 : name : 用于指定bean的id，当不写时，默认值是当前方法的名字 备注 : 当使用注解配置的方法有形式参数的时候，Spring会去请其中查找有没有匹配的bean对象, 匹配的方式以及结果都跟注解@Autowired相同 下面这段配置实现的功能 创建JdbcTemplate对象 再把这个对象存入容器中 通过注解实现相同的功能 在template中需要注入DataSource 这个时候就可以将配置文件删除了 进行测试 注意 此时获取容器需要使用的是注解的形式的配置 所以使用的是类AnnotationConfigApplicationContext 还存在的一个问题就是 我们之前使用的template是多例的 上面没有进行配置 可以使用@Scope进行配置 @Configuration的细节 当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写 此时类 已经没有了@Configuration配置 使用AnnotationConfigApplicationContext获取容器 因为参数就是SpringConfiguration类 但是如果 我们需要将SpringConfiguration作为一个配置类 放公共的配置 在JdbcConfiguration中放置数据库相关的配置的时候 该怎样实现呢 首先 将config包添加到需要扫描的包中 在JdbcConfiguration上配置@Configuration 因为 此时Test类中 获取容器中传入的参数是SpringConfiguration.class 所以在这个配置类的上面没有配置@Configuration 还有一种方式实现上述的功能 将JdbcConfiguration也作为参数传入AnnotationConfigApplicationContext 此时两个类都不需要@Configuration注解 @Import @import : 用于导入其他的配置类 属性 : value : 用于指定其他配置类的字节码 , 当我们使用@Import注解的时候 , 那么这个配置类是主配置类 , 而导入的是子配置类 使用Import注解实现上面的效果 在Test中 只需要指定这个主配置类的字节码文件 在主配置SpringConfiguration中 不再需要指定扫描的包config 使用Import注解 导入子配置JdbcConfiguration 子配置 可以不写@Configuration @PropertySource @PropertySource : 用于指定properties文件的位置 属性 : value : 用于指定文件的名称和文件的位置 , 其中有一个关键字 : classpath,用于表示这个文件是在类路径下 当前配置类存在的问题 : 应该从配置文件中来读取数据库连接的信息 而不是写死 配置类 配置文件 此时要想这个配置文件被读取 就需要配置注解@PropertySource 因为resources目录下的文件在发布在服务器上之后 resources目录下的文件放在target的classes目录下 所以可以使用classpath执行后面的路径是类路径 在现实开发中， 当我们使用的类是jar包（JdbcTemplate）中的，多数使用XML来配置 当我们使用的类是我们自己写的，多数使用注解配置 @Qualifier : 当有多个匹配的参数的时候 ,指定其中的一个作为参数 此处讲解的是作用在方法的参数上 比如有两个连接数据库的信息时 需要使用第二个的时候 就可以在参数上进行配置 他的匹配方式和@Autowired一样 Spring和Junit的整合 在测试类中存在的问题 在每个测试方法中的重复代码 试想通过自动注入的方式 但是却不能实现 因为在Test中不会创建容器存储 解决方法 导入Spring整合的Junit的依赖 使用Junit提供的一个注解@Runwith把原有的main方法替换成Spring提供的（称之为运行器） 告诉Spring的运行器@ContextConfiguration，Spring的Ioc容器创建基于xml还是注解的形式，以及位置 ContextConfiguration的属性 locations : 指定xml文件的位置，加上classpath关键字，表示在类路径下 classes：指定注解类所在的位置","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.chasingwind.top/tags/Spring/"}],"author":"ChasingWind"},{"title":"Spring概述以及基于XML的IOC配置","slug":"Spring概述以及基于XML的IOC配置","date":"2019-08-22T01:51:24.000Z","updated":"2021-03-04T00:54:54.564Z","comments":true,"path":"2019/08/22/Spring概述以及基于XML的IOC配置/","link":"","permalink":"https://www.chasingwind.top/2019/08/22/Spring%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%9F%BA%E4%BA%8EXML%E7%9A%84IOC%E9%85%8D%E7%BD%AE/","excerpt":"本节讲解了Spring框架的基础知识以及程序之间耦合的概念,使用Ioc(控制反转)来降低耦合,使用依赖注入的方式来管理依赖,也就是将类之间的依赖交给Spring来管理.","text":"本节讲解了Spring框架的基础知识以及程序之间耦合的概念,使用Ioc(控制反转)来降低耦合,使用依赖注入的方式来管理依赖,也就是将类之间的依赖交给Spring来管理. Spring概述Spring是什么Spring 是分层的 Java SE/EE 应用 full-stack （全栈）轻量级开源框架，以 IoC（Inverse Of Control： 控制反转）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。 Spring的优势 方便解耦，简化开发 通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP 编程的支持 通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架 Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持 降低 JavaEE API 的使用难度 Spring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的 使用难度大为降低。 Spring 源码是经典学习范例 Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 Spring的体系结构 程序的耦合以及解耦 耦合：程序之间的依赖关系 类之间的依赖 方法之间的依赖 解耦：降低程序之间的依赖关系 我们在开发中，应该做到：编译期不依赖，运行时才依赖 当我们取消mysql依赖的时候 去运行JdbcDemo 由于jdbc包已经不存在了 就会报错 而且是编译期的错误 当我们使用反射的方法来操作这个类的时候(同样没有依赖jdbc包的情况下) 这个时候不再是编译期错误 而是运行期异常 当我们把依赖添加上之后 就可以运行啦 解决类之间依赖思路: 在创建对象的时候，使用反射来创建对象，避免使用new关键字 比如上面的 通过依赖的方式创建对象的时候：依赖的只是这个类名的字符串 而通过new的方式创建对象的时候：依赖的确是整个类 通过读取配置文件来获取创建的对象的全限定类名 上面通过反射的方式存在的问题 因为这个字符串写死了 后期如果需要修改 就需要修改代码 所以应该写在配置文件中 模拟实际开发中的耦合问题 我们来模拟三层架构的实现 首先,测试类创建Servlet对象 调用其中的方法 Servlet创建Service对象 调用Service中的方法 Service创建Dao的对象 调用其中的方法 Dao中的方法 测试类执行 这是我们之前经常写的代码 这里的依赖其实是很严重的 只要缺少任何一个类 都会出现错误 降低依赖的方法 : 工厂模式 创建Bean对象的工厂 Bean : 可重用组件 Bean &gt; JavaBean JavaBean : 用Java语言编写的可重用组件 对于上面的实例 使用Bean对象工厂创建Service和Dao对象 首先 需要一个配置文件来配置我们的service和dao 配置的内容 : 唯一标志=全限定类名 (key=value) 配置文件可以是properties或者xml 这里使用的是properties配置文件 通过读取配置文件中的内容,通过反射创建对象 创建BeanFactory工厂类 提供通过反射创建对象的方法getBean 修改后的代码 Test调用Servlet Servlet调用Service Service调用Dao 最终实现了同样的效果 存在的问题 上面的创建对象是多例的 也就是说 每次执行都会重新创建对象 因为每次执行的话 都会调用getBean 其中的newInstance()就会创建对象 而我们并不需要每次调用方法都去创建对象 可以使用单例模式 可以通过 只使用一次newInstance创建一个对象 并将这个对象存起来 可以将这个newInstance放在static代码块中(这样就只会执行一次 创建一次对象) 并且将创建的对象存在Map中 以防止垃圾回收 将来getObject根据名称创建对象的时候 从Map中取 IOC概念和Spring中的IOCIOC的概念 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来降低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。 通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 控制反转（Inversion of Control）是说创建对象的控制权发生转移，以前创建对象的主动权和创建时机由应用程序把控，而现在这种权利转交给 IoC 容器，它就是一个专门用来创建对象的工厂，你需要什么对象，它就给你什么对象 Spring中的IOC Spring的简单使用 创建新项目 , 在pom.xml中导入Spring依赖 在maven中可以看到依赖的结构 resources文件夹下新建配置文件 这段配置可以在Spring的官方文档的Core中查找 将创建对象交给Spring的IoC管理 在resources目录下 创建beans.xml配置文件 这就是IoC的核心容器的配置文件 获取Spring的IoC核心容器 , 并根据id获取对象 运行结果 可见 我们使用IoC创建出了对应的对象 ApplicationContext的三个常用的实现类 ClassPathXmlApplicationContext : 可以加载类路径下的配置文件 , 如果配置文件不在类路径下 , 那么就无法加载 ,也就无法通过IoC创建对象 FileSystemXmlApplicationContext : 可以加载任意磁盘位置(具有访问权限)的配置文件 AnnotationConfigApplicationContext : 通过读取注解来创建容器 核心容器的两个接口 一个是ApplicationContext 而ApplicationContext实现了BeanFactory接口 ApplicationContext : 在构建核心容器的时候，创建对象采取的策略是立即加载的方式。也就是说 ， 只要一读取完配置文件就会立即根据配置文件中的&lt;bean&gt;通过反射来创建对象 适用于 ： 单例模式 只需要创建一次对象 ，在读取配置文件之后就进行创建 BeanFactory : 在构建核心容器时，创建对象采用延迟加载的策略。也就是说，什么时候根据id获取对象（执行getBean方法），就什么时候创建对象。 适用于：多例模式 用的时候再创建 创建Bean对象的三种方式 使用默认构造函数创建 在Spring的配置文件中使用&lt;bean&gt;标签，配置id和class属性之后，并且没有其他的属性和标签的时候。采用的就是默认构造函数创建Bean对象 当配置的全类名对应的类中没有默认构造函数的时候，则对象无法创建 修改构造函数 这样就没有了默认构造函数 此时已经在配置文件中出现了错误 运行的时候出现的错误 使用工厂中的普通方法创建对象 当我们需要使用jar包中的方法来创建对象 或者 当某个类中有一个方法，这个方法的返回值是一个对象，我们想要通过这个方法创建对应的对象的时候，并将它存入Spring容器 配置 使用工厂中的静态方法创建对象 类中的静态方法 配置 Bean对象的作用范围 默认情况下 可见 创建的是同一个对象 使用ApplicationContext 立即加载 创建的是单例对象 使用BeanFactory 使用的时候才进行对象的创建 可以用来创建多例对象 单例对象或者多例对象是可以在创建Bean对象的时候进行设置的 通过&lt;bean&gt;标签的scope属性可以进行设置bean的作用范围 取值： singleton：单例(默认情况) prototype：多例 request：作用于web应用的request请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境的时候，等同于session 单例 跟默认情况是相同的 多例 Bean对象的生命周期 单例对象 出生: 当容器创建时，对象出生 活着: 当容器还在, 对象就在存活 死亡: 当容器销毁, 对象死亡 配置 类中的方法 测试 多例对象 出生 : 使用对象的时候才创建 活着 : 只要在使用过程中中就一直活着 死亡 : 当对象长时间不用, 并且没有别的对象引用的时候 , 只能由Java的垃圾回收机制来回收 测试代码不变 结果 虽然容器关闭了 但是对象并没有执行销毁 只能等待垃圾回收机制来销毁对象 依赖注入（Dependency Injection） 概念 IOC实现的是降低类之间的耦合，但是并不是消除。所以，必然还会存在依赖关系。 将依赖关系的管理交给Spring来管理，在当前类需要使用到其他类对象的时候，由Spring来为我们提供，我们只需要在配置文件中说明，这就是依赖注入。 依赖注入主要用于类中对象成员变量的赋值 依赖注入的数据分类 基本类型和String 其他Bean类型（在配置文件或者注解中配置过的bean） 复杂类型（集合类型） 依赖注入的方式 使用构造函数提供（一般不用） 使用方式 使用的标签：constructor-arg 标签出现的位置：&lt;bean&gt;标签内 标签的属性： type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中的参数的类型 index：用于将要注入的数据给构造函数中指定索引位置的参数赋值，索引从0开始 name：根据构造函数中的参数名来赋值这三种都是用来给构造函数中的参数赋值的，直接用name就能达到效果 value：用于给参数赋值，用于基本类型和String类型的数据 ref：用于指定其他的bean类型，也就是在配置文件中配置过的bean 构造函数 这里只要关注数据类型就可以了 不要关心变量名 配置文件 使用通过依赖注入的方式获取的对象执行方法 并且可以发现这个对象已经通过构造函数赋值了 特点 优点 : 在获取bean对象的时候注入数据是必须的，否则创建对象会失败，因为已经没有默认构造函数（未提供）了 缺点 : 改变了bean对象的实例化方式，使我们在创建对象的时候，如果用不到这些数据，你也必须提供（在没有其他构造函数的情况下） 使用set方法提供（更常用） 使用 使用的标签 : &lt;property&gt; 标签出现的位置 : &lt;bean&gt;标签的内部 便签的属性 name : 需要设置的参数的属性名 value : 用于给参数赋值，用于基本类型和String类型的数据 ref : 用于指定其他的bean类型，也就是在配置文件中配置过的bean 使用set方法为参数赋值 配置文件 &lt;property&gt;的中name标签的值是属性值 测试类 特点 优势 : 创建对象时,可以直接使用默认构造函数 , 对参数的设置也没有要求 缺点 : 如果某个参数必须要有值, 这是无法保证的 对于复杂类型（集合类型的注入）：只能选择上面的两种方式的一种 通过set的方式进行注入 类 配置文件 对于List类型(只有值,而不是键值对类型的)的数据的配置 : 包括 Array,List,Set 结果 正确的封装进去 对于Map类型(键值对)的数据的封装 : 包括Map,Properties 结果 结构相同的,标签可以互换 List结构的 : Array,List,Set Map结构的: Map,Properties 标签可以互换 所以我们只需要使用两组标签(list,map)就行了 使用注解提供(后面讲解) 个人理解 IoC可以通过配置文件来创建一个类的对象 依赖注入(DI)的作用是 : Spring帮助我们管理对象的创建,那么对象对应的类中的成员变量（包括对其他类的对象的引用）的赋值就是通过DI的方式来进行初始化。 比如 下一节的内容中 在Service类中 配置文件 可以看到 通过IoC使用getBean的方法创建accountService对象, 存入容器 而在Service类中 需要依赖Dao对象 那么就需要使用依赖注入(DI)","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.chasingwind.top/tags/Spring/"}],"author":"ChasingWind"},{"title":"Mybatis的缓存以及注解开发","slug":"Mybatis的缓存以及注解开发","date":"2019-08-17T03:55:47.000Z","updated":"2021-03-04T00:51:34.134Z","comments":true,"path":"2019/08/17/Mybatis的缓存以及注解开发/","link":"","permalink":"https://www.chasingwind.top/2019/08/17/Mybatis%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"MyBatis中的延迟加载可以分为对一和对多的两种形式，在MyBatis的缓存中，又可以分为一级缓存和二级缓存。另外，使用注解的方式进行持久层的开发也是很便捷的。","text":"MyBatis中的延迟加载可以分为对一和对多的两种形式，在MyBatis的缓存中，又可以分为一级缓存和二级缓存。另外，使用注解的方式进行持久层的开发也是很便捷的。 MyBatis中的延迟加载 考虑如下情景 当一个用户 他有100个账户信息的时候 在查询这个用户信息的时候，需要把他的所有的账户信息同时查询出来吗（一对多） 在查询这个用户账户信息的时候，需要把这个用户信息查询出来吗（一对一） 在查询用户信息的时候，并不需要将用户的所有的账户信息查询出来，浪费内存空间 在查询用户的账户信息的时候，需要将用户的信息一并查出来，因为单单一个账户的信息，无法获取更多的信息 什么是延迟加载？ 在真正使用数据的时候才发起查询，不用的时候不查询。按需加载（懒加载） 什么是立即加载？ 不管用不用，只要一调用方法，就马上发起查询 我们该怎么进行选择呢? 一对多，多对多 通常情况下 ，延迟加载 多对一，一对一 通常情况下，立即加载(默认情况下就是立即加载) 使用Association实现延迟加载 一对一延迟加载 实现在查询账户信息的同时 查询用户的信息 懒加载的方式 AccountDao AccountDao.xml 注意到下面的select已经不是select * from account left join user on account.uid = user.id 测试类 注意到这个SQL语句 这样并未实现懒加载 这也是默认的情况 实现懒加载 在SQLMapperConfig.xml文件中进行配置lazyLoadingEnabled 执行测试类 先查询的是所有的订单 当需要查询用户的时候 再根据用户的信息进行查询 总结 总结以上实现懒加载的步骤 需要在对应的.xml文件中关联需要懒加载的对象(比如,这里的账户信息延迟加载用户信息,在Account.xml中配置association延迟加载为User) 并且在association中配置延迟加载的时候执行的方法(select) 在全局配置文件中进行懒加载的配置 使用Collection实现延迟加载 一对多延迟加载 查询用户的同时 查询用户的所有的账户 懒加载的方式 UserDao UserDao.xml 测试类 MyBatis中的缓存 什么是缓存 内存中的临时数据，MyBatis中的缓存就是将查询的数据存储在缓存中，下次再需要查询的时候直接在缓存中取，而不需要去和数据库进行交互 为什么使用缓存 减少和数据库的交互次数，提高执行效率 什么样的数据适合用缓存？ 经常需要查询并且不经常改变 对实时性数据要求不高 什么样的数据不适合用缓存？ 经常改变的数据 对实时性数据要求高，比如：银行汇率，抢购库存等等 MyBatis中的一级缓存（默认使用） 它指的是Mybatis中SqlSession对象的缓存。当SqlSession对象消失时，MyBatis的一级缓存也就消失了。 当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，MyBatis会先去SqlSession中查询是否有，有的话直接拿出来用。 实例 查询同一个用户 两次查询只执行了一次SQL查询语句 并且 查询得到的对象是同一个对象 也就是说 第一次查询是从数据库中进行查询 第二次查询是从缓存中进行的查询 缓存的清除 当SqlSession消失之后,缓存会被清空 可以看到这里执行了两次SQL 并且不是同一个对象了 可以使用SqlSession的方法来清空缓存 当缓存中的数据在数据库中发生改变之后并且提交时候,缓存中的数据就会发生改变 保存,删除,更新并且提交之后,一级缓存会被自动清空.从而保证数据的同步 再次查询的话,会执行SQL语句 MyBatis中的二级缓存（手动开启） 它指的是Mybatis中SqlSessionFactory对象的缓存。 由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 原理 同一个SqlSessionFactory下的SqlSession共享二级缓存 二级缓存的使用步骤 在SqlMaperConfig.xml中配置使MyBatis框架支持二级缓存cacheEnabled 在当前的映射文件(XxxDao.xml)中进行配置 在当前的操作中(select,insert…标签)支持二级缓存 结果 可见 第二次查询并没有执行SQL语句,而是从二级缓存中查询的 但是 查询的并不是同一个对象 原因是 二级缓存中存放的是数据,不是对象 当用户去使用缓存中的这些数据的时候, MyBatis会将这些缓存的数据封装成一个对象,从而就有了上面的现象 两个相同的数据不是同一个对象,每次查询都重新将数据进行封装,成为一个新的对象 MyBatis中的注解开发四个基础的注解的使用 环境搭建 目录 这次我们使用了数据库的外部配置文件 主配置文件中 User实体类 UserDao 这里使用的是注解的形式 测试类 可以调用这个使用注解的方法 两种方式的比较 上面只使用了注解，而没有使用映射配置文件 那么这两个都能实现相同的功能 两者比较 当既有注解，又有配置文件的时候，不管你用不用都会报错的 @Insert注解的使用 @Update的使用 @Delete的使用 @Select的使用 复杂功能的实现 模糊查询 聚合函数 属性名和数据库列名对应 当需要封装到的实体类的类名和数据库的列名不相同的时候 使用@Results注解配置 这样的写法只适用于一个方法上 要想将这个配置作用在多注解上的话 需要使用id属性 在需要用的注解上配置@ResultMap 值就是刚才的id的值 注解实现一对一查询 一个账户对应一个用户 首先在主表Account中添加User的引用 从表User中的根据用户的Id查询用户的信息 将来需被调用的 在从表中使用one 这里从表中的column的值是作为从表中的那个查询方法的参数的 , 比如这里是根据 用户的id查询用户的信息 , 他的值是主表Account中的用户的id 也就是uid 实现了对用户的封装 注解实现一对多的查询 一个用户有多个账户 首先在主表User中添加从表Account的集合的引用 Account中的FindAccountByUid的方法 在从表中使用many 还有一点就是这里使用的是延迟加载 注解实现二级缓存 一级缓存默认开启 二级缓存的开启 在全局配置文件中SqlMapConfig.xml进行配置cacheEnable 为true 其实不配置也可以 因为默认值就是true 在XxxDao上开启二级缓存 测试 可以看到只执行了一次SQL语句","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.chasingwind.top/tags/Mybatis/"}],"author":"ChasingWind"},{"title":"Mybatis使用以及多表","slug":"Mybatis使用以及多表","date":"2019-08-16T03:55:32.000Z","updated":"2021-03-04T00:52:08.752Z","comments":true,"path":"2019/08/16/Mybatis使用以及多表/","link":"","permalink":"https://www.chasingwind.top/2019/08/16/Mybatis%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%A4%9A%E8%A1%A8/","excerpt":"这里介绍了MyBatis中的连接池的种类以及事务,使用标签if,where,foreach实现动态SQL以及MyBatis中的多表查询的操作","text":"这里介绍了MyBatis中的连接池的种类以及事务,使用标签if,where,foreach实现动态SQL以及MyBatis中的多表查询的操作 MyBatis中的连接池以及事务 MyBatis连接池的3种配置方式 type属性值有3种 POOLED 使用连接池，每次从连接池中获取连接。连接池其实就是一个集合，这个集合需要是线程安全的，以防不同的线程拿到同一个连接，而且还需要实现队列的先进先出的特性（底层代码） UNPOOLED 不使用连接池，而是使用普通的连接，每次使用都需要重新创建连接，使用结束销毁连接 JNDI 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。 注意：如果不是web或者maven的war工程，是不能使用的 我们课程中使用的是tomcat服务器，采用连接池就是dbcp连接池。 查看源码可以知道 PooledDataSource和UnPooledDataSource都实现了DataSource接口 MyBatis中的事务 通过SqlSession对象的commit方法和rollback方法实现事务的提交和回滚 默认的是手动提交 我们可以设置为自动提交 可见 未设置之前是false 也就是手动提交的方式 在openSession参数中设置自动提交 动态SQL if标签的使用 首先是创建方法 配置这个方法 如果if标签的条件成立的话 就会将条件拼接到SQL语句中 测试类 只有姓名的时候的查询 当加上查询的条件性别的时候 从而实现了SQL语句的拼接 where标签的使用 不适用恒成立的where 1 = 1 而是将if标签放在where标签中 foreach和sql标签 foreach标签 当我们有这样的需求的时候 使用MaBatis来实现 UserDao接口 封装的UserInfo类 UserDao.xml 这里的if标签中的test中的Ids就是传入的测试类中的Ids集合 测试类 sql标签 用于抽取重复放入语句 MyBatis中的多表 表之间的关系 一对多 多对一 一对一 多对多 MyBatis中的多表查询 需求: 当我们查询用户时，可以同时得到用户下所包含的账户信息 当我们查询账户时，可以同时得到账户的所属用户信息 基础环境的准备 建立用户表,账户表 建立用户实体类,账户实体类 建立两个配置文件UserDao.xml以及AccountDao.xml SqlMapperConfig.xml中进行了别名的配置 一对一 一个账户只能对应一个用户 在获取用户账户信息的同时获取此账户的用户信息 SQL中查询语句是这样的 使用子类来封装信息(不常用) 我们可以通过一个Account账户类的子类来封装账户信息以及我们需要的用户的信息 AccountUser类 toString方法 AccountDao接口 配置 测试类 结果 将User封装在Account中 主表实体类中含有从表实体类的引用 Account类 配置AccountDao.xml 测试类 一对多 主表实体类应该包含从表实体的集合引用 一个用户有多个账户信息 在获取用户信息的时候获取用户的所有的账户信息 在主表中添加从表集合的引用 在主表的接口的配置文件中进行配置 这里的查询使用的是左外连接 因为有的用户没有账户信息 但是还是需要显示用户的信息的 测试类 多对多 一个用户可以有多种角色, 比如,学生,顾客…. 而每种角色可以有多个用户 基础环境的准备 为了让用户表和角色表具有多对多的关系, 需要借助中间表来实现。 中间表中包含各自的主键 建立对用的实体类User和Role(用户的角色) 查询所有的角色 ，同时获取角色对用的用户的信息 SQL查询语句 需要两次左外连接 第一次 第二次 去掉user_role表 进行配置 在Roledao.xml中添加引用 更正 上面 从表中的非主键 应该是result标签 测试类 查询所有的用户 , 同时获取用户的角色 首先是SQL语句 进行UserDao.xml的配置 测试类","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.chasingwind.top/tags/Mybatis/"}],"author":"ChasingWind"},{"title":"Mybatis基本使用","slug":"Mybatis基本使用","date":"2019-08-15T03:55:02.000Z","updated":"2021-03-04T00:51:45.806Z","comments":true,"path":"2019/08/15/Mybatis基本使用/","link":"","permalink":"https://www.chasingwind.top/2019/08/15/Mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"这里介绍了在MyBatis使用代理的情况下对于数据库的CRUD的操作以及常用的输入类型以及输出类型的结果集的介绍。","text":"这里介绍了在MyBatis使用代理的情况下对于数据库的CRUD的操作以及常用的输入类型以及输出类型的结果集的介绍。 MyBatis的CRUD 首先进行Test测试类的优化 将初始化的代码以及销毁的代码提取出来成为一个方法 MyBatis的保存操作 在UserDao接口中进行方法的定义 在UserDao.xml文件中进行配置 使用的是insert标签 这里的参数类型指的是方法传入的参数类型 另外values中需要对应User类中的属性名 执行Test测试的方法 查看控制台日志 控制台日志 也就是说 当前的事务是手动提交事务 去查询数据库 里面并没有进行用户数据的存储 设置事务的提交方式为自动提交 控制台日志 查询数据库 MyBatis中的更新操作 在UserDao中添加 在UserDao.xml中进行配置 使用update标签 测试类 这里已经将事务的提交放在了After中 因为这里是根据用户的id进行查询 所以需要设置查询用户的id 查询数据库 MyBatis中的删除操作 UserDao接口中的方法 根据用户的id进行删除 配置UserDao.xml文件 在这里的parameterType 可以填写Integer/integer/INT/int/java.lang.integer任意一个都可以 还有一点就是 因为deleteUser方法的参数只有一个 所以在SQL语句中**#{可以任意填写,只起占位的作用}** 执行Test测试 查询数据库 MyBatis中的查询一个操作 UserDao接口中的方法 根据用户的id进行查询 返回一个User对象 在UserDao.xml中进行配置 这里不仅需要参数的类型 , 还需要返回值类型 运行测试类 结果 MyBatis中的模糊查询操作 UserDao接口中的方法 根据用户名查询 姓名中含有王的用户 在UserDao.xml中进行配置 可见 在这里并没有实现模糊查询的%% 运行测试类 正在测试类中需要完成参数的传递 需要加上%%完成模糊查询的功能 结果 模糊查询的另一种方式**(了解)**以及两者的区别 在UserDao.xml中的配置 以及在测试类中的写法 这里不需要用% 区别就是 第一种查询语句 第二种的查询语句 可见 第一种方式实现的查询语句是使用的PreparedStatement 第二种使用的是Statement的方式 会出现SQL注入的问题 MyBatis中的聚合函数的查询 UserDao接口中的方法 在UserDao.xml中进行配置 运行测试类 MyBatis中的参数以及结果集 输入类型(parameterType) 基本类型 ,Int,String…. JavaBean类型, User… JavaBean的包装类, … OGNL表达式： Object Graphic Navigation Language 对象 图 导航 语言 它是通过对象的属性名来获取数据。在写法上把get给省略了。 比如：我们获取用户的名称 类中的写法：user.getUsername(); OGNL表达式写法：user.username mybatis中为什么能直接写username,而不用user.呢： 因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名 输出类型(resultType) 简单类型 JavaBean对象 JavaBean对象的集合 当数据库中的列名与实体类中的属性名不相同的时候 可以在SQL语句中将查询的列名起别名 进行配置resultMap 使得数据库中的列名和实体类的属性名相对应 解决SQL语句中的类名与封装的类中的属性名不一致 resultMap结果类型 在SQL语句中将查询的列起别名 标签的使用 typeAliases 这个标签要放在&lt;environments&gt;标签上方 用于指定domain包下的类 用来起别名的 package标签用来指定要配置别名的包,当指定之后,该包下的实体类都会注册别名,并且类名就是别名,不区分大小写 package 除了上面的package , package还有一个常用的地方就是 用于指定Dao接口所在的包 指定之后 就不需要再写mapper, resources以及class了 以前 现在","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.chasingwind.top/tags/Mybatis/"}],"author":"ChasingWind"},{"title":"Mybatis入门","slug":"Mybatis入门","date":"2019-08-14T10:12:43.000Z","updated":"2021-03-04T00:51:56.719Z","comments":true,"path":"2019/08/14/Mybatis入门/","link":"","permalink":"https://www.chasingwind.top/2019/08/14/Mybatis%E5%85%A5%E9%97%A8/","excerpt":"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录","text":"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录 框架概述 什么是框架 ? 框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 它是我们软件开发中的一套解决方案，不同的框架解决不同的问题。框架中封装了很多的细节，使开发者可以使用极简的方式实现功能，大大提高开发效率 简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。 三层架构 表现层：用户展示数据 业务层：处理业务需求 持久层：和数据库交互 各层对应的框架 持久层技术解决方案 JDBC技术 Connection PreparedStatement ResultSet Spring的JdbcTemplate：Spring中对JDBC的简单封装 Apache的DBUtils：它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装 但是这些都不是框架，因为这些只是对一些使用的封装，并没有一整套完整的解决方案 JDBC是规范 Spring的JdbcTemplate和Apache的DBUtils都只是工具类 回顾之前我们的JDBC中的问题 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。 SQL语句在代码中硬编码，造成代码不易维护，实际应用 SQL 变化的可能较大，SQL 变动需要改变 Java 代码。 使用 preparedStatement 向占有位符号传参数存在硬编码，因为 SQL 语句的 where 条件不一定，可能多也可能少，修改 SQL 还要修改代码，系统不易维护。 对结果集解析存在硬编码（查询列名），SQL 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 JavaBean对象解析比较方便。 MyBatis是一个优秀的基于 Java 的持久层框架 它内部封装了 JDBC，使开发者只需要关注 SQL语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程，他使用ORM思想实现对结果集的封装 MyBatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 Java 对象和 statement 中SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射为 Java 对象并返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC API 底层访问细节，使我们不用与 JDBC API 打交道，就可以完成对数据库的持久化操作。 ORM ：Object Relational Mappging 对象关系映射 功能：把数据库中的表和实体类中的属性对应起来，让我们可以操作实体类就实现操作数据库表的功能 Mybatis框架快速入门MyBatis环境搭建 创建一个Java项目（非JavaWeb项目） 创建数据库环境 项目的pom.xml的配置 新建实体类以及接口 实体类User 接口UserDao 在resources目录下创建.xml文件，一般习惯命名为SqlMapConfig.xml 加入约束 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 对Mybatis的约束 在对每个Dao的配置中 需要指定每个Dao配置文件的路径 下面是对每个Dao的配置 首先在对应的路径下创建文件 首先 引入约束 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//MyBatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 环境搭建的注意事项 创建UserDao.xml 和 UserDao.java时名称是为了和我们之前的知识保持一致。 在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper 所以：UserDao 和 UserMapper是一样的 在idea中创建目录的时候，它和包是不一样的 包(Package)在创建时：com.itheima.dao它是三级结构 目录(Directory)在创建时：com.itheima.dao是一级目录 MyBatis的映射配置文件位置必须和Dao接口的包结构相同 也就是说 映射配置文件的mapper标签namespace属性的取值必须是Dao接口的全限定类名 映射配置文件的操作配置（select,insert,update等等），id属性的取值必须是Dao接口的方法名 当我们遵守后面3条的时候!! 我们在开发中就不需要写Dao的实现类了!! MyBatis入门案例MyBatis的入门案例 导入log4j.properties配置文件到resources目录下 并且创建测试类 编写测试类 因为遵循了上面的规则 就不需要写接口的实现类了 这里还需要进行返回对象的设置 返回类型表示 数据库查询完之后需要将结果封装的类型 需要在UserDao.xml文件中进行配置 封装的全类名 结果 MyBatis入门案例分析 读取配置文件 在上面我们使用的是相对路径 /src/java/main/cccc.xml 其实在开发中更常用的是 第一个 : 使用类加载器 , 但是只能读取类路径的配置文件 第二个 : 使用ServletContext对象的getRealPath() 使用SqlSessionFactory创建工厂 创建工厂MyBatis使用了构建者模式 构建者模式: 把对象的创建细节隐藏 , 使用者直接调用方法获取对象 使用工厂生产SqlSession对象 生产SqlSession使用了工厂模式 优势 : 解耦 使用SqlSession创建Dao接口的代理对象 创建Dao接口实现类使用了代理 优势 : 不修改源码的基础上对已有方法进行增强 MyBatis基于注解的方式 删除UserDao.xml文件 , 在Dao接口的方法上使用@Select()注解, 并且指定SQL语句 在SQLMapConfig.xml文件中进行mapper配置的时候，使用class属性指定Dao接口的全限定类名 在MyBatis中也是可以通过实现接口来达到这样的结果的 但是比较繁琐 其实在MyBatis中是通过代理方式来找到Dao的方法的 是通过namespace和id来唯一确定这个SQL语句的 自定义MyBatis框架经过分析，MyBatis在使用代理Dao的方式实现findAll方法的时候做了什么事？ 第一：创建代理对象 第二：在代理对象中调用selectList方法 MyBatis框架执行过程的分析 读取配置文件 SQLMapConfig.xml文件 有了这些配置 可以创建Connection对象 SqlMapConfig.xml中的 &lt;mappers&gt; 有了这个就可以映射配置信息 UserDao.xml (XML的方式)有了这个就可以执行SQL语句, 就可以获取PreparedStatement 而且还封装了返回值封装的类型的全限定类名 FindAll()方法的执行过程 上图中的Mapper中封装的是键是全限定类名以及对应的执行的SQL语句以及执行的结果封装的类名 这样在以后还需要添加其他的SQL语句以及对应的类名的时候就比较方便通用 selectList代理方法的增强 需要我们自己实现 进行自定义方法的实现(XML的方式) 在实现的过程中，我们需要关注的就是 如何创建代理对象，使用这些设计模式带来的优点 调用之间的组合关系 首先，分析在入门案例中的代码设计的类与接口 class Resources class SqlSessionFactoryBuilder interface SqlSessionFactory interface SqlSession 进行自定义的实现 首先进行项目的创建, 并删除pom.xml文件中的MyBatis依赖 此时的Test中由于缺少对应的类以及接口 会报错 创建相应的类以及接口 类Resources以及其中的方法 创建类SqlSessionFactoryBuilder以及其中的方法build 创建接口SqlSessionFactory 创建接口SqlSession以及接口中的方法getMapper和close 到此为止 , Test中已经不会报错了 引入对应的创建的类以及接口 实现创建的类以及接口中的具体实现 准备工作 读取配置文件以及修改工具类 此时需要读取XML文件 此时已经不需要对应的 MyBatis中的约束文件了 需要将对应的约束删除 UserDao.xml SqlMapConfig.xml 要对XML文件进行解析 需要使用工具类XMLConfigBuilder 导入并进行修改 根据其中的错误进行修改 导入dom4j的坐标依赖以及jaxen坐标 创建Configuration配置类 创建Mapper类 这个时候 再将工具类中的导包进行注释以及将注解的方式进行注释 就不再报错了 实现SqlSessionFactoryBuilder的build方法 构建者 需要返回一个工厂 就需要实现创建工厂的实现类 创建SqlSessionFactory工厂的实现类 工厂的实现类中的openSession方法 需要返回一个工厂生产的对象 创建SqlSession对象的实现类 在SqlSessionImpl中实现对应的方法 以上 就将我们的各种类联系起来了 首先 , 我们读取配置文件使用到了Resources类 然后 , 将配置文件的信息交给构建者SqlSessionFactoryBuilder 然后 , 构建者根据信息使用工具类XMLConfigBuilder创建SqlSessionFactory工厂对象 然后 , 工厂对象SqlSessionFactory中的openSession方法给我们提供了创建SqlSession对象方法 最后 , 我们需要做的就是在SqlSession对象session中实现创建代理对象以及执行SQL语句的方法并且实现close方法 实现具体的SqlSession中的方法 在实现类中 实现接口中的方法 在MapperProxy类中对方法进行增强 这里invoke方法中主要是 获取mappers中存储的方法名以此作为键来获取对应的值 值中存储有SQL语句以及需要封装到的对应的类名 使用已经提供好的工具 来实现selectList方法 DataSourceUtil工具类 用来获取连接 我们需要的是查询所有findAll()的方法, 而这个功能在Exeuctor工具类中实现 在创建MapperProxy工具类调用这个Exeuctor工具类中的selectList方法 创建代理对象的时候实现MapperProxy工具类对方法进行增强(这里是指调用selectList方法) 在MapperProxy类中存储的有执行的SQL语句以及封装的结果, 这些内容都在配置文件中 然后就是读取配置文件, 工具类XMLConfigureBuilder将读取到的结果存储封装成Configuration类对象 , Configuration中存储的有连接数据库的信息以及执行的SQL的信息封装成的map 总的来说就是 创建代理对象 执行查询所有 自定义实现(注解的方式) 配置mapper中的属性为class 在UserDao上进行注解的设置 创建@interface 结束 总的来说, 过程是这样的 这里向看一下这个解析XML的类 虽然不是掌握的重点 但是却可以清晰的直到是如何获取通过配置文件获取SQL语句以封装的实体类的","categories":[{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.chasingwind.top/tags/Mybatis/"}],"author":"ChasingWind"},{"title":"Linux环境部署以及Nginx","slug":"Linux环境部署以及Nginx","date":"2019-08-12T12:25:19.000Z","updated":"2021-03-04T00:49:07.032Z","comments":true,"path":"2019/08/12/Linux环境部署以及Nginx/","link":"","permalink":"https://www.chasingwind.top/2019/08/12/Linux%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8ANginx/","excerpt":"本篇讲述了在Linux上部署JDK,MySQL，Tomcat以及Nginx，并在服务器上发布Web项目。此外，还会对于Ngix有一个基本的介绍以及如何使用等等。","text":"本篇讲述了在Linux上部署JDK,MySQL，Tomcat以及Nginx，并在服务器上发布Web项目。此外，还会对于Ngix有一个基本的介绍以及如何使用等等。 Linux上的项目环境搭建 为了让项目在服务器上运行，就需要在服务器上安装项目运行的环境，包括JDK，Tomcat，MySQL等等 Linux上安装JDK 在我们安装CentOS的时候，已经帮我们安装好了开源的JDK，OpenJDK，但是并不是我们想要的版本 卸载OpenJDK 执行rpm -qa | grep java : 查询到系统中与Java有关的安装包 Linux rpm 命令用于管理套件。 rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序 rpm 命令有点类似于Windows中的控制面板 , 对安装的软件进行管理 -q 使用询问模式，当遇到任何问题时，rpm指令会先询问用户。 -a 查询所有套件。 -e &lt;套件档&gt;或–erase&lt;套件档&gt; 删除指定的套件。 –nodeps 不验证套件档的相互关联性。 执行rpm -e --nodeps xxxxx : 卸载xxxx 创建JDK安装路径 创建JDK安装的目录 : usr/local/src目录下创建java目录 下载JDK的压缩文件(.tar.gz)到java目录下 并解压 配置环境变量 vim /etc/profile : 直接打开etc下的profile文件在此文件中进行配置 export JAVA_HOME=/usr/local/src/java/jdk1.8.0_181 #此处为jdk解压的路径 export JAVA_BIN=$JAVA_HOME/bin export JAVA_LIB=$JAVA_HOME/lib export CLASSPATH=.:$JAVA_LIB/tools.jar:$JAVA_LIB/dt.jar export PATH=$JAVA_BIN:$PATH 使JDK环境变量生效 , 并查看安装的Java版本 source /etc/profile Linux上安装MySQL 创建MySQL目录 : usr/local/src目录下创建MySQL目录 检测是否已经安装了MySQL, rpm -qa | grep mysql , 安装与否视情况而定, 我的系统没有自带MySQL 下载rpm文件 因为CentOS属于Redhat , 所以下载Redhat的就行了 安装 rpm -ivh mysql的rpm文件 yum install mysql-server 然后就是下载安装了 下载页面在这里 一定不要选错https://dev.mysql.com/downloads/repo/yum/ 启动并查看MySQL状态 启动 : systemctl start mysqld 查看MySQL状态 : systemctl status mysqld 登录MySQL 在第一次启动MySQL服务器的时候 , 系统吧会给root用户创建一个临时的密码,我们需要进行修改 首先,查看这个临时密码, 并使用他来登录 查看临时密码 : grep &#39;temporary password&#39; /var/log/mysqld.log 登录MySQL 进行密码的修改 alter user &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;你的新密码&#39;; 这里8.0以后的MySQL密码设置都比较严格 ,需要有大写字母数字和符号 设置开机自启动(root用户下) vim /etc/rc.local 打开文件 进行修改 (管理员命令下) 在文件中添加systemctl status mysqld 保存退出 开启远程服务(为某个用户) 使用root用户登录MySQL 设置权限 CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;root用户的密码&#39;; 主机名为%表示任意主机都可以访问 , 这句话是可以不执行的 因为系统默认有root用户 GRANT ALL PRIVILEGES ON *.* TO &#39;用户名&#39;@&#39;%&#39; WITH GRANT OPTION; 防火墙设置(不是在MySQL中进行设置) 开启3306端口 : firewall-cmd --zone=public --add-port=3306/tcp --permanent 重启防火墙 : firewall-cmd --reload 进行连接 如果实在阿里云服务器中的话 还需要开启安全组策略 因为我刚刚创建了一个叫client的用户 Linux上安装Tomcat 创建Tomcat目录 : usr/local/src目录下创建Tomcat目录 解压文件 tar -xvf Tomcat文件名 查看目录 有时我们熟悉的画面 启动和关闭 在Windows下使用的是start.bat和shutdown.bat 在Linux中使用的是start.sh和shutdown.sh sh == shell 执行命令 设置防火墙 开启8080端口 : firewall-cmd --zone=public --add-port=8080/tcp --permanent 重启防火墙 : firewall-cmd --reload 当我们重新启动的时候 , 就可以通过浏览器进行访问了 如果是阿里云的话 设置完需要重启服务器 Linux上发布项目 将数据库还原到Linux上 备份Windows上的数据库 在Linux上还原数据库 将程序的代码发布到Linux上 将项目打包成war包 使用IDEA中的Maven的package 将打包的.war文件上传到Tomcat的webapps目录下 使用FileZilla软件可以轻松将文件上传 将上传的.war文件放到Tomcat的webapps目录下 修改数据库的配置文件以及文件中的内容等等 通过路径进行访问 比如:https://IP地址:8080/项目打包的名字 NginxNginx概述 概念 : Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。 Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 为什么使用Nginx ? 大用户量高并发已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢? 用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的 为了解决这个问题引入了负载均衡方法, 而Nginx则是一款免费开源的负载均衡的服务器 Nginx+Tomcat的集群配置(Windows) 完成Nginx负载均衡,那么需要先来介绍Tomcat的安装和配置,我们首先要来配置Tomcat完成集群的配置. 因为我们没有多台服务器运行Tomcat.那么我们可以模拟在一台服务器上运行多个Tomcat程序. 在一台电脑上安装两个Tomcat 复制Tomcat的目录就行 修改Tomcat配置文件 , 修改端口 在conf目录下的server.xml文件中 我是在原本的端口上都加了1 只要不跟另一个Tomcat的端口冲突就行了 将项目分别发布到两个服务器中 将项目分别放在两个Tomcat的webapps目录下就行 分别启动Tomcat 进行访问 但是这样有一个问题 就是 这个时候我们去访问网站 用户需要使用不同的ip地址去访问同一个网站? 所以就需要一个网址在有多台服务器的情况下有一个统一的的入口 , 那就是Nginx 安装Nginx (端口号是80) 下载Nginx 解压就行了 双击开启 Nginx是有默认路径的 端口号是80 去访问localhost:80 进行配置 conf目录下的nginx.conf 将两个服务器映射到同一个Nginx , 那么就需要进行配置 这里是默认的配置 进行修改 这里是正常的修改 由于我的出现了致命的配置错误 , 这个问题搞了我大半天 除了上面的配置之外 还需要在location中配置 #修改发送到后端的header的host proxy_set_header Host $host; #设置真实IP proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; 在Nginx目录下 , 使用Cmder重新加载Nginx的配置文件 : nginx -s reload 这样我们就可以通过同一个地址访问这两个服务器了 也就实现了负载均衡 这里还有一个问题 那就是当我们刷新同一个local/test的时候, Session会发生改变 也就是不再是同一个会话 显然这并不是我们想要的 可见,Session的ID已经发生改变 Tomcat集群中的Session共享 让每一个用户只能访问同一台服务器 , 这样就不存在Session丢失的问题 可以在配置文件中进行配置 还可以设置权重 来让用户优先访问哪一个服务器 权重越大,那么就越优先被使用 使用Tomcat广播机制完成Session的共享(不推荐) 因为当集群中的服务器较多的时候,每一个服务器都需要广播自己的Session , 显然对资源的耗费比较大 修改Tomcat中的server.xml 将注释打开就行了 当有多个集群的时候 就需要再进行详细的配置 修改项目中的web.xml文件 , 加入节点&lt;distributable/&gt; 重启服务器 Tomcat集群+Redis缓存的Session共享配置方法 将所有的Session保存在Redis缓存中 , 并且取的时候也从Redis中取 参考 [配置参考]: https://blog.csdn.net/hua1586981/article/details/78132710 下载相关的jar包 , 导入到服务器下的lib目录中 在conf下的context.xml中配置 我的Redis没有密码 需哦一将password这一项去掉 重启Tomcat查看效果 Nginx+Tomcat的集群配置(Linux) 在Linux上安装多个Tomcat(root用户下) 解压tar.gz文件就行了 修改Tomcat2的conf/server.xml文件 进行端口的修改 将项目的war包上传到对应的webapps目录下 启动两个Tomcat 你会发现只能访问一个 这里还记得之前需要配置防火墙吗 ? 因为我们没有对新的端口(8081)进行防火墙的配置并重启防火墙 firewall-cmd --zone=public --add-port=8081/tcp --permanent firewall-cmd --reload 进行访问 Linux上安装Nginx 安装依赖包 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 一键安装所需要的依赖包 下载Nginx的安装包并解压 执行安装命令 在Nginx目录下执行命令 这个是默认路径 ./configure &amp;&amp; make &amp;&amp; make install 可以进行配置的修改 ./configure --prefix=安装路径 然后再执行make &amp;&amp; make install 比如我在我的Nginx目录下直接执行 ./configure \\ --prefix=/usr/local/src/Nginx/nginx-1.16.0 \\ --pid-path=/var/run/nginx/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi 注意 : 第一行中的就是安装的路径 然后执行 make &amp;&amp; make install命令 总之 你需要找到sbin目录 因为后面启动要使用 启动Nginx 在/sbin目录下执行./config 我的报错了 原因是没有对应的文件夹 创建就行了 进行访问 负载均衡相关知识 负载均衡 概念 负载均衡就是一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。当然, 请求的分配是有很多种算法的 负载均衡服务器 分类 硬负载 : 通过硬件实现的负载均衡服务器，简称硬负载 , 例如：f5。 软负载 : 通过软件来实现的负载均衡，简称软负载:例如apache和Nginx 区别 作用的网络层次 硬负载作用的网络层次比较多，可以作用到socket接口的数据链路层对发出的请求进行分组转发 软负载作用的层次在http协议层之上可以对http请求进行分组转发 成本 硬负载成本比较高 软负载因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。 代理相关知识 正向代理 概念 : 一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下： 正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代 理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 作用 : 访问本无法访问的服务器B 当用户与服务器之间的路由出现故障的时候 用户可以通过代理服务器进行服务器的访问，生活中常见的翻墙就是使用代理技术和其他技术一起实现的 加速访问服务器B 在早期带宽较小的时候, 使用正向代理来提速。做法就是在客户端到代理服务器和服务器的路径使用高速链路。这样就比通过路由访问速度快 Cache作用 如果在用户A访问服务器B中的某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。 这一技术在Cache中术语就叫Cache命中。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。 客户端访问授权 隐藏访问者的行踪 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内 容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 反向代理 概念 : 反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 作用 : 保护和隐藏原始资源服务器 用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。 由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情 负载均衡 当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群， 当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。 Cache作用 当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件， 如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心 CDN技术 : CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术 透明代理 概念 : 透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。 透明代理实践的例子就是时下很多公司使用的行为管理软件。 用户A和用户B并不知道行为管理设备充当透明代理行为， 当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求， 当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B， 如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.chasingwind.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.chasingwind.top/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.chasingwind.top/tags/Nginx/"}],"author":"ChasingWind"},{"title":"Linux基础","slug":"Linux基础","date":"2019-08-11T07:54:15.000Z","updated":"2021-03-04T00:49:18.254Z","comments":true,"path":"2019/08/11/Linux基础/","link":"","permalink":"https://www.chasingwind.top/2019/08/11/Linux%E5%9F%BA%E7%A1%80/","excerpt":"本篇主要讲述了Linux的基础知识,Linux在虚拟机上安装以及命令行的操作, 其中包括平常经常会使用的Linux的命令, 以及一些权限管理,包括对用户以及文件等等.","text":"本篇主要讲述了Linux的基础知识,Linux在虚拟机上安装以及命令行的操作, 其中包括平常经常会使用的Linux的命令, 以及一些权限管理,包括对用户以及文件等等. Linux概述 为什么需要学习Linux? 一般服务器都安装在Linux操作系统上, 我们需要将项目发布到Linux上 什么是Linux? Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux是基于Unix的 Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机 什么是Unix? UNIX操作系统（尤尼斯），是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统 UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。 Linux系统的应用 服务器系统：Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 主要是免费的系统 嵌入式系统：路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等， 高性能运算、计算密集型应用：Linux有强大的运算能力。 桌面应用系统 移动手持系统 Linux的版本 内核版本 内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ； 发行版本 发行版本是一些组织和公司根据自己发行版的不同而自定的 ； Linux的主流版本 Linux的安装 虚拟机：VMWare（收费），VirtualBox（免费） 在虚拟机中安装CentOS Linux的目录结构 root管理员的home目录root 其他用户的home目录home目录中 Linux的远程管理工具 远程管理工具的作用 Linux一般作为服务器使用，而服务器一般放在机房，你不可能在机房操作你的Linux服务器。这时我们就需要远程登录到Linux服务器来管理维护系统。 远程管理工具 SecureCRT 安装注册 配置Linux的ip 使用 可以看到跟在虚拟机上使用有一样的效果 Linux的常用命令切换目录的命令 cd cd /和cd ~ cd /和cd ~的区别就是 : 前者是系统根目录,就是我们看到的Linux的目录结构 后者是root用户的目录,就是这个样子的 cd xxx/,cd ..,cd - cd -：回到上一次所在的目录 cd .进入的还是当前的目录,cd..进入的是当前目录的上一级目录 列出文件列表 ls ll ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式 : ls[参数] [路径或文件名] ls 和 ls -a ： ls显示当前目录下的文件 ls -a 显示当前目录下的所有的文件 包括隐藏文件 Linux中的隐藏文件以.开头 ls -l == ll : 以一种格式显示查询到的文件 ll -a : 将命令进行组合使用 , 以某种格式显示目录下的所有的文件 可以看到其实每个目录下都会有隐藏文件.和..,这就是我们cd..使用的 当我们不知道命令的参数的时候, 我们可以使用man xxx来查询xxx中的对应的命令 的参数,q退出查询 创建目录和移除目录 mkdir rmdir mkdir xxx和mkdir -p xxx/xxx/xxx/.... mkdir(make directory)命令可用来创建子目录。 mkdir xxx 在当前目录下创建app目录 mkdir –p xxxx/xxxx 建立多层级目录 rmdir remove directory 命令可用来删除“空”的子目录： 当目录中为空的的时候 可以使用此命令进行删除空的目录 当目录中不为空的时候,无法使用这个命令进行删除 浏览文件 cat more less cat cat xxxx : 用来查看xxxx文件中的内容 more more xxx 当文件较多的时候(对于没有滚动条的终端),more用于要显示的内容会超过一个画面长度的情况 按空格键显示下一个画面。 回车显示下一行内容。 按 q 键退出查看。 less less xxx 用法和more类似，不同的是less可以通过PgUp、PgDn键来控制上下翻页 tail tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。 tail -num xxxx : 查看文件xxxx的后num行内容 tail -f xxxx : 动态查看xxxx中的内容 ,动态的意思就是对文件中的内容进行实时更新, 一般用于加载日志信息 Ctrl + c : 结束查看 文件操作的命令 rm : 删除文件 rm xxxx : 删除xxxx文件 rm -f xxxx : 删除xxxx文件不询问 rm -r xxxx : 删除目录,递归删除 a/b/c是一个多层级目录 可以使用此命令一下删除a以及其子目录 rm -rf xxxx : 不询问删除xxxx中的所有文件 rm -rf xxxx 不询问递归删除xxxx rm -rf * 删除所有文件 rm -rf /* 自杀 cp : copy,复制文件 cp a.txt b.txt : 将a.txt文件复制为b.txt , 到当前目录 cp xxxx 目录/ : 将xxxx文件复制到某个目录下 mv : move,移动文件(相当于剪切+粘贴) mv xxxx 目录/ : 将xxxx文件移动到某个指定的目录下 mv 文件a 文件b : 就相当于在当前目录下 , 将文件a重命名为文件b 打包/解压 tar tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。 一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，此时未经过压缩处理，后缀名为.tar，再以gzip压缩命令**压缩成xxx.tar.gz(或称为xxx.tgz)**的文件，此时就是压缩文件了。 .tar是一个打包过的文件，.tar.gz是一个压缩文件 tar常用的参数 -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 -t：查看压缩文件的内容 -x：解开tar文件 tar -cvf 文件名.tar 需要打包的文件 : 将文件打包 ./* : 代表当前目录下的所有的文件 tar -cvzf 文件名.tar.gz 需要压缩的文件 : 将文件打包并且压缩 tar -xvf 压缩文件名 : 将压缩文件解压缩到当前目录 tar -xvf 压缩文件名 -C 解压缩路径 : 将压缩文件解压缩到… 注意的是 : -C需要大写! 查找 grep 相当于Ctrl + F , 用于在文件中查找指定的字符串你 grep xxxx 文件名 : 在文件中查找xxxx grep xxxx 文件名 --color : 将查找到的结果高亮显示 grep xxxx 文件名 -Bx : 显示查找到的结果处的**(Before)前x行** grep xxxx 文件名 -Ax : 显示查找到的结果处的**(After)后x行** 其他常用命令 pwd : 显示当前所在的目录 touch : 创建一个空的文件 ll -h : 显示文件的大小 , 带单位的显示 wget 地址 : 下载文件 其他知识 在Linux中, 文件是没有扩展名之分的 , 所有的文件都可以使用编辑器打开 文件的格式 文件是以-开头的 文件夹是以d开头的 Vi和Vim编辑器 Vim可以当作Vi的升级版本，他可以用多种颜色的方式来显示一些特殊的信息 Vim的三种模式 : 命令行、插入、底行模式。 切换到命令行模式：按Esc键,然后根据命令(i,o,a,:等等)来切换不同的模式； 切换到插入模式：按 i 、o、a键； 切换到底行模式：按 :（冒号）； Vim中的一些常用的命令 使用vim打开文件进行编辑 vim 文件名 退出, 在命令行模式下 退出：esc + :q 修改文件：输入i进入插入模式 保存并退出：esc + :wq 不保存退出：esc + :q! 复制(yy) + 粘贴(p) dd删除当前行 重定向输出将输出信息不输出在控制台,而是输出到重定向的对应的文件中 &gt; : 不可以对重定向之后的文件进行追加操作, 也就是说 当我们再次重定向这个文件之后, 之前的文件内容就不在了 &gt;&gt; : 将输出信息重定向到文件中 , 并且这个文件是可追加的 , 新的重定向的数据会拼接在之前信息的后面 管道 | 管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。 比如 , 在Linux中查询Java相关的进程 ps -ef : Linux中的进程 这里的意思就是在查询到的ps -ef的数据中, 进行grep java操作 命令控制执行 &amp;&amp; 命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。 网络通信命令 ifconfig 显示或设置网络设备。 ifconfig 显示网络设备 ifconfig xxx up 启用xxx网卡 ifconfig xxx down 停用xxx网卡 ping 探测网络是否通畅。 ping ip地址 netstat -an 查看网络端口的信息。 netstat -an | grep 3306 查询3306端口占用情况 系统管理命令 date 显示或设置系统时间 date 显示当前系统时间 date -s “2014-01-01 10:10:10“ 设置系统时间 df 显示磁盘信息 df –h 友好显示大小 free 显示内存状态 top 显示，管理执行中的程序 有点像windows中的任务管理器 , 可以动态显示当前进程的状态 右上角load average 是 负载 clear 清屏幕 ps 正在运行的某个进程的状态 ps –ef 查看所有进程 ps –ef | grep xxxx 查找xxxx进程 kill 杀掉某一进程 kill xxxx 杀掉xxxx编号的进程 kill -9 xxxx 强制杀死进程xxxx du 显示目录或文件的大小。 who 显示目前登入系统的用户信息 hostname 查看当前主机名 vim /etc/sysconfig/network uname 显示系统信息。 uname -a 显示详细信息 uname -a 显示本机详细信息。依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称 用户管理 useradd 添加一个用户(root用户的状态下) passwd xxxx 为xxxx设置密码 su - 用户名 : 切换用户 ,注意空格 userdel : 删除一个用户(root用户状态下) userdel test 删除test用户(不会删除home目录) 可见 用户的文件夹还是存在的 userdel –r xxxx 删除xxxx用户以及home目录 组管理 当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组, 创建用户时也可以指定所在组 groupadd 组名 : 创建组 useradd 用户名 –g 组名 : 创建用户并且指定组 groupdel xxxx : 删除组xxxx 如果该组有用户成员，必须先删除用户才能删除组。 id : 查看当前用户的id以及所在组的id 权限命令 文件权限 可以发现 每组权限都有3个取值 r代表可读,w代表可写,x表示可执行 其实Linux中的每一组权限都可以取0~7的值(权限的值可以进行相加,表示一组权限),一共8种状态不重复 文件类型 普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 设备文件： Linux系统把每一个设备都看成是一个文件 文件类型标识 普通文件 : - 目录 : d 符号链接 (快捷方式) : l 字符设备文件 : c 文件权限管理 chmod : change modify , 变更文件或目录的权限。 chmod 755 a.txt : 修改a.txt的文件权限为rwxr-xr-x chmod u=rwx,g=rx,o=rx a.txt 修改a.txt的文件权限为rwxr-xr-x 即使你设置文件权限000, root用户还是可以对文件进行rwx的操作 chown : 变更文件或目录改文件所属用户和组 chown 用户名:组名 xxxx ：变更xxxx的所属用户和组 chown -R 用户名:组名 目录 ：变更目录中的所有的子目录及文件的所属用户和组","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.chasingwind.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.chasingwind.top/tags/Linux/"}],"author":"ChasingWind"},{"title":"JavaWeb项目","slug":"JavaWeb项目","date":"2019-08-08T15:21:11.000Z","updated":"2021-03-04T00:48:07.247Z","comments":true,"path":"2019/08/08/JavaWeb项目/","link":"","permalink":"https://www.chasingwind.top/2019/08/08/JavaWeb%E9%A1%B9%E7%9B%AE/","excerpt":"JavaWeb基础的知识学完了 , 做一个JavaWeb项目来复习巩固JavaWeb的知识.主要使用三层架构的思想来完成设计以及代码的编写 ,设计简单的前端,后端,客户端以及服务器之间的数据的传递等等","text":"JavaWeb基础的知识学完了 , 做一个JavaWeb项目来复习巩固JavaWeb的知识.主要使用三层架构的思想来完成设计以及代码的编写 ,设计简单的前端,后端,客户端以及服务器之间的数据的传递等等 技术选型Web层 Servlet：前端控制器 html：视图 Filter：过滤器 BeanUtils：数据封装 Jackson：json序列化工具 Service层 Javamail：java发送邮件工具 Redis：nosql内存数据库 Jedis：java的redis客户端 DAO层 Mysql：数据库 Druid：数据库连接池 JdbcTemplate：jdbc的工具 数据库环境搭建功能实现注册功能 页面效果 功能分析 代码实现 前台代码实现 在用户输入信息之后对用户输入是否符合规定进行校验 使用JavaScript实现 在此使用异步提交表单是为了获取服务器响应的数据。因为我们前台使用的是html作为视图层，不能够直接从servlet相关的域对象获取值，只能通过ajax获取响应数据 后台代码实现 RegisterSubmitServlet 对用户填入的信息进行校验 是去查询数据库的校验 以完成注册的功能 UserService和UserServiceImpl UserDao以及UserDaoImpl 邮件激活 在用户注册之后需要点击邮箱中的激活连接进行激活 这里需要使用MailUtil工具类来发送邮件 需要设置发信的邮箱的账号以及授权码 修改put中的邮箱的类型 这里是测试 使用sendMail的方法 用户点击激活邮件进行激活 用户激活其实就是修改用户表中的status为‘Y’ 激活的分析图 service中的方法 dao中的方法 用户点击邮箱中的链接进行激活的操作 Service中的active方法 通过用户请求的唯一code值来判断是否是本人激活 UserDao中的查找code的方法 一次来判断用户请求中的code是否等于用户数据库中的code 登录 前台代码 后台代码 LoginServlet 通过用户名和密码来判断用户输入的信息正确与否从而进行登录 Dao中的方法 退出什么叫做登录了？session中有user对象。 实现步骤： 访问servlet，将session销毁 跳转到登录页面 header.html Servlet 功能优化 BaseServlet的抽取 我们有很多个Servlet都是对用户的操作，可以将这些Servlet抽取出来，像Service一样，放在一个Service里面 减少Servlet的数量，现在是一个功能一个Servlet，将其优化为一个模块一个Servlet，相当于在数据库中一张表对应一个Servlet，在Servlet中提供不同的方法，完成用户的请求。 UserServlet中的find和add方法 UserServlet继承BaseServlet 因为继承HttpServlet的话 只能使用HttpServlet中的doPost,doGet等的方法 所以我们就可以利用BaseServlet作为”中间人”来实现既能有Servlet功能,又可以自定义方法的功能 BaseServlet继承自HttpServlet,并实现service方法 当我们访问的时候路径user/add的时候,控制台的输出 BaseServlet中的service方法被执行了…. 所以,我们可以利用类似的做法来实现将Servlet统一到一个里面,通过service方法中分发方法来实现 在service（）中完成方法的分发 在上面的测试中，可以看到我们访问的是/user/add，这样就执行了service的方法 所以我们可以拿到/user/add中的add，获取方法对象通过反射，来执行这个方法 当我们进行访问的时候发生了异常 这个异常是因为方法的权限是protected造成的 反射获取不到 当然可以通过暴力反射 但是这样不安全 因为这样的话私有的方法也可以获取了 将方法的权限修改成public 测试 我们分别去访问不同的add和find方法的时候 Category 可见,通过方法的分发 可以很好地调用不同的方法(继承了BaseServlet) Servlet的整合 就是将之前的各个Servlet中的代码放到一个方法中 比如之前的注册的功能 同时不要忘记前端代码的路径的修改 修改为 等等 ….之前的路径都需要进行修改…省略.. 分类展示 效果 分析 代码实现 后台代码 CategoryDaoImpl CategoryServiceImpl CategoryServlet 优化序列化为json的操作 我们在BaseServlet中重写Jackson的writeValue以及WriteValueAsString方法 前台代码 header.html中的静态的 通过ajax请求来获取 在浏览器中可以看到请求的数据 可以看到findAll请求响应回来的数据 优化分析：缓存优化 分析发现，分类的数据在每一次页面加载后都会重新请求数据库来加载，对数据库的压力比较大，而且分类的数据不会经常产生变化，所有可以使用redis来缓存这个数据。 分析 实现 CategoryServiceImpl 因为返回的是一个List集合的形式 而是用缓存查询出来的是一个set集合 所以需要将缓存中的数据进行转换为list 旅游路线分页展示 旅游分类和旅游线路的关系 数据库中的两个表的关系 一对多 当我们点击不同的条目的时候,显示不同的商品信息 上面分析到 路线分类中的cid可以对应多个商品信息 所以在我们请求的时候 需要在请求的路径中添加cid cid都是0? 因为我们在缓存中zrange的时候没有存储scores 可以使用zrangeWithScores 并且在封装的时候需要存储scores 在Tuple类中 分别有对应的获取element和score的方法 这样就取出来了对应的cid 如何在head.html中将cid取出来 search 属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号 ? 之后的部分）。 这样就将请求中的cid取出来了 后台代码 分页展示旅游线路的数据 分析 PageBean对象 将服务器端的数据封装成PageBean对象发送给浏览器 RouteServlet 完成浏览器请求的数据的处理 以及将服务器中查询到的数据进行封装展示给浏览器 RouteService 将在dao中查询的数据封装成PageBean返回给Servlet 因为客户端浏览器请求的URL中已经有cid,currentPage和PageSize的数据了 所以我们需要根据这些参数来计算出PageBean中未有的参数totalCount以及每页的数据list RouteDao 根据查询数据库的数据来返回给Service层需要的totalCount以及每页的数据的集合 我们通过给浏览器指定的URL的参数的形式来查看Servlet给浏览器返回的JSON数据 JSON解析器查看 前台代码 首先完成页面内容以及页码的展示 JavaScript 页面 显示当前页的效果 首页以及上一页的效果,下一页以及最后一页 首页以及上一页 下一页以及最后一页 注意字符串的拼接 页码的优化 需求 分页工具条的前5后4 效果 下一页跳转到页面顶部 s在页面拼接完成后 旅游线路搜索 效果 查询参数的传递 在header.html中完成输入数据的获取 以及 路径的跳转到route_list.html 在route_list中获取请求路径中的数据 – 这样我们就拿到了搜索的数据 后面我们就可以使用这些数据发送到服务器中,去查询数据库获取我们需要的数据 服务器端的代码的编写 首先 大概的情况就是 客户端请求的URL中可能会出现的情况\\ 1 只有cid 2 有cid和rname 所以我们需要将rname也放在查询的参数中 在RouteServlet中 在service中 在dao中 我们需要根据请求参数的不同来查询不同的sql 动态sql实现 这样我们就查询到了数据 前台代码 这里再进行参数的传递的时候 需要传递rname 并且需要完成分页的功能的话 需要对每个按钮中的load函数进行更新 特别注意这个拼接!!!!! 这里还有一个问题 当我们在首页直接请求搜索的时候 此时load函数中的第二个参数cid就是null 在地址栏中的cid就是null 当传的参数为null的时候,那么进行类型转换的话 也会出现异常 修改 让他不进行类型的转换 旅游线路详情页面 分析 Route类中的routeImgList存放的是详情页的图片 数据库中表之间的关系 页面的跳转 首先完成点击 查看详情 转到对应的页面 后台代码的编写 我们需要的是Route的所有的数据(虽然可能并不会用到全部的数据) 首先,这是Route的数据 Servlet Service方法 route中存储的是Route对象中的所有的数据 但是后面的RouteImg以及Seller需要进行新的查询数据库的设置 RouteDaoImpl RouteImgdaoImpl SellerDaoImpl 然后将这些查询到的数据封装到route对象中 转换为json格式的数据 通过路径查询 可以得到数据 格式化后的json 前台代码的编写 route_detail.html页面加载完成后 获取rid(route_list.html页面跳转过来的) 发送Ajax请求 解析route对象的数据填充到html 首先完成页面中数据部分的展示 图片部分的拼接 首先,页面是这样的 对应的html changeImg在toute_detail的上面 效果 旅游线路收藏页面 分析 表之间的关系 后台代码 RouteServlet Service Dao 前台代码 route_detail.html 改变收藏按钮的状态 收藏次数的动态展示 在RouteService中添加 dao 页面展示 点击按钮收藏线路 分析 RouteServlet favouriteService favouriteDao 前台代码 小优化","categories":[{"name":"项目","slug":"项目","permalink":"https://www.chasingwind.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"JavaWeb项目","slug":"JavaWeb项目","permalink":"https://www.chasingwind.top/tags/JavaWeb%E9%A1%B9%E7%9B%AE/"}],"author":"ChasingWind"},{"title":"Maven基础","slug":"Maven基础","date":"2019-08-06T02:33:46.000Z","updated":"2021-03-04T00:50:12.935Z","comments":true,"path":"2019/08/06/Maven基础/","link":"","permalink":"https://www.chasingwind.top/2019/08/06/Maven%E5%9F%BA%E7%A1%80/","excerpt":"Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。","text":"Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。 概念 什么是Maven? Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。 Maven能解决的问题 能帮你构建工程，管理 jar 包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站 点 Maven的两个核心特性 依赖管理：Maven对jar包的管理过程 传统的项目jar包需要放在工程中，而在Maven项目中的jar包，是放在jar包仓库中，Maven工程通过pom.xml中的jar包的坐标，从而在Maven工程中使用jar包 一键构建：项目的整个构建过程，Maven可以一键完成 项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven 进行管理，这个过程称为构建，一键构建是指Maven项目通过命令,可以一键完成上面的构建过程。 Maven安装 解压即可 目录结构 bin:存放了 maven 的命令，比如我们前面用到的mvn tomcat:run boot:存放了一些 maven 本身的引导程序，如类加载器等 conf:存放了 maven 的一些配置文件，如 setting.xml 文件 lib:存放了 maven 本身运行所需的一些 jar 包 至此我们的 maven 软件就可以使用了，前提是你的电脑上之前已经安装并配置好了 JDK。 进行环境变量的配置 新建系统环境变量 在Path中新建环境变量 在cmd中输入mvn -v查看版本信息,有的话就表明成功了 Maven仓库的种类以及仓库之间的关系 当我们启动Maven项目的时候,会优先去本地仓库中寻找jar包，如果本地仓库没有jar包的话,会去联网中央仓库下载jar包，如果本地仓库没有需要的jar包,并且没有联网的话,就会报错 本地仓库：系统用户/.m2/repository C:\\Users\\WUXINHHUA.m2\\repository 中央仓库 里面放置了几乎所有的开源的jar包 远程仓库(私服) 公司用的jar包的仓库,没有的话也会去中央仓库下载，当然也可以从本地仓库上传 本地仓库的配置 因为maven默认的本地仓库是在C盘的，可以通过配置把他放在其他的盘 在settings.xml中进行本地仓库的配置并把需要的jar包放进去 Maven标准目录结构 src/main/java —— 存放项目的.java 文件 src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件 src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类 src/test/resources —— 测试资源文件 target —— 项目输出位置，编译后的class 文件会输出到此目录 pom.xml——maven 项目核心配置文件 注意：如果是普通的 java 项目，那么就没有webapp 目录。 Maven中常用的命令 mvn clean : 清理已经编译过的信息,会删除target目录 mvn compile : 将src/main/java 下的文件编译为 class 文件输出到 target 目录下。 mvn test : test 是 maven 工程的测试命令 mvn test，会执行src/test/java下的单元测试类。 同时编译java目录下的代码以及tset目录下的代码 mvn package : 将项目打包 mvn install : install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。 上面的顺序中,当后面的命令执行时，前面的操作过程也都会自动执行， Maven生命周期 清理生命周期 : mvn clean,清理项目编译信息 默认生命周期 : mvn compile ，编译；mvn test，测试；mvn package，打包；mvn install，安装；mvn deploy，发布。 站点生命周期 Maven项目模型 在IDEA中集成Maven 一定要在这个里面进行设置 设置Maven以及Maven仓库 配置本地仓库优先 新建Servlet的时候,需要在pom.xml中添加依赖 关于scope tomcat7默认使用的是tomcat6 需要在pom.xml中进行配置tomcat7 运行的时候使用tomcat7:run 并且在运行的时候使用tomcat7:run","categories":[{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://www.chasingwind.top/tags/Maven/"}],"author":"ChasingWind"},{"title":"Redis","slug":"Redis","date":"2019-08-04T13:16:49.000Z","updated":"2021-03-04T00:54:23.335Z","comments":true,"path":"2019/08/04/Redis/","link":"","permalink":"https://www.chasingwind.top/2019/08/04/Redis/","excerpt":"Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，同时是一款NOSQL(Not Only SQL)系列的非关系型数据库。","text":"Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，同时是一款NOSQL(Not Only SQL)系列的非关系型数据库。 概念 概念: Redis是一款高性能的NOSQL(Not Only SQL)系列的非关系型数据库 关系型数据库和非关系型数据库(NOSQL) 当我们查询一些不是经常改变的数据的时候 ,去请求数据库的查询是比较耗时的, 所以可以用缓存的思想来解决这个问题 缓存的选择有很多 比如说 ,可以在内存中开辟空间 存储map集合(JVM中) , 但是这个问题就是他只能用在当前的项目中 分布式缓存,NOSQL数据存储在内存中,而且可以部署在独立的机器上,刚好符合上面的要求 ,Redis用来做缓存就很合适 一些相关的概念 什么是NOSQL NOSQL(NOSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 NOSQL非关系型数据库和关系型数据库比较 优点: 成本：NOSQL数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：NOSQL数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及NOSQL数据库。 存储数据的格式：NOSQL的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点 : 维护的工具和资料有限，因为NOSQL是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对SQL的支持，如果不支持SQL这样的工业标准，将产生一定用户的学习和使用成本。 关系型数据库和非关系型数据库的关系 关系型数据库与NOSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NOSQL的时候使用NOSQL数据库，让NOSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在NOSQL数据库中备份存储关系型数据库的数据 主流的NOSQL产品 键值(Key-Value)存储数据库 相关产品 : Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用 : 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 什么是Redis? Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedset Redis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） 分布式集群架构中的session分离 下载安装 官网 ：Redis官网 中文网：Redis中文网 解压即可使用 redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端 使用 双击redis-server.exe 启动Redis服务器端 可以看到Redis的端口号是6379 进程ID为2960 双击redis-cli.exe 打开本地的客户端 这样客户端就连接上了服务器端 命令操作 Redis的数据结构 : key,value格式的数据 , 其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： 相当于map格式 (key,value) 列表类型 list ： 相当于LinkedList格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 命令行的操作 字符串类型 string 存储 : set key value 获取 : get key 删除 : del key 哈希类型 存储 : hset key field(字段) value 获取 : hget key field: 获取指定的field对应的值 hgetall key：获取所有的field和value 删除 : hdel key field 列表类型 list : 允许重复元素, 可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加 lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边 获取 lrange key start end ：范围获取 lrange key 0 -1 : 获取列表中的所有元素 删除 lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 重复元素 集合类型 set : 不允许存储重复元素 不保证顺序,也就是存入和取出的顺序不一致 存储 : sadd key value 获取 : smembers key : 获取set集合中的所有的元素 删除 : srem key value : 删除set集合中的某个元素 有序集合类型 sortedset : 不允许存储重复元素，且元素有顺序。 保证有序 ：每个元素都会关联一个double类型的分数。redis正是通过score的值来为集合中的成员进行从小到大的排序。 存储 : zadd key score value , 根据score的大小来进行排序 获取 : zrange key start end [withscores] 删除 : zrem key value 通用命令 keys * : 查询所有的键 ,这个*可以替换为需要的正则表达式 type key : 获取键对应的value的类型 del key : 删除指定的key value 持久化操作 Redis是一个内存数据库，当Redis服务器重启，或者电脑重启了，那么数据就没有了。我们可以将Redis中的数据持久化保存到硬盘的文件中。这样当我们重启Redis后，会自动加载文件中的数据，进行恢复。 Redis持久化机制 RDB：默认方式，不需要进行配置，默认使用这种机制（开销较小） 在一定的间隔时间中，检测key的变化情况,然后持久化 在redis.windwos.conf文件中可以进行配置 , (图中的是默认的) 比如说 save 300 10的意思就是 在接下来的300秒key发生了10次变化,那么就在300s后进行一次持久化存储 如果将配置文件修改了 就需要在启动的时候指定配置文件的名称 redis-server.exe redis.windows.conf 当达到持久化的条件的时候 会在目录中生成.rpb的文件 关闭服务器 重启就会加载之前的rpb文件进行恢复的操作 AOF：日志记录的方式（开销较大） 可以记录每一条命令的操作,可以每一次命令操作后,持久化数据 编辑redis.windwos.conf文件 appendonly no（关闭AOF） –&gt; appendonly yes （开启AOF） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 使用Java客户端操作Redis(Jedis) Jedis : 一款Java操作Redis数据库的工具，作用可以类比MySQL中的JDBC 使用步骤： 下载Jedis的相关的jar包 commons-pool2-2.3.jar jedis-2.7.0.jar 使用 首先,需要确保你的数据库服务器是开着的 刚开始是没有数据的,执行过后的结果 使用Jedis来操作Redis中的各种数据结构 字符串类型 string set get setex()方法一般我们可以用在验证码 哈希类型 hash ： map格式 hset hget hgetAll 列表类型 list ： linkedlist格式。支持重复元素 lpush/rpush lpop/rpop lrange start end : 范围获取 集合类型 set ： 不允许重复元素 sadd smembers : 获取所有元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange Jedis的连接池(自带的) : JedisPool 对Jedis的连接有更好的复用和管理 使用 创建JedisPool连接池对象 调用方法 getResource()方法获取连接 注意,这里的close()不是关流 ,而是将连接归还到连接池中 当然 我们可以进行连接池的一些参数的配置 在创建连接池的时候,将配置对象传入构造函数中 配置的参数参考 #最大活动对象数 redis.pool.maxTotal=1000 #最大能够保持idel状态的对象数 redis.pool.maxIdle=100 #最小能够保持idel状态的对象数 redis.pool.minIdle=50 #当池内没有返回对象时，最大等待时间 redis.pool.maxWaitMillis=10000 #当调用borrow Object方法时，是否进行有效性检查 redis.pool.testOnBorrow=true #当调用return Object方法时，是否进行有效性检查 redis.pool.testOnReturn=true #“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1. redis.pool.timeBetweenEvictionRunsMillis=30000 #向调用者输出“链接”对象时，是否检测它的空闲超时； redis.pool.testWhileIdle=true # 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3. redis.pool.numTestsPerEvictionRun=50 #redis服务器的IP redis.ip=xxxxxx #redis服务器的Port redis1.port=6379 Jedis连接池的工具类 JedisPoolUtils 配置文件 工具类 使用工具类来获取连接池中的连接 这样我们就不需要进行配置了 直接使用工具类中的方法来获取连接就行了 案例 需求 提供index.html页面，页面中有一个省份 下拉列表 当 页面加载完成后 发送ajax请求，加载所有省份 分析 实现 数据库环境搭建 导入相关的jar包以及配置文件 这个问题碰到好几次了 ,就是druid.properties的问题 需要删除重新建立 别去复制内容 具体原因我也不知道为啥(找了我好久的) Servlet Service层调用dao层 dao层 index.html 注意内容的拼接 案例存在的问题 : 这里的数据是不经常发生变化的, 每一次去请求数据库耗时比较长 , 可以使用缓存解决 分析 使用缓存的方法 servlet中调用该方法 在这里给自己挖了个坑 就是之前代码出错把province中存储了”province_json”字符串 ,所以redis中是有数据的 , 一直获取不到正确的格式…. 删除数据库中的内容就好了 所以 一定要注意存储的时候province_json本来就是字符串了 别加引号 注意 使用redis缓存一些不经常发生变化的数据。 数据库的表执行 增删改的相关操作，需要将redis缓存数据删除，再次存入 在service对应的增删改方法中，将redis数据删除。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.chasingwind.top/tags/Redis/"}],"author":"ChasingWind"},{"title":"Ajax和JSON","slug":"Ajax和JSON","date":"2019-08-03T16:16:09.000Z","updated":"2021-03-04T00:44:28.632Z","comments":true,"path":"2019/08/04/Ajax和JSON/","link":"","permalink":"https://www.chasingwind.top/2019/08/04/Ajax%E5%92%8CJSON/","excerpt":"Ajax是指一种创建交互式网页应用的网页开发技术，在无需重新加载整个网页的情况下，能够更新部分网页的技术。JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。","text":"Ajax是指一种创建交互式网页应用的网页开发技术，在无需重新加载整个网页的情况下，能够更新部分网页的技术。JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。 Ajax 概念：Ajax 即“Asynchronous Javascript And XML”（异步的 JavaScript 和 XML），是指一种创建交互式应用的网页开发技术。 同步和异步：建立在客户端和服务器端相互通信的基础上 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax的特点 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 实现上面的特点就是使用异步的方式进行客户端与服务器之间的请求的 实现方式 原生JS实现方式(了解) 通过JS的方式实现异步 这里主要参考W3School 为了体现同步和异步的差别 我们让线程sleep 5秒来模拟服务器处理请求的时间 异步的情况下 当我们点击按钮之后,立即点击输入框是可以获取焦点的 同步的方式下, 当我们点击按钮之后,线程睡眠的5秒内,点击输入框无法获取焦点 jQeury实现方式 $.ajax(&#123;键值对,键值对...&#125;) jQuery文档 回调方法中的参数data是服务器返回的数据 常用的键值对 注意,每个键值对之间需要用,隔开,最后一个不用写逗号 $.get() : 用来发送get请求 语法: $.get(url, [data], [callback], [type]) : 后面3个参数是可选的 参数 url：请求路径 data：请求参数 callback：回调函数 type：服务器响应结果的类型 $.post(): 用来发送post请求 语法 : $.post(url, [data], [callback], [type]) 参数与get的相同 请求的参数data绑定在请求体中 JSON 概念 : JSON (JavaScript Object Notation, JavaScript对象表示法) 是一种轻量级的数据交换格式 在Java中,我们表示一个对象 Person p = new Person(); p.setName(&quot;zhangsan&quot;); p.setAge(23); p.setGender(&quot;男&quot;); 而在JavaScript中,我们可以用JSON来表示对象 var p = &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;; JSON的作用 可以用来表示JS对象 JSON现在多用于存储和交换文本信息,进行数据的传输 JSON 比 XML 更小、更快，更易解析。 JSON语法 基本规则 JSON数据由键值对构成 键用引号(单双都可以),也可以不使用引号 值的取值类型 数字 字符串(双引号中) 逻辑值: true/false 数组([]中) : 比如 : {“persons” : [{“name”:”zhangsan”,”age”:23},{“name”:”lisi”,”age”:23}]} JSON对象(&#123;&#125;中) null 多对键值对之间用,分割 &#123;&#125;保存对象 []保存数组 获取JSON中的数据 JSON对象.键名 JSON对象[“键名”] 数组对象[索引] 遍历 语法: for(... in ...) 对基本格式中的键值对进行遍历 对数组进行遍历 双层for循环 JSON数据和Java对象的相互转换 为什么要将数据进行转换? 因为JSON数据经常在客户端与服务器端作为数据的载体,服务器端需要将JSON中的数据取出来在程序中转换为Java对象进行使用,并且还可以将Java对象转换为JSON给客户端使用 JSON解析器 : jackson JSON数据转换为Java对象(了解) 导入jackson的jar包 创建jackson的核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 相关的方法 readValue(json字符串数据,class) Java对象转换为JSON数据 使用步骤 导入jackson的jar包 创建jackson的核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 相关的方法 writeValue(参数1 , obj) : 参数1: ​ File : 将obj对象转换为JSON字符串，并保存到指定的文件中 ​ Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 ​ OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 ​ writeValueAsString(obj) : 将obj对象转换为JSON字符串 writeValueAsString 注解(在对应的属性或者set方法上面添加注解) 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值的格式化 &gt; ![](https://blog.chasingwind.top/1564903464694.png) &gt; &gt; ---- &gt; &gt; 注解的添加 &gt; &gt; ![](https://blog.chasingwind.top/1564903502701.png) 复杂的Java对象的转换 List数组 结果就是Person的对象数组 Map : 对象的格式一致 案例 : 检验用户名是否存在当我们去注册账号的时候,往往会检查用户名是否已经存在 其实就是 当输入框离焦之后,浏览器会发送一个ajax请求给服务器去查询用户名是否已经存在,服务器会相应消息 当用户名已经存在的时候 , 服务器响应的消息 用户名不存在的时候响应的消息 前端代码 后台的代码 这里向服务器进行查询的代码进行了简化 界面 界面上的问题. 抓包已经显示了获取到了服务器响应的数据 但是页面却没有进行显示 存在的问题 响应消息中文乱码问题 在doPost中设置响应的数据的方式 问题2 : 响应回来的数据是一个字符串 而并不是当作json文件进行处理的 要想把文件作为json文件使用的话 处理方式1 : 在get方式中的type属性中设置为json 处理方式2: 设置服务器的数据的响应格式为response.setContentType(&quot;application/json;charset=utf-8&quot;); json的MIME类型是application/json 最后可用了 用户名可用的提示 用户名已存在 不可用的提示","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://www.chasingwind.top/tags/Ajax/"},{"name":"JSON","slug":"JSON","permalink":"https://www.chasingwind.top/tags/JSON/"}],"author":"ChasingWind"},{"title":"jQuery进阶","slug":"jQuery进阶","date":"2019-08-03T07:39:17.000Z","updated":"2021-03-04T00:48:43.815Z","comments":true,"path":"2019/08/03/jQuery进阶/","link":"","permalink":"https://www.chasingwind.top/2019/08/03/jQuery%E8%BF%9B%E9%98%B6/","excerpt":"jQuery是一个快速、简洁的JavaScript框架，jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。本节介绍了jQuery动画和遍历，事件绑定与切换以及一些案例。","text":"jQuery是一个快速、简洁的JavaScript框架，jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。本节介绍了jQuery动画和遍历，事件绑定与切换以及一些案例。 动画 默认显示和隐藏方式 show([speed,[easing],[fn]]) : 显示 下面的所有方法的参数都是相同的 speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，**默认是”swing”**，可用参数”linear” swing：动画执行时效果是 先慢，中间快，最后又慢 linear：动画执行时速度是匀速的 fn：在动画完成时执行的函数，每个元素执行一次。（可不写） hide([speed,[easing],[fn]]) : 隐藏 toggle([speed],[easing],[fn]) : 切换显示和隐藏 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历 js遍历 for(初始化值; 循环结束条件;步长) jQuery遍历方式 jQuery对象.each(callback) callback就是一个回调函数,其实就是一个function() 获取citys中的li的方式 this的方式的弊端就是无法获取索引 第二种方式 给回调函数传参 参数的名字随便 不一定是图中给的名字 index: 就是元素在集合中的索引 element: 就是集合中的每一个元素对象 在此方法中, function函数的返回值如果是false,那么结束循环(相当于break) function函数的返回值如果是true,那么结束循环继续下一次循环(相当于continue) 这里相当于continue的效果 $.each(object, [callback]) 这种方式与第一种方式的一个区别就是 第一种方式只能用jQuery对象进行调用 而这种方式,参数object既可以是jQuery对象也可以是js的数组对象 也称为全局遍历方式 this的方式获取值 方式2 for(..of..) : jQuery 3.0 版本之后提供的方式 对citys下的li元素进行遍历 事件绑定 jQuery标准的绑定方式 jQuery.事件方法(回调函数); focus事件 on绑定事件 , off解除绑定 on绑定事件 : jQuery对象.on(“事件名称”,回调函数); off解绑事件 : jQuery对象.off(“事件名称); 当off中没有function的时候, 是将组件上的所有事件全部解绑 事件切换 : toggle jQuery对象.toggle(事件1,事件2,….); 当单击jQuery对象对应的组件后,会依次执行事件1,事件2….直到最后一个,然后,再点击的话,又回到第一个,继续进行循环 注意：1.9版本之后, .toggle() 方法进行事件切换的功能删除,只能用于动画切换 , jQuery Migrate（迁移）插件可以恢复此功能。 案例 广告的自动显示与隐藏 需求 当页面加载完，3秒后。自动显示广告 广告显示5秒后，自动消失。 隐藏的时候 显示的时候 抽奖 界面 实现 效果图 插件 增强jQuery的功能 实现方式 $.fn.extend(object) : 对象级别的插件 增强通过jQuery获取的对象的功能 $(“#id”) 使用插件实现复选框的选中与取消选中 $.extend(object) : 全局级别的插件 增强JQeury对象自身的功能 ,调用 : $","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.chasingwind.top/tags/jQuery/"}],"author":"ChasingWind"},{"title":"jQuery基础","slug":"jQuery基础","date":"2019-08-02T07:08:15.000Z","updated":"2021-03-04T00:48:28.445Z","comments":true,"path":"2019/08/02/jQuery基础/","link":"","permalink":"https://www.chasingwind.top/2019/08/02/jQuery%E5%9F%BA%E7%A1%80/","excerpt":"jQuery是一个快速、简洁的JavaScript框架，jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。本节介绍了jQuery基础,选择器以及一些案例。","text":"jQuery是一个快速、简洁的JavaScript框架，jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。本节介绍了jQuery基础,选择器以及一些案例。 jQuery基础 概念： jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 JavaScript框架：本质上就是一些js文件,封装了js的原生代码而已 快速入门 下载jQuery 版本 版本说明 jquery-xxx.js和jquery-xxx.min.js的区别 jquery-xxx.js：开发版本。便于我们阅读，有良好的注释以及缩进 jquery-xxx.min.js：生产版本。程序中使用的，没有缩进，体积较小，加载速度更快 导入jQuery的文件 导入的是jquery-xxx.min.js 使用 jQuery对象和JS对象区别与转换 二者都可以作为数组使用,但是jQuery的使用比较方便 jQuery对象在操作的时候，更加的方便 jQuery对象和js对象方法不通用 jQuery对象和js对象的方法不通用 所以如果我们需要使用js中的方法,就需要进行转换 jQuery对象转换为js对象：jQuery对象[索引]或者jQuery对象.get(索引) 因为虽然是一个对象 ，但是本质上是一个数组 转换为js对象,从而使用js中的方法 js对象转换为jQuery对象：$（js对象） 转换为jQuery对象 使用jQuery中的方法html jQuery选择器选择器：筛选具有相似特征的元素(标签) 基本语法学习 事件绑定 入口函数 DOM文档加载完成之后才执行该函数中的代码 相当于js中的window.onload $(function())入口函数与window.onload的区别 window.onload只能定义一次,定义多次的话,后面的会将前面的覆盖 注意区别定义与调用 $(function())可以定义多次,而且不会被覆盖 样式控制 可以使用css属性来设置对象的css样式的键值对 推荐使用下面的那种,可进行检查 选择器分类 基本选择器 标签选择器（元素选择器） 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 id选择器 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 类选择器 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 并集选择器 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 需要注意的点: 并集选择器中的选择的元素需要用逗号隔开 层级选择器 后代选择器 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 子选择器 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 两者的差别 属性选择器(这里的A表示的是标签) 属性名称选择器 语法：$(&quot;A[属性名]&quot;)包含指定属性的选择器 属性选择器 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器 语法： $(&quot;A[属性名!=&#39;值&#39;]&quot;) 匹配所有不含有指定的属性,或者属性不等于特定值的元素 语法： $(&quot;A[属性名^=&#39;值&#39;]&quot;) 匹配给定的属性以某些值开始 语法： $(&quot;A[属性名$=&#39;值&#39;]&quot;) 匹配给定的属性以某些值结束 语法： $(&quot;A[属性名*=&#39;值&#39;]&quot;) 匹配给定的属性包含某些值 复合属性选择器 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器 复合属性选择器中的条件都成立的时候才会被选出来 过滤选择器 首元素选择器 语法： 元素:first 获得选择的元素中的第一个元素 尾元素选择器 语法： 元素:last 获得选择的元素中的最后一个元素 非元素选择器 语法： 元素:not(selector) 不包括指定内容的元素 偶数选择器 语法： 元素:even 偶数，从 0 开始计数 奇数选择器 语法： 元素:odd 奇数，从 0 开始计数 等于索引选择器 语法： 元素:eq(index) 指定索引元素 大于索引选择器 语法：元素 :gt(index) 大于指定索引元素 小于索引选择器 语法： 元素:lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法：元素 :enabled 获得可用元素 不可用元素选择器 语法： 元素:disabled 获得不可用元素 可用与不可用 可用选择器 初始页面 执行后 修改了其中的value值 而被标注的disabled的就不会被选中修改 不可用选择器 页面初始情况 执行后 选中选择器(单选/复选框) 语法： 元素:checked 获得单选/复选框选中的元素 选中选择器(下拉选择框) 语法： 元素:selected 获得下拉列表选中的元素，注意选取的是下拉列表中的option选项 复选框 length属性表示复选框中选中的个数 多选下拉列表 注意的一点是: 选中的是下拉列表下的option标签被选中的个数!! 当然这个前面的属性选择器写的可以更简单 jQuery的DOM操作 内容相关的操作 html()：获取/设置元素的标签体内容 比如,获取 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; –&gt; &lt;font&gt;内容&lt;/font&gt; text()：获取/设置元素的标签体纯文本内容 比如，获取 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; –&gt; 内容 val()：获取/设置元素的value属性值 页面 注意的一点就是 当设置text的时候 设置的可不仅仅是#mydiv的纯文本内容 而是#mydiv中的标签体的所有内容 删除属性 属性操作 通用属性操作(操作标签的所有属性) attr(): 获取/设置元素的属性 removeAttr():删除属性 prop():获取/设置元素的属性 removeProp():删除属性 attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 固有属性 就是在html中标签拥有的属性 比如: &lt;li&gt;标签的固有属性只有这两个 html内容 获取,设置,新增属性的值 浏览器中元素审查 checked是input标签的固有属性 所以使用prop 对class属性操作 addClass():添加class属性值 removeClass():删除class属性值 toggleClass():切换class属性 比如: 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加 second是一个class 这里是.second 类选择器 css() : 获取/设置css的属性 CRUD操作 append():父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 prepend():父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo(): 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 prependTo()： 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 初始页面 append和appendTo prepend和prependTo after():添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before():添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 after()和insertAfter() before和insertBefore remove():移除元素 对象.remove():将对象删除掉 empty():清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 remove empty 初始 结果 jQuery基础案例 隔行换色 需求 : 将数据行的奇数行背景色设置为 pink，偶数行背景色设置为 yellow 全选全不选 需要注意的一点就是 checked是属性!! QQ表情选择 这里我们需要用到jQuery中的clone() 多选下拉列表左右移动","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.chasingwind.top/tags/jQuery/"}],"author":"ChasingWind"},{"title":"Filter和Listener","slug":"Filter和Listener","date":"2019-08-01T07:42:19.000Z","updated":"2021-03-04T00:45:59.584Z","comments":true,"path":"2019/08/01/Filter和Listener/","link":"","permalink":"https://www.chasingwind.top/2019/08/01/Filter%E5%92%8CListener/","excerpt":"Fliter和Listener分别是Java Web中的过滤器和监听器, 在开发的过程中,结合Servlet在一起,他们三个被称为Java Web的三大组件。","text":"Fliter和Listener分别是Java Web中的过滤器和监听器, 在开发的过程中,结合Servlet在一起,他们三个被称为Java Web的三大组件。 Filter(过滤器) Web中的过滤器 ：当访问服务器的资源的时候，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的作用： 一般用于完成一些通用的操作。 比如说登录验证，去访问多个资源，但这些资源只有在你登陆的情况下你才能去访问，如果没有过滤器的话，每个页面都需要进行判断用户是否已经登录了，所以我们可以使用过滤器，将登录的要求放在里面 设置编码 敏感字符的过滤，好熟悉的操作，那年我还是个王者，直到被禁了言…… 快速入门 步骤 定义一个类,实现接口Filter(javax.servlet包中的) 重写方法 配置拦截路径，就是我们访问什么样的资源才会被过滤器拦截 配置 web.xml 注解 这里的注解配置的路径是所有的资源路径 jsp页面内容 在浏览器中并没有显示index.jsp的内容 , 在控制台输出了doFilter()中的内容 说明当我们去访问index.jsp资源的时候,被过滤器拦截了 放行 过滤器的重要的操作 : 符合条件的就放行 结果 页面显示了index.jsp的内容 说明我们访问成功了 也就是说被放行了 过滤器的细节 web.xml配置过滤器 过滤器执行过程 放行之前的代码→通过放行之后访问到的资源→放行之后的代码 一般我们是在放行之前对request对象的请求数据进行增强 在放行之后对response对象的响应消息进行增强 过滤器生命周期方法 init：服务器启动之后,会创建Filter对象,执行init方法 ，只执行一次。我们一般用于加载资源 doFilter：每一次请求被拦截的时候都会执行 ，可执行多次 destory：在服务器关闭之后,Filter对象被销毁，服务器正常关闭,就会执行destory方法 只执行一次。我们一般用于释放资源 过滤器配置详解 拦截路径的配置 具体资源路径：/index.jsp 只有访问index.jsp资源的时候,才会执行过滤器 目录拦截：/user/ 访问路径为/user下的所有资源的时候,都会执行过滤器 后缀名拦截：*.jsp 访问所有的后缀名为.jsp的资源的时候，过滤器都会被执行 拦截所有的资源：/* 访问所有的资源的时候,过滤器都会被执行 请求方式拦截的配置：资源被访问的方式，比如对直接进行资源访问的请求进行过滤，而不对因转发访问到的资源进行过滤 注解配置 设置注解中的dispatcherTypes属性 REQUEST：默认值，浏览器直接请求资源 配置注解中的dispatcherTypes为REQUEST属性的时候, 我们直接请求index.jsp的时候,过滤器被执行了 而通过转发的方式访问的index.jsp并没有被拦截 控制台没有输出”执行了过滤器” FORWARD：转发访问资源 配置注解中的dispatcherTypes为FORWARD属性的时候 我们直接访问index.jsp,可见控制台输出并没有显示执行了过滤器 而我们通过转发的方式访问index.jsp的时候 执行了过滤器 因为存放dispatcherTypes的属性值是一个数组的形式,所以可以配置多种属性值 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 在web.xml中进行dispatcher属性值的设置 过滤器链（配置多个过滤器） 过滤器的执行顺序：如果有多个过滤器的话 执行顺序如图所示 过滤器的先后 上面过滤器的执行顺序有一个疑问就是? 为什么我们没有设置过滤器的先后,执行的是5在前,6在后;而不是6在前,5在后? 注解配置：按照类名的字符串比较规则比较，值小的先执行 AFilter和BFilter相比 ，AFilter先执行 web.xml配置：&lt;filter-mapping&gt;谁定义在前面谁先执行 案例1：登录验证 需求 访问之前的用户信息的资源。验证其是否登录 如果登录了，则直接放行。 如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”。 分析 实现 当我们过滤的与登陆相关的资源仅仅有图片中的资源的时候 页面显示是这样的 所以 ,需要将各种css,js,fonts还有验证码等等与登录相关的资源全部都进行过滤 那么这个时候的界面是这样的 并且你在未登录的情况下去访问其他页面 会被拦截回到登录界面 这里因为是转发forward的形式,所以地址栏中的url并没有改变 案例2：敏感词过滤 需求 对之前的案例录入的数据进行敏感词汇过滤 如果是敏感词汇，替换为 *** 分析 因为过滤之前的request对象和过滤之后的request对象是同一个对象，但是request中只有getParameter方法来获取请求消息中的值，并没有setParameter方法来设置值，所以我们需要一个新的request对象 增强对象的功能 设计模式中的装饰模式和代理模式都可以用来增强对象的功能 代理模式 概念：代理对象代理真实对象，达到增强真实对象的目的 实现方式：两种实现方式的区别就在于代理对象的生成方式 静态代理：在一个.java文件中描述代理模式 动态代理：在内存中形成代理类 动态代理的实现步骤 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance(); 使用代理对象调用方法 增强方法 动态代理的基本实现 以上面的卖电脑为例 接口 真实类实现接口重写方法 这是普通的方法调用 我们用动态代理来增强对象 这里是基本的用法 实际的增强的操作是在invoke方法中来实现的 invoke方法来进行方法增强的增强方式 代理对象其实没有真实对象的功能,他只是调用接口中的方法,然后通过invoke方法中,去调用真实对象中的方法,并且可以在此同时来增强方法 首先必须需要明确的一点的是：代理模式需要我们站在代理的角度来考虑问题 增强参数列表 在代理对象中是没有具体的方法的,他需要去调用真实对象的对应的方法 比如,上面的卖电脑 用户拿5000买电脑(通过代理proxy_lenove.saleComputer(5000)方法)买电脑),代理商拿4250去买联想公司的电脑(method.invoke(lenovo,money)) 增强返回值 在上面的卖电脑的方法中 返回值return &quot;联想电脑&quot; 可以通过代理商 来增强返回值 增强方法体的执行逻辑 可以在方法的执行前后进行操作逻辑的编写 实现 在这里需要注意的是 放行的时候的参数是增强后的req 注意文件的编码 默认的是GBK编码 Listener(监听器) 概念：Web的三大组件之一 事件监听机制： 事件：一件事情 事件源：事件发生的地方 监听器：一个对象 注册监听：将事件，事件源，监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码,，也就是配置 比如,一个按钮（事件源）注册一个单击事件（事件）来执行一个function函数（监听器） ServletContextListener：监听ServletContext对象的创建和销毁 方法： void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 步骤： 定义一个类，实现ServletContext接口 重写其中的方法 配置 web.xml 注解 创建类实现接口，重写方法 配置 一般我们可以用来加载资源文件 在服务器一启动就进行加载 这样的文件一般是全局文件 比如 我们加载src目录下的fileContext.xml文件 getInitParameter的参数需要在web.xml文件中进行配置 这样的话 以后需要添加其他的新的文件的话 就可以在这里进行文件的添加 注解的形式进行配置的话 在类的上面直接添加注解就行了","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Fliter","slug":"Fliter","permalink":"https://www.chasingwind.top/tags/Fliter/"},{"name":"Listener","slug":"Listener","permalink":"https://www.chasingwind.top/tags/Listener/"}],"author":"ChasingWind"},{"title":"JSP,EL,JSTL,三层架构(重点)","slug":"JSP-EL和JSTL","date":"2019-07-28T06:00:12.000Z","updated":"2021-03-04T00:48:56.731Z","comments":true,"path":"2019/07/28/JSP-EL和JSTL/","link":"","permalink":"https://www.chasingwind.top/2019/07/28/JSP-EL%E5%92%8CJSTL/","excerpt":"这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要","text":"这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 JSP指令 作用：用于配置JSP页面，导入资源文件 格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; 分类 page：配置JSP页面的 contentType：等同于response.setContentType() 设置响应体的MIME类型以及字符集 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包，写java代码的时候,导包的内容 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exception false：否。默认值。不可以使用内置对象exception include：导入其他的页面，用于当一些页面的部分内容相同的的时候，直接将这些相同的内容写到一个jsp中，其他页面直接包含这个jsp。 taglib：导入资源，一般用来导入标签库 prefix表示的是标签库的前缀 jstl一般用c表示 注释 html注释 &lt;!-- --!&gt;：只能注释html代码片段 jsp特有注释（推荐使用） &lt;%-- --%&gt;：可以注释所有的jsp的内容 使用html注释的内容，服务器还是会将注释过的内容发送给浏览器，只不过浏览器不解析，而jsp注释的内容，服务器就不会发送给浏览器 内置对象 在jsp页面中不需要创建，直接使用的对象 jsp中的内置对象一共有9个： 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源之间(转发) response HttpServletResponse 响应对象 session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据（最大的域对象） page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 MVC：开发模式 JSP演变历史 早期只有Servlet,只能使用response输出标签数据,非常麻烦 后来有了JSP,简化了Servlet的开发,如果过度使用jsp，在jsp中既写大量的java代码，又写html表，难于维护，难于分工协作的弊端 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC开发模式 M：Model,模型（JavaBean）: 完成具体的业务操作，如：查询数据库，封装对象 V：View,视图（JSP） : 展示数据 C：Controller,控制器（Servlet）: 获取用户的输入,调用模型,将数据交给视图进行展示 优缺点 优点：耦合性低，方便维护，可以利于分工协作，重用性高 缺点：使得项目架构变得复杂，对开发人员要求高 EL表达式 概念：Expression Language 表达式语言 作用：替换和简化JSP页面中Java代码的编写 语法：$&#123;表达式&#125; 注意：JSP默认是支持EL表达式的 JSP会直接将结果展示 \\可以告诉浏览器不解析,从而让他原样展示 当在page里面配置isELIgnored为true的时候,全局不解析EL表达式,原样展示 使用 运算 运算符 算术运算符：+ - * /(div) %(mod) 比较运算符：&gt; &lt; &gt;= &lt;= == != 逻辑运算符：&amp;&amp;(and) ||(or) !(not) 空运算符：empty 功能：用于判断字符串，集合，数组对象是否是null或者长度是0 比如 : $&#123;empty list&#125;,取反 $&#123;not empty list&#125; 获取值 EL表达式只能从域对象中获取值 语法： $&#123;域名称.键名称&#125;：从指定域中获取指定键的值 域名称 比如：在request域中存储了username=zhangsan 获取：${requestScope.username} 注意最后一个,当键名称不存在的时候,会用空字符串来代替 $&#123;键名&#125;:表示依次从最小的域中查找是否有该键对应的值,直到找到为止 获取对象,List集合,Map集合的值 对象: $&#123;域名称.键名.属性名&#125;,实质上会去调用对象的对应属性的get方法 获取对象中的属性值,只要有对应的Get方法,就有对应的属性值,如果填写的属性值不存在的话,页面会报错的 使用时间 如果要实现时间的格式化? 在User中写getBir() 在jsp中调用,一定要注意属性名第一个字母要小写 List集合:$&#123;域名城.键名[索引]&#125; 下标越界则会显示的是空字符串 list[2]表示的就是list集合中下标为2的数据, 这里就是user对象 然后化成获取对象的操作 Map集合:$&#123;域名称.键名.key&#125; 或$&#123;域名称.键名[&quot;key名&quot;]&#125;: 获取map集合中键对应的值 隐式对象: EL表达式中不用创建就可以直接使用 EL隐式对象中有11个隐式对象 pageContext: 获取其他8个内置对象 JSTL标签 概念 : JavaServer Pages Tag Library , JSP标准标签库 Apache组织提供的开源的免费的JSP标签 作用: 用于简化和替换JSP页面上的Java代码 使用步骤 导入JSTL相关的jar包 引入标签库 : taglib属性, &lt;%@taglib %&gt; 使用标签 常用的JSTL标签 if :相当于java中的if语句,他没有else if标签必须有的属性是test,其中用来存放条件表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 choose : 相当于java中的switch语句 choose标签相当于switch when标签相当于case otherwise标签相当于ddefault foreach : 相当于java中的for语句 完成重复操作 属性 begin : 开始值（包含） end : 结束值（包含） var ：临时变量 step：步长 varStatus: 循环状态对象 index:容器中元素的索引 count: 循环次数,从1开始 遍历容器 三层架构:软件设计架构 界面层(表示层): 用户看到的界面, 用户可以通过界面上的组件和服务器进行交互 业务逻辑层(控制层): 处理业务逻辑. 数据访问层(持久层) : 操作数据存储文件 ※※※※※※※※※※※※※※※※ 超 级 重 点 ※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※ 用户信息的列表展示 需求 : 用户信息的增删改查操作 设计: 技术选型 : Servlet + JSP + MySQL + Tomcat 数据库的设计 开发 环境搭建 创建数据库环境 创建项目,导入jar包 编码 测试 部署运维 环境搭建 创建数据库环境 创建项目,导入jar包 导入页面内容 编码 列表查询功能的实现 创建包 JavaBean 首页改造,将index.html内容复制到index.jsp中 修改跳转的路径到UserListServlet 创建UserListServlet 根据分析,第一步需要调用service层的findAll() 所以,创建UserService接口 以及他的实现类 UserService接口 UserServiceImpl实现类 UserService需要调用dao完成查询 所以,创建UserDao接口以及他的实现类 UserDaoImpl实现类 在这里编写使用JDBC操作数据库 以上代码先不写,先完成UserListServlet中的逻辑 首先,将dao的结果返回给UserServiceImpl,将结果返回给Servlet 然后,根据分析,在Servlet中完成对应的逻辑 将结果转发到jsp页面(request.getRequestDispatcher(&quot;跳转到的jsp页面&quot;)) 在后面的jsp页面中获取数据并进行数据的填写 完成DAO层的操作 将druid的配置文件放在src目录下 导入JDBCUtils工具类 编写代码 接下来就是在list.jsp页面进行数据的展示 首先,创建list.jsp 之后便是用EL和JSTL遍历查询到的List集合中的数据展示在页面上 这个时候已经完成了查询的功能 检查跳转的页面是否正确, 删除无用的html文件","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://www.chasingwind.top/tags/JSP/"},{"name":"EL","slug":"EL","permalink":"https://www.chasingwind.top/tags/EL/"},{"name":"JSTL","slug":"JSTL","permalink":"https://www.chasingwind.top/tags/JSTL/"},{"name":"MVC","slug":"MVC","permalink":"https://www.chasingwind.top/tags/MVC/"},{"name":"三层架构","slug":"三层架构","permalink":"https://www.chasingwind.top/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"}],"author":"ChasingWind"},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2019-07-25T09:43:50.000Z","updated":"2021-03-04T00:44:52.764Z","comments":true,"path":"2019/07/25/Cookie和Session/","link":"","permalink":"https://www.chasingwind.top/2019/07/25/Cookie%E5%92%8CSession/","excerpt":"Cookie和Session分别是客户端会话技术和服务端会话技术，Cookie是将请求的会话数据存储到客户端，而Session则是将数据存储到服务器端。","text":"Cookie和Session分别是客户端会话技术和服务端会话技术，Cookie是将请求的会话数据存储到客户端，而Session则是将数据存储到服务器端。 会话技术 概念：在一次会话中，包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开，会话结束。 功能：在一次会话的范围内（多次请求与响应之间）的多次请求间，共享数据（区别Http的请求与响应，是在域中共享数据,比如request域,servletContext域，是在某一次的请求与响应之中） 方式： 客户端会话技术：Cookie，把数据存储到客户端 服务器端会话技术：Session，把数据存储到服务器端 Cookie 概念：客户端会话技术，将数据保存到客户端 快速入门 使用步骤 创建Cookie对象，绑定数据 Cookie类中：new Cookie(String name, String value) 通过服务器端的响应response，将Cookie对象发送到客户端 HttpServletResponse接口中：response.addCookie(Cookie cookie) 浏览器获取Cookie，通过request拿到数据：如果浏览器继续访问其他资源的话，浏览器的请求会自动将Cookie携带给服务器 HttpServletRequest接口中：Cookie[] request.getCookies() CookieServletDemo1 CookieServletDemo2 先访问Demo1打开会话 这样Cookie携带的信息就传递到了客户端存储起来了,再访问Demo2 就可以获取到之前存储在客户端的Cookie信息 ,在浏览器显示的结果是 就是我们发送的数据 但是注意的一点就是 我们没有请求转发(forward)也没有重定向(redirect),两个Servlet之间并没有直接的联系 但是也是可以进行数据的传递的 但是你在新的浏览器中直接访问Demo2 是不会有数据的 因为他们不在同一个会话中 实现原理 基于响应头set-cookie和请求头cookie实现 访问Demo1 服务器端会通过Set-Cookie: message=helloCookie 将Cookie发送到浏览器端 访问Demo2 浏览器会携带Cookie: message=helloCookie 去请求服务器端 cookie的细节 一次可不可以发送多个cookie? 可以 创建多个cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，Cookie是存储在浏览器的内存中，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge（int seconds） 参数为正数 ：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 当参数是正数的时候 比如这里的setMaxAge(60)表示的含义有: 1 . 将cookie持久化存储到内存中 2 . cookie的存活时间是60s 关闭浏览器再重新打开浏览器访问Demo2的时候(60s内),控制台输出了cookie的数据 时间超过60s,再去访问Demo2的时候,控制台不会输出数据,说明cookie已经被删除了 cookie能不能存中文？ 在Tomcat8之前不支持中文数据 将中文进行转码–一般用的是URL编码 Tomcat8之后支持中文数据，但是对于特殊字符还是不支持，建议使用URL编码和URL解码进行编解码 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie是不共享的 Cookie类中的方法： setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 不同的tomcat服务器间cookie共享问题？ setDomain（String path）：如果设置一级域名相同，那么多个服务器之间cookie可以共享 比如：setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 特点 cookie存储数据在客户端浏览器， 这样相比在服务器中存储不安全 浏览器对于单个cookie的大小有限制，以及同一域名下的总cookie数量也有限制 作用： cookie一般用于存储少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 比如：百度首页的个性化设置，不登录的情况下也是可以进行设置的，当你退出重新进浏览器的时候 ，这些设置还在生效，也就是说这些设置存储在cookie中，你去请求百度页面的时候，会将这些cookie携带过去,百度服务器会根据cookie的信息对你的页面进行个性化的展示 Cookie案例:记住上一次的访问时间 需求： 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 分析： 可以采用Cookie来完成 在服务器端的Servlet判断是否有一个名为lastTime的cookie 有：说明不是第一次访问 响应数据：欢迎回来，你上次访问的时间是2019年7月25日22:05:27 写回cookie：lastTime=2019年7月25日22:05:32 没有：是第一次访问 响应数据：您好，欢迎访问本站 写回cookie：lastTime=2019年7月25日22:06:10 实现 注意的问题：时间格式中的特殊字符Tomcat还是不支持的，这里需要进行URL编解码 Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门 获取HttpSession对象 HttpSession session = request.getSession(); 使用HttpSession对象 Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) SessionServletDemo1 用来存储数据 这里是第一次获取Session 因为之前没有进行存储 也就是说在服务器端是没有Session的, 所以就会创建一个新的Session(服务器帮我们创建) 并存储数据 然后响应给客户端(通过set-cookie:JSESSIONID=xxxx) 客户端存储下这个Cookie SessionServletDemo2 在访问的过程中会通过cookie头携带JESSIONID去请求服务器 这样的话 我们就可以通过request,getSession获取到Session对象了 通过对比JESSIONID就可以知道是同一个Session了 先通过SessionServletDemo1 请求,再通过SessionServletDemo2请求 在控制台输出了共享的数据 将浏览器断开再去访问SessionServletDemo2,控制台没有输出,说明共享数据是在一次会话间的多次请求数据中 控制台的输出为null , 说明并没有获取到数据 Session原理 Session的实现是依赖于Cookie的 在两个服务中都创建了Session对象，其实他们是同一个对象。那么服务器是怎样来判断这两次的Session对象是同一个的呢？ Session的细节 当客户端关闭后，服务器不关闭，两次获取的是不是同一个Session？ 默认情况下不是同一个，因为客户端关闭后，一次会话就结束了，那么Cookie默认下是会被清除的,也就是说响应中的Set-cookie中携带的JSESSIONID就被清除了，那么再去请求的时候，携带的JSESSIONID就不再是之前的那一个了，也就不再是同一个Session了。 第一次请求之后,关闭浏览器,再重新打开浏览器请求,发现获取的Session并不是同一个 通过理解Session的原理，我们将Session的ID封装在响应头中通过Cookie发送到客户端并设置一定的存活时间 可见,这两次获取的是同一个Session 当客户端不关闭，服务器关闭后(或者不是在同一次会话中的情况,比如你在浏览购物车,之后杀后台,但是这个购物车的数据还在)，两次获取的是不是同一个Session对象？ 不是同一个，但是要确保数据不丢失，Tomcat已经帮我们完成这个功能 Session的钝化：在服务器正常关闭之前，将Session对象序列化到硬盘上 Session的活化：在服务器启动后，将Session文件转化为内存中的Session对象即可 当服务器正常关闭的时候，本地的Tomcat会将Session对象序列化到硬盘上，当服务器正常启动之后，这个序列化文件会被Tomcat自动读取并将本地文件删除，并将之前的Session对象还原到内存中，虽然这两次的Session的地址值不同，也就是说这两个Session不是同一个对象，但是这两次的Session的ID是相同的，这样就确保了数据不会丢失 IDEA会完成Session的钝化，但是活化的时候，会将存放Session的Work目录先删除，再新建一个Work目录，这样就不能读取倒这个序列化文件了，也就不能确保数据一样了 Session什么时候被销毁？ 服务器关闭 Session对象调用HttpSession中的invalidate()方法自杀 Session的默认失效时间是30分钟，可以在web.xml中配置 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; Session的特点 Session用于存储一次会话的多次请求的数据,存储在服务器端 Session可以存储任意类型,任意大小的数据 Session与Cookie的区别 Session存储数据在服务器端，Cookie在客户端 Session没有数据大小限制，Cookie有 Session数据安全，Cookie相对于不安全 Session案例:验证码 需求 访问带有验证码的登录页面login.jsp 用户输入用户名，密码以及验证码。 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 分析 实现 JSP：入门学习JSP入门 概念：JSP=Java Server Pages：Java服务器端页面，可以理解为一个特殊的页面，其中既可以定义html标签，又可以写Java代码 作用:简化书写，页面中有一部分是需要用Java代码从服务器中来获取动态生成（writer（）方法），有一部分是静态的HTML页面 JSP原理：JSP本质上就是一个Servlet Tomcat下的work目录中存放的是运行时产生的一些文件,其中放的就是.jsp生成的.java和.class文件 .java文件中可以看到他继承自HttpJspBase 在Tomcat的源码中,可以发现HttpJspBase继承自HttpServlet 在他的service方法中,输出页面标签的工作JSP回来帮我们完成 JSP的脚本：JSP定义Java代码的方式 &lt;% Java代码%&gt;：定义的Java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 在jsp转换后的java文件中的位置是在_jspService方法中 &lt;%! Java代码%&gt;：定义的是成员变量或者成员方法，在转换后的jsp的类的成员位置 转换后的jsp文件中的位置是在成员变量的位置 &lt;%= Java代码%&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 转换后的jsp JSP的内置对象 在jsp页面中不需要获取和创建,就可以直接使用的对象 request和out这两个对象,没有创建就直接使用 对应在jsp.java中的位置 因为这两个对象在jsp的.java中的service中都有声明 JSP一共有9个内置对象 今天学习3个： request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 以后直接用out输出就行了,以免打乱页面的数据","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"Cookie","slug":"Cookie","permalink":"https://www.chasingwind.top/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://www.chasingwind.top/tags/Session/"},{"name":"JSP","slug":"JSP","permalink":"https://www.chasingwind.top/tags/JSP/"}],"author":"ChasingWind"},{"title":"Http响应协议和Response","slug":"Http响应协议和Response","date":"2019-07-24T13:46:47.000Z","updated":"2021-03-04T00:47:14.068Z","comments":true,"path":"2019/07/24/Http响应协议和Response/","link":"","permalink":"https://www.chasingwind.top/2019/07/24/Http%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%92%8CResponse/","excerpt":"Response对象用于动态响应客户端请示，控制发送给用户的信息，并将动态生成响应。Response对象只提供了一个数据集合cookie，它用于在客户端写入cookie值。若指定的cookie不存在，则创建它。若存在，则将自动进行更新。结果返回给客户端浏览器","text":"Response对象用于动态响应客户端请示，控制发送给用户的信息，并将动态生成响应。Response对象只提供了一个数据集合cookie，它用于在客户端写入cookie值。若指定的cookie不存在，则创建它。若存在，则将自动进行更新。结果返回给客户端浏览器 HTTP协议 请求消息：客户端发送给服务器端的数据 数据格式 请求行 请求头 请求空行 请求体 响应消息：服务器端发送给客户端的数据 数据格式 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 状态码都是3位数字 分类 1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。代表：404（请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 response.setContentType(String MIME)的作用是使客户端浏览器，区分不同种类的数据，并根据不同的MIME调用浏览器内不同的程序嵌入模块来处理相应的数据。例如web浏览器就是通过MIME类型来判断文件是GIF图片。通过MIME类型来处理json字符串。 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 值: in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行 响应体：传输的数据 Response对象 功能：设置响应消息 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus（int sc） 设置响应头：setHeader（String name, String value） 设置响应体： 使用步骤： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 完成重定向 重定向：资源跳转的方式 ResponseDemo1 ResponseDemo2 跳转结果 简化的重定向：因为每次重定向的状态码以及响应头location是相同的 使用sendRedirect 重定向的特点：redirect 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 路径的写法 相对路径：通过相对路径不可以确定唯一资源 如：./index.html 以.开头的路径 规则：找到当前资源和目标资源之间的相对位置关系,比较他们的绝对路径 ./:当前目录 ../:后退一级目录 绝对路径：通过绝对路径可以确定唯一资源 如：https://localhost/day15/responseDemo2 简化形式/day15/responseDemo2 以/开头的路径 规则:判断定义的路径是给谁用的？就是判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 比如 ： HTML中的标签的地址&lt;a&gt;,&lt;form&gt;,以及重定向 建议虚拟目录动态获取：request.getContextPath() 给服务器使用：不需要加虚拟目录 比如：转发的时候的资源跳转 动态获取虚拟目录 request.getContextPath() 服务器输出字符数据到浏览器 步骤 获取字符输出流 输出数据 其实也可以写标签 中文乱码的问题 原因：编码和解码使用的字符集不相同 服务器编码：输出流是response创建的 ，Tomcat默认的是ISO-8859-1 浏览器解码：默认的字符集和使用的操作系统的字符集相同中文的操作系统默认的是GBK（GBK2312扩展码）或者GBK2312 解决：在获取流对象之前设置流的默认编码与浏览器解码使用的一致 这里还存在问题的,当我们不知道流的默认编码的时候,怎么办呢? 告诉浏览器,服务器发送的消息体数据的编码,建议浏览器使用该编码进行解码 简化的形式 服务器输出字节数据到浏览器 获取字节输出流 输出数据 转换为字节 验证码 本质：就是一张图片 目的：防止恶意表单注册 生成基本的图片 生成的默认图片是这样的 美化图片 效果 使用javascript来实现验证码的切换 巧妙利用时间戳来避免浏览器不刷新!! ServletContext对象 概念：代表整个web应用，可以和程序的容器(服务器)来通信，进行数据的交互 获取 通过request对象获取 request.getServletContext(); 通过HttpServlet获取 getServletContext() 结果 可见 获取的结果是同一个对象 功能 获取MIME类型 MIME类型：在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 比如：text/html image/jpeg 作用：就是告诉客户端，服务器发送的数据类型 获取MIME类型：String getMimeType（String file） 这个方法是通过文件名来获取的MIME类型 域对象：共享数据 方法： setAttribute（String name,Object value） getAttribute（String name） removeAttribute（String name） ServletContext对象范围：所有用户所有请求的数据 获取文件的真实（服务器端路径）路径 因为我们是在编译器中编写代码,此时资源对应的位置即使工作目录中的位置,而当我们把项目发布到服务器上面的时候,我们通过浏览器进行访问,就需要知道在工作目录中的资源对应到服务器上面的资源的路径,以便我们通过浏览器进行访问. 方法 ：String getRealPath（String path） 这个目录下就是将来发布到服务器上的 工作空间文件目录 通过工作空间中的文件和getRealPath()方法获取服务器目录 文件在web目录下 文件在web目录下的WEB-INF目录下 文件在src目录下,将来在服务器上会放在WEB-INF目录下的classes目录下 在src目录下的文件还可以通过类加载器来获取 但是他不能获取web目录下的文件 所以有局限性 文件下载案例 需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 任何资源都必须弹出下载提示框 使用响应头设置资源的打开方式：content-disposition:attachment;filename=xxx 步骤： 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 定义Servlet 获取文件名称 使用字节输入流加载文件进内存 指定response的响应头： content-disposition:attachment;filename=xxx 将数据写出到response输出流 实现 html页面中href属性的填写 Servlet的编写 结果 存在的问题：中文文件名的问题 文件名变成了__.jpg 解决思路 获取客户端使用的浏览器的版本信息 根据不同的版本信息,设置filename的编码方式的不同 DownLoadUtils包根据不同的浏览器的版本进行不同编码的设置 通过工具类修改文件名 结果","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"Http协议","slug":"Http协议","permalink":"https://www.chasingwind.top/tags/Http%E5%8D%8F%E8%AE%AE/"},{"name":"Response","slug":"Response","permalink":"https://www.chasingwind.top/tags/Response/"}],"author":"ChasingWind"},{"title":"Request练习:登录页面","slug":"Request练习-登录页面","date":"2019-07-24T08:48:11.000Z","updated":"2021-03-04T00:54:33.595Z","comments":true,"path":"2019/07/24/Request练习-登录页面/","link":"","permalink":"https://www.chasingwind.top/2019/07/24/Request%E7%BB%83%E4%B9%A0-%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/","excerpt":"看似简单的登录页面,其实背后的逻辑试试有点复杂的,要用到数据库中的Druid连接池,JDBCTemplate；还有Servlet中的请求转发,数据共享等等","text":"看似简单的登录页面,其实背后的逻辑试试有点复杂的,要用到数据库中的Druid连接池,JDBCTemplate；还有Servlet中的请求转发,数据共享等等 需求用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，loggin数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 分析 步骤 创建项目，导入html页面，配置文件，jar包 一般我们会在web下的WEB-INF创建lib包来存储导入的jar包,并Add as Library 创建数据库以及表 创建Package domain , 编写User用户类 目录 创建Package util , 编写工具类JDBCUtils 创建Package dao , 编写类UserDao , 其中提供login方法 创建Package test , 进行单元测试 , 查看数据库等是否正常 Test1 Test2 创建Package web ,编写LoginServlet类 编写FailServlet和SuccessServlet类 FailServlet SuccessSevlet 填写login.html的form表单的action的属性为 ：虚拟目录 + Servlet资源路径 进行整体测试 正确的用户名和密码 错误的用户名或密码 改进：使用BeanUtils工具类，简化数据封装 在LoginServlet中,当获取的参数很多的时候 ,这样操作就很麻烦 期望就是 一次把所有的参数都获取出来 并且将他们一次封装成对象 BeanUtils的使用 BeanUtils工具类:用于封装JavaBean 什么是JavaBean? JavaBean : 标准的Java类 一般放在domain包下 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 一些概念 成员变量 就是我们声明的变量 属性：大多数情况下和成员变量是相同的 getUsername() –&gt; Username–&gt; username 但也难免出现这样的 方法： setProperty() ：设置属性值 ，而不是成员变量 参数分别是Bean对象 , 属性名,属性值 getProperty()：获取属性值 populate（Object obj , Map map）：将map集合的键值对信息，封装到对应的JavaBean对象中 把键当作属性的名称 , 值当作JavaBean对应的属性的值进行封装，会自动解析并遍历map","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"Request","slug":"Request","permalink":"https://www.chasingwind.top/tags/Request/"},{"name":"练习","slug":"练习","permalink":"https://www.chasingwind.top/tags/%E7%BB%83%E4%B9%A0/"}],"author":"ChasingWind"},{"title":"Http请求协议和Request","slug":"Http请求协议和Request","date":"2019-07-22T15:08:22.000Z","updated":"2021-03-04T00:46:59.779Z","comments":true,"path":"2019/07/22/Http请求协议和Request/","link":"","permalink":"https://www.chasingwind.top/2019/07/22/Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CRequest/","excerpt":"Request用来取出请求信息，Request对象是服务器对浏览器请求的封装。本节介绍了Request的基本原理以及其中一些常用的方法，并且利用所学的知识进行登录案例的实现。","text":"Request用来取出请求信息，Request对象是服务器对浏览器请求的封装。本节介绍了Request的基本原理以及其中一些常用的方法，并且利用所学的知识进行登录案例的实现。 HTTP请求协议概念HTTP : Hyper Text Transfer Protocol 超文本传输协议 传输协议 : 定义了客户端和服务器端通信时，发送数据的格式 HTTP 协议特点 : 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型 : 一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本 1.0：每一次请求响应都会建立新的连接 1.1：复用连接 每次请求响应之后不会立即将连接断开,而是等一会,如果有新的请求,就会复用刚才的连接;如果没有请求,就会释放连接 请求消息的数据格式 请求行 格式 : 请求方式 请求url 请求协议/版本 请求方式 : HTTP协议有7种请求方式，常用的有2种 GET : 请求参数在请求行中，在URL后。 请求的URL长度有限制的 不太安全 POST : 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求URL GET后面可能会有请求的数据 POST后面不会有请求的数据 请求头 : 客户端浏览器告诉服务器一些信息 格式 : 请求头名称: 请求头值 常见的请求头 Host : localhost 表示请求的主机是localhost User-Agent : …. 浏览器告诉服务器 , 我访问你使用的浏览器的版本信息 作用就是在服务器端获取该头的信息 , 解决浏览器的兼容问题 Accept : … 告诉服务器,我作为浏览器可以接受什么样的信息格式 Referer : http://localhost:8080/hello.html 告诉服务器,当前请求从哪里来 作用 : 1.防止别人盗取连接 , 2.统计工作 Connection : keep-alive 表示连接可以被复用 请求空行 空行 ,就是用于分隔POST请求的请求头，和请求体的。 请求体（正文） &lt;POST方式有请求体 GET方式没有请求体&gt; 封装POST请求消息的请求参数的 POST方式的请求体 就是我们提交的表单数据 username=zhangsan 而 GET方式是没有请求体的 提交的数据会在请求行中 注 : 这里有个大坑就是 注释掉doXxx()中的super.doXxx(),不然405错误 RequestRequest原理 Request对象和Reponse对象 request原理 request对象和response对象的原理 Request对象和Response对象是由服务器创建的。我们来使用它们 Request对象是来获取请求消息，Response对象是来设置响应消息 request对象继承体系结构 ServletRequest – 接口 ———-↑ 继承————- HttpServletRequest – 接口 ———-↑ 继承————– org.apache.catalina.connector.RequestFacade 类 (tomcat实现 ,将来tomcat通过这个类创建request对象,并传递给service方法) request功能获取请求消息数据获取请求行数据GET /day14/demo1?name=zhangsan HTTP/1.1 方法 : 获取请求方式 ：GET String getMethod() 获取虚拟目录 : /day14（重点） String getContextPath() 获取Servlet路径 : /demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQueryString() 获取请求URI：/day14/demo1 （重点） String getRequestURI(): /day14/demo1 StringBuffer getRequestURL() : https://localhost/day14/demo1 获取协议及版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr() 输入的URL 结果 URL : 统一资源定位符 https://localhost:8080/Servlet/servletDemo1 URI : 统一资源标识符 /Servlet/servletDemo1 URI的范围比URL的范围大 获取请求头数据 String getHeader(String name):通过请求头的名称获取请求头的值（重点） Enumeration getHeaderNames():获取所有的请求头名称 结果 获取请求体数据 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤 : 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 结果 html页面 其他的功能获取请求参数通用方式 : 不论get还是post请求方式都可以使用下列方法来获取请求参数&lt;ServletRequest类中的方法&gt; String getParameter(String name) : 根据请求消息中的请求参数名称获取请求参数值 比如 ： 对于username=zs&amp;password=123 参数为username 返回zs 代码 post方式的html 结果 get方式 结果 可见 ,doPost和doGet中的代码是一样的 所以我们可以进行简化 String[] getParameterValues(String name):根据参数名称获取参数值的数组 比如 : hobby=xx&amp;hobby=game , 参数为hobby，返回xx和game。多用于复选框 结果 复选框中勾选的都会显示 Enumeration getParameterNames():获取所有请求的参数名称 这样的话 可以通过这个参数名获取值 注意一点的是: getparameter获取的结果是String,而不是数组,在复选框中只会显示一个结果 Map&lt;String,String[]&gt; getParameterMap() : 获取所有参数的map集合 注意: 这里的键是String类型的,值是String[] 这样就解决了上面的通过getParameter获取的结果只有一个的问题 中文乱码问题 get方式下 : Tomcat 8 已经将get方式乱码问题解决了 post方式：会乱码 解决 ： 在获取参数前，设置request的编码。request.setCharacterEncoding(“页面的编码方式”); 请求转发：一种在服务器内部的资源跳转方式 步骤 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 这里的参数path就是转发的目的地 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) ServletDemo3 ServletDemo4 结果 ,我们在浏览器中访问的是/servletSDemo3 控制台的结果 不仅有Demo3还有Demo4 特点 这里的转发可以发现,当资源跳转的时候,浏览器的地址栏路径并未发生改变 转发之后的路径只能是当前服务器的内部资源 , 不能是外部资源（比如 ： www.baidu.com） 转发过程中,只对服务器有一次请求，尽管在资源之间进行跳转多次 共享数据 域对象 ：一个有作用范围的对象，可以在范围内共享数据 request域 ：代表一次请求的范围（多个Servlet之间），一般用于请求转发的多个资源中共享数据 方法 ： void setAttribute(String name,Object obj):存储数据 Object getAttitude(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 ServletDemo3中存储数据到resquest域 ServletDemo4通过键来获取值 结果 访问Demo3跳转到Demo4 其中Demo4也获取到Demo3的共享的数据 ServletContext域 作用范围 : 整个webApps内的一个应用程序范围。也就是说Request域只能由相应的Requset访问（别的request不能访问），而ServletContext可以由该应用程序下的所有Servlet和Request访问，所以它的作用是实现数据的共享。共享的数据一般为该应用程序共同使用的数据，例如数据库的url，密码，用户名等等。 获取ServletContext ServletContext getServletContext() : 返回Context对象","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"Request","slug":"Request","permalink":"https://www.chasingwind.top/tags/Request/"},{"name":"Http协议","slug":"Http协议","permalink":"https://www.chasingwind.top/tags/Http%E5%8D%8F%E8%AE%AE/"}],"author":"ChasingWind"},{"title":"Servlet及其相关配置","slug":"Servlet及其相关配置","date":"2019-07-22T03:55:54.000Z","updated":"2021-03-04T00:54:43.134Z","comments":true,"path":"2019/07/22/Servlet及其相关配置/","link":"","permalink":"https://www.chasingwind.top/2019/07/22/Servlet%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"Server Applet , 运行在服务器端的小程序，Servlet就是一个接口，定义了Java类被浏览器访问到（或者说是被Tomcat识别）的规则。","text":"Server Applet , 运行在服务器端的小程序，Servlet就是一个接口，定义了Java类被浏览器访问到（或者说是被Tomcat识别）的规则。 Servlet概念 Servlet : Server Applet , 运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到（或者说是被Tomcat识别）的规则。 将来我们自定义一个类，实现Servlet接口，重写其中的方法, 从而被Tomcat识别,那么这个类就是Servlet Java EE7文档 快速入门 创建Java EE项目 定义一个类,并实现Servlet接口 实现接口中的抽象方法 配置Servlet 因为访问的时候是通过URL进行访问的,也就是需要将这个类映射到访问路径 在web.xml文件中进行配置 结果 浏览器页面没有内容 每次刷新浏览器 都会在控制台显示 说明这个方法被调用了 Servlet的执行原理 当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则在找到对应的&lt;servlet-class&gt;全类名 Tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet中的生命周期（方法） 被创建 : 执行init方法 , 只执行一次 Servlet什么时候被创建? 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 在&lt;servlet&gt;标签下配置&lt;load-on-startup&gt; 第一次被访问时，创建 &lt;load-on-startup&gt;的值为负数,其实我们不写这个标签的话 默认值就是-1 第一次被访问才会执行 在服务器启动时，创建 &lt;load-on-startup&gt;的值为0或正整数 Servlet中的的init()方法，只执行一次，说明一个Servlet在内存中只存在一个对象，也就是说Servlet是单例的 多个用户同时访问的时候, 可能存在线程安全问题 解决方案 : 尽量不要在Servlet中定义成员变量 , 即使定义了成员变量,也不要对其进行值的修改 , 这样就不会出现并发的问题 提供服务 : 执行service()方法 , 执行多次 每次访问Servlet时，Service方法都会被调用一次 被销毁 : 执行destory方法,只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 当刷新浏览器的时候 一直执行的是service方法 , 而init还是只执行了一次 服务器正常关闭的时候执行destroy方法 getServletConfig : 获取ServletConfig对象 getServletInfo : 获取Servlet的一些信息,比如版本,作者等 Servlet 3.0 注解配置好处 : 支持注解配置 , 可以不需要web.xml了 步骤 : 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 重写其中的方法 在类上使用@WebServlet注解，进行配置 这里仅仅需要配置访问路径就行了,而全类名因为这个注解本来就在这个类里面,就不需要写了 更简单的 直接写 @WebServlet(&quot;资源路径&quot;) 注 : Java EE6之后才支持Servlet3.0 IDEA与Tomcat的相关配置 IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 查看控制台的log：Using CATALINA_BASE: …. 工作空间项目 和 Tomcat部署的web项目 Tomcat真正访问的是“Tomcat部署的web项目”，”Tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问。 断点调试：使用”小虫子”启动 debug 启动 Servlet的体系结构Servlet – 接口 ​ ↓ GenericServlet – 抽象类 ​ ↓ HttpServlet – 抽象类 GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 HttpServlet 为什么会有HttpServlet类的出现 ? 将来service方法需要从服务器中处理的事情 : 获取数据 , 但是在获取数据之前需要进行判断数据的请求方式是Post或者Get , 当我们使用GenericServlet方法的时候 , 这些判断是需要我们自己写的 , 这些我们自己写的话, 每次使用service都需要我们自己在service方法中进行编写 这样就很麻烦 HttpServlet帮我们进行了上述的判断的操作 , 并且在判断中实现了不同的doXxx()方法 所以我们只需要实现doXxx()方法就行了 HttpServlet : 对http协议的一种封装，简化操作 在HttpServlet类中的service方法中对Http的7种请求方式进行了判断 使用步骤 定义类继承HttpServlet 重写doGet和doPost方法 Servlet的相关配置 urlpartten:Servlet访问路径 一个Servlet可以定义多个访问路径,这些访问路径访问的都是同一个资源文件 ： @WebServlet（{“/d4”,”/dd4”,”/ddd4”}） 路径定义规则： /xxx：路径匹配 /xxx/xxx : 多层路径，目录结构 *.扩展名：扩展名匹配 前面不能加/,","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"Servlet","slug":"Servlet","permalink":"https://www.chasingwind.top/tags/Servlet/"}],"author":"ChasingWind"},{"title":"Tomcat","slug":"Tomcat","date":"2019-07-21T12:30:33.000Z","updated":"2021-03-04T00:56:56.072Z","comments":true,"path":"2019/07/21/Tomcat/","link":"","permalink":"https://www.chasingwind.top/2019/07/21/Tomcat/","excerpt":"","text":"复习 : 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65536 传输协议：规定了数据传输的规则 基础协议： TCP:安全协议，三次握手。 速度稍慢 UDP：不安全协议。 速度快 Web服务器软件 服务器：安装了服务器软件的计算机 服务器软件：接收用户的请求，处理请求，做出响应 Web服务器软件：接收用户的请求，处理请求，做出响应。 在web服务器软件中，可以部署Web项目，让用户通过浏览器来访问这些项目 动态资源需要借助Web服务器软件才能运行 , 所以有时候Web服务器软件也称为Web容器 常见的java相关的web服务器软件： webLogic：Oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 Java EE : Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat 下载 安装 : 解压即可 , 安装的目录建议不要有中文和空格 卸载 : 删除解压的文件夹就行 Tomcat文件目录 启动 bin/startup.bat ,双击运行该文件即可 访问 : 浏览器输入 : https://localhost:8080 访问自己 https://别人的ip:8080 访问别人 可能遇到的问题 黑窗口一闪而过 原因 : 没有正确配置JAVA_HOME环境变量 因为Tomcat纯java编写,启动和运行需要依赖电脑上的jdk ,所以正确配置JAVA_HOME 启动报错 一般是因为8080端口被占用 解决方法1 :结束占用端口的进程 netstat -ano : Cmd查看进程的端口号和对应的PID(进程ID),根据PID去任务管理器结束进程 解决方法2: 修改Tomcat的端口号 conf文件夹下的server.xml文件的默认端口号 &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口 号,这样的好处就是 : 在访问的时候 ,不需要输入端口号就可以直接进行访问 关闭 正常关闭 bin/shutdown.bat Ctrl + C 强制关闭 点击启动窗口的退出按钮 配置 部署项目的方式 : 直接将Web项目文件夹放到webapps目录下 项目的访问路径 : localhost:8080/Web项目访问路径/资源名称 , /Web项目访问路径:也称为虚拟目录 简化部署 : 将项目打包成war包,再将war包放置到webapps目录下 war包在webapps目录下会自动解压缩 方式1的问题就是Web项目只能存放在固定的位置,方式2解决的问题就是可以将Web项目放在电脑的任意位置 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;项目存放的路径&quot; path=&quot;虚拟目录&quot; /&gt; docBase:项目存放的路径 path：虚拟目录 ,也就是访问的时候的地址 方式2的配置方式很不安全 , 因为server.xml是Tomcat的整个配置文件 在conf\\Catalina\\localhost创建任意名称的xml文件。 在文件中编写&lt;Context docBase=&quot;项目存放的路径&quot; /&gt; 这里没有虚拟目录,那么该怎样访问呢&gt; 访问的时候的虚拟目录就是这个xml文件的名称 方式3也成为了热部署方式, 他不需要重启服务器就可以进行修改后的访问 静态项目和动态项目 目录结构的区别 Java动态项目的目录结构 : – 项目的根目录 – WEB-INF目录: – web.xml：web项目的核心配置文件 – classes目录：放置字节码文件的目录 – lib目录：放置依赖的jar包 将Tomcat集成到IDEA中,并且创建JavaEE的项目 , 部署项目 将Tomcat集成到IDEA中 Run –&gt; Edit Configures Temlpates–&gt;Tomcat Server–local(配置本地的Tomcat) 选择Tomcat所在的目录 创建Java EE项目 创建新项目 项目目录 : 部署项目 查看部署配置 启动项目 这里默认打开的就是localhost:8080,默认的首页就是index.jsp 访问自己的html 在web目录下创建html文件 访问的时候带上文件名 这里需要重新启动Tomcat 热部署","categories":[{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://www.chasingwind.top/tags/Java-Web/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://www.chasingwind.top/tags/Tomcat/"}],"author":"ChasingWind"},{"title":"XML","slug":"XML","date":"2019-07-21T01:24:54.000Z","updated":"2021-03-04T00:57:06.345Z","comments":true,"path":"2019/07/21/XML/","link":"","permalink":"https://www.chasingwind.top/2019/07/21/XML/","excerpt":"可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。XML被设计用来传输和存储数据,HTML被设计用来显示数据。","text":"可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。XML被设计用来传输和存储数据,HTML被设计用来显示数据。 概念 概念 : Extensible Markup Language 可扩展标记语言 可扩展 : 标签都是自定义的。 &lt;user&gt; &lt;student&gt; 功能 存储数据,作为配置文件使用 把数据存起来 , 在网络中传输 , XML是纯文本的,可以跨平台 XML与HTML的区别 xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 语法 基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 标签中的属性值必须使用引号(单双都可)引起来 标签必须正确关闭 (围堵标签或者自闭合标签) xml标签名称区分大小写 浏览器解析 组成部分 文档声明 1&lt;?xml 属性列表?&gt; 注意 : &lt;,?,xml之间不能有空格 属性列表 version：版本号，必须的属性 , 使用1.0就行了 encoding : 编码方式 , 告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 (这个一般不写) 取值 yes：不依赖其他文件 no：依赖其他文件 指令(了解) ：结合CSS的 &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 标签 : 标签名称是自定义的 规则 : 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 标签中的属性 id属性值需要唯一 文本 CDATA区：在该区域中的数据会被原样展示 格式 : &lt;![CDATA[ 数据 ]]&gt; 约束 : 规定xml文档的书写规则 作为框架的使用者(程序员)： 能够在xml中引入约束文档 能够简单的读懂约束文档 约束的分类 DTD:一种简单的约束技术 引入dtd文档到xml文档中 内部dtd：将约束规则定义在xml文档中 (不常用) 外部dtd：将约束的规则定义在外部的dtd文件中 本地 : &lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 网络 : &lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; DTD的缺陷 : 对文本内容没有限制, 即使是错误的数据 , 也是没有限制的 等价的xml文件 Schema:一种复杂的约束技术 (文件后缀名 : .xsd) 这是Schema文件 等价的XML文件 在XML中引入schema文件 1.填写xml文档的根元素 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; 2.引入xsi前缀. xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;https://www.itcast.cn/xml student.xsd&quot; //第一个值是需要使用的命名空间。第二个值是供命名空间使用的 XML schema 的位置 就是将上面声明的命名空间和相应的.xsd文件相关联 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;https://www.itcast.cn/xml&quot; // xmlns : xml namespace 起前缀 : 当一个xml被多个文件约束的时候 , 并且两个约束中有同一个标签名是的时候 用作区分 演示 像我们之前并没有起别名的话 就是默认使用的就是这个约束 Spring的schema 解析 解析 : 操作XML文档 , 将文档中的数据读取到内存中 操作XML文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析XML的方式 DOM : 将标记语言文档一次性加载进内存，在内存中形成一棵DOM树 优点 : 操作方便，可以对文档进行CRUD的所有操作 缺点 : 当文档比较大的时候,形成的树形结构太大 ,占内存 SAX : 逐行读取 , 基于事件驱动的 优点 : 基本上不占内存 缺点 : 只能进行读取 , 不能增删改 XML常见的解析器 : 根据解析XML不同的方式开发出的工具包 JAXP : SUN公司提供的解析器 , 支持DOM和SAX思想 DOM4J : 一款优秀的解析器 Jsoup : Jsoup 是一款Java 的HTML解析器，但也用在XML解析 , 可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup解析器 快速入门 导入jar包 获取Document对象 获取对应的标签(Element对象) 获取数据 Jsoup中的对象中的使用 Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse(File in, String charsetName)：解析xml或html文件的。 parse(String html)：解析xml或html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 返回值document就是字符串形式的html或者xml文档内容 Document：文档对象。代表内存中的DOM树 获取Element对象,返回值是字符串 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 结果中还有number= “s002”的信息 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 Element：元素对象 获取标签的子元素对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 通过Document对象获取的是所有的标签名为name的对象 而 Element对象是Document对象集合中的一个子对象 也就是说获取的是子对象中的标签名为name的对象 获取属性值 String attr(String key)：根据属性名称获取属性值 , 属性名不区分大小写 获取文本内容 String text():获取所有字标签的纯文本内容 String html():获取标签体的所有内容(包括子标签的标签和文本的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式 selector : 选择器 , 结合CSS里面的选择器进行比较使用 参考文档 使用的方法：Elements select(String cssQuery) Jsoup中的Selector类中的方法 返回值是Elements类型的 但是Document继承自Element 所以可以用Document来调用 XPath : XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath完成查询 : XPath语法 注意 : XPath是对DOM树结构进行操作, 也就是说,使用Document 文档对象就可以;了","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"XML","slug":"XML","permalink":"https://www.chasingwind.top/tags/XML/"}],"author":"ChasingWind"},{"title":"BootStrap","slug":"BootStrap","date":"2019-07-20T08:56:11.000Z","updated":"2021-03-04T00:44:40.189Z","comments":true,"path":"2019/07/20/BootStrap/","link":"","permalink":"https://www.chasingwind.top/2019/07/20/BootStrap/","excerpt":"BootStrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。","text":"BootStrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 BootStrap中文文档 概念 : 是一个前端开发的框架 , BootStrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 框架 : 一个半成品的软件 , 开发人员可以在框架的基础上 ,再进行开发 , 简化编码 好处: 定义了很多CSS的样式和JS插件。开发人员可以直接使用这些样式和插件得到丰富的页面效果 响应式布局 : 同一套页面可以兼容不同分辨率的设备. 快速入门 下载BootStrap 将css,fonts,js目录复制到项目中 创建HTML页面,引入必要的资源文件 Module文件列表 这里是模板文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Hello BootStrap&lt;/title&gt; &lt;!-- BootStrap --&gt; &lt;link href=&quot;css/BootStrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!--这里是对IE浏览器的支持--&gt; &lt;!--&lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;--&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- 引入jQury --&gt; &lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入BootStrap --&gt; &lt;script src=&quot;js/BootStrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 响应式布局 同一套页面可以兼容不同分辨率的设备. 实现 : 依赖于栅格系统 栅格系统 : 在所有的尺寸的显示设备中,将一行平均分成12个格子，可以指定元素占几个格子 步骤 : 定义容器 : 相当于之前的table 容器分类 : container : 两边有留白 container-fluid : 每种屏幕100%的屏幕宽度 定义行 : 相当于之前的tr 样式 : row 定义元素 : 指定该元素在不同的设备上,所占的格子数目(CSS实现) 样式 : col-设备代号-格子数目 设备代号 : xs：超小屏幕 手机 (&lt;768px)：比如 : col-xs-12 sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 当屏幕尺寸在变化的时候,每行显示的div的个数也在动态的变化 但是,无论在多大的尺寸的屏幕上,栅格系统都是将一行分为12个 注意 一行中如果格子的数目超过12的话,超出部分就会自动换行 栅格类属性可以向上兼容,也就是说如果你有3个&lt;div class=&quot;col-xs-4&quot;&gt;的话, 在手机上是这样 在pad上是这样 在电脑上是这样 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素占满一整行 当时设置的是中等屏幕大小的时候 屏幕尺寸大于992px是这样 小于992px是这样 ,占 一行 CSS样式 全局CSS样式 按钮 : class=”btn btn-自己设置” 图片 : class=”img-responsive”：图片在任意尺寸都占100% 图片形状 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框 表格 table table-bordered table-hover 表单 表单项添加：class=”form-control” 组件 导航条 分页条 插件 轮播图 JS插件","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"BootStrap","slug":"BootStrap","permalink":"https://www.chasingwind.top/tags/BootStrap/"}],"author":"ChasingWind"},{"title":"JavaScript","slug":"JavaScript","date":"2019-07-17T08:39:23.000Z","updated":"2021-03-04T00:47:54.962Z","comments":true,"path":"2019/07/17/JavaScript/","link":"","permalink":"https://www.chasingwind.top/2019/07/17/JavaScript/","excerpt":"JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎","text":"JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎 JavaScript 概念 : 一门客户端脚本语言 运行在客户端浏览器中,每一个浏览器都有JavaScript的解析引擎 脚本语言 : 不需要编译,直接就可以被浏览器解析执行了 功能 : 可以来增强用户和html页面的交互过程,可以来控制HTML元素,让页面有一些动态的效果,增强用户的体验 JavaScript发展史: 为什么会出现客户端脚本语言 ? 因为在以前我们在填写表单与服务器的交互过程中,在网络带宽的限制下体验非常差.所以发明了一种在客户端就可以进行表单校验的功能的语言 1992年,Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C– ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出JScript语言,搭载到IE浏览器上 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 所以总的来说 : JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) ECMAScript 基本语法 与HTML的结合的方式 内部JS : 在HTML内部定义一个&lt;script&gt;标签,&lt;script&gt;标签内部就是JavaScript的代码 可以将将JavaScript代码放在HTML的任意位置,但是执行的顺序跟JavaScript的放置顺序有关 这里的alert是弹出一个框, 是阻塞式的 ,不点击确定的话,就不会加载下面的内容 这里是将&lt;script&gt;放置在input的前面 点击 确定 之后 这里是将input放在script的前面 先显示这个输入框 然后出现的弹窗 外部JS : 定义script,使用它的src属性加载外部的JS文件 注意 : script标签可以定义多个,并且可以在HTML的任意位置 注释 单行注释 : //注释内容 多行注释 : /*注释内容*/ 数据类型 原始数据类型(基本数据类型) number : 数字。 整数,小数,NaN(not a number 一个不是数字的数字类型) string : 字符串 。JavaScript没有字符的概念, 单引号,双引号都可以用来定义字符串,例如 : “a” , ‘aaaaa’,”aasddd”等等,都是字符串 boolean : 布尔类型 , true和false null : 表示一个对象为空 undefined : 未定义, 就是一变量没有给初始化值,则会被默认赋值为undefined 引用数据类型 : 对象 变量 变量 : 一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言。 强类型 : 在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法 : var 变量名 = 初始化值;或者var 变量名 ;,用到的时候再赋值是一样的 可见,JavaScript中的变量是弱类型的 typeof(变量名): 可以用来查看变量的类型 运算符 一元运算符 ++ , – , +(正号), -(负号) ++(–) : 自增(自减) : ++(–) 在前，先自增(自减)，再运算 ++(–) 在后，先运算，再自增(自减) +(-)：正负号 只用来要求number类型 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）, NaN和任何数进行运算都是NaN boolean转number：true转为1，false转为0 算术运算符 + - * / % ... 因为number可以接收小数类型 赋值运算符 = += -+.... 比较运算符 &gt; &lt; &gt;= &lt;= == ===(全等于) 比较方式 类型相同：直接比较 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 类型不同：先进行类型转换，再比较 ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 逻辑运算符 &amp;&amp; || ! &amp;&amp; (与),具有短路效果 ||(或) ,具有短路效果 !(非) 其他类型转boolean： number：0或NaN为假，其他为真 string：除了空字符串(“”)，其他都是true null&amp;undefined:都是false 对象：所有对象都为true 可以运用上面的!来作为条件进行判断 这样的条件判断的效果是一样的 因为字符串只有&quot;&quot;为false 三元运算符 A ? B : C 流程控制语句 if ...else : switch 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) 在JS中,switch语句可以接收任意的原始数据类型 while do...while for JS特殊语法(了解) 语句以 ; 结尾，如果一行只有一条语句则 ;可以省略 (不建议) 变量的定义使用var关键字，也可以不使用 用： 定义的变量是局部变量 不用：定义的变量是全局变量(不建议) 练习 : 这里使用document.write(&quot;&quot;);在script中使用HTML; 基本对象 Function ： 函数(方法)对象 创建 方式1 : function 方法名称(形式参数列表)&#123; 方法体 &#125; 定义方法的时候,形式参数可以不写类型 ,因为写的话都是var类型的 方式2 : var 方法名 = function(形式参数类表)&#123; 方法体 &#125; 方法 属性 length : 形参的个数 特点 定义方法的时候,形参类型不用写,返回值类型也不用写 方法是一个对象,如果定义名称相同的方法,后面的方法会覆盖前面的方法 在JS中,方法的调用只与方法的名称有关,和参数列表无关 在方法声明中有一个隐藏的内置对象arguments(数组),封装了所有的实际参数,也就是说arguments数组中存储的是所有的实际参数 调用 方法名称(实际参数列表) Array : 数组对象 创建 var arr = new Array(元素列表); var arr = new Array(数组长度); var arr = [元素列表]; 方法 join() : 将数组中的元素按照指定的分隔符拼接成字符串 push() : 向数组的尾部添加一个或更多元素,并返回新的长度 属性 length : 数组的长度 特点 JS中,数组元素的类型是可变的 JS中,数组的长度是可变的 可见,数组中可以存储任意类型的数据 当访问的数组的下标越界的时候 ,显示的数据是undefined 当将越界的数组元素定义之后 显示数组的长度是扩展后的长度 Date : 日期对象 创建 : var date = new Date() 方法 : toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 Math : 数学对象 创建 特点：Math对象不用创建，直接使用。 Math.方法名(); 方法 random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入。 上取整 ,比x大的最小整数 floor(x)：对数进行下舍入。下取整 , 比x小的最大整数 round(x)：把数四舍五入为最接近的整数。 属性 PI : 圆周率 练习 产生1~100之间的随机整数 RegExp：正则表达式对象 正则表达式：定义字符串的组成规则。 单个字符:[ ] 如： [a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符: \\d:单个数字字符 [0-9] \\w:单个单词字符[a-zA-Z0-9_] 量词符号 ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n m如果缺省： {,n}:最多n次 n如果缺省：{m,} 最少m次 开始结束符号 开始 : ^ 结束 : $ 正则对象 : 创建 var reg = new RegExp(&quot;正则表达式&quot;); var reg = /正则表达式/; 方法 test(参数):验证指定的字符串是否符合正则定义的规范 在第一种创建的方式中,一点注意的是 \\w转义了 所以不再表达正则表达式的含义 Global : 特点 : 全局对象 , 这个Global中封装的方法不需要对象就可以直接调用。使用方法: 方法名(); 方法 : encodeURI():url编码 decodeURI():url解码 在浏览器中,索尼的编码是 %E7%B4%A2%E5%B0%BC encodeURIComponent():url编码,编码的字符更多 decodeURIComponent():url解码 URL编码 : 在浏览器的数据传输的过程中 , 需要借助协议进行传输 , 而这些协议是不支持中文字符传的,所以中文就需要先进行编码 parseInt() : 将字符串转为数字 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN():判断一个值是否是NaN NaN六亲不认，连自己都不认。所以就不能用NaN跟自己进行比较看是否相等。 NaN参与的==比较全部为false eval():将 JavaScript 字符串 转换为JavaScript代码 ，并把它作为脚本代码来执行 DOM简单学习 功能 : 控制(增删改查)html文档的内容 代码 : 获取页面标签(元素)对象：DOM中标签(元素)被封装成Element对象 document.getElementById(&quot;id值&quot;) :通过标签(元素)的id获取元素对象 操作Element对象 修改属性值 明确获取的对象是哪一个? 查看API文档 , 查看哪些属性可以设置 API:w3school 比如: &lt;img&gt;有这么多属性可以设置 修改标签体内容 属性 : innerHTML , 设置标签体的内容 注意区分 : 操作Element对象是修改标签的属性 , 而innerHTML是修改标签体的内容 事件简单学习 功能 : 某些组件被执行了某些操作后，触发某些代码的执行。 如何绑定事件? 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 事件：onclick— 单击事件 这种写法的缺点就是html代码和事件写在一起了 , 耦合度比较高 点击灯泡之后就会弹出弹窗 通过js获取元素对象，指定事件属性(操作)，设置一个函数 , 这个函数就是事件要执行的代码 注意上面的事件绑定的过程中,方法只有方法名 练习 BOM概念 BOM : Browser Object Model 浏览器对象模型 , 将浏览器的各个组成部分封装成对象。 组成Window：窗口对象 创建 : Window对象不需要创建就可以直接使用, window.方法名(),且window可省略 方法 与弹出有关的方法 alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框 返回值是用户输入的值 与打开关闭有关的方法 open : 打开一个新的浏览器窗口 返回值是新的Window对象 open(参数) : 参数是新窗口的URL close : 关闭浏览器窗口 谁调用close,那么就关闭谁 可以发现 ,默认的close()其实是window.close() 关闭的是当前窗口 利用open()的返回值是一个窗口来作为参数 ,调用close()方法 与定时器有关的方法 setTimeout(参数1 , 参数2) 在指定的毫秒数后调用函数或计算表达式。 只执行一次 参数1 : js代码或者方法对象 参数2 : 毫秒值 返回值 : 唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval(参数1 , 参数2) 按照指定的周期（以毫秒计）来调用函数或计算表达式。 每隔参数2毫秒之后,执行参数1 参数1 : js代码或者方法对象 参数2 : 毫秒值 clearInterval() 取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象： history location Navigator Screen: 获取DOM对象 document 返回值是对应属性的对象 document 特点 : Window对象不需要创建就可以直接使用, window.方法名() window可省略 , 直接写成 方法名() 练习 : 轮播图练习 ,也就是定时更换图片 注意这里的下标的变换的拼接方法!! Navigator：浏览器对象Screen：显示器屏幕对象History：历史记录对象 仅仅表示当前窗口的历史记录 创建 window.history history 方法 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 这两个功能相同 ​ go(参数) 加载 history 列表中的某个具体页面。 参数 正数：前进几个历史记录 go(1)=forward 负数：后退几个历史记录 go(-1)=back 属性 length 返回当前窗口历史列表中的 URL 数量。 Location：地址栏对象 创建 window.location location 方法 reload() : 重新加载当前文档。刷新 属性 href : 设置或返回完整的 URL。 一般我们获取href是对他进行修改 练习 自动跳转主页 DOM概念 Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 DOM树 当HTML文档进入浏览器内存的时候, 浏览器将整个文档转换为DOM树 W3C DOM 标准被分为 3 个不同的部分 核心DOM Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment : 注释对象 Node：节点对象，其他5个的父对象 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 注: XML DOM 和 HTML DOM是对核心DOM的扩展和封装 核心DOM模型Document：文档对象 创建 : 在HTML DOM模型中可以使用window对象来获取 window.document document 方法 获取Element对象 : 获取的是标签的对象们 getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName()：根据元素的标签名称获取元素对象们。返回值是一个数组 getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象 createAttribute(name) : 创建属性节点对象 createComment() : 创建注释节点对象 createElement() : 创建元素节点对象(标签) createTextNode() : 创建文本节点对象 这里是创建table标签对象 , 这些对象是在内存中,并且跟原来的HTML文档没有关系 属性 Element：元素对象 获取/创建 : 通过document来获取和创建 方法 : setAttribute()：设置属性 可见,一开始&lt;a&gt;是没有属性的,所以只显示为普通的文本 ,通过setAttribute()设置&lt;a&gt;d的href属性 这样&lt;a&gt;就变成了超链接 removeAttribute()：删除属性 Node : 节点对象 特点 : 他是其他5个核心DOM中的对象的父对象 , 所有DOM对象都可以被认为是一个节点 方法 : DOM树的CRUD操作: appendChild()：向节点的子节点列表的结尾添加新的子节点 removeChild() ：删除（并返回）当前节点的指定子节点。 当我们点击的时候 并没有删除 / 其实是删除了的 只不过因为设置的href属性为空 ,相当于在本页面内跳转 也就是说 当删除过后,又刷新了当前的页面 设置href=&quot;javascript:void(0);&quot; ,当我们点击之后 不进行页面的跳转 void 是阻止返回值的运算符 replaceChild()：用新节点替换一个子节点。 属性 : parentNode 返回当前节点的父节点。 Node里面封装的CRUD方法,对于DOM树中的所有的对象都可以使用 练习 这里实现的是动态表格内容的添加 动态表格的删除 //动态表格的删除 // 1. 首先要知道要删除的是哪一个超链接 //给a标签添加onclick onclick=&quot;delTr(this)&quot; // 2. 怎么删除 //removeChild() : 通过父节点删除子节点 在每个&lt;a&gt;标签内设置属性 onclick : onclick onclick=&quot;delTr(this)&quot; 这里的this就是指当前的对象 table--&gt;tr--&gt;td--&gt;a 以上只可以将原始的3条数据删除,要删除新添加的项 需要设置属性 HTML DOM HTML DOM是关于如何获取,修改,添加或删除HTML元素的标准 标签体的设置和获取 : innerHTML 利用&lt;table&gt;的innerHTML来进行动态表格项的添加 使用html元素对象的属性 : 使用的时候查看文档 控制元素样式 : 使用元素的style属性来设置 每一个元素都有style属性 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 提前设置好类选择器 通过className设置标签的class属性值 事件监听机制(简称事件) 概念 : 某些组件被执行了某些操作后，触发某些代码的执行。 事件 : 某些操作 如 : 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框.. 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件 点击事件 onclick：单击事件 ondblclick：双击事件 焦点事件 –&gt;光标 onblur：失去焦点 一般用于表单校验,当用户填写完成的时候,提示正确与否 只有当获取焦点之后,才能失去焦点 当鼠标点击非编辑框的区域的时候,就失去焦点 onfocus:元素获得焦点。 加载事件 onload：一张页面或一幅图像完成加载。 常用于window或者&lt;body&gt; 正常情况下,&lt;script&gt;在&lt;input&gt;之前的话,会因为getNameById为null而报错 当我们用onload来包裹这片代码的时候,就会等页面加载完成才会执行后面的代码,这样就不会发生错误了 鼠标事件 onmousedown 鼠标按钮被按下。 onmouseup 鼠标按键被松开。 onmousemove 鼠标被移动。 onmouseover 鼠标移到某元素之上。 onmouseout 鼠标从某元素移开。 键盘事件 onkeydown 某个键盘按键被按下。 Enter键是13 onkeyup 某个键盘按键被松开。 onkeypress 某个键盘按键被按下并松开。 选中和改变 onchange 域的内容被改变。 onselect 文本被选中。 表单事件 onsubmit 确认按钮被点击。 当表单校验失败,会阻止提交 当这个方法的返回值是false的时候,就不会提交表单 或者,这样写 因为浏览器会把onclick解析成 function fun()&#123; //onclick中的内容 return checkForm(); &#125; onreset 重置按钮被点击。 事件练习 这里是实现表格的全选,全不选以及反选的功能 主要是熟悉事件 这里是校验填写的表单是否正确","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.chasingwind.top/tags/JavaScript/"}],"author":"ChasingWind"},{"title":"HTML 和 CSS","slug":"HTML和CSS","date":"2019-07-15T00:49:45.000Z","updated":"2021-03-04T00:46:23.113Z","comments":true,"path":"2019/07/15/HTML和CSS/","link":"","permalink":"https://www.chasingwind.top/2019/07/15/HTML%E5%92%8CCSS/","excerpt":"HTML不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。","text":"HTML不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 概念介绍Web概念 JavaWeb : 使用Java语言开发基于互联网的项目 软件架构 : C / S : Client/Server 客户端/服务器端 在用户本地有一个客户端程序,在远程有一个服务器端程序 优点 用户体验好,比如客户端游戏和网页端游戏 可以将一些大型的本地数据存储下来,不会每次都去服务器重新下载,体验更好 缺点 : 开发,安装,部署,维护麻烦 开发需要同时开发客户端和服务器端 B / S : Browser/Server 浏览器端/服务器端 只需要一个浏览器,用户可以通过不同的URL,客户访问不同的服务器端程序 优点 : 开发,安装,部署,维护简单 只需要开发服务器端 缺点 : 如果应用过大,用户的体验可能会受到影响 对硬件要求过高,比如服务器端存储大,带宽大,客户这边太占带宽 B/S架构详解 资源 : 静态资源 : 使用静态网页开发技术发布的资源 特点 : 所有用户访问的结果是一样的 , 如 : 文本,图片,音频,视频 静态网页开发技术 : HTML,CSS,JavaScript 如果用户请求的是静态资源,那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎,可以展示静态资源 动态资源 : 使用动态网页开发技术发布的资源 特点 : 所有用户能访问的结果, 可能不一样 动态网页开发技术 : Jsp/Servlet 如果用户请求的是动态资源,那么服务器会执行动态资源,转换为静态资源,再发送给浏览器 我们要学习动态资源,必须要先学习静态资源 静态资源 : HTML : 用于搭建基础网页 , 展示页面的内容 CSS : 用于美化页面 , 页面布局 JavaScript : 控制页面的元素,让页面有一些动态的效果 HTML概述 概念 : Hyper Text Markup Language 超文本标记语言 超文本 : 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言 : 由标签构成的语言。&lt;标签名称&gt; 如 html，xml 标记语言不是编程语言,没有逻辑性 HTML入门 语法 : 文档的后缀是 .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 : &lt;html&gt; &lt;/html&gt; 自闭合标签：开始标签和结束标签在一起。如 : &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确: &lt;a&gt;&lt;b&gt; &lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性 , 属性是由键值对构成 , 值用单双引号都可以 html标签不区分大小写 ,但是建议使用小写 展示 基本标签 文件标签: 构成html最基本的标签 html : html文档的根标签, 根标签:最顶层的标签 head : 头标签 ,用于指定html文档的一些属性 ,引入外部的资源 title : 定义网页标题的标签 body : 体标签 ：&lt;!DOCTYPE html&gt; html5中定义该文档是html文档 文本标签: 和文本有关的标签 html注释 : &lt;!-- 注释 --&gt; &lt;br /&gt;或者 &lt;br&gt; : 换行标签 不添加&lt;br /&gt;标签 而在html中手动换行是没有效果的 会将tab,无论多少个空格都解析成一个空字符 只有添加&lt;br /&gt;标签后,才能起到换行的效果 &lt;h1&gt; to &lt;h6&gt;: 标题标签 自带换行 &lt;p&gt; : 段落标签 &lt;hr /&gt; : 自闭合标签,显示一条水平线 &lt;b&gt; : 字体加粗 bold &lt;i&gt; : 斜体 italic &lt;font&gt; : 字体标签 属性的定义 color : 英文单词 : 比如 : red,green RGB : rgb(值1,值2,值3) : 值的范围0~255 ,值1,值2,值3 分别表示的是红绿蓝三种颜色的占比 这种方式已经不怎么使用了 #值1,值2,值3 : 值的范围00~FF,使用16进制来表示红绿蓝三种颜色的占比 推荐使用这种方式 width : 数值 : 比如 :width = ‘20’ ,数值的单位,默认是px(像素) 百分比 :比如 : width = ‘20%’ , 相对于父元素的占比 html中的特殊字符的显示 其中,空格&amp;nbsp;最为常用 图片标签 &lt;img / &gt;: 自闭合标签 属性 src : 图片路径 align : 对齐方式 alt : 图片加载失败的时候,就会显示alt中文字的信息 关于图片路径src的书写 列表标签 有序列表 &lt;ol&gt; : order list &lt;li&gt;: 列表项 属性 : 无序列表 并不是说他的顺序是乱的 而是他的列表项前面的标识是没有先后顺序之分的 &lt;ul&gt; : unorder list &lt;li&gt; : 列表项 属性: type : 可以修改无序列表的标识形式 链接标签 &lt;a&gt; : 超链接标签 &lt;a&gt; 标签始终是超链接，但是如果未设置 href 属性，则只是超链接的占位符。也就是普通的文本 属性 : href : 指定访问资源到的URL (统一资源定位符) target : 指定打开资源的方式 ,就是 在当前页面或者在新的页面打开 _self : 默认值 ,在当前页面打开 _blank: 在新的空表页面打开 span和div span : 文本信息在一行展示，行内标签 内联标签 div : 每一个div占满一整行。块级标签 他们本身没有对包裹的文字起到任何效果,以后会结合CSS进行文字样式的修改 语义化标签 : HTML5中为了提高程序的可读性,提供的一些标签, 这些标签跟上面的&lt;div&gt;和&lt;span&gt;一样,对文字没有任何的效果,将来会通过CSS来进行样式的控制 &lt;header&gt; &lt;footer&gt; 等等 表格标签 : 在HTML中,表格没有列的概念只有行,然后每一行中有不同个数的单元格 &lt;table&gt; : 定义表格 属性: width: 宽度 border : 边框 cellpadding : 定义内容和单元格的距离 ,就是单元格上下两条边的间距 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor : 表格背景色 align: 表格对齐方式 tr : 定义行 bgcolor : 行背景色 align: 行中内容的对齐方式 th : 定义表头单元格 td : 定义单元格 rowspan : 合并行 colspan : 合并列 &lt;caption&gt; : 表名 &lt;thead&gt; : 表格的头部分 没有效果 , 有点像语义标签 &lt;tbody&gt; : 表格的体部分 没有效果 , 有点像语义标签 &lt;tfoot&gt; : 表格的脚部分 没有效果 , 有点像语义标签 表单标签 表单 : 概念 : 用于采集用户输入的数据的。这些采集到的数据用于和服务器进行交互 &lt;form&gt; : 用于定义表单的, 可以定义一个范围,范围代表采集用户数据的范围,也就是说在&lt;form&gt;标签内的数据才会被采集 属性 : action : 提交数据到指定的URL ,”#” 代表指向的是当前的html的URL method : 指定提交方式 分类 : 一共7种,常用2种 get : 请求参数会在地址栏中显示,会封装到请求行中 请求参数的长度是有限制的 不太安全 post : 请求参数不会在地址栏中显示。会封装在请求体中(HTTP协议中讲解) 请求参数的长度是没有限制的 比较安全 表单中的数据要想被提交,必须指定其name属性 当连接中拼接有提交的值的时候就说明数据采集成功了 必须注意的是 : 数据要想被提交,需要满足 数据必须在&lt;form&gt;标签内 数据必须有name 属性 表单项标签 &lt;input&gt; : 可以通过type属性值 ,改变元素展示的样式 不写默认为**”text”** type : 样式属性 text : 文本 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 value : 输入框中的信息 ,但需要手动清空 password : 密码框 输入密码的时候会隐藏 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 radio : 单选框 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样 ,只有name属性值相同的单选框 ,才能作为同一组进行选择。 一般会给每一个单选框提供value属性，指定其被选中后提交的值 . 不给的话, 提交的时候默认值是on checked属性，可以指定默认值 checkbox : 复选框 一般会给每一个单选框提供value属性，指定其被选中后提交的值 . 不给的话, 提交的时候默认值是on checked属性，可以指定默认值 &lt;label&gt; : 指定输入项的文字描述信息 for属性 : 一般会和 input 的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点,就是光标自动跳到对应的输入框 一定要注意 : 数据要想被采集,必须有name 属性 ,因为在提交的时候我们可以在地址栏中看到name的值是作为键的 &lt;file&gt; : 文件选择框 &lt;hidden&gt; : 隐藏域，用于提交一些信息。 在页面中并不会显示,但是提交的时候会将其中的value值提交 按钮 : submit : 提交按钮。可以提交表单 button : 普通按钮 不会进行提交 后面结合CSS进行使用 image : 将图片作为一个按钮 src属性指定图片的路径 type的其他属性: &lt;select&gt; : 下拉列表 &lt;option&gt; :子元素,下拉列表的选项 这里的value的作用就是提交的时候province对应的值 selected 是说默认选择 &lt;textarea&gt; : 文本域 rows : 指定多少个字符作为宽度 cols : 指定多少个字符作为长度 CSS概述 概念 : Cascading Style Sheets 层叠样式表 用于页面美化和布局控制 层叠 : 多个样式可以作用在同一个html的元素上，同时生效 相比用html标签中的属性控制的好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 CSS的使用 : CSS与html结合方式 内联样式 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 外部样式 定义css资源文件 在&lt;head&gt;标签内，定义&lt;link&gt;标签，引入外部的资源文件 通过&lt;head&gt;标签中用link标签来引入外部CSS文件 也可以这样引用外部资源文件 (了解) CSS文件内容 注意 作用范围: 内联样式 &lt; 内部样式 &lt; 外部样式 常用的方式是内部样式和外部样式 CSS语法 : 格式 : 选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ... &#125; 注意 :每一对属性需要使用；隔开，最后一对属性可以不加；但是建议加上 CSS选择器 分类 : 基础选择器 id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 元素选择器：选择具有相同标签名称的元素 可见 , id选择器的优先级比元素选择器的高 类选择器：选择具有相同的class属性值的元素。 可见 ,类选择器优先级高于元素选择器 扩展选择器 选择所有元素 *&#123;&#125; 并集选择器 选择器1,选择器2&#123;&#125; 子选择器 : 筛选选择器1元素下选择器2的元素 选择器1 选择器2&#123;&#125; 父选择器 : 筛选选择器2的父元素选择器1 选择器1 &gt; 选择器2&#123;&#125; 属性选择器 : 选择元素名称 ,属性名 = 属性值的元素 元素名称[属性名=&quot;属性值&quot;]&#123;&#125; 伪类选择器 : 选择一些元素具有的状态 元素 : 状态&#123;&#125; 如 : 超链接&lt;a&gt; 每个标签具有的状态并不同 状态 : link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态 CSS属性 字体,文本 font-size : 字体大小 color : 文本颜色 text-align：对齐方式 line-height：行高 背景 background：复合属性 边框和轮廓 border：复合属性 尺寸 width：宽度 height：高度 盒子模型 : 用来控制布局 margin : 外边距 以div2作为参考的话 使用外边距 padding : 内边距 默认情况下 ,内边距会影响盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float : 浮动 left : right : 内外边距是相对的,需要根据我们的主元素来进行参考","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.chasingwind.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://www.chasingwind.top/tags/CSS/"}],"author":"ChasingWind"},{"title":"JDBC","slug":"JDBC","date":"2019-07-11T06:06:45.000Z","updated":"2021-03-04T00:48:18.935Z","comments":true,"path":"2019/07/11/JDBC/","link":"","permalink":"https://www.chasingwind.top/2019/07/11/JDBC/","excerpt":"JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。","text":"JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。 JDBC基础 JDBC基本概念 概念: Java DataBase Connectivity , Java数据库连接 , 用Java语言操作数据库 JDBC本质: 就是官方(Sun公司)定义的一套操作所有关系型数据库的规则,也就是接口. 各个数据库厂商去实现这套接口,提供数据库驱动jar包. 我们可以使用这套接口(JDBC) 编程,真正执行的代码是驱动jar包中的实现类 —-&gt; 多态 快速入门 导入驱动jar包 复制jar包到项目中的自己创建的libs目录下 右键–&gt; Add as Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql,返回结果 处理结果 释放资源 注意 : JDK9之后的改变 注册驱动的时候是 com.mysql.cj.jdbc.Driver 获取数据库连接对象的时候需要设置时区,同时需要在MySQL数据库中的my.ini配置文件进行时区的设置 JDBC操作中的各个对象 DriverManager 类: 驱动管理对象 功能: 注册驱动 : 告诉程序该使用哪一个数据库驱动jar包 Drivermanager类中的 registerDriver方法 而我们注册驱动写的程序是 那么他们之间的关系是什么呢? 查看源码: 在com.mysql.cj.jdbc.Driver类中的静态代码块区域 使用的就是registerDriver方法进行驱动的注册的 在MySQL5之后可以省略注册驱动的步骤,在次目录下会自动帮我们进行注册 但是,建议自己进行注册,避免不必要的麻烦 获取数据库连接 方法: 参数: url:指定连接的路径 语法: jdbc:mysql://ip地址(或域名):端口号/数据库名称?serverTimezone 例如:jdbc:mysql://localhost:3306/db2?serverTimezone 简写: 当ip是localhost,端口是3306 可以简写为 jdbc:mysql:///db2?serverTimezone user:用户名 password:密码 Connection:数据库连接对象,代表了当前代码和数据库之间的桥梁 功能: 获取执行sql的对象 管理事务: 开启事务 参数设置成false 就会开启事务 提交事务 回滚事务 Statement:执行sql的对象 execute : 可以执行任意的sql语句 很少用这个语句 executeUpdate : 执行DML(insert , delete , update) , DDL(create , alter , drop)语句 返回值为int ,表示的是sql语句影响的行数 ,返回值&gt;0则执行成功,否则执行失败 executeQuery : 执行DQL(select)语句 返回值是ResultSet 结果集对象 练习account表 添加一条记录这里才是完整的带有错误处理的JDBC 遇到的问题 : sql语句中用双引号会报错 以后都用单引号 account表 修改一条记录 同1account表 删除一条记录 同1 ResultSet:结果集对象,封装查询的结果 那么怎样将查询的结果给取出来呢? ==&gt;游标 涉及的方法: ResultSet接口中的方法 boolean next() : 游标向下移动一行 判断当前行是否是最后一行末尾(是否有数据),如果是最后一行,则返回false, 如果不是最后一行, 返回true getXxx(参数) : Xxx代表数据类型 参数: int : 代表列的编号,列的编号从1开始 String : 代表列的名称 如 :getInt(id) 通过上述的两个方法,就可以获取封装的数据了。 但是每次获取数据并不是一整行的数据,而是这一行中的某一列对应的数据 游标默认指向的是表中数据名称的行 也就是非数据行 ResultSet也是资源 使用完毕后需要进行释放 上面针对的是一条数据 当有多条数据的时候代码复用性很差 而且,有时候我们并不知道ResultSet集合中有多少条数据 当查询的条数多于集合中的数据的时候 就可能会产生错误 正确使用游标的方式: 游标向下移动一行 判断是否有数据 使用next()的返回值进行判断 获取数据 这才是标准的写法 使用while(rs.next())进行循环 并将rs.next()作为循环的条件 练习 抽取JDBC工具类 目的: 降低代码的冗余度 jdbc.properties 配置文件 调用 模拟登陆练习 模拟登陆,判断账号密码是否正确 注意的是 sql语句的书写 PreparedStatement:执行sql的对象 PreparedStatement与Statement的关系 : PreparedStatement是Statement的子接口 在上面的模拟登陆练习中有一个小小的bug 这个用户名和密码并不在数据库中, 但却登录成功了 这就是SQL注入问题 SQL注入问题 : 在拼接SQL时,有一些SQL的特殊关键字参与字符串的拼接,会造成安全问题 用户名 ：用户随便输 ,密码 : a’ or ‘a’ = ‘a SQL : SELECT * FROM USER WHERE id = ‘18545’ AND PASSWORD = ‘a’ OR ‘a’ = ‘a’; 解决SQL注入问题 : 使用PreparedStatement对象来解决 PreparedStatement中的SQL语句的形式 可见,在PreparedStatement中的SQL语句 参数使用? 来作为占位符 静态SQL : 所有的参数,在生成SQL的时候都是拼接好的 预编译SQL : 参数并没有拼接好, 而是使用占位符?来进行替代 PreparedStatement使用步骤 导入驱动jar包 注册驱动 获取数据库连接对象 Connection 定义sql语句 sql的参数使用?来进行代替 例如: SELECT * FROM USER WHERE id = ? AND PASSWORD = ?; 执行获取SQL语句的对象 Connection接口中的方法 Connection.preparedstatement(String sql) 给?赋值 方法 : preparedstatement 中的 setXxx(参数1,参数2)方法 参数1 : SQL语句中的?的位置编号 ?位置编号从1开始 参数2 : ?处的值 执行SQL语句,返回结果 不需要传递参数 处理结果 释放资源 注意 : 我们后面都会用PreparedStatement而不是Statement了 PreparedStatement可以防止SQL注入问题 PreparedStatement效率更高 JDBC事务管理 事务 : 一个包含一个或者多个步骤的业务操作。如果这个业务操作被事务管理,则这多个步骤要么同时成功,要么同时失败 操作 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务 参数设置成false 就会开启事务 提交事务 回滚事务 演示 经过事务管理 发生异常 account并未发生变化 如何使用Connection来管理事务 开启事务 在执行sql之前开启事务 提交事务 当所有sql执行完提交事务 回滚事务 在catch中回滚事务 JDBC连接池 用户访问数据库的时候不是直接向系统底层获取连接,而是向数据库连接池中获取连接 这样可以减少系统资源的开销 数据库连接池 : 其实就是一个存放数据库连接的容器 , 当系统初始化好后 , 容器中会申请一些连接对象,当用户来访问数据库的时候,从容器中获取连接对象,用户访问完之后,会将连接对象归还给连接池 好处: 节约资源 用户访问高效 实现数据库连接池 DataSource接口 获取连接: 归还连接 : Connection.close() ​ 如果连接对象Connection是从连接池中获取的,那么调用Connection.close()方法,则不会再关闭连接了,而是归还连接 数据库厂商来实现 C3P0 : 数据库连接池技术 使用步骤 导入jar包 c3p0-0.9.5.2.jar 和 依赖的jar包 mchange-commons-java-0.2.12.jar 以及数据库的驱动jar包 定义配置文件 名称 : c3p0.properties 或者 c3p0-config.xml 路径 : 直接将文件放在src目录下即可。 创建核心对象 : 数据库连接池对象 CombopooledDataSource 获取连接 : getConnection() 实现 首先 将jar包进行导入 以及 xml 文件 代码 Console控制台显示 这里打印出来的是日志信息 可以使用自己定义的数据库连接池配置 代码: 不过 一般情况下都是使用默认的配置 Druid : 数据库连接池的实现技术 , 阿里巴巴提供的 使用步骤 导入jar包 druid-1.0.9.jar 和 数据库驱动jar包 定义配置文件 是properties形式的配置文件 可以叫任意名称 任意目录 需要手动指定位置 加载配置文件 获取数据库连接池对象 通过工厂类来获取 DruidDataSourceFactory 获取连接 getConnection 实现 定义一个工具类来进行连接池的简化 定义一个类 JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 实现 使用工具类 Spring JDBC Spring 框架对JDBC的简单封装 , 提供了一个JDBCTemplate对象简化JDBC的开发 使用步骤 导入jar包 创建JDBCTemplate对象, 依赖于数据源DataSource JDBCTemplate template = new JDBCTemplate(ds); 调用JDBCTemplate的方法来进行CRUD 的操作 Update() : 执行DML语句 queryForMap() : 查询结果,将结果封装成Map集合, 当且仅当结果集中只有一条数据的时候使用 queryForList() : 查询结果,将结果封装成List集合, 当结果集有多条数据的时候,将每一条数据都存储为键值对的形式 query() : 查询结果,将结果封装成指定的JavaBean存储到List集合中 queryForObject() : 查询,一般用于查询聚合函数的结果,将结果封装成某种类型 演示 DML 我们只需要关系sql语句的执行 而不需要关心其他的操作 需求 修改1号数据的 salary 为 10000 添加一条记录 删除刚才添加的记录 查询id为1001的记录，将其封装为Map集合 当查询的结果集只有一条数据的时候 封装为map集合 键值对的形式 当查询的结果集有多条数据的时候 会报错 查询所有记录，将其封装为List 当查询的结果集中的数据有多条的时候 , 使用List集合 可见 这里的List&lt;Map&lt;String , Object&gt;&gt; 也就是将每一条是数据封装成map集合,然后将map集合中的数据存储到list集合中 查询所有记录，将其封装为Emp对象的List集合 这里的query(sql 语句, RowMapper接口) RowMapper是告诉query将结果封装成什么样的对象 当然一般用已经实现的BeanPropertyRowMapper 这个类已经实现了RowMapper接口 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 查询总记录数 queryforObject(sql语句 , 返回值结果类型.class) 一般是用来查询聚合函数的","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://www.chasingwind.top/tags/JDBC/"}],"author":"ChasingWind"},{"title":"MySQL数据库进阶","slug":"MySQL数据库进阶","date":"2019-06-21T01:19:05.000Z","updated":"2021-03-04T00:53:15.001Z","comments":true,"path":"2019/06/21/MySQL数据库进阶/","link":"","permalink":"https://www.chasingwind.top/2019/06/21/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/","excerpt":"本篇主要讲述了 MySQL数据库的设计, 数据库的备份与还原, 多表查询, 事务以及DCL(管理用户以及授权)","text":"本篇主要讲述了 MySQL数据库的设计, 数据库的备份与还原, 多表查询, 事务以及DCL(管理用户以及授权) 表的约束 概念 : 对表中的数据进行限定 , 从而保证数据的正确性,有效性和完整性. 没有约束的时候 添加的数据可以任意 这样就不太合适 分类: 主键约束 : primary key 非空约束 : not null 唯一约束 : unique 外键约束 : foreign key 主键约束 注意 含义: 非空且唯一 一张表中只可以有一个字段为主键 主键就是表中记录的唯一标识 创建表的时候添加约束 主键的唯一性 主键的非空性 在表创建完成后进行主键约束的添加以及修改 删除主键 因为主键在表中的唯一性 所以不需要指定字段 当然 指定字段也是可以的 添加主键 自动增长 如果某一列是数值类型的,使用auto-increment 可以完成值的自动增长 创建表的时候添加 注意: 自动增长的时候 标号只跟上一条数据有关 删除自动增长 这样并不会删除主键 添加自动增长 注意 大多数情况下 自动增长都是和主键一起使用的 非空约束 : not null ,值不能为null 创建表的时候添加约束 在表创建完成后进行非空约束的添加以及修改 唯一约束 : unique , 值不能重复 创建表的时候添加唯一约束 在表创建完成后对唯一约束进行添加以及删除 删除唯一约束 DROP INDEX 添加唯一约束 注意: 外键约束 : foreign key —&gt;让表与表产生关系,从而保证数据的正确性 问题: 下面的数据中存在大量的数据冗余问题 问题解决: 将表中的信息拆分成两张表 这样表的结构就变成了这样的: 这样就将之前的部门的名称修改成了部门的编号 其实数据还是存在问题的 当我们将部门表中的某一行删除的时候,在员工表中还存在着部分编号的引用 现实中的逻辑是 当部门没有人的时候才可以将部门表中的部门信息删除 为了解决上述问题,就可以使用外键约束,将员工表中的部门编号去关联部门表中的主键id 在创建表的时候添加外键 create table 表名( ​ ……….. ​ 外键列 ​ constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列的名称) ); 此时去删除部门表的某一行就会出错 因为和主表有外键约束 另外 当你去员工表中添加一行 部门编号在部门表中不存在的时候 也会报错 这样就保证了数据的正确性 constraint 约束,约束条件 references 参考,参照,引用 在这里翻译为”关联”我觉得更为合适 在表创建完成后进行外键的删除以及添加 删除外键 语法: ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 在表创建完成之后添加外键 语法:ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称); 级联操作 当我们需要将部门表中的部门编号修改的时候 首先 将员工表中的这个部门的员工的所在部门编号修改为NULL 然后 将部门表中的这个部门修改成相应的编号 最后 将员工表中的部门NULL 修改成对应的操作 级联更新操作就是 当我们修改部门表中的部门编号的时候, 员工表中的部门编号会相应的自动修改 级联删除操作 当我们删除部门表中的某一行的时候 那么 在员工表中部门编号为此部门编号的行 都会被删除 弊端 : 删除的时候风险比较大 因为关联的数据都会被删除 实际开发中 级联的使用比较谨慎!! 数据库的设计 多表之间的关系 分类: 一对一 人和身份证 分析:一个人只有一个身份证,一个身份证只对应一个人 一对多(多对一) 部门和员工 分析:一个部门有多个员工,一个员工只属于一个部门 多对多 学生和课程 一个学生可以选择很多课程,一个课程可以被多个学生选择 实现关系: 一对一 任意一方 添加 唯一外键, 指向另一方的 主键 一对一的关系合成一张表岂不是更实在. 一对多(多对一) 在 多 的一方建立外键,指向 1 的一方的主键 多对多 借助 中间表 来实现,中间表 至少 包含两个字段 ,这两个字段作为中间表的外键,分别指向两张表的主键 案例分析 tab_category tab_route tab_user tab_favorite 中间表中的两个字段成为联合主键(中间表的) 然后将这个联合主键作为两个主表的外键 架构图 可以清晰的看出一对多(多对一)的tab_category和tab_route 以及借助中间表(tab_favorite)来实现的多对多的关系tab_route和tab_user 数据库设计的范式 概念 : 在设计数据库时,需要遵循的一些规范, 要遵循后面的范式, 要求必须遵循前面的所有范式, 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小 分类: 第一范式(1NF),第二范式(2NF),第三范式(3NF),BC范式,第四范式(4NF),第五范式(5NF) 第一范式(1NF) : 每一列都是不可分割的原子数据项 也就是说不能存在这样的表 系这一列还可以分割成两个原子项 修改后 就变成了原子列 第一范式是数据库设计中最基本的要求 因为在创建表的时候是不可能存在复合列的 第二范式(2NF) : 在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 几个概念： 可将 –&gt; 读作 “确定” 函数依赖：A–&gt;B,如果通过**A属性(属性组)**的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号–&gt;姓名。 （学号，课程名称） –&gt; 分数 完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值 例如：（学号，课程名称） –&gt; 分数 部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） – &gt; 姓名 这里只需要学号就可以确定姓名的 传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号–&gt;系名，系名–&gt;系主任 系主任传递依赖于学号 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 通俗的来书就是,通过这个属性或属性组 , 可以确定其他所有的属性 例如：该表中码为：属性组 （学号，课程名称） 主属性：码属性组中的所有属性 非主属性：除了码属性组的属性 第二范式就是在第一范式基础上 消除非主属性对主码的部分函数依赖 在表中 码是(学号,课程名称) 分数完全依赖于码 姓名,系名,系主任 部分函数依赖于码 也就是部分依赖 消除部分依赖:将表进行拆分 可见 在选课表中 分数完全依赖与码(学号,课程名称) ​ 在学生表中 姓名,系名,系主任完全函数依赖于码 (学号) 第三范式(3NF) : 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 在上面的表中, 存在 学号–&gt;系名,系名–&gt;系主任 的传递函数依赖 数据库的备份和还原 命令行的方式 语法 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行文件 source 文件路径 图形化工具 多表查询 笛卡尔积 有两个集合A, B ,取这两个集合的所有的组成情况 总的组成情况的个数= A集合的元素个数 * B集合的元素个数 要完成多表查询 , 需要消除无用的数据 这就需要用到下列的三种方式 多表查询的分类 内连接查询 : 隐式内连接 : 使用where条件消除无用的数据 这样的话 当名称太长的时候 我们可以起别名来代替 开发规范: 进行相应的备注 以便查阅 显示内连接 语法: SELECT 查询字段 FROM 表1 INNER JOIN 表2 ON 连接条件; INNER可省略 SELECT 查询字段 FROM 表1 JOIN 表2 ON 连接条件; 内连接查询的逻辑 从哪些表中查询数据 查询的条件是什么 查询哪些字段 外连接查询 : 此时新加入的员工 还没有分配部门的时候 这样并没有完成需求 左外连接 语法: SELECT 查询内容 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件; 完成需求: 结果显示关键词left左边表中的所有数据,右边表数据数据少了补NULL值,数据多了不显示 注: OUTER可省略 右外连接 语法: SELECT 查询内容 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件; 完成需求: 右连接是以右边为参照,左边少了补NULL,多了删除 子查询 概念 : 查询中嵌套查询 , 称为 嵌套的查询为子查询 子查询的不同情况 子查询的结果单行单列 子查询可以作为条件 使用运算符去判断 子查询的结果多行单列 使用IN来进行判断 子查询的结果多行多列 子查询作为一张虚拟表进行表的查询 还可以用内连接进行查询 多表查询练习 表结构 完成需求 : 将工资范围作为条件 使用BETWEEN…AND 使用子查询来实现 查询所有的数据 使用左外连接 事务 事务的基本介绍 概念 : 如果一个包含多个步骤的业务操作 , 被事务管理 , 那么这些操作就变成了一个整体 , 要么同时成功,要么同时失败. 操作 开启事务 : start transaction; 回滚 : rollback; 提交 : commit; MySQL数据库中的事务默认自动提交 一条DML语句自动提交一次事务 开启事务的话,需要手动提交事务. 不提交的话 数据只是在临时状态 Oracle数据库默认手动提交 修改事务的默认提交方式 查看事务的提交方式 修改默认的事务提交方式 设置成手动提交之后 如果数据修改了 而没有commit的话 数据只是在临时状态 ,表中的数据并未改变 事务的四大特征(重点) 原子性（Atomicity） : 被事务管理的SQL语句成为不可分割的最小操作单位, 要么同时成功,要么同时失败 持久性（Consistency） : 当事务提交或回滚之后,数据库会持久化地保存数据 隔离性（Isolation） : 多个事务之间相互独立 一致性（Durability） : 事务操作前后,数据总量不变 事务的隔离级别 概念 : 多个事务之间是隔离的,相互独立的. 但是如果多个事务操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题 存在的问题 脏读 : 一个事务读取到另一个事务中的没有提交的数据 不可重复读(虚读) : 在同一个事务中,两次读取到的数据不一样 比如说一个操作中,事务未提交之前查询结果与提交之后的查询结果不一样,但是进行查询的语句是一样的 幻读 : 一个事务操作(DML)数据表中所有的数据 , 另一个事务添加了一条数据,则第一个事务查询不到自己的修改 与多线程加锁相似 ,将表加锁 隔离级别: read uncommitted : 读未提交 产生的问题 : 脏读、不可重复读、幻读 read committed : 读已提交———&gt;(Oracle默认) 产生的问题 :不可重复读、幻读 repeatable read : 可重复读———&gt; (MySQL默认) 产生的问题 :幻读 serializable : 串行化 解决所有的问题 注意 : 隔离级别从小到大 安全性越来越高, 但是同时 效率越来越低 数据库隔离级别的查询与设置 – 查询事务隔离级别SELECT @@tx_isolation; – 设置事务的隔离级别SET GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别; DCL DCL :管理用户,授权 管理用户 添加用户 删除用户 修改用户密码 查询用户 注意 : 用户的数据存储在mysql数据库中的user 表中 % 通配符 : 表示可以在任意主机使用用户登录数据库 权限管理 查询权限 授予权限 撤销权限 ​ DBA : 数据库管理员","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.chasingwind.top/tags/MySQL/"}],"author":"ChasingWind"},{"title":"MySQL数据库基础","slug":"MySQL数据库基础","date":"2019-06-20T04:11:18.000Z","updated":"2021-03-04T00:52:52.611Z","comments":true,"path":"2019/06/20/MySQL数据库基础/","link":"","permalink":"https://www.chasingwind.top/2019/06/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","excerpt":"MySQL是一个轻量级关系型数据库管理系统,由于体积小、速度快、总体拥有成本低，开放源码、免费，一般中小型网站的开发都选择Linux + MySQL作为网站数据库。","text":"MySQL是一个轻量级关系型数据库管理系统,由于体积小、速度快、总体拥有成本低，开放源码、免费，一般中小型网站的开发都选择Linux + MySQL作为网站数据库。 数据库的基本概念 数据库 DataBase 简称:DB 什么是数据库 用于存储和管理数据的仓库 数据库的特点 持久化存储数据,其实数据库就是一个文件系统 方便存储和管理数据 使用统一的方式操作数据库 常见的数据库软件 MySQL：开源免费的数据库，小型的数据库，已经被 Oracle 收购了。 MySQL6.x 版本也开始收费。后来Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购 Oracle：收费的大型数据库， Oracle 公司的产品 DB2 ： IBM 公司的数据库产品,收费的。常应用在银行系统中。 SQL Server： MicroSoft 公司收费的中型的数据库。 C#、 .net 等语言常使用。 SQLite: 嵌入式的小型数据库，应用在手机端，如： Android MySQL数据库的优点 MySQL是一个轻量级关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。目前MySQL被广泛地应用在Internet上的中小型网站中，由于体积小、速度快、总体拥有成本低，开放源码、免费，一般中小型网站的开发都选择Linux + MySQL作为网站数据库。 MySQL是一个关系型数据库管理系统，MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，就增加了速度并提高了灵活性。 注:为什么使用数据库存储文件 存储位置 优点 缺点 内存 速度快 不能永久保存,数据是临时状态 文件 数据可以永久保存 操作数据不方便,不便于管理 数据库 1.数据可以永久保存2.查询速度快3.对数据的管理方便 占用资源,需要购买 数据库的安装与卸载,配置 我们安装MySQL其实安装的是MySQL的服务器软件,他会在windows的注册列表里注册MySQL的服务(service),服务就是一些没有界面的应用程序 查看服务 cmd–&gt; services.msc 关闭mysql服务 net stop mysql 开启mysql服务 net start mysql 数据库的连接 本地数据库的连接 远程数据库的连接 mysql -h远程的ip地址 -uroot -p 远程的密码 mysql –host=连接的ip –user=root –password=___ 数据库的退出 注:以上关闭和开启都需要在管理员的模式下 并且上述服务的名称必须和你的服务名称相同 当你的服务名称是mysql1,那么后面就需要的是mysql1 MySQL的目录结构 安装目录 配置文件my.ini 数据目录 上图中的data目录 建议不要将data目录与安装目录放在一起 1 数据库—&gt; 文件夹 2 表—&gt; 文件 3 数据—&gt; 数据 MySQL数据库基础中的数据库,表,数据的关系 MySQL服务器:安装MySQL服务的电脑 SQL 什么是SQL SQL = Structured Query Language 结构化查询语言 其实就是定义了操作所有的关系型数据库的规则 —–&gt; 关系型数据库必须遵守SQL 每一种数据库操作的方式存在不一样的地方称为”方言” SQL通用语法 SQL语句可以单行或多行书写,以分号结尾 在这里输入的语句才是SQL语句 以分号结尾: 可使用空格和缩进来增强语句的可读性 MySQL数据库基础的SQL语句不区分大小写,但是关键字建议使用大写 3种注释 单行注释 ‘– 注释内容’ ‘# 注释内容’–&gt;MySQL特有 注意空格 多行注释 ‘/* 注释 */‘ SQL的分类 Data Definition Language (DDL 数据定义语言) 如：建库，建表 Data Manipulation Language(DML 数据操纵语言)，如：对表中的记录操作增删改 Data Query Language(DQL 数据查询语言)，如：对表中的查询操作 Data Control Language(DCL 数据控制语言)，如：对用户权限的设置 分类及对应的作用 DDL:操作数据库、表 操作数据库:CRUD(增删改查) C: Create 创建 创建数据库 create database 数据库名称; 如果数据库不存在才进行创建数据库 创建指定字符集的数据库 R: Retrieve 查询 查看所有的数据库名称 show create database 数据库名称; 查询创建数据库MySQL的语法 查看数据库对应的字符集,这里是utf-8 U: Update 修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; 注: 当修改成字符集UTF-8的时候输入的应该是UTF8; D: Delete 删除 删除数据库 判断存在再删除 使用数据库 上面的操作都是在数据库之外 也就相当于在下面的目录中 只有进入到相应的数据库的文件夹才可以对其中的文件进行操作 查询当前正在使用的数据库名称 select database(); 并对相应的数据库进行使用 use 数据库名称; 这样就相当于我们进入了db1文件夹 操作表 C: Create 创建 语法 create table 表名( ​ 列名1 数据类型1**,** ​ 列名2 数据类型2**,** ​ 列名3 数据类型3**,** ​ … … ​ 列名n 数据类型n ); 注:最后一列不需要加”,” 常用的数据类型: 类型 英文 整数类型 int 小数类型 double(小数的位数,保留的位数) 日期类型 date: 只包含年月日,yyyy-MM-dddatetime: 包含年月日时分秒,yyyy-MM-dd HH:mm:sstimestamp: 时间戳类型 包含年月日时分秒,yyyy-MM-dd HH:mm:ss 字符串类型 varchar(最大长度) timestamp: 如果这个字段不手动赋值的话,或者赋值为null,那么就会使用当前系统默认的时间,来自动赋值 varchar(最大长度),其中的长度是以字符为单位的,zhangsan 8个字符,张三 2个字符 复制一张表 create table 表名 like 被复制表名; R: Retrieve 查询 查询某个数据库中的所有的表的名称 show tables; 查询表结构 desc 表名; U: Update 修改 修改表名 alter table 表名 rename to 新的表名 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列的名称 类型 修改列的列名和类型 alter table 表名 change 列名 新的列名 新的类型 ; 只修改列的类型 alter table 表名 modify 列名 新的类型; 删除列 alter table 表名 drop 列名; D: Delete 删除 drop table 表名; drop table if exists 表名; 客户端图形化工具 : SQLyog DML: 增删改表中的数据 添加数据 基本语法 insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意: 列名和值要一一对应 如果表名后,不定义列名,则默认给所有列添加值 除了数字类型,其他类型都需要用引号(单双均可) 删除数据 语法 delete from 表名 [where 条件成立] truncate table 表名; –&gt;删除表 然后创建一个一模一样的空表 注意: 当没有WHERE条件的时候 delete会将表中的所有的数据删除 删除所有的数据 delete from 表名; – 不推荐使用 ,有多少条数据执行多少次删除操作 truncate table 表名; –删除表 然后创建一个一模一样的空表 这条语句就相当于只执行了 drop table; create table ; 两条语句 效率更高 修改数据 语法 update 表名 set 列名1 = 值1 , 列名2 = 值2,…. [where 条件]; 注意 如果没有where条件 那么表中的所有的数据都会被修改 DQL: 查询表中的数据 语法 select ​ 字段列表 from ​ 表名列表 where ​ 条件列表 group by ​ 分组字段 having ​ 分组之后的条件 order by ​ 排序 limit ​ 分页限定 基础的查询 多个字段的查询 ​ 2. 去除重复 当去除重复的字段是多个的时候,所有的字段的值都必须相同才能去除 计算列 但是上述的null 计算的结果不合理, 因为在含有null参与的运算中,计算结果都是null ifnull(exp1,exp2)函数 —&gt; 如果exp1为null,就替换为exp2 起别名 当然 在列名后面 添加空格 然后添加别名也是可以的 条件查询 where子句后面跟条件 运算符 &lt;、&gt;、&lt;=、&gt;=、=、&lt;&gt;(不等于) SQL中的等于就是 = ,一个等于号 BETWEEN…AND between A and B 包含A和B IN(集合) LIKE(模糊查询) 占位符 _ : 单个任意字符 % : 多个任意字符 IS NULL NULL值不可以用基本运算符运算 AND 或者 &amp;&amp; (与) OR 或者 || (或) NOT 或者 ! (非) 排序查询 语法: order by 子句; order by 排序字段1 排序方式1 , 排序字段2 排序方式2,….; 排序方式 ASC : 升序 — &gt; ascend DESC: 降序 — &gt; descend 排序方式默认的是升序 多个字段的排序 靠前的是主排序,靠后的为次排序 当主排序相同的时候,才会使用次排序 上图中 主排序是数学升序 ,当数学成绩相同的时候 ,使用英语成绩降序为次排序 聚合函数: 将一列数据作为整体,进行纵向的计算 注: 聚合函数的计算会排除NULL值 选择不包含NULL的列进行计算 IFNULL函数 count : 计算数量,个数 一般选择没有NULL的列 : 主键 count(*) count(*) 代表只要一条数据中有一列不是NULL,都算作一条数据 max : 计算最大值 min : 计算最小值 sum : 计算和 avg : 计算平均值 分组查询 语法: group by 分组字段; 注意: 分组之后查询的字段必须是 分组字段或者聚合函数 where 和 having 的区别 where 在分组之前进行条件的限定 如果不满足条件 ,则不参与分组 having 在分组之后进行限定 如果不满足结果, 则不会被查询出来 where后不可以跟聚合函数 having后可以进行聚合函数的判断 给聚合函数起别名 后面可以用来进行查询 分页查询 语法: limit 开始的索引 , 每页查询的条数; 表中的数据的索引从0开始 *公式: 开始的索引 = (当前的页码 - 1) * 每页显示的条数* 当数据不够的时候,会将剩下的所有的数据都显示出来 LIMIT是MySQL数据库基础的”方言”","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.chasingwind.top/tags/MySQL/"}],"author":"ChasingWind"},{"title":"花津南路(完....)","slug":"花津南路","date":"2019-05-31T10:21:19.000Z","updated":"2021-03-04T00:43:51.263Z","comments":true,"path":"2019/05/31/花津南路/","link":"","permalink":"https://www.chasingwind.top/2019/05/31/%E8%8A%B1%E6%B4%A5%E5%8D%97%E8%B7%AF/","excerpt":"花津南路, 生活学习四年的地方,我想,总该要留些作为纪念的吧。慢慢地发现这座城市还是比较的美好","text":"花津南路, 生活学习四年的地方,我想,总该要留些作为纪念的吧。慢慢地发现这座城市还是比较的美好 2019-06-11 镜湖 中江桥 噪点奇多 看来是时候入手一个大光圈镜头了 Others 2019-06-16 学校的荷花 2019-06-21 八佰伴附近 AHNU赭山校区 夜晚的镜湖 2019-06-26 滨江公园 长江二桥 长江江景 世茂滨江 天主教堂 Others","categories":[{"name":"旅行志","slug":"旅行志","permalink":"https://www.chasingwind.top/categories/%E6%97%85%E8%A1%8C%E5%BF%97/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"https://www.chasingwind.top/tags/%E6%97%85%E8%A1%8C/"},{"name":"摄影","slug":"摄影","permalink":"https://www.chasingwind.top/tags/%E6%91%84%E5%BD%B1/"}],"author":"ChasingWind"},{"title":"旅行志--2019上海","slug":"旅行志-2019上海","date":"2019-05-20T11:05:46.000Z","updated":"2021-03-04T00:44:17.105Z","comments":true,"path":"2019/05/20/旅行志-2019上海/","link":"","permalink":"https://www.chasingwind.top/2019/05/20/%E6%97%85%E8%A1%8C%E5%BF%97-2019%E4%B8%8A%E6%B5%B7/","excerpt":"2019年”五一”上海之旅, 这篇记录最大的目的其实是我用来练习MarkDown语法用的, 大家随便看看就好啦。","text":"2019年”五一”上海之旅, 这篇记录最大的目的其实是我用来练习MarkDown语法用的, 大家随便看看就好啦。 一篇迟到的上海之旅Apr the 28th 啦啦啦~ 去上海啦~ Apr the 29th 一觉醒来就到了上海~ 现在才七点多,我姐还在休息,我就自己去逛逛~ 打开地图,地铁到徐家汇,就去走走 地铁站 高楼林立徐家汇 街道上的外星人和败家之眼瞩目 接着就是去交通大学啦! 这是交大徐汇校区的某一个校门,鉴于我分不清东西南北,也没找到交大的正大门交大真的特别漂亮~~ 交大校门 进去之后,我太感动了!!! 此刻我也是交大人(雾) 交大校园 交大图书馆(新上院) 交大新上院(图书馆)的古色古香~ 交大部分学院楼 经管学院 法学院 国际与公共事务学院 Others Apr the 30th吨吨吨~~ ​ May the 1st嚯嚯嚯~~~ May the 2nd去淮海中路看了人人人人 May the 3rd不想去看人人人 May the 4th 上午的蓝天~~ 下午想着应该没那么多人了,出发外滩 错综复杂的立交桥 ​ 沿途建筑风景 外滩 我认为我拍的最好的一张了 陆家嘴呀 ~ 开箱上海三件套 上海地标——东方明珠 May the 5th吨吨吨~ May the 6th回学校啦~ 今天写博客了吗 get! ​","categories":[{"name":"旅行志","slug":"旅行志","permalink":"https://www.chasingwind.top/categories/%E6%97%85%E8%A1%8C%E5%BF%97/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"https://www.chasingwind.top/tags/%E6%97%85%E8%A1%8C/"},{"name":"摄影","slug":"摄影","permalink":"https://www.chasingwind.top/tags/%E6%91%84%E5%BD%B1/"}],"author":"ChasingWind"}],"categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://www.chasingwind.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"https://www.chasingwind.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JVM系列","slug":"JVM系列","permalink":"https://www.chasingwind.top/categories/JVM%E7%B3%BB%E5%88%97/"},{"name":"MySQL高级","slug":"MySQL高级","permalink":"https://www.chasingwind.top/categories/MySQL%E9%AB%98%E7%BA%A7/"},{"name":"Java基础","slug":"Java基础","permalink":"https://www.chasingwind.top/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"工具","permalink":"https://www.chasingwind.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.chasingwind.top/categories/MySQL/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.chasingwind.top/categories/SpringBoot/"},{"name":"全文检索","slug":"全文检索","permalink":"https://www.chasingwind.top/categories/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"},{"name":"项目","slug":"项目","permalink":"https://www.chasingwind.top/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"主流框架","slug":"主流框架","permalink":"https://www.chasingwind.top/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Linux","slug":"Linux","permalink":"https://www.chasingwind.top/categories/Linux/"},{"name":"Java EE","slug":"Java-EE","permalink":"https://www.chasingwind.top/categories/Java-EE/"},{"name":"旅行志","slug":"旅行志","permalink":"https://www.chasingwind.top/categories/%E6%97%85%E8%A1%8C%E5%BF%97/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://www.chasingwind.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"Redis","slug":"Redis","permalink":"https://www.chasingwind.top/tags/Redis/"},{"name":"JVM内存与垃圾回收","slug":"JVM内存与垃圾回收","permalink":"https://www.chasingwind.top/tags/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"MYSQL锁机制","slug":"MYSQL锁机制","permalink":"https://www.chasingwind.top/tags/MYSQL%E9%94%81%E6%9C%BA%E5%88%B6/"},{"name":"IO","slug":"IO","permalink":"https://www.chasingwind.top/tags/IO/"},{"name":"Docker","slug":"Docker","permalink":"https://www.chasingwind.top/tags/Docker/"},{"name":"MySQL高级","slug":"MySQL高级","permalink":"https://www.chasingwind.top/tags/MySQL%E9%AB%98%E7%BA%A7/"},{"name":"Java8","slug":"Java8","permalink":"https://www.chasingwind.top/tags/Java8/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.chasingwind.top/tags/MyBatis/"},{"name":"代码生成工具","slug":"代码生成工具","permalink":"https://www.chasingwind.top/tags/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"},{"name":"MySQL架构","slug":"MySQL架构","permalink":"https://www.chasingwind.top/tags/MySQL%E6%9E%B6%E6%9E%84/"},{"name":"Web","slug":"Web","permalink":"https://www.chasingwind.top/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.chasingwind.top/tags/SpringBoot/"},{"name":"日志","slug":"日志","permalink":"https://www.chasingwind.top/tags/%E6%97%A5%E5%BF%97/"},{"name":"Spring","slug":"Spring","permalink":"https://www.chasingwind.top/tags/Spring/"},{"name":"SpringBoot入门","slug":"SpringBoot入门","permalink":"https://www.chasingwind.top/tags/SpringBoot%E5%85%A5%E9%97%A8/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.chasingwind.top/tags/ElasticSearch/"},{"name":"Lucene","slug":"Lucene","permalink":"https://www.chasingwind.top/tags/Lucene/"},{"name":"SSM","slug":"SSM","permalink":"https://www.chasingwind.top/tags/SSM/"},{"name":"SSM项目","slug":"SSM项目","permalink":"https://www.chasingwind.top/tags/SSM%E9%A1%B9%E7%9B%AE/"},{"name":"SVN","slug":"SVN","permalink":"https://www.chasingwind.top/tags/SVN/"},{"name":"Maven","slug":"Maven","permalink":"https://www.chasingwind.top/tags/Maven/"},{"name":"Oracle","slug":"Oracle","permalink":"https://www.chasingwind.top/tags/Oracle/"},{"name":"Git","slug":"Git","permalink":"https://www.chasingwind.top/tags/Git/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.chasingwind.top/tags/SpringMVC/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.chasingwind.top/tags/Mybatis/"},{"name":"Linux","slug":"Linux","permalink":"https://www.chasingwind.top/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.chasingwind.top/tags/Nginx/"},{"name":"JavaWeb项目","slug":"JavaWeb项目","permalink":"https://www.chasingwind.top/tags/JavaWeb%E9%A1%B9%E7%9B%AE/"},{"name":"Ajax","slug":"Ajax","permalink":"https://www.chasingwind.top/tags/Ajax/"},{"name":"JSON","slug":"JSON","permalink":"https://www.chasingwind.top/tags/JSON/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.chasingwind.top/tags/jQuery/"},{"name":"Fliter","slug":"Fliter","permalink":"https://www.chasingwind.top/tags/Fliter/"},{"name":"Listener","slug":"Listener","permalink":"https://www.chasingwind.top/tags/Listener/"},{"name":"JSP","slug":"JSP","permalink":"https://www.chasingwind.top/tags/JSP/"},{"name":"EL","slug":"EL","permalink":"https://www.chasingwind.top/tags/EL/"},{"name":"JSTL","slug":"JSTL","permalink":"https://www.chasingwind.top/tags/JSTL/"},{"name":"MVC","slug":"MVC","permalink":"https://www.chasingwind.top/tags/MVC/"},{"name":"三层架构","slug":"三层架构","permalink":"https://www.chasingwind.top/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"},{"name":"Cookie","slug":"Cookie","permalink":"https://www.chasingwind.top/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://www.chasingwind.top/tags/Session/"},{"name":"Http协议","slug":"Http协议","permalink":"https://www.chasingwind.top/tags/Http%E5%8D%8F%E8%AE%AE/"},{"name":"Response","slug":"Response","permalink":"https://www.chasingwind.top/tags/Response/"},{"name":"Request","slug":"Request","permalink":"https://www.chasingwind.top/tags/Request/"},{"name":"练习","slug":"练习","permalink":"https://www.chasingwind.top/tags/%E7%BB%83%E4%B9%A0/"},{"name":"Servlet","slug":"Servlet","permalink":"https://www.chasingwind.top/tags/Servlet/"},{"name":"Java Web","slug":"Java-Web","permalink":"https://www.chasingwind.top/tags/Java-Web/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://www.chasingwind.top/tags/Tomcat/"},{"name":"XML","slug":"XML","permalink":"https://www.chasingwind.top/tags/XML/"},{"name":"BootStrap","slug":"BootStrap","permalink":"https://www.chasingwind.top/tags/BootStrap/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.chasingwind.top/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://www.chasingwind.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://www.chasingwind.top/tags/CSS/"},{"name":"JDBC","slug":"JDBC","permalink":"https://www.chasingwind.top/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.chasingwind.top/tags/MySQL/"},{"name":"旅行","slug":"旅行","permalink":"https://www.chasingwind.top/tags/%E6%97%85%E8%A1%8C/"},{"name":"摄影","slug":"摄影","permalink":"https://www.chasingwind.top/tags/%E6%91%84%E5%BD%B1/"}]}